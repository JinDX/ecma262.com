<!DOCTYPE html>
<html lang="ja-JP">
<meta charset="utf-8">
<script src="https://htmlspecs.com/dropdown.js"></script>
<link rel="icon" href="https://tc39.es/ecma262/img/favicon.ico">
<style>
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }

  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }
  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }

  #ecma-logo {
    width: 500px;
  }

  .corner-cell {
    position: relative;
    height: 2lh;
  }
  .corner-cell .slash {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom left, transparent calc(50% - 1px), gray, transparent calc(50% + 1px));
  }
  .corner-cell > .column {
    position: absolute;
    bottom: 0.4em;
    left: 1em;
  }
  .corner-cell > .row {
    position: absolute;
    top: 0.4em;
    right: 1em;
  }
</style>
<style media="print">
  /**
  * ECMA-262-specific hacks. Shouldn't require a ton of maintenance; audit if
  * visual inspection results in unexpected page breaks.
  *
  * For print version, the table captioned "Module fields after the initial Evaluate() call" _may_ need to set the row
  * EVALUATING-ASYNC to one cell with a colspan of 5. It typically does not fit on the page, but the cell merging is
  * not a perfectly accurate solution and will not be merged back in to the specification.
  * See https://github.com/tc39/ecma262/pull/3623#issuecomment-3029366960
  */

  /* Make sure tables are wide enough for their captions */
  table {
    min-width: 135mm;
  }

  /* 2.2 Examples of legacy/normative-optional are small enough to be aggressive against breaks */
  #sec-conformance [example],
  /* 16.2.1.xxx many tables */
  #sec-example-cyclic-module-record-graphs table {
    break-inside: avoid-page;
  }

  /* 12.10.1 long note can break wherever it wants */
  #sec-rules-of-automatic-semicolon-insertion > emu-note {
    break-before: initial;
    break-inside: initial;
  }

  /* 12.10.X Sections start with an <em> not inside a <p> */
  #sec-examples-of-automatic-semicolon-insertion > em,
  #sec-interesting-cases-of-automatic-semicolon-insertion > em,
  #sec-asi-cases-with-no-lineterminator-here > em {
    display: block;
    margin-top: 1.25ex;
  }

  /* 15.1.X missing spacing between intro and first emu-grammar */
  #sec-static-semantics-containsexpression > emu-grammar:first-of-type {
    margin-top: 2ex;
  }

  /* 15.3 A very long term combined with inline-block, nowrap, and justified text resulting in weird punctuation */
  #sec-arrow-function-definitions > p > emu-grammar {
    text-align: left;
  }

  /* 20.X legacy title */
  #sec-object\.prototype\.__proto__ > .attributes-tag {
    break-before: avoid-page;
    break-after: avoid-page;
  }

  /* 21.X table middle column is too narrow */
  #table-time-zone-identifier-record-fields > figure > table th:nth-of-type(2) {
    min-width: 19mm;
  }

  /* 29.X extremely long note */
  #sec-shared-memory-guidelines > emu-note {
    break-inside: auto;
  }

  .unicode-property-table {
    table-layout: initial;
    width: auto;
    font-size: 90%;
  }

  .unicode-property-table th:first-of-type {
    width: 33%;
  }

  .corner-cell {
    background-image: url(data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI0NiIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEuNSIgd2lkdGg9IjI0MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzE1LjI2NiAzOTYuMzQzIDI0MS4zOTQgNDUuMTU1IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS4wNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMxNC45MyAtMzk1LjkzNSkiLz48L3N2Zz4=);
    background-repeat: no-repeat;
    background-size: 100% 3em;
    height: 3em;
    padding: 0;
    vertical-align: inherit;
    position: static;
  }

  .corner-cell .slash {
    display: none;
  }

  .corner-cell > .column, .corner-cell > .row {
    display: block;
    position: relative;
  }

  .corner-cell > .row {
    text-align: right;
    top: -0.75em
  }

  .corner-cell > .column {
    text-align: left;
    bottom: -1.25em;
  }
</style>
<pre class="metadata">
  title: ECMAScript<sup>&reg;</sup> 2026 言語仕様
  shortname: ECMA-262
  status: draft
  location: https://tc39.es/ecma262/
  markEffects: true
</pre>
<p><img src="https://tc39.es/ecma262/img/ecma-logo.svg" id="ecma-logo" alt="Ecma International ロゴ"></p>
<div id="metadata-block">
  <h1>この仕様書について</h1>
  <p><a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a> にある文書は、最も正確かつ最新の ECMAScript 仕様です。ここには、最新の年次スナップショットの内容と、スナップショット以降に <a href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md">完了した提案</a>（<a href="https://tc39.es/process-document/">提案プロセス</a>にて Stage&nbsp;4 に到達し、複数の実装に導入され、次回の実用的な改訂に含まれる予定のもの）が含まれています。</p>
  <p>本仕様書は <a href>単一ページ</a>、および <a href="multipage/">複数ページ</a>でご利用いただけます。</p>
  <h1>この仕様書への貢献について</h1>
  <p>この仕様は GitHub 上で ECMAScript コミュニティの協力によって開発されています。仕様書の開発に貢献する方法はいくつかあります：</p>
  <ul>
    <li>GitHub リポジトリ: <a href="https://github.com/tc39/ecma262">https://github.com/tc39/ecma262</a></li>
    <li>Issue: <a href="https://github.com/tc39/ecma262/issues">すべての Issue</a>、<a href="https://github.com/tc39/ecma262/issues/new">新しい Issue を提出</a></li>
    <li>Pull Request: <a href="https://github.com/tc39/ecma262/pulls">すべての Pull Request</a>、<a href="https://github.com/tc39/ecma262/pulls/new">新しい Pull Request を作成</a></li>
    <li>テストスイート: <a href="https://github.com/tc39/test262">Test262</a></li>
    <li>
      編集者:
      <ul>
        <li><a href="mailto:shu at rfrn dot org">Shu-yu Guo</a></li>
        <li><a href="mailto:ecma262-editor-list at michael dot ficarra dot me">Michael Ficarra</a> (<a href="https://bsky.app/profile/michael.ficarra.me">@michael.ficarra.me</a>)</li>
        <li><a href="mailto:bakkot at gmail dot com">Kevin Gibbons</a></li>
      </ul>
    </li>
    <li>
      コミュニティ:
      <ul>
        <li>Discourse: <a href="https://es.discourse.group">https://es.discourse.group/</a></li>
        <li>チャット: <a href="https://github.com/tc39/how-we-work/blob/HEAD/matrix-guide.md">Matrix</a></li>
        <li>メーリング <emu-not-ref>リスト</emu-not-ref> アーカイブ: <a href="https://esdiscuss.org">https://esdiscuss.org/</a></li>
      </ul>
    </li>
  </ul>
  <p>この文書の作成方法については <emu-xref href="#sec-colophon">colophon</emu-xref> を参照してください。</p>
</div>

<emu-intro id="sec-intro">
  <h1>はじめに</h1>
  <p>このEcma標準は、ECMAScript 2026言語を定義します。これはECMAScript言語仕様の第17版です。1997年の第1版公開以来、ECMAScriptは世界で最も広く使われている汎用プログラミング言語の一つに成長しました。主にウェブブラウザに組み込まれている言語として知られていますが、サーバーや組み込み用途にも広く採用されています。</p>
  <p>ECMAScriptはいくつかの技術をもとにしており、最もよく知られているのはJavaScript（Netscape）とJScript（Microsoft）です。この言語はNetscapeのBrendan Eichによって発明され、同社のNavigator 2.0ブラウザで初めて登場しました。その後、Netscapeの全てのブラウザと、Internet Explorer 3.0以降のMicrosoftの全てのブラウザに搭載されています。</p>
  <p>ECMAScript言語仕様の開発は1996年11月に始まりました。このEcma標準の第1版は1997年6月のEcma総会で採択されました。</p>
  <p>このEcma標準はISO/IEC JTC 1に高速トラック手続きで提出され、1998年4月に国際標準ISO/IEC 16262として承認されました。1998年6月のEcma総会では、ISO/IEC 16262との完全な整合性を保つため第2版（ECMA-262）が承認されました。第1版と第2版の間の変更は編集上のものです。</p>
  <p>第3版の標準では、強力な正規表現、より良い文字列処理、新しい制御文、try/catch例外処理、エラー定義の強化、数値出力のフォーマット、将来の言語成長を見越した小さな変更などが導入されました。ECMAScript標準の第3版は1999年12月のEcma総会で採択され、2002年6月にISO/IEC 16262:2002として発行されました。</p>
  <p>第3版発行後、ECMAScriptはWorld Wide Webとともに大量に普及し、事実上すべてのウェブブラウザでサポートされるプログラミング言語となりました。第4版の開発も大きく進みましたが、最終的には完了せず、第4版としては公開されませんでした。しかし、その一部は第6版の開発に取り込まれました。</p>
  <p>第5版（ECMA-262第5版として発行）は、ブラウザ実装で一般的となった言語仕様の事実上の解釈を成文化し、第3版以降に登場した新機能への対応を追加しました。これにはアクセサプロパティ、オブジェクトの反射的な生成・検査、プロパティ属性の制御、配列操作関数の追加、JSONオブジェクトエンコーディング形式のサポート、エラー検出とプログラムの安全性を強化するstrict modeなどが含まれます。第5版は2009年12月のEcma総会で採択されました。</p>
  <p>第5版はISO/IEC JTC 1に高速トラック手続きで提出され、国際標準ISO/IEC 16262:2011として承認されました。ECMAScript標準のEdition 5.1では小さな修正が加えられ、ISO/IEC 16262:2011と同一のテキストとなりました。5.1版は2011年6月のEcma総会で採択されました。</p>
  <p>第6版の集中的な開発は2009年に始まりましたが、その前には1999年の第3版発行以降、言語拡張設計や実験が積み重ねられてきました。第6版の完成は、まさに15年にわたる取り組みの集大成です。本版の目標には、大規模アプリケーションやライブラリ作成、他言語のコンパイルターゲットとしてのECMAScriptのサポート強化などが含まれます。主な拡張点は、モジュール、クラス宣言、レキシカルブロックスコープ、イテレータとジェネレータ、非同期プログラミングのためのPromise、分割代入パターン、適切な末尾呼び出しです。組み込みライブラリも拡張され、マップ・セット・バイナリ数値配列のほか、文字列や正規表現でのUnicode補助文字サポートも強化されました。組み込みオブジェクトはサブクラス化によって拡張可能になりました。第6版は、定期的かつ漸進的な言語・ライブラリ拡張の基礎となります。第6版は2015年6月の総会で採択されました。</p>
  <p>ECMAScript 2016は、Ecma TC39による新たな年次リリースおよびオープン開発プロセスのもとで初めて公開されたECMAScript版です。ECMAScript 2015のソース文書からプレーンテキスト文書を作成し、以降の開発は全てGitHub上で行われました。本標準の開発期間中、数百件のPull RequestやIssueが提出され、何千ものバグ修正や編集修正、その他の改善が行われました。また、Ecmarkup・Ecmarkdown・Grammarkdownなどの開発支援ツールも多数作られました。ES2016では新しいべき乗演算子や、`Array.prototype`に`includes`メソッドが追加されました。</p>
  <p>ECMAScript 2017ではAsync Function、Shared Memory、Atomicsが導入され、他にも小規模な言語・ライブラリ拡張やバグ修正、編集更新が行われました。Async FunctionはPromiseを返す関数のための構文を提供し、非同期プログラミング体験を向上させます。Shared MemoryとAtomicsは、複数エージェント間で原子的な操作による通信を可能にし、並列CPUでも明確な実行順序を保証する新しいメモリモデルを導入します。また、Objectには`Object.values`、`Object.entries`、`Object.getOwnPropertyDescriptors`などの新しい静的メソッドが追加されました。</p>
  <p>ECMAScript 2018では、非同期イテレーションを実現するasync iteratorプロトコルとasync generatorがサポートされました。さらに、4つの新しい正規表現機能（`dotAll`フラグ、名前付きキャプチャグループ、Unicodeプロパティエスケープ、後方参照）が追加されました。最後に、オブジェクトのrest/spreadプロパティも導入されました。</p>
  <p>ECMAScript 2019では、`Array.prototype`の`flat`と`flatMap`、`Object.fromEntries`による`Object.entries`の戻り値から新しいオブジェクトを直接作成する関数、`String.prototype`の`trimStart`と`trimEnd`（従来の`trimLeft`・`trimRight`よりも適切な名称）などのビルトイン関数が追加されました。また、構文と意味への小規模な更新も含まれています。構文の更新では、catchバインディングパラメータの省略や、文字列リテラルでU+2028（行区切り）・U+2029（段落区切り）をJSONに合わせて許可する変更がありました。その他、`Array.prototype.sort`の安定ソートの要求や、`JSON.stringify`の入力に関わらずUTF-8の整形式な出力の要求、`Function.prototype.toString`の仕様明確化（元のソースまたは標準プレースホルダーの返却）が行われました。</p>
  <p>ECMAScript 2020（第11版）では、文字列の全マッチオブジェクトをイテレータで返す`matchAll`メソッド、動的指定子でモジュールを非同期インポートする`import()`構文、任意精度整数を扱う新しい数値型`BigInt`、短絡しないPromise合成のための`Promise.allSettled`、グローバルな`this`値への統一的アクセス手段`globalThis`、`export * as ns from 'module'`のモジュール構文、`for-in`列挙順序の標準化、モジュール文脈情報のための`import.meta`、nullish値（*undefined*や*null*）の扱いを改善するnullish合体演算子・オプショナルチェーン演算子などが導入されました。</p>
  <p>ECMAScript 2021（第12版）では、文字列の`replaceAll`メソッド、Promiseの短絡合成`Promise.any`、複数のエラーを同時に表現する新しいエラー型`AggregateError`、論理代入演算子（`??=`、`&&=`、`||=`）、ガベージコレクション抑止なしでターゲットオブジェクト参照を可能にする`WeakRef`、ガベージコレクション時のクリーンアップ操作管理のための`FinalizationRegistry`、数値リテラルの区切り（`1_000`）、`Array.prototype.sort`の実装定義順序を減らす仕様強化などが追加されました。</p>
  <p>ECMAScript 2022（第13版）では、モジュールのトップレベルで`await`キーワードが使用できるようになり、クラスの新要素（public/privateインスタンスフィールド、public/private staticフィールド、privateインスタンスメソッド・アクセサ、private staticメソッド・アクセサ）、クラス内のstatic blockによる初期化、`#x in obj`構文によるオブジェクトのprivateフィールド存在判定、正規表現の`/d`フラグによるマッチ開始・終了インデックス取得、エラーの原因記録用`cause`プロパティ、文字列・配列・TypedArrayでの相対インデックス取得の`at`メソッド、`Object.hasOwn`による`Object.prototype.hasOwnProperty`の簡便な代替手段などが導入されました。</p>
  <p>ECMAScript 2023（第14版）では、`Array.prototype`と`TypedArray.prototype`の`toSorted`、`toReversed`、`with`、`findLast`、`findLastIndex`メソッド、および`Array.prototype`の`toSpliced`メソッドが追加されました。また、ファイル先頭の`#!`コメントによる実行可能ECMAScriptファイル対応や、弱コレクションのキーとしてほとんどのSymbolの使用が許可されました。</p>
  <p>ECMAScript 2024（第15版）では、ArrayBufferとSharedArrayBufferのサイズ変更・転送機能、文字列集合操作に便利な新しいRegExp `/v`フラグ、Promise構築のための`Promise.withResolvers`、データ集計の`Object.groupBy`と`Map.groupBy`、共有メモリ変更を非同期で待つ`Atomics.waitAsync`、文字列のUnicode整形式判定・修正の`String.prototype.isWellFormed`と`String.prototype.toWellFormed`などが導入されました。</p>
  <p>ECMAScript 2025（第16版）では、イテレータ操作のための新しいグローバル`Iterator`（静的・プロトタイプメソッド付き）、`Set.prototype`のセット操作メソッド、JSONモジュールのインポートとインポート属性宣言構文、正規表現用の`RegExp.escape`メソッド、正規表現内での修飾子フラグのインライン変更構文、Promise返却有無を問わず常にPromiseを返す`Promise.try`メソッド、新しいTypedArray種`Float16Array`とそれに対応する`DataView.prototype.getFloat16`、`DataView.prototype.setFloat16`、`Math.f16round`メソッドが導入されました。</p>
  <p>本版および以前の版の開発において、Ecma TC39には多くの組織を代表する多数の個人が非常に重要な貢献をしています。さらに、TC39のECMAScript活動を支える活発なコミュニティも生まれました。このコミュニティは多数のドラフトのレビュー、数千件に及ぶバグ報告、実装実験、テストスイートの提供、世界中の開発者へのECMAScriptの教育などで貢献しています。残念ながら、この取り組みに貢献した全ての個人や組織を特定し、謝意を表することは不可能です。</p>
  <p>
    Allen Wirfs-Brock<br>
    ECMA-262、第6版プロジェクトエディター
  </p>
  <p>
    Brian Terlson<br>
    ECMA-262、第7～10版プロジェクトエディター
  </p>
  <p>
    Jordan Harband<br>
    ECMA-262、第10～12版プロジェクトエディター
  </p>
  <p>
    Shu-yu Guo<br>
    ECMA-262、第12～16版プロジェクトエディター
  </p>
  <p>
    Michael Ficarra<br>
    ECMA-262、第12～16版プロジェクトエディター
  </p>
  <p>
    Kevin Gibbons<br>
    ECMA-262、第12～16版プロジェクトエディター
  </p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>適用範囲</h1>
  <p>本標準は、ECMAScript 2026汎用プログラミング言語を定義します。</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>適合性</h1>
  <p>ECMAScriptの適合する実装は、本仕様で記述されているすべての型、値、オブジェクト、プロパティ、関数、プログラムの構文および意味を提供し、サポートしなければなりません。</p>
  <p>ECMAScriptの適合する実装は、Unicode標準およびISO/IEC 10646の最新バージョンに従って、ソーステキスト入力を解釈しなければなりません。</p>
  <p>異なる言語や国の言語的・文化的慣習に適応する必要があるプログラムをサポートするアプリケーションプログラミングインターフェイス（API）を提供するECMAScriptの適合実装は、本仕様と互換性のある最新のECMA-402版で定義されたインターフェイスを実装しなければなりません。</p>
  <p>ECMAScriptの適合する実装は、本仕様で記述されているもの以外にも追加の型、値、オブジェクト、プロパティ、関数を提供することができます。特に、適合する実装は本仕様で記述されていないプロパティやその値を、本仕様で記述されているオブジェクトに対して提供することができます。</p>
  <p>ECMAScriptの適合する実装は、本仕様で記述されていないプログラムおよび正規表現の構文をサポートすることができます。特に、適合する実装は、本仕様の<emu-xref href="#sec-keywords-and-reserved-words"></emu-xref>の小項で示される「将来予約語」を使用するプログラム構文をサポートすることができます。</p>
  <p>ECMAScriptの適合する実装は、<emu-xref href="#sec-forbidden-extensions"></emu-xref>の小項で「禁止拡張」としてリストされているいかなる拡張も実装してはなりません。</p>
  <p>ECMAScriptの適合する実装は、実装定義、実装近似、またはホスト定義でないいかなる機能も再定義してはなりません。</p>
  <p>ECMAScriptの適合する実装は、特に指示がない限り、<dfn>規範的任意</dfn>の小項を実装するかしないかを選択できます。ウェブブラウザは一般的にすべての規範的任意の小項を実装する必要があります。（付録<emu-xref href="#sec-additional-ecmascript-features-for-web-browsers"></emu-xref>を参照。）規範的任意の動作が実装される場合は、その規範的任意項内のすべての動作を実装しなければなりません。規範的任意の項は、本仕様書では「規範的任意」と書かれた色付きのボックスで示されます。下記はその例です。</p>

  <emu-clause id="sec-conformance-normative-optional" oldids="sec-conformance.normative-optional" example normative-optional>
    <h1>規範的任意項目の見出し例</h1>
    <p>項目内容の例。</p>
  </emu-clause>
  <p>ECMAScriptの適合する実装は、規範的任意としてもマークされていない限り、<dfn>レガシー</dfn>の小項を実装しなければなりません。レガシーの小項で規定された言語機能や動作は、いずれも何らかの望ましくない特性を有しています。しかし、既存アプリケーションでの継続的な利用により、本仕様からの削除ができません。これらの機能はECMAScript言語のコア部分とはみなされません。プログラマーは新しいECMAScriptコードを書く際、これらの機能や動作の利用や存在を前提とすべきではありません。</p>

  <emu-clause id="sec-conformance-legacy" example legacy>
    <h1>レガシー項目の見出し例</h1>
    <p>項目内容の例。</p>
  </emu-clause>

  <emu-clause id="sec-conformance-legacy-normative-optional" example legacy normative-optional>
    <h1>レガシー規範的任意項目の見出し例</h1>
    <p>項目内容の例。</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>規範参照</h1>
  <p>以下に参照する文書は、本書の適用に不可欠です。日付付き参照については、記載された版のみが適用されます。日付なし参照については、参照文書の最新版（修正等を含む）が適用されます。</p>
  <p>IEEE 754-2019, <i>浮動小数点算術のIEEE標準</i>。</p>
  <p>
    Unicode標準。<br>
    <a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>
  </p>
  <p>ISO/IEC 10646, <i>情報技術 ― 多オクテット符号化文字集合（UCS）</i> および Amendment 1:2005, Amendment 2:2006, Amendment 3:2008, Amendment 4:2008、追加の修正および後継。</p>
  <p>
    ECMA-402, <i>ECMAScript国際化API仕様</i>、特に本仕様の版に対応する年次版。<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-402/">https://www.ecma-international.org/publications-and-standards/standards/ecma-402/</a>
  </p>
  <p>
    ECMA-404, <i>JSONデータ交換フォーマット</i>。<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a>
  </p>
</emu-clause>

<emu-clause id="sec-overview">
  <h1>概要</h1>
  <p>本節では、ECMAScript言語の非規範的な概要を示します。</p>
  <p>ECMAScriptは、オブジェクト指向プログラミング言語であり、計算処理やホスト環境内での計算オブジェクトの操作を行うために使用されます。ここで定義されるECMAScriptは、計算自体を自給自足で行うことを意図していません。実際、本仕様では外部データの入力や計算結果の出力の手段は規定されていません。その代わりに、ECMAScriptプログラムの計算環境が本仕様で記述されるオブジェクトや機能に加え、環境固有のオブジェクトも提供することが期待されます。これらのオブジェクトの詳細な説明や挙動は本仕様の範囲外ですが、ECMAScriptプログラムからプロパティや関数としてアクセスや呼び出しが可能であることを示しています。</p>
  <p>ECMAScriptは元々スクリプト言語として設計されましたが、現在では汎用プログラミング言語として広く利用されています。<em>スクリプト言語</em>とは、既存システムの機能を操作・カスタマイズ・自動化するためのプログラミング言語です。こうしたシステムでは、ユーザーインターフェースを通じて有用な機能がすでに利用可能で、スクリプト言語はその機能をプログラムで制御する手段となります。このように、既存システムはオブジェクトや機能からなるホスト環境を提供し、スクリプト言語の能力を補完します。スクリプト言語は、専門・非専門のプログラマー双方による利用を想定しています。</p>
  <p>ECMAScriptは元々<em>Webスクリプト言語</em>として設計され、ブラウザ上でWebページを動的にしたり、Webベースのクライアント・サーバーアーキテクチャの一部としてサーバー計算を行う仕組みを提供していました。現在では様々なホスト環境のためのコアスクリプト機能を提供しており、コア言語は特定のホスト環境から切り離して本書で定義されています。</p>
  <p>ECMAScriptの利用は単純なスクリプト用途を超えて拡大し、さまざまな環境や規模におけるあらゆるプログラミング課題に使われています。それに伴い、言語の機能や設備も拡充されてきました。ECMAScriptは現在、十分に機能を備えた汎用プログラミング言語です。</p>

  <emu-clause id="sec-web-scripting">
    <h1>ウェブスクリプト</h1>
    <p>ウェブブラウザは、クライアントサイドの計算処理のためのECMAScriptホスト環境を提供します。例えば、ウィンドウ・メニュー・ポップアップ・ダイアログボックス・テキストエリア・アンカー・フレーム・履歴・クッキー・入出力などを表すオブジェクトがあります。さらに、ホスト環境は、フォーカスの変化、ページや画像の読み込み・アンロード・エラー・中断・選択・フォーム送信・マウス操作等のイベントにスクリプトコードを関連付ける手段を提供します。スクリプトコードはHTML内に記述され、表示ページはユーザーインターフェース要素と固定・計算済みのテキストや画像の組み合わせとなります。スクリプトコードはユーザー操作に反応し、メインプログラムは不要です。</p>
    <p>ウェブサーバは、サーバサイドの計算処理のための別のホスト環境を提供し、リクエスト・クライアント・ファイルなどを表すオブジェクトや、データのロック・共有の仕組みを備えています。クライアント側とサーバ側のスクリプトを組み合わせることで、Webアプリケーションにおいて計算処理をクライアントとサーバ間で分散し、カスタマイズされたユーザーインターフェースを提供できます。</p>
    <p>ECMAScriptをサポートする各ウェブブラウザやサーバは、それぞれ独自のホスト環境を提供し、ECMAScriptの実行環境を完結させます。</p>
  </emu-clause>

  <emu-clause id="sec-hosts-and-implementations">
    <h1>ホストと実装</h1>
    <p>ECMAScriptをホスト環境に統合しやすくするため、本仕様は一部の機能（例：抽象演算）について、その定義を外部に委譲しています。編集上、本仕様では以下の区分を区別します。</p>
    <p><em id="implementation">実装</em>とは、付録<emu-xref href="#sec-host-layering-points"></emu-xref>で列挙される機能や、実装定義・実装近似と記載された機能をさらに定義する外部ソースです。非公式には、実装は特定のウェブブラウザなどの具体的な成果物を指します。</p>
    <p><dfn id="implementation-defined">実装定義</dfn>の機能とは、追加の条件なく外部ソースに定義を委ねるものです。本仕様は特定の挙動について推奨はせず、適合実装は本仕様の制約内で任意の挙動を選択できます。</p>
    <p><dfn id="implementation-approximated">実装近似</dfn>の機能とは、外部ソースに定義を委ねつつ、理想的な挙動を推奨するものです。適合実装は本仕様の制約内で任意の挙動を選択できますが、理想的な挙動に近づくことが推奨されます。例えば<emu-xref href="#sec-math.exp"><code>Math.exp</code></emu-xref>などの数学演算が該当します。</p>
    <p><dfn id="host" variants="hosts">ホスト</dfn>とは、付録<emu-xref href="#sec-host-layering-points"></emu-xref>で列挙される機能をさらに定義する外部ソースですが、他の実装定義や実装近似の機能は定義しません。非公式には、ホストは本仕様に同じ方法でインターフェースする全てのウェブブラウザ等の集合を指します。ホストは WHATWG HTML（<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>）などの外部仕様であることが多いです。つまり、ホスト定義の機能は外部仕様でさらに定義されることが多いです。</p>
    <p><dfn id="host-hook" variants="host hooks">ホストフック</dfn>とは、外部ソースによって全体または一部が定義される抽象演算です。すべてのホストフックは付録<emu-xref href="#sec-host-layering-points"></emu-xref>に列挙される必要があります。ホストフックは少なくとも以下の要件を満たさなければなりません：</p>
    <ul>
      <li>正常完了またはthrow完了を返す必要があります。</li>
    </ul>
    <p><dfn id="host-defined">ホスト定義</dfn>の機能とは、追加の条件なく外部ソースに定義を委ね、付録<emu-xref href="#sec-host-layering-points"></emu-xref>に列挙されるものです。ホストでない実装もホスト定義の機能の定義を提供できます。</p>
    <p><dfn id="host-environment" variants="host environments">ホスト環境</dfn>とは、すべてのホスト定義機能の定義を選択したものです。ホスト環境は、グローバルオブジェクトのホスト定義プロパティとして入出力等のオブジェクトや関数を含むことが一般的です。</p>
    <p>本仕様は、常に最も具体的な用語を用いる編集方針です。例えば、機能がホスト定義の場合、実装定義として言及してはなりません。</p>
    <p>ホストと実装の両方が、本仕様で定義される言語型・仕様型・抽象演算・文法・組み込みオブジェクト・組み込みシンボルを通して本仕様とインターフェース可能です。</p>
  </emu-clause>

  <emu-clause id="sec-ecmascript-overview">
    <h1>ECMAScript概要</h1>
    <p>以下はECMAScriptの非公式な概要であり、言語のすべての部分を記述するものではありません。この概要は標準本体には含まれません。</p>
    <p>ECMAScriptはオブジェクトベースです。基本的な言語機能やホスト機能はオブジェクトによって提供され、ECMAScriptプログラムは相互に通信するオブジェクトの集まりです。ECMAScriptにおける<em>オブジェクト</em>は、0個以上の<em>プロパティ</em>を持ち、各プロパティには<em>属性</em>があり、プロパティの利用方法を決定します。例えば、プロパティのWritable属性が*false*の場合、ECMAScriptコードでそのプロパティに値を代入しようとしても失敗します。プロパティは他のオブジェクトや<em>プリミティブ値</em>、<em>関数</em>を格納するコンテナです。プリミティブ値は、<b>Undefined</b>、<b>Null</b>、<b>Boolean</b>、<b>Number</b>、<b>BigInt</b>、<b>String</b>、<b>Symbol</b>のいずれかの組み込み型のメンバーです。オブジェクトは組み込み型<b>Object</b>のメンバーであり、関数は呼び出し可能なオブジェクトです。オブジェクトのプロパティとして結び付けられた関数は<em>メソッド</em>と呼ばれます。</p>
    <p>ECMAScriptは<em>組み込みオブジェクト</em>の集合を定義し、ECMAScriptの構成要素を補完します。これらの組み込みオブジェクトにはグローバルオブジェクト、言語のランタイム意味論に不可欠な`Object`、`Function`、`Boolean`、`Symbol`、各種`Error`オブジェクト、数値値を表現・操作する`Math`、`Number`、`Date`、テキスト処理用の`String`・`RegExp`、値のインデックス付きコレクションである`Array`と9種類のTyped Array（いずれも特定数値表現）、キー付きコレクションの`Map`・`Set`、構造化データのための`JSON`・`ArrayBuffer`・`SharedArrayBuffer`・`DataView`、制御抽象のためのジェネレータ関数や`Promise`オブジェクト、リフレクション用の`Proxy`・`Reflect`などがあります。</p>
    <p>ECMAScriptはまた、組み込み<em>演算子</em>の集合も定義しています。ECMAScriptの演算子には、各種単項演算、乗算演算子、加算演算子、ビットシフト演算子、関係演算子、等価演算子、2項ビット演算子、2項論理演算子、代入演算子、カンマ演算子などがあります。</p>
    <p>大規模なECMAScriptプログラムは<em>モジュール</em>によってサポートされ、プログラムを複数の文・宣言列に分割できます。各モジュールは、他のモジュールから提供される必要がある宣言と、他のモジュールで利用可能な自身の宣言を明示します。</p>
    <p>ECMAScriptの構文は意図的にJava構文に似せられています。ECMAScriptの構文は、使いやすいスクリプト言語として機能するように緩やかです。例えば、変数に型宣言は不要であり、プロパティにも型は関連付けられません。また、定義済み関数は宣言が呼び出しより前に現れなくてもかまいません。</p>

    <emu-clause id="sec-objects">
      <h1>オブジェクト</h1>
      <p>ECMAScriptにはクラス定義の構文が含まれていますが、ECMAScriptのオブジェクトはC++・Smalltalk・Javaのようなクラスベースではありません。代わりに、リテラル記法や、オブジェクトを生成しプロパティに初期値を割り当てる<em>コンストラクター</em>など、様々な方法でオブジェクトが作成されます。各コンストラクターは*"prototype"*というプロパティを持ち、<em>プロトタイプベースの継承</em>や<em>共有プロパティ</em>を実現します。オブジェクトは<b>new</b>式でコンストラクターを使うことで作成されます。例えば、`new Date(2009, 11)`は新しいDateオブジェクトを生成します。コンストラクターを<b>new</b>なしで呼び出すと、その挙動はコンストラクターごとに異なります。例えば、`Date()`は現在の日付と時刻の文字列表現を返し、オブジェクトは生成しません。</p>
      <p>コンストラクターで作成されたすべてのオブジェクトは、コンストラクターの*"prototype"*プロパティ値への暗黙的な参照（そのオブジェクトの<em>プロトタイプ</em>と呼ばれる）を持ちます。さらに、プロトタイプは非*null*なプロトタイプへの暗黙参照を持つ場合があり、これを<em>プロトタイプチェーン</em>と呼びます。オブジェクトのプロパティ参照は、その名前のプロパティを持つプロトタイプチェーンの最初のオブジェクトのプロパティへの参照です。つまり、まず参照されるオブジェクト自身にそのプロパティがあるかを調べ、あればそのプロパティが参照されます。なければ、そのオブジェクトのプロトタイプを次に調べ、以降同様です。</p>
      <emu-figure id="figure-1" caption="オブジェクト／プロトタイプ関係">
        <img alt="たくさんの箱と矢印の図。" height="354" src="https://tc39.es/ecma262/img/figure-1.svg" width="719">
      </emu-figure>
      <p>クラスベースのオブジェクト指向言語では、一般にインスタンスが状態を持ち、メソッドはクラスに属し、継承は構造と振る舞いのみです。ECMAScriptでは、状態とメソッドの両方がオブジェクトに属し、構造・振る舞い・状態すべてが継承されます。</p>
      <p>プロトタイプが直接持つプロパティを持たないすべてのオブジェクトは、そのプロパティと値を共有します。図1はこれを示します：</p>
      <p><b>CF</b>はコンストラクター（同時にオブジェクトでもある）です。`new`式で5つのオブジェクト<b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b>、<b>cf<sub>5</sub></b>が生成されています。各オブジェクトは*"q1"*と*"q2"*プロパティを持ちます。破線は暗黙のプロトタイプ関係を示します。例えば<b>cf<sub>3</sub></b>のプロトタイプは<b>CF<sub>p</sub></b>です。コンストラクター<b>CF</b>自身は*"P1"*と*"P2"*プロパティを持っており、<b>CF<sub>p</sub></b>、<b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b>、<b>cf<sub>5</sub></b>からは見えません。<b>CF<sub>p</sub></b>の*"CFP1"*プロパティは<b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b>、<b>cf<sub>5</sub></b>で共有されます（<b>CF</b>自身は除く）。また、プロトタイプチェーン上で*"q1"*、*"q2"*、*"CFP1"*以外のプロパティも共有されます。<b>CF</b>と<b>CF<sub>p</sub></b>の間に暗黙のプロトタイプリンクはありません。</p>
      <p>多くのクラスベース言語と異なり、プロパティは値を代入することで動的に追加できます。つまり、コンストラクターは生成したオブジェクトのすべてのプロパティを命名・初期化する必要はありません。上述の図では、<b>CF<sub>p</sub></b>に新しい値を割り当てることで<b>cf<sub>1</sub></b>～<b>cf<sub>5</sub></b>の共有プロパティを追加できます。</p>
      <p>ECMAScriptオブジェクトは本来クラスベースではありませんが、共通パターンのコンストラクター関数・プロトタイプオブジェクト・メソッドを使ってクラスライクな抽象化を定義することが便利な場合が多いです。ECMAScriptの組み込みオブジェクト自身もそのようなクラスライクなパターンに従っています。ECMAScript 2015以降、組み込みオブジェクトと同様のクラスライク抽象に沿ったオブジェクトを簡潔に定義できる構文的なクラス定義が導入されました。</p>
    </emu-clause>

    <emu-clause id="sec-strict-variant-of-ecmascript">
      <h1>ECMAScriptの厳格バリアント</h1>
      <p>ECMAScript言語は、利用者が言語の一部機能の利用を制限したい場合があることを認識しています。これはセキュリティ向上、エラーを起こしやすい機能回避、エラー検出強化など様々な理由によるものです。そのため、ECMAScriptは言語の厳格バリアントを定義しています。厳格バリアントでは、通常のECMAScript言語の特定の構文的・意味的機能が除外され、いくつかの機能の詳細な意味論が変更されます。また、非厳格な言語形式ではエラーとされていない状況でも、追加のエラー条件を規定し、エラー例外のthrowが必須となります。</p>
      <p>厳格バリアントは一般に言語の<em>strict mode</em>（厳格モード）と呼ばれます。厳格モードの選択および構文・意味論の利用は、個々のECMAScriptソーステキスト単位ごとに明示的に行われます（<emu-xref href="#sec-strict-mode-code"></emu-xref>参照）。厳格モードは構文単位ごとに選択されるため、制限はその単位内でのみ局所的に作用します。厳格モードは、複数のソーステキスト単位にまたがって一貫して動作が求められるECMAScript意味論には影響しません。完全なECMAScriptプログラムは、厳格モードと非厳格モードのソーステキスト単位の混在から構成可能です。この場合、厳格モードは実際に厳格モードのソーステキスト単位内のコードが実行されるときのみ適用されます。</p>
      <p>本仕様への適合には、ECMAScriptの制限なしの完全な言語と、本仕様で定義される厳格バリアントの両方を実装する必要があります。また、制限なしの単位と厳格モード単位を単一の複合プログラムとして組み合わせてサポートする必要があります。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-terms-and-definitions">
    <h1>用語と定義</h1>
    <p>本書の目的のため、以下の用語と定義が適用されます。</p>

    <emu-clause id="sec-terms-and-definitions-implementation-approximated">
      <h1>実装近似</h1>
      <p>実装近似機能は、外部ソースによって全部または一部が定義されますが、本仕様で推奨される理想的な挙動を持ちます</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-implementation-defined">
      <h1>実装定義</h1>
      <p>実装定義機能は、本仕様外の外部ソースによって全部または一部が定義されます</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-host-defined">
      <h1>ホスト定義</h1>
      <p>実装定義と同義</p>
      <emu-note>
        <p>編集上の詳細は<emu-xref href="#sec-hosts-and-implementations"></emu-xref>を参照。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-type">
      <h1>型</h1>
      <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref>で定義されるデータ値の集合</p>
    </emu-clause>

    <emu-clause id="sec-primitive-value">
      <h1>プリミティブ値</h1>
      <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref>で定義される、Undefined・Null・Boolean・Number・BigInt・Symbol・Stringのいずれかの型のメンバー</p>
      <emu-note>
        <p>プリミティブ値は、言語実装の最下層で直接表現されるデータです。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-object">
      <h1>オブジェクト</h1>
      <p>Object型のメンバー</p>
      <emu-note>
        <p>オブジェクトはプロパティの集合であり、1つのプロトタイプオブジェクトを持ちます。プロトタイプは*null*の場合もあります。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-constructor">
      <h1>コンストラクター</h1>
      <p>オブジェクトを生成・初期化する関数オブジェクト</p>
      <emu-note>
        <p>コンストラクターの*"prototype"*プロパティ値は、継承や共有プロパティの実現に用いられるプロトタイプオブジェクトです。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-prototype">
      <h1>プロトタイプ</h1>
      <p>他のオブジェクトに共有プロパティを提供するオブジェクト</p>
      <emu-note>
        <p>コンストラクターがオブジェクトを生成すると、そのオブジェクトはプロパティ参照解決のためにコンストラクターの*"prototype"*プロパティを暗黙参照します。*"prototype"*プロパティは<code><var>constructor</var>.prototype</code>式で参照でき、プロトタイプに追加したプロパティはすべての派生オブジェクトで継承して共有されます。`Object.create`組み込み関数で明示的なプロトタイプを指定して新規作成することもできます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinary-object">
      <h1>通常オブジェクト</h1>
      <p>すべてのオブジェクトがサポートすべき基本的な内部メソッドについて、デフォルトの挙動を持つオブジェクト</p>
    </emu-clause>

    <emu-clause id="sec-exotic-object">
      <h1>特異オブジェクト</h1>
      <p>基本的な内部メソッドのうち1つ以上についてデフォルトの挙動を持たないオブジェクト</p>
      <emu-note>
        <p>通常オブジェクトでないものはすべて特異オブジェクトです。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-standard-object">
      <h1>標準オブジェクト</h1>
      <p>本仕様で意味論が定義されているオブジェクト</p>
    </emu-clause>

    <emu-clause id="sec-built-in-object">
      <h1>組み込みオブジェクト</h1>
      <p>ECMAScript実装によって指定・供給されるオブジェクト</p>
      <emu-note>
        <p>標準組み込みオブジェクトは本仕様で定義されます。実装は追加の組み込みオブジェクトを指定・供給することができます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-undefined-value">
      <h1>undefined値</h1>
      <p>変数に値が代入されていない場合に用いられるプリミティブ値</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-undefined-type">
      <h1>Undefined型</h1>
      <p>唯一の値が*undefined*値である型</p>
    </emu-clause>

    <emu-clause id="sec-null-value">
      <h1>null値</h1>
      <p>任意のオブジェクト値が存在しないことを明示的に表すプリミティブ値</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-null-type">
      <h1>Null型</h1>
      <p>唯一の値が*null*値である型</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-value">
      <h1>Boolean値</h1>
      <p>Boolean型のメンバー</p>
      <emu-note>
        <p>Boolean値は*true*と*false*の2つのみです。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-type">
      <h1>Boolean型</h1>
      <p>プリミティブ値*true*と*false*からなる型</p>
    </emu-clause>

    <emu-clause id="sec-boolean-object">
      <h1>Booleanオブジェクト</h1>
      <p>標準組み込みBooleanコンストラクターのインスタンスであるObject型メンバー</p>
      <emu-note>
        <p>Booleanオブジェクトは、`new`式でBooleanコンストラクターにBoolean値を渡して生成します。生成されたオブジェクトは内部スロットにBoolean値を保持します。BooleanオブジェクトはBoolean値に変換できます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-value">
      <h1>String値</h1>
      <p>有限個の16ビット符号なし整数値からなる順序付き列のプリミティブ値</p>
      <emu-note>
        <p>String値はString型のメンバーです。各整数値は通常UTF-16テキストの1単位を表しますが、ECMAScriptでは16ビット符号なし整数であること以外に制約はありません。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-type">
      <h1>String型</h1>
      <p>すべてのString値の集合</p>
    </emu-clause>

    <emu-clause id="sec-string-object">
      <h1>Stringオブジェクト</h1>
      <p>標準組み込みStringコンストラクターのインスタンスであるObject型メンバー</p>
      <emu-note>
        <p>Stringオブジェクトは、`new`式でStringコンストラクターにString値を渡して生成します。生成されたオブジェクトは内部スロットにString値を保持します。Stringオブジェクトは、Stringコンストラクター関数呼び出し（<emu-xref href="#sec-string-constructor-string-value"></emu-xref>）でString値に変換できます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-value">
      <h1>Number値</h1>
      <p>倍精度64ビット2進形式IEEE 754-2019値に対応するプリミティブ値</p>
      <emu-note>
        <p>Number値はNumber型のメンバーであり、数値を直接表現します。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-type">
      <h1>Number型</h1>
      <p>*NaN*（非数）、*+∞*<sub>𝔽</sub>（正の無限大）、*-∞*<sub>𝔽</sub>（負の無限大）を含むすべてのNumber値の集合</p>
    </emu-clause>

    <emu-clause id="sec-number-object">
      <h1>Numberオブジェクト</h1>
      <p>標準組み込みNumberコンストラクターのインスタンスであるObject型メンバー</p>
      <emu-note>
        <p>Numberオブジェクトは、`new`式でNumberコンストラクターにNumber値を渡して生成します。生成されたオブジェクトは内部スロットにNumber値を保持します。Numberオブジェクトは、Numberコンストラクター関数呼び出し（<emu-xref href="#sec-number-constructor-number-value"></emu-xref>）でNumber値に変換できます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-infinity">
      <h1>Infinity</h1>
      <p>正の無限大のNumber値</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-nan">
      <h1>NaN</h1>
      <p>IEEE 754-2019のNaN（非数）値であるNumber値</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-value">
      <h1>BigInt値</h1>
      <p>任意精度整数値に対応するプリミティブ値</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-type">
      <h1>BigInt型</h1>
      <p>すべてのBigInt値の集合</p>
    </emu-clause>

    <emu-clause id="sec-bigint-object">
      <h1>BigIntオブジェクト</h1>
      <p>標準組み込みBigIntコンストラクターのインスタンスであるObject型メンバー</p>
    </emu-clause>

    <emu-clause id="sec-symbol-value">
      <h1>Symbol値</h1>
      <p>一意かつ非Stringのオブジェクトプロパティキーを表すプリミティブ値</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-symbol-type">
      <h1>Symbol型</h1>
      <p>すべてのSymbol値の集合</p>
    </emu-clause>

    <emu-clause id="sec-symbol-object">
      <h1>Symbolオブジェクト</h1>
      <p>標準組み込みSymbolコンストラクターのインスタンスであるObject型メンバー</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-function">
      <h1>関数</h1>
      <p>サブルーチンとして呼び出し可能なObject型のメンバー</p>
      <emu-note>
        <p>関数はプロパティに加えて、呼び出し時の挙動を決定する実行コードと状態を持ちます。関数のコードはECMAScriptで書かれている場合もそうでない場合もあります。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-function">
      <h1>組み込み関数</h1>
      <p>関数である組み込みオブジェクト</p>
      <emu-note>
        <p>組み込み関数の例として`parseInt`や`Math.exp`があります。ホストや実装は、本仕様に記載されていない追加の組み込み関数を提供する場合があります。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-constructor">
      <h1>組み込みコンストラクター</h1>
      <p>コンストラクターである組み込み関数</p>
      <emu-note>
        <p>組み込みコンストラクターの例として`Object`や`Function`があります。ホストや実装は、本仕様に記載されていない追加の組み込みコンストラクターを提供する場合があります。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-property">
      <h1>プロパティ</h1>
      <p>キー（String値またはSymbol値）と値を関連付けるオブジェクトの一部</p>
      <emu-note>
        <p>プロパティの形式によって、値はデータ値（プリミティブ値・オブジェクト・関数オブジェクト）として直接、またはアクセサ関数のペアによって間接的に表現されます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-method">
      <h1>メソッド</h1>
      <p>プロパティの値である関数</p>
      <emu-note>
        <p>関数がオブジェクトのメソッドとして呼び出されると、そのオブジェクトが*this*値として関数に渡されます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-method">
      <h1>組み込みメソッド</h1>
      <p>組み込み関数であるメソッド</p>
      <emu-note>
        <p>標準組み込みメソッドは本仕様で定義されます。ホストや実装は、本仕様に記載されていない追加の組み込みメソッドを提供する場合があります。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-attribute">
      <h1>属性</h1>
      <p>プロパティの特性を定義する内部値</p>
    </emu-clause>

    <emu-clause id="sec-own-property">
      <h1>自身のプロパティ</h1>
      <p>オブジェクトが直接保持するプロパティ</p>
    </emu-clause>

    <emu-clause id="sec-inherited-property">
      <h1>継承プロパティ</h1>
      <p>オブジェクト自身のプロパティではないが、そのプロトタイプのプロパティ（自身または継承）であるプロパティ</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-organization-of-this-specification">
    <h1>本仕様書の構成</h1>
    <p>本仕様書の残りの部分は以下の通り構成されています：</p>
    <p><emu-xref href="#sec-notational-conventions"></emu-xref>では、仕様全体で使用される記法規則を定義します。</p>
    <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref>から<emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>まででは、ECMAScriptプログラムが動作する実行環境を定義します。</p>
    <p><emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>から<emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref>まででは、ECMAScriptプログラミング言語そのもの（構文的記述とすべての言語機能の実行意味論）を定義します。</p>
    <p><emu-xref href="#sec-ecmascript-standard-built-in-objects"></emu-xref>から<emu-xref href="#sec-reflection"></emu-xref>まででは、ECMAScript標準ライブラリを定義します。これには、ECMAScriptプログラムの実行時に利用可能なすべての標準オブジェクトの定義が含まれます。</p>
    <p><emu-xref href="#sec-memory-model"></emu-xref>では、SharedArrayBufferバックメモリへのアクセスおよびAtomicsオブジェクトのメソッドに関するメモリ整合性モデルを説明します。</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notational-conventions">
  <h1>記法規則</h1>

  <emu-clause id="sec-syntactic-and-lexical-grammars">
    <h1>構文・字句文法</h1>

    <emu-clause id="sec-context-free-grammars">
      <h1>文脈自由文法</h1>
      <p><em>文脈自由文法</em>は、複数の<em>生成式</em>で構成されます。各生成式は、<em>非終端記号</em>と呼ばれる抽象的な記号を<em>左辺</em>に持ち、0個以上の非終端記号と<em>終端記号</em>の並びを<em>右辺</em>に持ちます。各文法ごとに、終端記号は指定されたアルファベットから選ばれます。</p>
      <p><dfn variants="chain productions">連鎖生成式</dfn>は、右辺にまさに1個の非終端記号と0個以上の終端記号のみを持つ生成式です。</p>
      <p>区別される単一の非終端記号（<dfn variants="goal symbols">ゴール記号</dfn>）から始めて、与えられた文脈自由文法は<em>言語</em>、すなわち、非終端記号をその左辺となる生成式の右辺で繰り返し置き換えることで得られる終端記号の並びの（おそらく無限の）集合を定義します。</p>
    </emu-clause>

    <emu-clause id="sec-lexical-and-regexp-grammars">
      <h1>字句・正規表現文法</h1>
      <p>ECMAScriptの<em>字句文法</em>は<emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref>で示されています。この文法の終端記号は、<emu-xref href="#sec-source-text"></emu-xref>で定義される|SourceCharacter|の規則に従うUnicodeコードポイントです。ゴール記号|InputElementDiv|、|InputElementTemplateTail|、|InputElementRegExp|、|InputElementRegExpOrTemplateTail|、|InputElementHashbangOrRegExp|から始まる生成式集合が定義され、これらのコードポイントの並びを入力要素の並びへ変換する方法を表します。</p>
      <p>空白やコメント以外の入力要素は、ECMAScriptの構文文法の終端記号となり、ECMAScriptの<em>トークン</em>と呼ばれます。これらのトークンは、予約語、識別子、リテラル、句読点です。さらに、行終端文字はトークンとはみなされませんが、入力要素のストリームの一部となり自動セミコロン挿入（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）を導きます。単純な空白や1行コメントは破棄され、構文文法の入力要素ストリームには現れません。|MultiLineComment|（つまり、`/*`…`*/`形式のコメントで、複数行にまたがるかどうかにかかわらず）は、行終端文字を含まなければ単に破棄されますが、行終端文字が1つ以上含まれていれば、1つの行終端文字に置き換えられ、構文文法の入力要素ストリームの一部となります。</p>
      <p>ECMAScriptの<em>正規表現文法</em>は<emu-xref href="#sec-patterns"></emu-xref>で示されています。この文法の終端記号も|SourceCharacter|で定義されるコードポイントです。ゴール記号|Pattern|から始まる生成式集合が定義され、コードポイントの並びを正規表現パターンへ変換する方法を表します。</p>
      <p>字句文法・正規表現文法の生成式は、「<b>::</b>」の2つのコロンで区切られていることで区別されます。字句文法と正規表現文法は一部の生成式を共有します。</p>
    </emu-clause>

    <emu-clause id="sec-numeric-string-grammar">
      <h1>数値文字列文法</h1>
      <p><em>数値文字列文法</em>は<emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>に示されています。終端記号は|SourceCharacter|であり、ゴール記号|StringNumericLiteral|から文字列を数値値へ変換するために使われます（<emu-xref href="#sec-literals-numeric-literals">数値リテラルの字句文法</emu-xref>とは似ていますが異なります）。</p>
      <p>数値文字列文法の生成式は「<b>:::</b>」の3つのコロンで区切られており、ソーステキストの構文解析には使用されません。</p>
    </emu-clause>

    <emu-clause id="sec-syntactic-grammar">
      <h1>構文文法</h1>
      <p>ECMAScriptの<em>構文文法</em>は<emu-xref href="#sec-ecmascript-language-expressions"></emu-xref>から<emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref>までの節で示されています。この文法の終端記号は字句文法で定義されたECMAScriptトークンです（<emu-xref href="#sec-lexical-and-regexp-grammars"></emu-xref>）。ゴール記号|Script|と|Module|の2つから始まる生成式集合が定義され、トークンの並びがECMAScriptプログラムの構文的に正しい独立要素を形成する方法を表します。</p>
      <p>コードポイントのストリームをECMAScriptの|Script|や|Module|として構文解析する場合、まず字句文法を繰り返し適用して入力要素のストリームに変換し、その後構文文法を1回適用して解析します。入力ストリームが、ゴール非終端記号（|Script|または|Module|）の単一インスタンスとして解析できず、トークンが余る場合は構文エラーとなります。</p>
      <p>構文解析が成功すると、<em>構文木</em>という根付きの木構造が構築され、各ノードは<dfn variants="Parse Nodes">構文ノード</dfn>です。各構文ノードは文法記号の<em>インスタンス</em>であり、その記号から導出できるソーステキストの範囲を表します。構文木の根ノードは解析全体のゴール記号のインスタンスです。構文ノードが非終端記号のインスタンスである場合、その非終端記号を左辺に持つ生成式のインスタンスでもあります。また、右辺の各記号ごとに0個以上の<em>子ノード</em>を持ちます。各子は対応する記号のインスタンスである構文ノードです。</p>
      <p>構文ノードはパーサーの呼び出しごとに新たに生成され、同じソーステキストでも解析間で使い回されることはありません。構文ノードは、同じソース範囲を表し、同じ文法記号のインスタンスであり、同じパーサー呼び出しから生成された場合のみ<dfn>同じ構文ノード</dfn>とみなされます。</p>
      <emu-note>
        <p>同じ文字列を複数回解析すると、異なる構文ノードが得られます。例えば：</p>
        <pre><code class="javascript">
          let str = "1 + 1;";
          eval(str);
          eval(str);
        </code></pre>
        <p>それぞれの`eval`呼び出しは、`str`の値をECMAScriptソーステキストに変換し、独立した構文木を生成する個別の解析を行います。各木は、同じ文字列値から導出されたソーステキストであっても別物です。</p>
      </emu-note>
      <emu-note>構文ノードは仕様上のアーティファクトであり、実装が同様のデータ構造を使う必要はありません。</emu-note>
      <p>構文文法の生成式は、区切りが1つのコロン「<b>:</b>」であることで区別されます。</p>
      <p>構文文法は、<emu-xref href="#sec-ecmascript-language-expressions"></emu-xref>から<emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref>までで示されるものだけでは、どのトークン並びが正しいECMAScriptの|Script|や|Module|として受理されるかの完全な説明にはなりません。特定の追加トークン並び（たとえば行終端文字の前にセミコロンを追加した場合など）は、文法で記述されていれば受理されます。逆に、文法で記述されていても、行終端文字が「不自然」な場所に現れると受理されない場合もあります。</p>
      <p>曖昧さ回避のため、構文文法では有効なECMAScriptの|Script|や|Module|にならないトークン並びも許容する一般化生成式が使われる場合があります。例えば、オブジェクトリテラルや分割代入パターンでこの手法が使われます。その場合、より制約された<em>補助文法</em>が提供され、受理可能なトークン並びが制限されます。通常、早期エラー規則で「"_P_は_N_を<dfn id="must-cover">カバーしなければならない</dfn>"」と記されます。_P_は一般化生成式の構文ノード、_N_は補助文法の非終端記号です。これは次の意味です：</p>
      <ol>
        <li>_P_がもともとマッチしたトークン並びを、_N_をゴール記号として再度解析します。_N_が文法パラメータを持つ場合は、_P_の解析時と同じ値で設定します。</li>
        <li>トークン並びが、余りなく_N_の単一インスタンスとして解析できれば：
          <ol>
            <li>その_N_のインスタンス（_P_固有の構文ノード）を「_P_によって<dfn>カバーされた</dfn>_N_」と呼びます。</li>
            <li>_N_およびその派生生成式の早期エラー規則は、_P_によってカバーされた_N_にも適用されます。</li>
          </ol>
        </li>
        <li>そうでなければ（解析失敗時）、早期構文エラーとなります。</li>
      </ol>
    </emu-clause>

    <emu-clause id="sec-grammar-notation" namespace="grammar-notation">
      <h1>文法記法</h1>

      <emu-clause id="sec-terminal-symbols">
        <h1>終端記号</h1>
        <p>ECMAScriptの文法では、`等幅`フォントで示される終端記号があります。これらはソーステキストに正確に記述されたとおりに現れなければなりません。このように指定されたすべての終端記号コードポイントは、他のUnicode範囲ではなく、基本ラテンブロックの適切なUnicodeコードポイントであると理解されます。終端記号内のコードポイントは、`\\` |UnicodeEscapeSequence|で表現することはできません。</p>
        <p>終端記号が個々のUnicodeコードポイントで構成される文法（字句・正規表現・数値文字列文法）では、生成式内の複数の等幅コードポイントの連続は、同じコードポイントの並びを個別の終端記号として書く省略表記です。</p>
        <p>例えば、次の生成式：</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0x` HexDigits
        </emu-grammar>
        <p>は、次の省略表記です：</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0` `x` HexDigits
        </emu-grammar>
        <p>一方、構文文法では、等幅コードポイントの連続は1つの終端記号です。</p>
        <p>終端記号には他にも2つの形式があります：</p>
        <ul>
          <li>字句文法・正規表現文法では、通常の印刷表現がないUnicodeコードポイントは、"&lt;ABBREV>"の形で示されます。"ABBREV"はコードポイントまたはその集合の略称です。これらの形式は<emu-xref href="#sec-unicode-format-control-characters" title></emu-xref>、<emu-xref href="#sec-white-space" title></emu-xref>、<emu-xref href="#sec-line-terminators" title></emu-xref>で定義されます。</li>
          <li>構文文法では、特定の終端記号（例：|IdentifierName|や|RegularExpressionLiteral|）は斜体で示され、字句文法の同名非終端記号を参照しています。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-nonterminal-symbols-and-productions">
        <h1>非終端記号と生成式</h1>
        <p>非終端記号は<i>斜体</i>で示されます。非終端記号（「生成式」とも呼ばれる）の定義は、定義される非終端記号の名前の後に1つ以上のコロンを続けて導入されます。（コロンの数はその生成式が属する文法を示します。）非終端記号の右辺の選択肢が続く形になります。例えば、構文定義：</p>
        <emu-grammar type="definition" example>
          WhileStatement :
            `while` `(` Expression `)` Statement
        </emu-grammar>
        <p>は、非終端記号|WhileStatement|が、`while`トークン、左括弧トークン、|Expression|、右括弧トークン、|Statement|の並びを表すことを示します。|Expression|や|Statement|はそれ自体非終端記号です。別の例として、構文定義：</p>
        <emu-grammar type="definition" example>
          ArgumentList :
            AssignmentExpression
            ArgumentList `,` AssignmentExpression
        </emu-grammar>
        <p>は、|ArgumentList|が、単一の|AssignmentExpression|または、|ArgumentList|の後にカンマと|AssignmentExpression|が続く場合のいずれかを表すことを示します。この|ArgumentList|の定義は再帰的であり、自己参照によって任意個数の引数（各引数式は|AssignmentExpression|）をカンマ区切りで持つことができます。このような非終端記号の再帰定義はよく使われます。</p>
      </emu-clause>

      <emu-clause id="sec-optional-symbols">
        <h1>省略可能記号</h1>
        <p>終端記号や非終端記号の後に「<sub>opt</sub>」という下付き文字が付く場合、省略可能記号を表します。省略可能記号を含む選択肢は、実際には省略要素なしとありの2つの右辺を指定します。つまり：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer?
        </emu-grammar>
        <p>は、次の省略表記です：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer
        </emu-grammar>
        <p>また、次の：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <p>は、次の省略表記です：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression? `)` Statement
        </emu-grammar>
        <p>さらに、次の省略表記です：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` `)` Statement
            `for` `(` LexicalDeclaration `;` Expression `)` Statement
            `for` `(` LexicalDeclaration Expression `;` `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
        </emu-grammar>
        <p>つまり、この例では非終端記号|ForStatement|は実際には4つの右辺選択肢を持ちます。</p>
      </emu-clause>

      <emu-clause id="sec-grammatical-parameters">
        <h1>文法パラメータ</h1>
        <p>生成式は、下付きの「<sub>[parameters]</sub>」という注釈でパラメータ化できます。これは定義される非終端記号の後ろに付与されます。「<sub>parameters</sub>」は単一名またはカンマ区切りの複数名です。パラメータ化された生成式は、パラメータ名のすべての組合せに対して、パラメータ化非終端記号にアンダースコアで付加したものとして生成式を定義する省略表記です。つまり：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>は、次の省略表記です：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>また、次の：</p>
        <emu-grammar type="definition" example>
          StatementList[Return, In] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>は、次の省略表記です：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement

          StatementList_In :
            ReturnStatement
            ExpressionStatement

          StatementList_Return_In :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>複数パラメータは、完全な文法で参照されない生成式も含め、組合せ数だけ生成式を生みます。</p>
        <p>生成式右辺の非終端記号への参照もパラメータ化できます。例えば：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[+In]
        </emu-grammar>
        <p>は、次の表現と同義です：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement_In
        </emu-grammar>
        <p>また、次の：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[~In]
        </emu-grammar>
        <p>は、次の表現と同義です：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>非終端記号参照には、パラメータリストと「<sub>opt</sub>」を両方付けることもできます。例えば：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer[+In]?
        </emu-grammar>
        <p>は、次の表現と同義です：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>右辺の非終端記号参照に「<sub>?</sub>」付きパラメータ名を付けると、そのパラメータ値は現在の生成式左辺への参照時に使われたパラメータ名の有無に依存します。例えば：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration[In] :
            BindingIdentifier Initializer[?In]
        </emu-grammar>
        <p>は、次の表現と同義です：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer

          VariableDeclaration_In :
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>右辺選択肢の先頭に「[+parameter]」が付く場合、その選択肢は参照時にパラメータ名が使われている場合のみ利用可能です。「[\~parameter]」付きの場合は、参照時にパラメータ名が<em>使われていない</em>場合のみ利用可能です。つまり：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [+Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>は、次の表現と同義です：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>また、次の：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [~Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>は、次の表現と同義です：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ExpressionStatement
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-one-of">
        <h1>one of</h1>
        <p>文法定義のコロンの後に「<b>one of</b>」と記されている場合、続く行に示す各終端記号がそれぞれ代替定義であることを意味します。例えば、ECMAScriptの字句文法には次の生成式があります：</p>
        <emu-grammar type="definition" example>
          NonZeroDigit :: one of
            `1` `2` `3` `4` `5` `6` `7` `8` `9`
        </emu-grammar>
        <p>これは、次の表現の省略形です：</p>
        <emu-grammar type="definition" example>
          NonZeroDigit ::
            `1`
            `2`
            `3`
            `4`
            `5`
            `6`
            `7`
            `8`
            `9`
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-empty">
        <h1>[empty]</h1>
        <p>生成式の右辺に「[empty]」と記されている場合、その生成式の右辺には終端記号も非終端記号も含まれないことを示します。</p>
      </emu-clause>

      <emu-clause id="sec-lookahead-restrictions">
        <h1>先読み制約</h1>
        <p>生成式の右辺に「[lookahead = _seq_]」と記されている場合、その生成式はトークン並び_seq_が直後の入力トークン並びの接頭辞である場合のみ利用できます。同様に「[lookahead ∈ _set_]」では、_set_のいずれかの要素が直後のトークン並びの接頭辞である場合のみ利用できます。簡便のため、_set_を非終端記号として書くこともでき、その場合はその非終端記号が展開できるすべてのトークン並びの集合を表します。非終端記号が無限個の異なるトークン並びに展開できる場合、編集上の誤りとされます。</p>
        <p>これらの条件は否定できます。「[lookahead ≠ _seq_]」は、_seq_が直後の入力トークン並びの接頭辞<em>でない</em>場合のみ利用できることを意味し、「[lookahead ∉ _set_]」は、_set_のいずれの要素も直後のトークン並びの接頭辞でない場合のみ利用できます。</p>
        <p>例として、次の定義を考えます：</p>
        <emu-grammar type="definition" example>
          DecimalDigit :: one of
            `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

          DecimalDigits ::
            DecimalDigit
            DecimalDigits DecimalDigit
        </emu-grammar>
        <p>次の定義：</p>
        <emu-grammar type="definition" example>
          LookaheadExample ::
            `n` [lookahead &notin; { `1`, `3`, `5`, `7`, `9` }] DecimalDigits
            DecimalDigit [lookahead &notin; DecimalDigit]
        </emu-grammar>
        <p>は、アルファベット`n`の後に1つ以上の10進数字が続き、その最初が偶数である場合、または10進数字の後にさらに数字が続かない場合にマッチします。</p>
        <p>これらの句が構文文法で使われる場合、直後のトークン並びを一意に特定できない可能性があることに注意してください。後続トークンの決定には後続位置で使う字句ゴール記号の選択が必要となるためです。したがって、構文文法でこれらを使う場合、_seq_のトークン並びが先読み制約（集合の一部としても）に現れ、字句ゴール記号の選択によって接頭辞となるかどうかが変わる場合、編集上の誤りとされます。</p>
      </emu-clause>

      <emu-clause id="sec-no-lineterminator-here">
        <h1>[no |LineTerminator| here]</h1>
        <p>構文文法の生成式の右辺に「[no |LineTerminator| here]」と記されている場合、その生成式は<em>制限生成式</em>であり、指定された位置に|LineTerminator|が入力ストリームに現れると利用できません。例えば、次の生成式：</p>
        <emu-grammar type="definition" example>
          ThrowStatement :
            `throw` [no LineTerminator here] Expression `;`
        </emu-grammar>
        <p>は、`throw`トークンと|Expression|の間に|LineTerminator|が現れる場合、生成式を利用できないことを示します。</p>
        <p>制限生成式で|LineTerminator|の存在が禁止されていない限り、入力要素ストリームの任意の2つの連続トークンの間に|LineTerminator|がいくら現れても、スクリプトの構文的な正当性には影響しません。</p>
      </emu-clause>

      <emu-clause id="sec-but-not">
        <h1>but not</h1>
        <p>生成式の右辺は、「<b>but not</b>」という句を使って、特定の展開を許可しないことを指定できます。例えば、次の生成式：</p>
        <emu-grammar type="definition" example>
          Identifier ::
            IdentifierName but not ReservedWord
        </emu-grammar>
        <p>は、非終端記号|Identifier|は|IdentifierName|で置換できるコードポイント並びのうち、同じ並びが|ReservedWord|でも置換できる場合を除くことを意味します。</p>
      </emu-clause>

      <emu-clause id="sec-descriptive-phrases">
        <h1>記述的句</h1>
        <p>最後に、非終端記号のうち、すべての選択肢を列挙するのが非現実的な場合、サンセリフ体の記述的句で説明されるものがあります：</p>
        <emu-grammar type="definition" example>
          SourceCharacter ::
            &gt; any Unicode code point
        </emu-grammar>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-algorithm-conventions">
    <h1>アルゴリズム規則</h1>
    <p>仕様書では、アルゴリズムの手順を指定するために番号付きリストをよく使用します。これらのアルゴリズムは、ECMAScript言語構成要素の必要な意味論を厳密に規定するために使われます。ただし、特定の実装技法の使用を示唆するものではありません。実際には、ある機能を実装するためにより効率的なアルゴリズムが存在する場合もあります。</p>
    <p>アルゴリズムは、順序付きのカンマ区切りのエイリアス名の列で明示的にパラメータ化されることがあります。これらの名前は、アルゴリズムの手順内でその位置に渡された引数を参照するために使用できます。省略可能なパラメータは角括弧([ , _name_ ])で囲まれて示され、アルゴリズム手順内では必須パラメータと違いはありません。パラメータリストの末尾には、先頭に省略記号(..._name_)を付けたrestパラメータを指定できます。restパラメータは、必須・省略可能パラメータの後に渡された全ての引数をListにまとめて受け取ります。追加の引数がない場合、そのListは空です。</p>
    <p>アルゴリズムの手順は、順序付きのサブステップに分割できます。サブステップはインデントされ、さらにインデントされたサブステップに分割することもできます。アウトライン番号付け規則により、最初のサブステップは小文字アルファベット、次のレベルは小文字ローマ数字でラベル付けされます。3段階を超える場合は、4段階目で数字ラベルが使われ、以降繰り返します。例えば:</p>
    <emu-alg example>
      1. 最上位の手順
        1. サブステップ
        1. サブステップ
          1. サブサブステップ
            1. サブサブサブステップ
              1. サブサブサブサブステップ
                1. サブサブサブサブサブステップ
    </emu-alg>
    <p>手順やサブステップは、「if」条件で書かれており、サブステップは条件が真の時のみ適用されます。「else」で始まる場合は、同じ階層の直前の「if」手順の否定条件になります。</p>
    <p>手順は、サブステップの反復適用を指定することがあります。</p>
    <p>「<dfn id="assert">Assert</dfn>:」で始まる手順やサブステップは、そのアルゴリズムの不変条件を主張します。これらのアサートは、暗黙的なアルゴリズム不変性を明示するために使われます。アサートは追加の意味的要件を持たず、実装がチェックする必要はありません。アルゴリズムの明確化のためだけに使用されます。</p>
    <p>アルゴリズム手順では、「Let _x_ be _someValue_」の形式で任意の値に名前付きエイリアスを宣言できます。これらのエイリアスは参照のようなもので、_x_と_someValue_は同じデータを参照し、どちらかを変更すると両方に反映されます。参照的挙動を避けたい場合は、「Let _x_ be a copy of _someValue_」と明示的にコピーを作成することもできます。</p>
    <p>エイリアスは宣言後の任意の手順で参照できますが、宣言より前の手順では参照できません。エイリアスは「Set _x_ to _someOtherValue_」の形式で変更できます。</p>

    <emu-clause id="sec-algorithm-conventions-abstract-operations">
      <h1>抽象操作</h1>
      <p>この仕様の複数箇所で利用しやすくするために、あるアルゴリズム（<dfn>抽象操作</dfn>）は名前付き・パラメータ化された関数形式で記述され、他のアルゴリズムから名前で参照できるようになっています。抽象操作は通常、OperationName(_arg1_, _arg2_)のような関数呼び出し形式で参照されます。一部の抽象操作は、クラスライクな仕様抽象のメソッドとして多態的に呼び出されます。メソッドライク抽象操作は、_someValue_.OperationName(_arg1_, _arg2_)のようなメソッド呼び出し形式で参照されます。</p>
    </emu-clause>

    <emu-clause id="sec-algorithm-conventions-syntax-directed-operations">
      <h1>構文指示操作</h1>
      <p><dfn variants="syntax-directed operations">構文指示操作</dfn>は、名前付き操作であり、その定義は複数のアルゴリズムからなり、それぞれがECMAScript文法の1つ以上の生成式に関連付けられています。生成式が複数の代替定義を持つ場合、各代替ごとに異なるアルゴリズムがあることが多いです。アルゴリズムが文法生成式に関連付けられている場合、生成式代替の終端記号や非終端記号をアルゴリズムのパラメータのように参照できます。この場合、非終端記号は、ソーステキストを構文解析したときにマッチした実際の代替定義を参照します。文法生成式やそこから導出されるParse Nodeがマッチしたソーステキストとは、最初にマッチした終端記号から最後にマッチした終端記号までのソーステキスト部分です。</p>
      <p>アルゴリズムが生成式代替に関連付けられる場合、代替は通常「[ ]」文法注釈なしで示されます。これらの注釈は代替の構文的認識のみに影響し、代替に関連付けられた意味論には影響しません。</p>
      <p>構文指示操作は、パースノードと（必要に応じて）他のパラメータを使って、以下のアルゴリズムの手順<emu-xref href="#step-sdo-invocation-example-1"></emu-xref>、<emu-xref href="#step-sdo-invocation-example-2"></emu-xref>、<emu-xref href="#step-sdo-invocation-example-3"></emu-xref>で示される規則で呼び出します:</p>
      <emu-alg example>
        1. [id="step-sdo-invocation-example-1"] Let _status_ be SyntaxDirectedOperation of |SomeNonTerminal|.
        1. Let _someParseNode_ be the parse of some source text.
        1. [id="step-sdo-invocation-example-2"] Perform SyntaxDirectedOperation of _someParseNode_.
        1. [id="step-sdo-invocation-example-3"] Perform SyntaxDirectedOperation of _someParseNode_ with argument *"value"*.
      </emu-alg>
      <p>明示的な記載がない限り、すべての連鎖生成式には、その生成式の左辺非終端記号に適用される可能性のあるすべての操作の暗黙定義があります。暗黙定義は、同じ操作を同じパラメータ（あれば）で連鎖生成式の唯一の右辺非終端記号に再適用し、その結果を返すだけです。たとえば、あるアルゴリズムに「Return Evaluation of |Block|」という手順があり、次の生成式があるとします:</p>
      <emu-grammar example>
        Block :
          `{` StatementList `}`
      </emu-grammar>
      <p>Evaluation操作がその生成式にアルゴリズムを関連付けていない場合、Evaluation操作には次のような暗黙の関連付けが含まれます:</p>
      <p><b>実行時意味論: Evaluation</b></p>
      <emu-grammar example>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg example>
        1. Return Evaluation of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics">
      <h1>実行時意味論</h1>
      <p>実行時に呼び出される必要がある意味論を規定するアルゴリズムは<dfn>実行時意味論</dfn>と呼ばれます。実行時意味論は抽象操作または構文指示操作によって定義されます。</p>

      <emu-clause id="sec-completion-ao" type="abstract operation">
        <h1>
          Completion (
            _completionRecord_: Completion Record,
          ): Completion Record
        </h1>
        <dl class="header">
          <dt>説明</dt>
          <dd>Completion Recordが返されることを強調するために使われます。</dd>
          <dt>returnチェック省略</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: _completionRecord_はCompletion Recordである。
          1. _completionRecord_を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throw-an-exception">
        <h1>例外を投げる</h1>
        <p>例外を投げるように記載されたアルゴリズム手順、例えば</p>
        <emu-alg example>
          1. *TypeError*例外を投げる。
        </emu-alg>
        <p>は、次の意味と同じです:</p>
        <emu-alg example>
          1. ThrowCompletion(新しく生成された*TypeError*オブジェクト)を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt" aoid="ReturnIfAbrupt">
        <h1>ReturnIfAbrupt</h1>
        <p>次のような記載やそれに相当するアルゴリズム手順:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_argument_)。
        </emu-alg>
        <p>は、次の意味と同じです:</p>
        <emu-alg example>
          1. Assert: _argument_はCompletion Recordである。
          1. _argument_がabrupt completionなら、Completion(_argument_)を返す。
          1. それ以外の場合、_argument_を_argument_.[[Value]]にセットする。
        </emu-alg>
        <p>次のような記載やそれに相当するアルゴリズム手順:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(AbstractOperation())。
        </emu-alg>
        <p>は、次の意味と同じです:</p>
        <emu-alg example>
          1. Let _hygienicTemp_ be AbstractOperation()。
          1. Assert: _hygienicTemp_はCompletion Recordである。
          1. _hygienicTemp_がabrupt completionなら、Completion(_hygienicTemp_)を返す。
          1. それ以外の場合、_hygienicTemp_を_hygienicTemp_.[[Value]]にセットする。
        </emu-alg>
        <p>ここで、_hygienicTemp_はReturnIfAbruptに関する手順でのみ一時的に可視です。</p>
        <p>次のような記載やそれに相当するアルゴリズム手順:</p>
        <emu-alg example>
          1. Let _result_ be AbstractOperation(ReturnIfAbrupt(_argument_))。
        </emu-alg>
        <p>は、次の意味と同じです:</p>
        <emu-alg example>
          1. Assert: _argument_はCompletion Recordである。
          1. _argument_がabrupt completionなら、Completion(_argument_)を返す。
          1. それ以外の場合、_argument_を_argument_.[[Value]]にセットする。
          1. Let _result_ be AbstractOperation(_argument_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt-shorthands">
        <h1>ReturnIfAbruptの省略記法</h1>
        <p>抽象操作や構文指示操作の呼び出しの前に`?`が付く場合、ReturnIfAbruptをそのCompletion Recordに適用することを示します。例えば、この手順:</p>
        <emu-alg example>
          1. ? OperationName()。
        </emu-alg>
        <p>は次の手順と同義です:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(OperationName())。
        </emu-alg>
        <p>同様に、メソッド呼び出し形式の場合は:</p>
        <emu-alg example>
          1. ? _someValue_.OperationName()。
        </emu-alg>
        <p>は次の手順と同義です:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_someValue_.OperationName())。
        </emu-alg>
        <p>また、`!`のプレフィックスは、後続の抽象操作や構文指示操作の呼び出しがabrupt completionを返さないことを示し、Completion Recordの[[Value]]フィールドを操作の戻り値として使うことを意味します。例えば、この手順:</p>
        <emu-alg example>
          1. Let _val_ be ! OperationName()。
        </emu-alg>
        <p>は、次の手順と同義です:</p>
        <emu-alg example>
          1. Let _val_ be OperationName()。
          1. Assert: _val_はnormal completionである。
          1. _val_を_val_.[[Value]]にセットする。
        </emu-alg>
        <p>実行時意味論の構文指示操作では、操作呼び出しの前に`!`または`?`を付けてこの省略記法を利用します:</p>
        <emu-alg example>
          1. ! SyntaxDirectedOperation of |NonTerminal|を実行する。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-implicit-normal-completion" oldids="sec-implicit-completion-values">
        <h1>暗黙のnormal completion</h1>
        <p>Completion Recordを返すことが宣言された抽象操作内や、全ての組み込み関数内のアルゴリズムでは、返される値はまずNormalCompletionに渡され、その結果が代わりに使われます。この規則はCompletionアルゴリズム内や、その手順でCompletion Recordと明示されている場合には適用されません。具体的には次のケースです:</p>
        <ul>
          <li>Completion、NormalCompletion、ThrowCompletion、ReturnCompletionの適用結果を直接返す場合</li>
          <li>Completion Recordの構築結果を直接返す場合</li>
        </ul>
        <p>これら以外の方法でCompletion Recordを返すことは編集上の誤りです。例として、これらの抽象操作内では、</p>
        <emu-alg example>
          1. *true*を返す。
        </emu-alg>
        <p>は次のいずれかと同義です:</p>
        <emu-alg example>
          1. NormalCompletion(*true*)を返す。
        </emu-alg>
        <p>あるいは</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*)。
          1. Completion(_completion_)を返す。
        </emu-alg>
        <p>あるいは</p>
        <emu-alg example>
          1. Completion Record { [[Type]]: ~normal~, [[Value]]: *true*, [[Target]]: ~empty~ }を返す。
        </emu-alg>
        <p>ReturnIfAbrupt展開によって、次の例は許容されます。展開後の手順内でCompletionの適用結果がabruptの場合は直接返され、normalの場合はアンラップ後に暗黙のNormalCompletion適用が行われます。</p>
        <emu-alg example>
          1. Return ? _completion_。
        </emu-alg>
        <p>次の例は、Completion Recordをその手順で注釈なしに返しているため編集上の誤りです。</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*)。
          1. _completion_を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-static-semantic-rules">
      <h1>静的意味論</h1>
      <p>文脈自由文法だけでは、入力要素のストリームが評価可能な有効なECMAScriptの|Script|や|Module|になるかどうかを定義する全ての規則を表現することはできません。場合によっては、ECMAScriptアルゴリズム規則や記述的要件を使って追加の規則を記述する必要があります。これらの規則は常に文法生成式に関連付けられ、生成式の<dfn>静的意味論</dfn>と呼ばれます。</p>
      <p>静的意味論規則には名前があり、通常アルゴリズムで定義されます。名前付き静的意味論規則は文法生成式に関連付けられ、生成式が複数の代替定義を持つ場合、各代替ごとに適用される名前付き静的意味論規則のアルゴリズムが異なることが多いです。</p>
      <p>静的意味論規則の中には、<dfn id="early-error-rule">早期エラー規則</dfn>という特別なものがあります。早期エラー規則は、特定の文法生成式に関連付けられた早期エラー条件（<emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref>参照）を定義します。ほとんどの早期エラー規則の評価は、仕様のアルゴリズム内で明示的に呼び出されません。適合実装は、|Script|や|Module|を初めて評価する前に、パースに使われた生成式の全ての早期エラー規則を検証しなければなりません。早期エラー規則が違反している場合、その|Script|や|Module|は無効となり、評価できません。</p>
    </emu-clause>

    <emu-clause id="sec-mathematical-operations">
      <h1>数学演算</h1>
      <p>本仕様書では、以下の種類の数値値に言及します:</p>
      <ul>
        <li><dfn id="mathematical-value" variants="mathematical value,mathematical values">数学値</dfn>: 任意の実数。デフォルトの数値型として使われます。</li>
        <li><dfn id="extended-mathematical-value" variants="extended mathematical value,extended mathematical values">拡張数学値</dfn>: 数学値に加えて+∞と-∞を含みます。</li>
        <li><em>Numbers</em>: IEEE 754-2019 binary64（倍精度浮動小数点）値。</li>
        <li><em>BigInts</em>: ECMAScript言語値であり、任意の整数を一対一で表現します。</li>
      </ul>

      <p>仕様書の記述では、数値値は下付き添え字で種類が区別されます。添え字<sub>𝔽</sub>はNumber、添え字<sub>ℤ</sub>はBigIntを指します。添え字なしは数学値です。数値の表記はほとんど10進数ですが、0xに続く数字0-9やA-Fは16進数値として使われます。</p>
      <p>一般に、本仕様が数値値（例えば「_y_の長さ」や「4桁の16進数が表す整数」など）に言及する場合、数値種類を明示しない限り数学値を指します。NumberやBigInt値に言及する場合は、明示的に注釈されます（例:「…のcode point数のNumber値」や「…のBigInt値」など）。</p>
      <p>本仕様で<dfn id="integer" oldids="mathematical integer" variants="integers">整数</dfn>という用語は、特に断りがない限り、整数集合に属する数学値を指します。<dfn id="integral-number" oldids="sec-isintegralnumber,sec-isinteger" variants="integral Numbers">整数値(Number)</dfn>は、その数学値が整数集合に属する有限のNumber値を指します。</p>
      <p>数値演算子（+, ×, =, ≥など）は、オペランドの型に応じた演算を指します。数学値に適用すれば通常の数学演算、拡張数学値なら拡張実数上の演算（未定義形は定義しないので仕様に現れたら編集誤り）、NumberならIEEE 754-2019の演算、BigIntならBigIntの数学値への演算です。型の異なるオペランドへの数値演算子の適用（例: Numberと数学値）は未定義であり、仕様書に現れたら編集誤りです。</p>
      <p>数学値とNumberやBigInt間の変換は常に明示的です。数学値または拡張数学値_x_からNumberへの変換は「_x_のNumber値」または<emu-eqn id="𝔽" aoid="𝔽">𝔽(_x_)</emu-eqn>と記述され、<emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>で定義されます。整数_x_からBigIntへの変換は「_x_の<dfn id="bigint-value-for">BigInt値</dfn>」または<emu-eqn id="ℤ" aoid="ℤ">ℤ(_x_)</emu-eqn>と記述されます。NumberやBigInt_x_から数学値への変換は「_x_の<dfn id="mathematical-value-of">数学値</dfn>」または<emu-eqn id="ℝ" aoid="ℝ">ℝ(_x_)</emu-eqn>と記述されます。*+0*<sub>𝔽</sub>と*-0*<sub>𝔽</sub>の数学値は数学値0です。非有限値の数学値は定義されません。<dfn id="extended-mathematical-value-of">拡張数学値</dfn>は有限値に対しては数学値、*+∞*<sub>𝔽</sub>と*-∞*<sub>𝔽</sub>に対してはそれぞれ+∞と-∞、*NaN*には定義されません。</p>
      <p>数学関数<emu-eqn id="eqn-abs" aoid="abs">abs(_x_)</emu-eqn>は_x_の絶対値（_x_ &lt; 0なら- _x_、それ以外は_x_）を返します。</p>
      <p>数学関数<emu-eqn id="eqn-min" aoid="min">min(_x1_, _x2_, … , _xN_)</emu-eqn>は<emu-eqn>_x1_</emu-eqn>から<emu-eqn>_xN_</emu-eqn>までの最小値、<emu-eqn id="eqn-max" aoid="max">max(_x1_, _x2_, ..., _xN_)</emu-eqn>は最大値を返します。これらの関数の定義域と値域は拡張数学値です。</p>
      <p>記法「<emu-eqn id="eqn-modulo" aoid="modulo">_x_ modulo _y_</emu-eqn>」（_y_は有限かつ非零）は、_y_と同じ符号（または0）で絶対値が_y_未満になる値_k_を計算し、<emu-eqn>abs(_k_) &lt; abs(_y_) and _x_ - _k_ = _q_ × _y_</emu-eqn>（_q_は整数）を満たします。</p>
      <p>「_x_を_lower_から_upper_の間で<dfn id="clamping">クランプする</dfn>」という句（_x_は拡張数学値、_lower_と_upper_は_lower_ ≤ _upper_な数学値）は、_x_ &lt; _lower_なら_lower_、_x_ > _upper_なら_upper_、それ以外は_x_を返します。</p>
      <p>数学関数<emu-eqn id="eqn-floor" aoid="floor">floor(_x_)</emu-eqn>は_x_以下で最大の整数（+∞に最も近いもの）を返します。</p>
      <emu-note>
        <p><emu-eqn>floor(_x_) = _x_ - (_x_ modulo 1)</emu-eqn>です。</p>
      </emu-note>
      <p>数学関数<emu-eqn id="eqn-truncate" aoid="truncate">truncate(_x_)</emu-eqn>は_x_の小数部をゼロ方向に切り捨て、_x_ &lt; 0なら<emu-eqn>-floor(-_x_)</emu-eqn>、それ以外は<emu-eqn>floor(_x_)</emu-eqn>を返します。</p>
      <p>数学関数min, max, abs, floor, truncateはNumberやBigIntには定義されません。非数学値引数でこれらの関数を使うのは仕様書の編集誤りです。</p>
      <p><dfn id="interval">区間</dfn>とは、下限_a_から上限_b_までの同じ数値型の値（無限または空の場合もある）の集合です。各端点は包含か排他かどちらかのみ指定されます。区間には次の4種類があります:</p>
      <ul>
        <li>_a_（包含）から_b_（包含）の区間: <dfn id="inclusive-interval">包含区間</dfn>とも呼ばれ、_a_ ≤ _x_ ≤ _b_を満たす値_x_のみ含みます。</li>
        <li>_a_（包含）から_b_（排他）の区間: _a_ ≤ _x_ &lt; _b_を満たす値_x_のみ含みます。</li>
        <li>_a_（排他）から_b_（包含）の区間: _a_ &lt; _x_ ≤ _b_を満たす値_x_のみ含みます。</li>
        <li>_a_（排他）から_b_（排他）の区間: _a_ &lt; _x_ &lt; _b_を満たす値_x_のみ含みます。</li>
      </ul>
      <p>例えば、1（包含）から2（排他）の区間は1以上2未満の数学値全て（1は含み、2は含まない）です。区間定義の目的で、*-0*<sub>𝔽</sub> &lt; *+0*<sub>𝔽</sub>（比較対象が0の場合のエラー回避コメントあり）なので、例えば下端が*+0*<sub>𝔽</sub>の包含区間は*+0*<sub>𝔽</sub>のみ含み、*-0*<sub>𝔽</sub>は含みません。*NaN*は区間に含まれません。</p>
    </emu-clause>

    <emu-clause id="sec-value-notation">
      <h1>値の記法</h1>
      <p>本仕様書では、ECMAScript言語値は*太字*で表示されます。例: *null*, *true*, *"hello"*など。これらは、`Function.prototype.apply`や`let n = 42;`などのECMAScriptソーステキストとは区別されます。</p>
    </emu-clause>

    <emu-clause id="sec-identity">
      <h1>同一性</h1>
      <p>本仕様書では、仕様値とECMAScript言語値の両方の等価性を比較します。等価性を比較する場合、値は2つのカテゴリのいずれかに属します。<dfn variants="values without identity,value without identity">同一性のない値</dfn>は、全ての本質的特徴が同じであれば他の同一性のない値と等価です（整数の大きさや配列の長さなど）。同一性のない値は、特徴を完全に記述することで事前参照なしに現すことができます。対照的に、<dfn variants="values with identity">同一性を持つ値</dfn>は一意であり自分自身とだけ等価です。同一性を持つ値は、同一性のない値の特徴に加え、推測不可・不変・普遍的な<em>同一性</em>という特徴を持ちます。既存の同一性を持つ値への参照は、同一性自体が記述不可能なので記述によって現せず、明示的に他所から受け渡す必要があります。同一性を持つ値の一部は可変であり、特徴（同一性以外）はその場で変更可能で、値を保持する者全員が新しい特徴を観察することになります。同一性のない値は同一性を持つ値と等価になることはありません。</p>
      <p>本仕様書の観点では、「is」は2つの値の等価性比較に使われます（例:「_bool_ is *true*なら…」）。「contains」はリスト内の値を等価性比較で探索する場合に使われます（例:「_list_がRecord _r_（_r_.[[Foo]] is *true*）を含むなら…」）。値の<em>仕様同一性</em>がこれらの比較結果を決定し、本仕様では公理的に扱います。</p>
      <p>ECMAScript言語の観点では、言語値の等価性比較はSameValue抽象操作と、それが遡及的に呼び出す抽象操作で行われます。これらの比較抽象操作のアルゴリズムがECMAScript言語値の<em>言語同一性</em>を定義します。</p>
      <p>仕様値の例として、仕様同一性を持たない値には、数学値・拡張数学値、ECMAScriptソーステキスト、サロゲートペア、Directive Prologue、UTF-16コード単位、Unicodeコードポイント、enum、抽象操作（構文指示操作・ホストフック等）、順序対などが含まれます。仕様同一性を持つ値には、Record（Property Descriptor、PrivateElement等）、Parse Node、List、<emu-xref href="#sec-set-and-relation-specification-type">Set</emu-xref>・Relation、Abstract Closure、Data Block、Private Name、実行コンテキスト・スタック、agent signifier、WaiterList Recordなどがあります。</p>
      <p>仕様同一性は、<emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>で生成されたSymbol値を除き、全てのECMAScript言語値で言語同一性と一致します。仕様同一性も言語同一性も持たないECMAScript言語値は、<emu-xref href="#sec-ecmascript-language-types-undefined-type">*undefined*</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-null-type">*null*</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-boolean-type">Boolean</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-string-type">String</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-number-type">Number</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-bigint-type">BigInt</emu-xref>です。仕様同一性も言語同一性も持つのは<emu-xref href="#sec-ecmascript-language-types-symbol-type">Symbol</emu-xref>（<emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>生成を除く）と<emu-xref href="#sec-object-type">Object</emu-xref>です。<emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>で生成されたSymbol値は仕様同一性のみ持ち、言語同一性は持ちません。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScriptデータ型と値</h1>
  <p>本仕様書のアルゴリズムは、それぞれ型が結び付けられた値を操作します。値の型の種類は本節で定義されるものだけです。型はさらにECMAScript言語型と仕様型に分類されます。</p>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript言語型</h1>
    <p><dfn variants="ECMAScript language types">ECMAScript言語型</dfn>は、ECMAScriptプログラマーがECMAScript言語で直接操作する値に対応します。ECMAScript言語型には、Undefined、Null、Boolean、String、Symbol、Number、BigInt、Objectがあります。<dfn variants="ECMAScript language values">ECMAScript言語値</dfn>は、ECMAScript言語型によって特徴付けられる値です。</p>

    <emu-clause id="sec-ecmascript-language-types-undefined-type">
      <h1>Undefined型</h1>
      <p>Undefined型は、*undefined*という唯一の値だけを持ちます。値が代入されていない変数は*undefined*値を持ちます。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-null-type">
      <h1>Null型</h1>
      <p>Null型は、*null*という唯一の値だけを持ちます。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-boolean-type">
      <h1>Boolean型</h1>
      <p><dfn variants="is a Boolean,is not a Boolean">Boolean型</dfn>は、*true*と*false*という2つの値を持つ論理的な存在を表します。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-string-type">
      <h1>String型</h1>
      <p><dfn variants="is a String,is not a String">String型</dfn>は、0個以上の16ビット符号なし整数値（「要素」）の順序付き列で、最大長は2<sup>53</sup> - 1個です。String型は、実行中のECMAScriptプログラムで主にテキストデータの表現に使われます。その場合、String内の各要素はUTF-16コード単位値として扱われます。各要素は列内の位置を持ち、その位置は非負整数でインデックスされます。最初の要素（存在する場合）はインデックス0、次はインデックス1、以降同様です。Stringの長さはその中の要素（16ビット値）の数です。空文字列は長さ0で要素を含みません。</p>
      <p>String内容を解釈しないECMAScript操作は、追加の意味論を持ちません。String値を解釈する操作は、各要素を単一のUTF-16コード単位として扱います。ただし、ECMAScriptはこれらのコード単位の値や相互関係を制限しないため、String内容をUTF-16でエンコードされたUnicodeコードポイントの並びとしてさらに解釈する操作は、不正な部分列も考慮する必要があります。こうした操作では、数値が0xD800から0xDBFFまでの包含区間にあるコード単位（Unicode標準で<dfn id="leading-surrogate" variants="leading surrogates">リーディングサロゲート</dfn>、または正式には<dfn id="high-surrogate-code-unit" variants="high-surrogate code units">ハイサロゲートコード単位</dfn>）、および0xDC00から0xDFFFまでの包含区間にあるコード単位（<dfn id="trailing-surrogate" variants="trailing surrogates">トレーリングサロゲート</dfn>、または正式には<dfn id="low-surrogate-code-unit" variants="low-surrogate code units">ローサロゲートコード単位</dfn>）に対して以下の規則を適用します：</p>
      <ul>
        <li>
          リーディングサロゲートでもトレーリングサロゲートでもないコード単位は、同じ値のコードポイントとして解釈されます。
        </li>
        <li>
          2つのコード単位の並びで、最初のコード単位_c1_がリーディングサロゲート、2番目のコード単位_c2_がトレーリングサロゲートの場合、それは<dfn id="surrogate-pair" variants="surrogate pairs">サロゲートペア</dfn>であり、(_c1_ - 0xD800) × 0x400 + (_c2_ - 0xDC00) + 0x10000の値のコードポイントとして解釈されます。（<emu-xref href="#sec-utf16decodesurrogatepair"></emu-xref>参照）
        </li>
        <li>
          サロゲートペアの一部でないリーディングサロゲートまたはトレーリングサロゲートのコード単位は、同じ値のコードポイントとして解釈されます。
        </li>
      </ul>
      <p>`String.prototype.normalize`関数（<emu-xref href="#sec-string.prototype.normalize"></emu-xref>参照）は、String値を明示的に正規化するために使えます。`String.prototype.localeCompare`（<emu-xref href="#sec-string.prototype.localecompare"></emu-xref>参照）は内部でString値を正規化しますが、他の操作は暗黙に正規化しません。操作結果は、特に記載がない限り言語・ロケールに依存しません。</p>
      <emu-note>
        <p>この設計の理由は、Stringの実装をできるだけ単純かつ高性能に保つことでした。ECMAScriptソーステキストがNormalized Form Cであれば、文字列リテラルもUnicodeエスケープシーケンスを含まない限り正規化が保証されます。</p>
      </emu-note>
      <p>本仕様では、「_A_、_B_...の<dfn id="string-concatenation">文字列連結</dfn>」（各引数がString値・コード単位・コード単位列）は、各引数（順番通り）のコード単位を連結した並びを持つString値を指します。</p>
      <p>「_S_の_inclusiveStart_から_exclusiveEnd_までの<dfn id="substring">部分文字列</dfn>」（_S_はString値またはコード単位列、_inclusiveStart_と_exclusiveEnd_は整数）は、_S_の_inclusiveStart_インデックスから_exclusiveEnd_の直前までの連続コード単位からなるString値（_inclusiveStart_ = _exclusiveEnd_なら空文字列）を指します。「to」接尾語が省略された場合は_exclusiveEnd_に_S_の長さが使われます。</p>
      <p>
        「<dfn id="ASCII-word-characters">ASCIIワード文字</dfn>」は、Unicode基本ラテンブロックの全ての英字・数字とU+005F（LOW LINE）のみからなる、次のString値を指します：<br>
        *"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"*。<br>
        歴史的事情により、様々なアルゴリズムで意味を持ちます。
      </p>

      <emu-clause id="sec-stringindexof" type="abstract operation">
        <h1>
          StringIndexOf (
            _string_: String,
            _searchValue_: String,
            _fromIndex_: 非負整数,
          ): 非負整数または~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _string_の長さを_len_とする。
          1. _searchValue_が空文字列でかつ_fromIndex_ ≤ _len_なら、_fromIndex_を返す。
          1. _searchValue_の長さを_searchLen_とする。
          1. _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_を満たす各整数_i_について、昇順で：
            1. _string_の_i_から_i_ + _searchLen_までの部分文字列を_candidate_とする。
            1. _candidate_が_searchValue_なら_i_を返す。
          1. ~not-found~を返す。
        </emu-alg>
        <emu-note>
          <p>_searchValue_が空文字列でかつ_fromIndex_ ≤ _string_の長さなら、このアルゴリズムは_fromIndex_を返します。空文字列は、文字列内のすべての位置（最後のコード単位の後も含む）で「見つかる」ものとみなされます。</p>
        </emu-note>
        <emu-note>
          <p>このアルゴリズムは、_fromIndex_ + _searchValue_の長さが_string_の長さを超える場合、必ず~not-found~を返します。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-stringlastindexof" type="abstract operation">
        <h1>
          StringLastIndexOf (
            _string_: String,
            _searchValue_: String,
            _fromIndex_: 非負整数,
          ): 非負整数または~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _string_の長さを_len_とする。
          1. _searchValue_の長さを_searchLen_とする。
          1. Assert: _fromIndex_ + _searchLen_ ≤ _len_。
          1. 0 ≤ _i_ ≤ _fromIndex_を満たす各整数_i_について、降順で：
            1. _string_の_i_から_i_ + _searchLen_までの部分文字列を_candidate_とする。
            1. _candidate_が_searchValue_なら_i_を返す。
          1. ~not-found~を返す。
        </emu-alg>
        <emu-note>
          <p>_searchValue_が空文字列の場合、このアルゴリズムは_fromIndex_を返します。空文字列は、文字列内のすべての位置（最後のコード単位の後も含む）で「見つかる」ものとみなされます。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>Symbol型</h1>
      <p><dfn variants="is a Symbol,is not a Symbol">Symbol型</dfn>は、Objectプロパティのキーとして使える全ての非String値の集合です（<emu-xref href="#sec-object-type"></emu-xref>）。</p>
      <p>各Symbolは一意で不変です。</p>
      <p>各Symbolは、不変の[[Description]]内部スロットを持ち、その値はStringまたは*undefined*です。</p>

      <emu-clause id="sec-well-known-symbols">
        <h1>Well-known Symbol</h1>
        <p>Well-known Symbolは、本仕様のアルゴリズムから明示的に参照される組み込みのSymbol値です。これらは、値が仕様アルゴリズムの拡張ポイントとなるプロパティのキーとして使われることが一般的です。特に記載がない限り、Well-known Symbol値は全Realmで共有されます（<emu-xref href="#sec-code-realms"></emu-xref>）。</p>
        <p>本仕様では、Well-known Symbolは標準の<emu-xref href="#sec-well-known-intrinsic-objects">intrinsic記法</emu-xref>で参照されます。intrinsicは<emu-xref href="#table-well-known-symbols"></emu-xref>で挙げられた値のいずれかです。</p>
        <emu-note>以前の版では@@name形式の記法が使われていましたが、現行版では%Symbol.name%形式を使います。具体的には、@@asyncIterator、@@hasInstance、@@isConcatSpreadable、@@<emu-not-ref>iterator</emu-not-ref>、@@match、@@matchAll、@@replace、@@search、@@species、@@split、@@toPrimitive、@@toStringTag、@@unscopablesなどの名称が使われていました。</emu-note>
        <emu-table id="table-well-known-symbols" caption="Well-known Symbol" oldids="table-1">
          <table>
            <thead>
              <tr>
                <th>
                  仕様名
                </th>
                <th>
                  [[Description]]
                </th>
                <th>
                  値／目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                <dfn>%Symbol.asyncIterator%</dfn>
              </td>
              <td>
                *"Symbol.asyncIterator"*
              </td>
              <td>
                オブジェクトのデフォルト非同期イテレータを返すメソッド。`for`-`await`-`of`文の意味論から呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.hasInstance%</dfn>
              </td>
              <td>
                *"Symbol.hasInstance"*
              </td>
              <td>
                コンストラクターオブジェクトがあるオブジェクトを自分のインスタンスとして認識するかどうかを判定するメソッド。`instanceof`演算子の意味論から呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.isConcatSpreadable%</dfn>
              </td>
              <td>
                *"Symbol.isConcatSpreadable"*
              </td>
              <td>
                真の場合、そのオブジェクトが<emu-xref href="#sec-array.prototype.concat">`Array.prototype.concat`</emu-xref>で配列要素として平坦化されるべきことを示すBoolean値のプロパティ。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.iterator%</dfn>
              </td>
              <td>
                *"Symbol.iterator"*
              </td>
              <td>
                オブジェクトのデフォルトイテレータを返すメソッド。for-of文の意味論から呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.match%</dfn>
              </td>
              <td>
                *"Symbol.match"*
              </td>
              <td>
                正規表現で文字列とマッチさせるメソッド。<emu-xref href="#sec-string.prototype.match">`String.prototype.match`</emu-xref>メソッドから呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.matchAll%</dfn>
              </td>
              <td>
                *"Symbol.matchAll"*
              </td>
              <td>
                正規表現に一致するすべてのマッチをイテレータで返すメソッド。<emu-xref href="#sec-string.prototype.matchall">`String.prototype.matchAll`</emu-xref>メソッドから呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.replace%</dfn>
              </td>
              <td>
                *"Symbol.replace"*
              </td>
              <td>
                文字列の一致部分を置換する正規表現メソッド。<emu-xref href="#sec-string.prototype.replace">`String.prototype.replace`</emu-xref>メソッドから呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.search%</dfn>
              </td>
              <td>
                *"Symbol.search"*
              </td>
              <td>
                正規表現と一致する文字列内のインデックスを返すメソッド。<emu-xref href="#sec-string.prototype.search">`String.prototype.search`</emu-xref>メソッドから呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.species%</dfn>
              </td>
              <td>
                *"Symbol.species"*
              </td>
              <td>
                派生オブジェクトの作成に使われるコンストラクター関数の値を持つプロパティ。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.split%</dfn>
              </td>
              <td>
                *"Symbol.split"*
              </td>
              <td>
                正規表現で一致するインデックスで文字列を分割するメソッド。<emu-xref href="#sec-string.prototype.split">`String.prototype.split`</emu-xref>メソッドから呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toPrimitive%</dfn>
              </td>
              <td>
                *"Symbol.toPrimitive"*
              </td>
              <td>
                オブジェクトを対応するプリミティブ値に変換するメソッド。ToPrimitive抽象操作から呼び出されます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toStringTag%</dfn>
              </td>
              <td>
                *"Symbol.toStringTag"*
              </td>
              <td>
                オブジェクトのデフォルト文字列表現の生成に使われるString値のプロパティ。組み込みメソッド<emu-xref href="#sec-object.prototype.tostring">`Object.prototype.toString`</emu-xref>でアクセスされます。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.unscopables%</dfn>
              </td>
              <td>
                *"Symbol.unscopables"*
              </td>
              <td>
                自身および継承したプロパティ名が、関連オブジェクトの`with`環境バインディングから除外されるプロパティ名となるオブジェクト値のプロパティ。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-numeric-types">
      <h1>数値型</h1>
      <p>ECMAScriptには組み込み数値型が2つあります：Number型とBigInt型です。以下の抽象操作はこれらの数値型に対して定義されています。「結果」列には返却型、そしてある操作の一部の呼び出しがabrupt completion（例外的完了）を返す可能性がある場合はその旨も示されます。</p>
      <emu-table id="table-numeric-type-ops" caption="数値型の操作">
        <table>
          <thead>
            <tr>
              <th>
                操作
              </th>
              <th>
                ソース例
              </th>
              <th>
                評価意味論で呼び出される箇所
              </th>
              <th>
                結果
              </th>
            </tr>
          </thead>

          <tr>
            <td>
              Number::unaryMinus
            </td>
            <td rowspan="2">
              `-x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unary-minus-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unaryMinus
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseNOT
            </td>
            <td rowspan="2">
              `~x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-bitwise-not-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseNOT
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::exponentiate
            </td>
            <td rowspan="2">
              `x&nbsp;**&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-exp-operator" title></emu-xref>
              および <emu-xref href="#sec-math.pow" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::exponentiate
            </td>
            <td>
              正常完了でBigIntを含む、またはthrow completion
            </td>
          </tr>

          <tr>
            <td>
              Number::multiply
            </td>
            <td rowspan="2">
              `x&nbsp;*&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::multiply
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::divide
            </td>
            <td rowspan="2">
              `x&nbsp;/&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::divide
            </td>
            <td>
              正常完了でBigIntを含む、またはthrow completion
            </td>
          </tr>

          <tr>
            <td>
              Number::remainder
            </td>
            <td rowspan="2">
              `x&nbsp;%&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::remainder
            </td>
            <td>
              正常完了でBigIntを含む、またはthrow completion
            </td>
          </tr>

          <tr>
            <td>
              Number::add
            </td>
            <td rowspan="2">
              `x ++`<br>
              `++ x`<br>
              `x&nbsp;+&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-increment-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-increment-operator" title></emu-xref>,
              および <emu-xref href="#sec-addition-operator-plus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::add
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::subtract
            </td>
            <td rowspan="2">
              `x --`<br>
              `-- x`<br>
              `x&nbsp;-&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-decrement-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-decrement-operator" title></emu-xref>,
              および <emu-xref href="#sec-subtraction-operator-minus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::subtract
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::leftShift
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&lt;&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-left-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::leftShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::signedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-signed-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::signedRightShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::unsignedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unsigned-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unsignedRightShift
            </td>
            <td>
              throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::lessThan
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&nbsp;y`<br>
              `x&nbsp;>&nbsp;y`<br>
              `x&nbsp;&lt;=&nbsp;y`<br>
              `x&nbsp;>=&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-relational-operators" title></emu-xref>,
              <emu-xref href="#sec-islessthan" title></emu-xref>経由
            </td>
            <td>
              Boolean または *undefined*（順序付けできない入力の場合）
            </td>
          </tr>

          <tr>
            <td>
              BigInt::lessThan
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::equal
            </td>
            <td rowspan="2">
              `x&nbsp;==&nbsp;y`<br>
              `x&nbsp;!=&nbsp;y`<br>
              `x&nbsp;===&nbsp;y`<br>
              `x&nbsp;!==&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-equality-operators" title></emu-xref>,
              <emu-xref href="#sec-isstrictlyequal" title></emu-xref>経由
            </td>
            <td rowspan="2">
              Boolean
            </td>
          </tr>
          <tr>
            <td>
              BigInt::equal
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValue
            </td>
            <td>
              `Object.is(x, y)`
            </td>
            <td>
              Object内部メソッド、
              <emu-xref href="#sec-samevalue" title></emu-xref>経由、
              厳密な値の等価性検証
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValueZero
            </td>
            <td>
              `[x].includes(y)`
            </td>
            <td>
              <emu-xref href="#sec-samevaluezero" title></emu-xref>経由、
              ArrayやMap、Setのメソッドなどで*+0*<sub>𝔽</sub>と*-0*<sub>𝔽</sub>の違いを無視して値の等価性を検証
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseAND
            </td>
            <td rowspan="2">
              `x&nbsp;&amp;&nbsp;y`
            </td>
            <td rowspan="6">
              <emu-xref href="#sec-binary-bitwise-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseAND
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseXOR
            </td>
            <td rowspan="2">
              `x&nbsp;^&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseXOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseOR
            </td>
            <td rowspan="2">
              `x&nbsp;|&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::toString
            </td>
            <td rowspan="2">
              `String(x)`
            </td>
            <td rowspan="2">
              多くの式や組み込み関数、<emu-xref href="#sec-tostring" title></emu-xref>経由
            </td>
            <td rowspan="2">
              String
            </td>
          </tr>
          <tr>
            <td>
              BigInt::toString
            </td>
          </tr>
        </table>
      </emu-table>
      <p>数値型は一般的に精度の損失や切り捨てなしに変換できないため、ECMAScript言語ではこれらの型間の暗黙的な変換は提供されません。プログラマーは、別の型を必要とする関数を呼び出す際に、型間の変換を明示的に`Number`や`BigInt`関数で行う必要があります。</p>
      <emu-note>
        <p>ECMAScriptの第1版以降、特定の演算子では精度が失われたり切り捨てられる暗黙の数値変換が提供されてきました。これらの従来の暗黙変換は後方互換性のために維持されていますが、BigIntには提供されていません。これはプログラマーのミスの機会を最小限に抑えるためであり、将来版での一般化された<em>値型</em>の選択肢を残すためです。</p>
      </emu-note>

      <emu-clause id="sec-ecmascript-language-types-number-type">
        <h1>Number型</h1>
        <p><dfn variants="is a Number,is not a Number">Number型</dfn>は18,437,736,874,454,810,627個（すなわち<emu-eqn>2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>）の値を持ち、IEEE 754-2019の倍精度浮動小数点binary64値を表します。ただし、IEEE標準の9,007,199,254,740,990個（すなわち<emu-eqn>2<sup>53</sup> - 2</emu-eqn>）の異なるNaN値は、ECMAScriptでは単一の特別な*NaN*値として表現されます。（*NaN*値はプログラム式`NaN`によって生成されます。）実装によっては外部コードが異なるNaN値を検出できる場合がありますが、その挙動は実装依存です。ECMAScriptコードからはすべての*NaN*値は相互に区別できません。</p>
        <emu-note>
          <p>Number値をArrayBuffer（<emu-xref href="#sec-arraybuffer-objects"></emu-xref>）やSharedArrayBuffer（<emu-xref href="#sec-sharedarraybuffer-objects"></emu-xref>）に格納した後に観察されるビットパターンは、ECMAScript実装が内部で使用するNumber値の表現と必ずしも同じではありません。</p>
        </emu-note>
        <p>他に2つの特別な値があり、*正の無限大*と*負の無限大*と呼ばれます。説明の簡略化のため、これらの値は記述上*+∞*<sub>𝔽</sub>、*-∞*<sub>𝔽</sub>という記号で呼ばれることもあります。（これら2つの無限大Number値は、プログラム式`+Infinity`（または単に`Infinity`）と`-Infinity`で生成されます。）</p>
        <p>残りの18,437,736,874,454,810,624個（すなわち<emu-eqn>2<sup>64</sup> - 2<sup>53</sup></emu-eqn>）の値は<dfn id="finite">有限</dfn>数と呼ばれます。これらの半分は正の数、半分は負の数です。すべての有限な正のNumber値には、同じ大きさの負の値が対応しています。</p>
        <p>*正のゼロ*と*負のゼロ*が存在することに注意してください。説明の簡略化のため、これらの値は記述上*+0*<sub>𝔽</sub>、*-0*<sub>𝔽</sub>という記号で呼ばれることもあります。（これら2つのゼロNumber値は、プログラム式`+0`（または単に`0`）と`-0`で生成されます。）</p>
        <p>18,437,736,874,454,810,622個（すなわち<emu-eqn>2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>）の有限非ゼロ値は2種類あります：</p>
        <p>18,428,729,675,200,069,632個（すなわち<emu-eqn>2<sup>64</sup> - 2<sup>54</sup></emu-eqn>）は正規化されており、次の形を持ちます：</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>ここで、_s_は1または-1、_m_は2<sup>52</sup>（含む）から2<sup>53</sup>（含まない）までの整数、_e_は-1074から971までの整数（両端含む）です。</p>
        <p>残りの9,007,199,254,740,990個（すなわち<emu-eqn>2<sup>53</sup> - 2</emu-eqn>）は非正規化値であり、次の形を持ちます：</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>ここで、_s_は1または-1、_m_は0（含まない）から2<sup>52</sup>（含まない）までの整数、_e_は-1074です。</p>
        <p>絶対値が2<sup>53</sup>以下のすべての正負の整数はNumber型で表現可能です。整数0はNumber型で*+0*<sub>𝔽</sub>と*-0*<sub>𝔽</sub>の2つの表現を持ちます。</p>
        <p>有限な数値は、それが非ゼロで上記いずれかの形で表される整数_m_が奇数である場合、<em>奇数の仮数</em>を持ちます。そうでなければ<em>偶数の仮数</em>となります。</p>
        <p>この仕様では、「<dfn id="number-value-for" oldids="number-value">_x_のNumber値</dfn>」という表現は、_x_が実数（πのような無理数も含む）であるとき、次の方法で選ばれたNumber値を意味します。Number型の有限値の集合から*-0*<sub>𝔽</sub>を除き、さらにNumber型で表現できない値2<sup>1024</sup>（<emu-eqn>+1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>）と<emu-eqn>-2<sup>1024</sup></emu-eqn>（<emu-eqn>-1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>）を加えます。この集合のうち_x_に最も近い値を選びます。2つの値が同じだけ近い場合は偶数の仮数を持つ方を選びます（この場合、追加された2つの値も偶数の仮数とみなします）。最後に、2<sup>1024</sup>が選ばれた場合は*+∞*<sub>𝔽</sub>に、<emu-eqn>-2<sup>1024</sup></emu-eqn>が選ばれた場合は*-∞*<sub>𝔽</sub>に、*+0*<sub>𝔽</sub>が選ばれた場合_x_ &lt; 0のときのみ*-0*<sub>𝔽</sub>に置き換え、その他はそのまま使います。結果が_x_のNumber値です。（この手順はIEEE 754-2019のroundTiesToEvenモードの挙動と一致します。）</p>
        <p>+∞のNumber値は*+∞*<sub>𝔽</sub>、-∞のNumber値は*-∞*<sub>𝔽</sub>です。</p>
        <p>一部のECMAScript演算子は、<emu-eqn>-2<sup>31</sup></emu-eqn>から<emu-eqn>2<sup>31</sup> - 1</emu-eqn>まで、または0から<emu-eqn>2<sup>16</sup> - 1</emu-eqn>までなど、特定の範囲の整数のみを扱います。これらの演算子はNumber型の任意の値を受け入れますが、まずその値を期待される範囲の整数値に変換します。数値変換操作の説明は<emu-xref href="#sec-type-conversion"></emu-xref>を参照してください。</p>

        <emu-clause id="sec-numeric-types-number-unaryMinus" type="numeric method">
          <h1>
            Number::unaryMinus (
              _x_: a Number,
            ): a Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_が*NaN*であれば、*NaN*を返す。
            1. _x_の符号を反転した値（絶対値は同じで符号が逆のNumber）を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseNOT" type="numeric method">
          <h1>
            Number::bitwiseNOT (
              _x_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _oldValue_を! ToInt32(_x_)とする。
            1. _oldValue_のビットごとの補数を返す。結果の数学的な値は32ビット2の補数ビット列として正確に表現可能である。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-exponentiate" type="numeric method" oldids="sec-applying-the-exp-operator">
          <h1>
            Number::exponentiate (
              _base_: a Number,
              _exponent_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_base_を_exponent_乗した結果を表す実装依存の近似値を返す。</dd>
          </dl>
          <emu-alg>
            1. _exponent_が*NaN*なら*NaN*を返す。
            1. _exponent_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら*1*<sub>𝔽</sub>を返す。
            1. _base_が*NaN*なら*NaN*を返す。
            1. _base_が*+∞*<sub>𝔽</sub>なら
              1. _exponent_ > *+0*<sub>𝔽</sub>なら*+∞*<sub>𝔽</sub>、それ以外は*+0*<sub>𝔽</sub>を返す。
            1. _base_が*-∞*<sub>𝔽</sub>なら
              1. _exponent_ > *+0*<sub>𝔽</sub>なら
                1. _exponent_が奇数の整数Numberなら*-∞*<sub>𝔽</sub>、それ以外は*+∞*<sub>𝔽</sub>を返す。
              1. それ以外なら
                1. _exponent_が奇数の整数Numberなら*-0*<sub>𝔽</sub>、それ以外は*+0*<sub>𝔽</sub>を返す。
            1. _base_が*+0*<sub>𝔽</sub>なら
              1. _exponent_ > *+0*<sub>𝔽</sub>なら*+0*<sub>𝔽</sub>、それ以外は*+∞*<sub>𝔽</sub>を返す。
            1. _base_が*-0*<sub>𝔽</sub>なら
              1. _exponent_ > *+0*<sub>𝔽</sub>なら
                1. _exponent_が奇数の整数Numberなら*-0*<sub>𝔽</sub>、それ以外は*+0*<sub>𝔽</sub>を返す。
              1. それ以外なら
                1. _exponent_が奇数の整数Numberなら*-∞*<sub>𝔽</sub>、それ以外は*+∞*<sub>𝔽</sub>を返す。
            1. （アサート）_base_は有限であり*+0*<sub>𝔽</sub>でも*-0*<sub>𝔽</sub>でもない。
            1. _exponent_が*+∞*<sub>𝔽</sub>なら
              1. abs(ℝ(_base_)) > 1なら*+∞*<sub>𝔽</sub>を返す。
              1. abs(ℝ(_base_)) = 1なら*NaN*を返す。
              1. abs(ℝ(_base_)) &lt; 1なら*+0*<sub>𝔽</sub>を返す。
            1. _exponent_が*-∞*<sub>𝔽</sub>なら
              1. abs(ℝ(_base_)) > 1なら*+0*<sub>𝔽</sub>を返す。
              1. abs(ℝ(_base_)) = 1なら*NaN*を返す。
              1. abs(ℝ(_base_)) &lt; 1なら*+∞*<sub>𝔽</sub>を返す。
            1. （アサート）_exponent_は有限であり*+0*<sub>𝔽</sub>でも*-0*<sub>𝔽</sub>でもない。
            1. _base_ &lt; *-0*<sub>𝔽</sub>かつ_exponent_が整数Numberでない場合、*NaN*を返す。
            1. ℝ(_base_)のℝ(_exponent_)乗の結果を表す実装依存の近似Number値を返す。
          </emu-alg>
          <emu-note>
            <p>_base_が*1*<sub>𝔽</sub>や*-1*<sub>𝔽</sub>で_exponent_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>の場合、または_base_が*1*<sub>𝔽</sub>で_exponent_が*NaN*の場合の`**`演算の結果は、IEEE 754-2019とは異なります。ECMAScript第1版ではこの操作の結果を*NaN*と規定していましたが、後のIEEE 754改訂では*1*<sub>𝔽</sub>とされています。互換性のため、従来のECMAScriptの挙動を維持しています。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-multiply" type="numeric method" oldids="sec-applying-the-mul-operator">
          <h1>
            Number::multiply (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_と_y_の積をIEEE 754-2019バイナリ倍精度演算規則に従って計算します。</dd>
          </dl>
          <emu-alg>
            1. _x_が*NaN*または_y_が*NaN*なら*NaN*を返す。
            1. _x_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら
              1. _y_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら*NaN*を返す。
              1. _y_ > *+0*<sub>𝔽</sub>なら_x_を返す。
              1. それ以外は-_x_を返す。
            1. _y_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら
              1. _x_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら*NaN*を返す。
              1. _x_ > *+0*<sub>𝔽</sub>なら_y_を返す。
              1. それ以外は-_y_を返す。
            1. _x_が*-0*<sub>𝔽</sub>なら
              1. _y_が*-0*<sub>𝔽</sub>または_y_ &lt; *-0*<sub>𝔽</sub>なら*+0*<sub>𝔽</sub>を返す。
              1. それ以外は*-0*<sub>𝔽</sub>を返す。
            1. _y_が*-0*<sub>𝔽</sub>なら
              1. _x_ &lt; *-0*<sub>𝔽</sub>なら*+0*<sub>𝔽</sub>を返す。
              1. それ以外は*-0*<sub>𝔽</sub>を返す。
            1. 𝔽(ℝ(_x_) × ℝ(_y_))を返す。
          </emu-alg>
          <emu-note>
            <p>有限精度の乗算は可換ですが、常に結合法則が成り立つわけではありません。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-divide" type="numeric method" oldids="sec-applying-the-div-operator">
          <h1>
            Number::divide (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_（被除数）と_y_（除数）の商をIEEE 754-2019バイナリ倍精度演算規則に従って計算します。</dd>
          </dl>
          <emu-alg>
            1. _x_が*NaN*または_y_が*NaN*なら*NaN*を返す。
            1. _x_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら
              1. _y_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら*NaN*を返す。
              1. _y_が*+0*<sub>𝔽</sub>または_y_ > *+0*<sub>𝔽</sub>なら_x_を返す。
              1. それ以外は-_x_を返す。
            1. _y_が*+∞*<sub>𝔽</sub>なら
              1. _x_が*+0*<sub>𝔽</sub>または_x_ > *+0*<sub>𝔽</sub>なら*+0*<sub>𝔽</sub>、それ以外は*-0*<sub>𝔽</sub>を返す。
            1. _y_が*-∞*<sub>𝔽</sub>なら
              1. _x_が*+0*<sub>𝔽</sub>または_x_ > *+0*<sub>𝔽</sub>なら*-0*<sub>𝔽</sub>、それ以外は*+0*<sub>𝔽</sub>を返す。
            1. _x_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら
              1. _y_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら*NaN*を返す。
              1. _y_ > *+0*<sub>𝔽</sub>なら_x_を返す。
              1. それ以外は-_x_を返す。
            1. _y_が*+0*<sub>𝔽</sub>なら
              1. _x_ > *+0*<sub>𝔽</sub>なら*+∞*<sub>𝔽</sub>、それ以外は*-∞*<sub>𝔽</sub>を返す。
            1. _y_が*-0*<sub>𝔽</sub>なら
              1. _x_ > *+0*<sub>𝔽</sub>なら*-∞*<sub>𝔽</sub>、それ以外は*+∞*<sub>𝔽</sub>を返す。
            1. 𝔽(ℝ(_x_) / ℝ(_y_))を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-remainder" type="numeric method" oldids="sec-applying-the-mod-operator">
          <h1>
            Number::remainder (
              _n_: a Number,
              _d_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_n_（被除数）と_d_（除数）の暗黙的な割り算から余りを返します。</dd>
          </dl>
          <emu-alg>
            1. _n_が*NaN*または_d_が*NaN*なら*NaN*を返す。
            1. _n_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら*NaN*を返す。
            1. _d_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら_n_を返す。
            1. _d_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら*NaN*を返す。
            1. _n_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら_n_を返す。
            1. （アサート）_n_と_d_は有限かつ非ゼロ。
            1. _quotient_をℝ(_n_) / ℝ(_d_)とする。
            1. _q_をtruncate(_quotient_)とする。
            1. _r_をℝ(_n_) - (ℝ(_d_) × _q_)とする。
            1. _r_ = 0かつ_n_ &lt; *-0*<sub>𝔽</sub>なら*-0*<sub>𝔽</sub>を返す。
            1. 𝔽(_r_)を返す。
          </emu-alg>
          <emu-note>
            <p>CやC++の剰余演算子は整数のみを受け付けますが、ECMAScriptでは浮動小数点も受け付けます。</p>
          </emu-note>
          <emu-note>浮動小数点の剰余演算（`%`演算子）はIEEE 754-2019で定義される「remainder」演算と同じではありません。IEEE 754-2019の「remainder」演算は丸め割り算に基づく余りを計算しますが、ECMAScript言語では浮動小数点演算の`%`はJavaの整数剰余演算に類似した切り捨て割り算の余りとなります。これはCライブラリのfmod関数と比較できます。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-add" type="numeric method" oldids="sec-applying-the-additive-operators-to-numbers">
          <h1>
            Number::add (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_と_y_の和をIEEE 754-2019バイナリ倍精度演算規則に従って計算します。</dd>
          </dl>
          <emu-alg>
            1. _x_が*NaN*または_y_が*NaN*なら*NaN*を返す。
            1. _x_が*+∞*<sub>𝔽</sub>かつ_y_が*-∞*<sub>𝔽</sub>なら*NaN*を返す。
            1. _x_が*-∞*<sub>𝔽</sub>かつ_y_が*+∞*<sub>𝔽</sub>なら*NaN*を返す。
            1. _x_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら_x_を返す。
            1. _y_が*+∞*<sub>𝔽</sub>または*-∞*<sub>𝔽</sub>なら_y_を返す。
            1. （アサート）_x_と_y_はともに有限。
            1. _x_が*-0*<sub>𝔽</sub>かつ_y_が*-0*<sub>𝔽</sub>なら*-0*<sub>𝔽</sub>を返す。
            1. 𝔽(ℝ(_x_) + ℝ(_y_))を返す。
          </emu-alg>
          <emu-note>
            <p>有限精度の加算は可換ですが、常に結合法則が成り立つわけではありません。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-subtract" type="numeric method">
          <h1>
            Number::subtract (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>減算を行い、_x_（被減数）と_y_（減数）の差を返します。</dd>
          </dl>
          <emu-alg>
            1. Number::add(_x_, Number::unaryMinus(_y_))を返す。
          </emu-alg>
          <emu-note>
            <p>`x - y`の結果は常に`x + (-y)`の結果と同じになります。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-leftShift" type="numeric method">
          <h1>
            Number::leftShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_を! ToInt32(_x_)とする。
            1. _rNum_を! ToUint32(_y_)とする。
            1. _shiftCount_をℝ(_rNum_) modulo 32とする。
            1. _lNum_を_shiftCount_ビット左シフトした結果を返す。結果の数学的な値は32ビット2の補数ビット列として正確に表現可能である。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-signedRightShift" type="numeric method">
          <h1>
            Number::signedRightShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_を! ToInt32(_x_)とする。
            1. _rNum_を! ToUint32(_y_)とする。
            1. _shiftCount_をℝ(_rNum_) modulo 32とする。
            1. _lNum_を_shiftCount_ビット符号拡張付き右シフトした結果を返す。最上位ビットは伝播されます。結果の数学的な値は32ビット2の補数ビット列として正確に表現可能である。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-unsignedRightShift" type="numeric method">
          <h1>
            Number::unsignedRightShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_を! ToUint32(_x_)とする。
            1. _rNum_を! ToUint32(_y_)とする。
            1. _shiftCount_をℝ(_rNum_) modulo 32とする。
            1. _lNum_を_shiftCount_ビットゼロ埋め右シフトした結果を返す。空いたビットはゼロで埋めます。結果の数学的な値は32ビット符号なしビット列として正確に表現可能である。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-lessThan" type="numeric method">
          <h1>
            Number::lessThan (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean or *undefined*
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_が*NaN*なら*undefined*を返す。
            1. _y_が*NaN*なら*undefined*を返す。
            1. _x_が_y_と等しいなら*false*を返す。
            1. _x_が*+0*<sub>𝔽</sub>かつ_y_が*-0*<sub>𝔽</sub>なら*false*を返す。
            1. _x_が*-0*<sub>𝔽</sub>かつ_y_が*+0*<sub>𝔽</sub>なら*false*を返す。
            1. _x_が*+∞*<sub>𝔽</sub>なら*false*を返す。
            1. _y_が*+∞*<sub>𝔽</sub>なら*true*を返す。
            1. _y_が*-∞*<sub>𝔽</sub>なら*false*を返す。
            1. _x_が*-∞*<sub>𝔽</sub>なら*true*を返す。
            1. （アサート）_x_と_y_は有限。
            1. ℝ(_x_) &lt; ℝ(_y_)なら*true*、それ以外は*false*を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-equal" type="numeric method">
          <h1>
            Number::equal (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_が*NaN*なら*false*を返す。
            1. _y_が*NaN*なら*false*を返す。
            1. _x_が_y_と等しいなら*true*を返す。
            1. _x_が*+0*<sub>𝔽</sub>かつ_y_が*-0*<sub>𝔽</sub>なら*true*を返す。
            1. _x_が*-0*<sub>𝔽</sub>かつ_y_が*+0*<sub>𝔽</sub>なら*true*を返す。
            1. *false*を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValue" type="numeric method">
          <h1>
            Number::sameValue (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_と_y_がともに*NaN*なら*true*を返す。
            1. _x_が*+0*<sub>𝔽</sub>かつ_y_が*-0*<sub>𝔽</sub>なら*false*を返す。
            1. _x_が*-0*<sub>𝔽</sub>かつ_y_が*+0*<sub>𝔽</sub>なら*false*を返す。
            1. _x_が_y_と等しいなら*true*を返す。
            1. *false*を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValueZero" type="numeric method">
          <h1>
            Number::sameValueZero (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_と_y_がともに*NaN*なら*true*を返す。
            1. _x_が*+0*<sub>𝔽</sub>かつ_y_が*-0*<sub>𝔽</sub>なら*true*を返す。
            1. _x_が*-0*<sub>𝔽</sub>かつ_y_が*+0*<sub>𝔽</sub>なら*true*を返す。
            1. _x_が_y_と等しいなら*true*を返す。
            1. *false*を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numberbitwiseop" type="abstract operation">
          <h1>
            NumberBitwiseOp (
              _op_: `&amp;`, `^`, or `|`,
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_を! ToInt32(_x_)とする。
            1. _rNum_を! ToInt32(_y_)とする。
            1. _lBits_をℝ(_lNum_)の32ビット2の補数ビット列とする。
            1. _rBits_をℝ(_rNum_)の32ビット2の補数ビット列とする。
            1. _op_が`&amp;`なら
              1. _result_を_lBits_と_rBits_のビットごとのAND演算結果とする。
            1. そうでなく_op_が`^`なら
              1. _result_を_lBits_と_rBits_のビットごとの排他的論理和（XOR）演算結果とする。
            1. それ以外（アサート：_op_は`|`）
              1. _result_を_lBits_と_rBits_のビットごとの論理和（OR）演算結果とする。
            1. _result_の32ビット2の補数ビット列が表す整数のNumber値を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseAND" type="numeric method">
          <h1>
            Number::bitwiseAND (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`&amp;`, _x_, _y_)を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseXOR" type="numeric method">
          <h1>
            Number::bitwiseXOR (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`^`, _x_, _y_)を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseOR" type="numeric method">
          <h1>
            Number::bitwiseOR (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`|`, _x_, _y_)を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-tostring" type="numeric method" oldids="sec-tostring-applied-to-the-number-type">
          <h1>
            Number::toString (
              _x_: a Number,
              _radix_: an integer in the inclusive interval from 2 to 36,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_を_radix_進法の位置記数法でStringとして表現します。_r_進法での数字は*"0123456789abcdefghijklmnopqrstuvwxyz"*の最初の_r_個のコードユニットが順に用いられます。絶対値が*1*<sub>𝔽</sub>以上の数値の表現は先頭ゼロを含みません。</dd>
          </dl>
          <emu-alg>
            1. _x_が*NaN*なら*"NaN"*を返す。
            1. _x_が*+0*<sub>𝔽</sub>または*-0*<sub>𝔽</sub>なら*"0"*を返す。
            1. _x_ &lt; *-0*<sub>𝔽</sub>なら、文字列連結で*"-"*とNumber::toString(-_x_, _radix_)を返す。
            1. _x_が*+∞*<sub>𝔽</sub>なら*"Infinity"*を返す。
            1. [id="step-number-tostring-intermediate-values"] _n_、_k_、_s_を整数として、_k_ ≥ 1、_radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>、𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>)が_x_、かつ_k_が可能な限り最小となるようにする。_k_は_radix_進法での_s_の桁数で、_s_は_radix_で割り切れない。最下位桁が一意に決まるとは限らない。
            1. _radix_ ≠ 10または_n_が-5から21の範囲なら
              1. _n_ ≥ _k_なら
                1. 次の文字列連結で返す：
                  * _s_の_radix_進法表現の_k_桁
                  * 0x0030（数字ゼロ）のコードユニットを_n_ - _k_回
              1. それ以外で_n_ > 0なら
                1. 次の文字列連結で返す：
                  * _s_の_radix_進法表現の最上位_n_桁
                  * 0x002E（ピリオド）
                  * 残り_k_ - _n_桁
              1. それ以外（_n_ ≤ 0をアサート）
                1. 次の文字列連結で返す：
                  * 0x0030（数字ゼロ）
                  * 0x002E（ピリオド）
                  * 0x0030（数字ゼロ）を-_n_回
                  * _s_の_radix_進法表現の_k_桁
            1. 注：この場合、入力は科学的E表記（例：`1.2e+3`）で表現される。
            1. （アサート）_radix_は10。
            1. _n_ &lt; 0なら
              1. _exponentSign_を0x002D（ハイフンマイナス）とする。
            1. それ以外
              1. _exponentSign_を0x002B（プラス記号）とする。
            1. _k_ = 1なら
              1. 次の文字列連結で返す：
                * _s_の1桁目
                * 0x0065（小文字e）
                * _exponentSign_
                * abs(_n_ - 1)の10進表現
            1. 次の文字列連結で返す：
              * _s_の最上位桁（10進表現）
              * 0x002E（ピリオド）
              * 残り_k_ - 1桁（10進表現）
              * 0x0065（小文字e）
              * _exponentSign_
              * abs(_n_ - 1)の10進表現
          </emu-alg>
          <emu-note>
            <p>次の点は実装の指針となり得ますが、この規格の規範的要件の一部ではありません：</p>
            <ul>
              <li>
                xが*-0*<sub>𝔽</sub>以外の任意のNumber値の場合、ToNumber(ToString(x))はxとなる。
              </li>
              <li>
                _s_の最下位桁はstep <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref>の要件では一意に決まるとは限らない。
              </li>
            </ul>
          </emu-note>
          <emu-note>
            <p>規定よりも高精度の変換が可能な実装には、step <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref>の次の代替手順が指針となります：</p>
            <emu-alg replaces-step="step-number-tostring-intermediate-values">
              1. _n_、_k_、_s_を整数として、_k_ ≥ 1、_radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>、𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>)が_x_、_k_が最小となるようにする。_s_の値が複数ある場合、_s_ × _radix_<sup>_n_ - _k_</sup>がℝ(_x_)に最も近いものを選ぶ。2つの可能な値がある場合は偶数の方を選ぶ。_k_は_radix_進法での_s_の桁数であり、_s_は_radix_で割り切れない。
            </emu-alg>
          </emu-note>
          <emu-note>
            <p>ECMAScript実装者は、David M. Gayによる浮動小数点数の2進-10進変換に関する論文およびコードが参考になるかもしれません：</p>
            <p>
              Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell Laboratories (Murray Hill, New Jersey). 1990年11月30日。<br>
              <a href="https://ampl.com/_archive/first-website/REFS/rounding.pdf">https://ampl.com/_archive/first-website/REFS/rounding.pdf</a>。関連コード：<br>
              <a href="http://netlib.sandia.gov/fp/dtoa.c">http://netlib.sandia.gov/fp/dtoa.c</a> および<br>
              <a href="http://netlib.sandia.gov/fp/g_fmt.c">http://netlib.sandia.gov/fp/g_fmt.c</a>。また各`netlib`ミラーサイトにもあります。
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-ecmascript-language-types-bigint-type">
        <h1>BigInt型</h1>
        <p><dfn variants="is a BigInt,is not a BigInt">BigInt型</dfn>は整数値を表します。値のサイズは任意であり、特定のビット幅に制限されません。特に記載がない限り、演算は正確な数学的結果を返すよう設計されています。2項演算の場合、BigIntは2の補数のバイナリ文字列として扱われ、負の数は左側に無限にビットが立っているものとして扱われます。</p>

        <emu-clause id="sec-numeric-types-bigint-unaryMinus" type="numeric method">
          <h1>
            BigInt::unaryMinus (
              _x_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = *0*<sub>ℤ</sub>なら、*0*<sub>ℤ</sub>を返す。
            1. -_x_を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseNOT" type="numeric method">
          <h1>
            BigInt::bitwiseNOT (
              _x_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_の1の補数を返します。</dd>
          </dl>
          <emu-alg>
            1. -_x_ - *1*<sub>ℤ</sub>を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-exponentiate" type="numeric method">
          <h1>
            BigInt::exponentiate (
              _base_: a BigInt,
              _exponent_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _exponent_ &lt; *0*<sub>ℤ</sub>なら、*RangeError*例外を投げる。
            1. _base_ = *0*<sub>ℤ</sub>かつ_exponent_ = *0*<sub>ℤ</sub>なら、*1*<sub>ℤ</sub>を返す。
            1. _base_を_exponent_乗した値を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-multiply" type="numeric method">
          <h1>
            BigInt::multiply (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ × _y_を返す。
          </emu-alg>
          <emu-note>結果が入力よりもはるかに大きなビット幅となっても、正確な数学的答えが返されます。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-divide" type="numeric method">
          <h1>
            BigInt::divide (
              _x_: a BigInt,
              _y_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _y_ = *0*<sub>ℤ</sub>なら、*RangeError*例外を投げる。
            1. _quotient_をℝ(_x_) / ℝ(_y_)とする。
            1. ℤ(truncate(_quotient_))を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-remainder" type="numeric method">
          <h1>
            BigInt::remainder (
              _n_: a BigInt,
              _d_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _d_ = *0*<sub>ℤ</sub>なら、*RangeError*例外を投げる。
            1. _n_ = *0*<sub>ℤ</sub>なら、*0*<sub>ℤ</sub>を返す。
            1. _quotient_をℝ(_n_) / ℝ(_d_)とする。
            1. _q_をℤ(truncate(_quotient_))とする。
            1. _n_ - (_d_ × _q_)を返す。
          </emu-alg>
          <emu-note>結果の符号は被除数と同じです。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-add" type="numeric method">
          <h1>
            BigInt::add (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ + _y_を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-subtract" type="numeric method">
          <h1>
            BigInt::subtract (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ - _y_を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-leftShift" type="numeric method">
          <h1>
            BigInt::leftShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _y_ &lt; *0*<sub>ℤ</sub>なら
              1. ℤ(floor(ℝ(_x_) / 2<sup>-ℝ(_y_)</sup>))を返す。
            1. _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>を返す。
          </emu-alg>
          <emu-note>ここでの意味論は、BigIntを無限長の2の補数バイナリ文字列として扱うビットシフトと同等です。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-signedRightShift" type="numeric method">
          <h1>
            BigInt::signedRightShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigInt::leftShift(_x_, -_y_)を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-unsignedRightShift" type="numeric method">
          <h1>
            BigInt::unsignedRightShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. *TypeError*例外を投げる。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-lessThan" type="numeric method">
          <h1>
            BigInt::lessThan (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ℝ(_x_) &lt; ℝ(_y_)なら*true*、それ以外は*false*を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-equal" type="numeric method" oldids="sec-numeric-types-bigint-sameValue,sec-numeric-types-bigint-sameValueZero">
          <h1>
            BigInt::equal (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ℝ(_x_) = ℝ(_y_)なら*true*、それ以外は*false*を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryand" type="abstract operation">
          <h1>
            BinaryAnd (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1かつ_y_ = 1なら1を返す。
            1. それ以外は0を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryor" type="abstract operation">
          <h1>
            BinaryOr (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1または_y_ = 1なら1を返す。
            1. それ以外は0を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryxor" type="abstract operation">
          <h1>
            BinaryXor (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1かつ_y_ = 0なら1を返す。
            1. それ以外で_x_ = 0かつ_y_ = 1なら1を返す。
            1. それ以外は0を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-bigintbitwiseop" type="abstract operation">
          <h1>
            BigIntBitwiseOp (
              _op_: `&amp;`, `^`, or `|`,
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_をℝ(_x_)に設定する。
            1. _y_をℝ(_y_)に設定する。
            1. _result_を0とする。
            1. _shift_を0とする。
            1. (_x_ = 0または_x_ = -1)かつ(_y_ = 0または_y_ = -1)になるまで繰り返す：
              1. _xDigit_を_x_ modulo 2とする。
              1. _yDigit_を_y_ modulo 2とする。
              1. _op_が`&amp;`なら
                1. _result_を_result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_)に設定する。
              1. それ以外で_op_が`|`なら
                1. _result_を_result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_)に設定する。
              1. それ以外
                1. アサート：_op_は`^`である。
                1. _result_を_result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_)に設定する。
              1. _shift_を_shift_ + 1に設定する。
              1. _x_を(_x_ - _xDigit_) / 2に設定する。
              1. _y_を(_y_ - _yDigit_) / 2に設定する。
            1. _op_が`&amp;`なら
              1. _tmp_をBinaryAnd(_x_ modulo 2, _y_ modulo 2)とする。
            1. それ以外で_op_が`|`なら
              1. _tmp_をBinaryOr(_x_ modulo 2, _y_ modulo 2)とする。
            1. それ以外
              1. アサート：_op_は`^`である。
              1. _tmp_をBinaryXor(_x_ modulo 2, _y_ modulo 2)とする。
            1. _tmp_ ≠ 0なら
              1. _result_を_result_ - 2<sup>_shift_</sup>に設定する。
              1. 注：これは符号拡張となる。
            1. _result_のBigInt値を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseAND" type="numeric method">
          <h1>
            BigInt::bitwiseAND (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`&amp;`, _x_, _y_)を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseXOR" type="numeric method">
          <h1>
            BigInt::bitwiseXOR (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`^`, _x_, _y_)を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseOR" type="numeric method">
          <h1>
            BigInt::bitwiseOR (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`|`, _x_, _y_)を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-tostring" type="numeric method">
          <h1>
            BigInt::toString (
              _x_: a BigInt,
              _radix_: an integer in the inclusive interval from 2 to 36,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_を_radix_進法の位置記数法でStringとして表現します。_r_進法でのBigIntの表現に使われる数字は*"0123456789abcdefghijklmnopqrstuvwxyz"*の最初の_r_個のコードユニットが順番に使われます。*0*<sub>ℤ</sub>以外のBigIntの表現には先頭ゼロは含まれません。</dd>
          </dl>
          <emu-alg>
            1. _x_ &lt; *0*<sub>ℤ</sub>なら、文字列連結で*"-"*とBigInt::toString(-_x_, _radix_)を返す。
            1. _x_を_radix_で表現したString値を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-type">
      <h1>オブジェクト型</h1>
      <p><dfn variants="is an Object,is not an Object">Object型</dfn>（単に「オブジェクト」とも呼ばれる）の各インスタンスは、プロパティの集合を表します。各プロパティはデータプロパティまたはアクセサプロパティのいずれかです：</p>
      <ul>
        <li>
          <dfn variants="data properties">データプロパティ</dfn>は、キー値をECMAScript言語値と一連の真偽値属性に関連付けます。
        </li>
        <li>
          <dfn variants="accessor properties">アクセサプロパティ</dfn>は、キー値を1つまたは2つのアクセサ関数と一連の真偽値属性に関連付けます。アクセサ関数はそのプロパティに関連付けられたECMAScript言語値の保存または取得に使用されます。
        </li>
      </ul>
      <p>オブジェクトのプロパティはプロパティキーによって一意に識別されます。<dfn id="property-key" variants="property keys" oldids="sec-ispropertykey">プロパティキー</dfn>はStringまたはSymbolです。空文字列を含むすべてのStringとSymbolはプロパティキーとして有効です。<dfn id="property-name">プロパティ名</dfn>は、プロパティキーのうちStringであるものです。</p>
      <p><dfn id="integer-index" variants="integer indices,integer-indexed">整数インデックス</dfn>は、CanonicalNumericIndexString(_n_)が*+0*<sub>𝔽</sub>から𝔽(2<sup>53</sup> - 1)までの範囲の整数Numberを返すプロパティ名_n_です。<dfn id="array-index" variants="array indices">配列インデックス</dfn>は、CanonicalNumericIndexString(_n_)が*+0*<sub>𝔽</sub>から𝔽(2<sup>32</sup> - 2)までの範囲の整数Numberを返す整数インデックス_n_です。</p>
      <emu-note>
        <p>全ての非負の安全な整数には対応する整数インデックスがあります。<emu-eqn>2<sup>32</sup> - 1</emu-eqn>を除く全ての32ビット符号なし整数には対応する配列インデックスがあります。*"-0"*は整数インデックスでも配列インデックスでもありません。</p>
      </emu-note>
      <p>プロパティキーはプロパティおよびその値へのアクセスに用いられます。プロパティへのアクセスには、値の取得（get）と値の代入（set）の2種類があります。get/setアクセスで利用できるプロパティには、オブジェクト自身が直接持つ<em>自身のプロパティ</em>と、プロパティ継承関係によって関連する他のオブジェクトから提供される<em>継承プロパティ</em>の両方が含まれます。継承プロパティも、その関連オブジェクトの自身プロパティまたは継承プロパティのいずれかである場合があります。オブジェクトの自身プロパティは、それぞれ他の自身プロパティとは異なるキー値を持たねばなりません。</p>
      <p>全てのオブジェクトは論理的にはプロパティの集合ですが、プロパティへのアクセスや操作の意味論が異なる複数の形式のオブジェクトがあります。複数のオブジェクト形式の定義については<emu-xref href="#sec-object-internal-methods-and-internal-slots"></emu-xref>を参照してください。</p>
      <p>さらに、一部のオブジェクトは呼び出し可能（callable）であり、これらは関数または関数オブジェクトと呼ばれ、後述します。ECMAScriptの全ての関数はObject型のメンバーです。</p>

      <emu-clause id="sec-property-attributes">
        <h1>プロパティ属性</h1>
        <p>属性は、この仕様において<emu-xref href="#table-object-property-attributes"></emu-xref>で説明されるオブジェクトプロパティの状態を定義・説明するために使用されます。明示的に指定されていない限り、各属性の初期値はそのデフォルト値です。</p>
        <emu-table id="table-object-property-attributes" caption="オブジェクトプロパティの属性" oldids="table-2,table-3,table-4,table-data-property-attributes,table-accessor-property-attributes,table-default-attribute-values">
          <table>
            <thead>
              <tr>
                <th>属性名</th>
                <th>存在するプロパティの種類</th>
                <th>値のドメイン</th>
                <th>デフォルト値</th>
                <th>説明</th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                データプロパティ
              </td>
              <td>
                ECMAScript言語値
              </td>
              <td>
                *undefined*
              </td>
              <td>
                プロパティへのgetアクセス時に取得される値。
              </td>
            </tr>
            <tr>
              <td>
                [[Writable]]
              </td>
              <td>
                データプロパティ
              </td>
              <td>
                真偽値
              </td>
              <td>
                *false*
              </td>
              <td>
                *false*の場合、ECMAScriptコードによる[[Set]]でプロパティの[[Value]]属性を変更しようとしても成功しない。
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                アクセサプロパティ
              </td>
              <td>
                オブジェクトまたは*undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                値がオブジェクトの場合、関数オブジェクトでなければならない。プロパティのgetアクセスごとに、関数の[[Call]]内部メソッド（<emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>）が空の引数リストで呼び出され、値を取得する。
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                アクセサプロパティ
              </td>
              <td>
                オブジェクトまたは*undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                値がオブジェクトの場合、関数オブジェクトでなければならない。プロパティのsetアクセスごとに、関数の[[Call]]内部メソッド（<emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>）が代入値のみを含む引数リストで呼び出される。プロパティの[[Set]]内部メソッドの効果は、後の[[Get]]内部メソッドの呼び出しで返される値に影響を与えても与えなくてもよい。
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                データプロパティまたはアクセサプロパティ
              </td>
              <td>
                真偽値
              </td>
              <td>
                *false*
              </td>
              <td>
                *true*の場合、プロパティはfor-in列挙（<emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>参照）で列挙される。そうでなければ非列挙プロパティとされる。
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                データプロパティまたはアクセサプロパティ
              </td>
              <td>
                真偽値
              </td>
              <td>
                *false*
              </td>
              <td>
                *false*の場合、プロパティの削除やデータ⇄アクセサプロパティの変更、その他の属性変更（既存の[[Value]]の置換や[[Writable]]を*false*にする以外）は成功しない。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>オブジェクトの内部メソッドと内部スロット</h1>
        <p>ECMAScriptでは、オブジェクトの実際の意味論は<em>内部メソッド</em>と呼ばれるアルゴリズムによって定義されます。ECMAScriptエンジンの各オブジェクトには、そのランタイム動作を定義する内部メソッドの集合が関連付けられています。これらの内部メソッドはECMAScript言語の一部ではなく、説明目的で仕様に定義されています。ただし、実装内の各オブジェクトは、関連付けられた内部メソッドで指定された通りに振る舞わなければなりません。その実現方法は実装によって異なります。</p>
        <p>内部メソッド名は多態的です。つまり、同じ内部メソッド名が呼び出されても、異なるオブジェクト値は異なるアルゴリズムを実行することがあります。内部メソッドが呼び出される実際のオブジェクトがその呼び出しの「ターゲット」です。実行時にアルゴリズムの実装がオブジェクトのサポートしていない内部メソッドを使おうとした場合、*TypeError*例外が投げられます。</p>
        <p>内部スロットは、オブジェクト、Symbol、プライベート名に関連付けられた内部状態であり、様々なECMAScript仕様アルゴリズムで使われます。内部スロットはプロパティではなく、継承もされません。特定の内部スロット仕様によっては、状態が任意のECMAScript言語型または仕様型値になることがあります。明示的な記載がない限り、内部スロットはオブジェクト、Symbol、プライベート名の作成時に割り当てられ、動的に追加されることはありません。明示的な記載がない限り、内部スロットの初期値は*undefined*です。本仕様内の様々なアルゴリズムは内部スロットを持つ値を生成しますが、ECMAScript言語は内部スロットを直接操作する方法を提供しません。</p>
        <p>全てのオブジェクトは[[PrivateElements]]という名前の内部スロットを持ちます。これはPrivateElementsのリストであり、そのオブジェクトのプライベートフィールド、メソッド、アクセサの値を表します。初期状態では空のリストです。</p>
        <p>内部メソッドと内部スロットは本仕様中では[[ ]]で囲まれた名前で識別されます。</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref>は、ECMAScriptコードで生成・操作される全てのオブジェクトに適用される<em>本質的な内部メソッド</em>をまとめたものです。全てのオブジェクトは本質的な内部メソッドのアルゴリズムを持たねばなりませんが、必ずしも同じアルゴリズムを使うとは限りません。</p>
        <p><dfn id="ordinary-object" variants="ordinary objects">通常オブジェクト</dfn>は、次の全ての条件を満たすオブジェクトです：</p>
        <ul>
          <li>
            <emu-xref href="#table-essential-internal-methods"></emu-xref>に記載された内部メソッドについて、<emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>で定義されたものを使用する。
          </li>
          <li>
            オブジェクトが[[Call]]内部メソッドを持つ場合、<emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>または<emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref>で定義されたものを使用する。
          </li>
          <li>
            オブジェクトが[[Construct]]内部メソッドを持つ場合、<emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref>または<emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref>で定義されたものを使用する。
          </li>
        </ul>
        <p><dfn id="exotic-object" variants="exotic objects">エキゾチックオブジェクト</dfn>は、通常オブジェクトでないオブジェクトです。</p>
        <p>本仕様では、エキゾチックオブジェクトの種類はその内部メソッドによって認識されます。特定の種類のエキゾチックオブジェクト（配列エキゾチックオブジェクトや束縛関数エキゾチックオブジェクトなど）と振る舞いが同等でも、その種類に指定された内部メソッド群を持たない場合は、その種類のエキゾチックオブジェクトとして認識されません。</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref>などの表の「Signature」列は、各内部メソッドの呼び出しパターンを示します。呼び出しパターンには常に括弧付きの説明的パラメータ名リストが含まれます。パラメータ名がECMAScript型名と同じなら、その型の値が必要です。内部メソッドが値を明示的に返す場合、パラメータリストの後に「→」と返却値型名が続きます。Signatureで使われる型名は<emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref>で定義された型に、下記の追加型名を加えたものです。「<em>any</em>」は任意のECMAScript言語型の値を意味します。</p>
        <p>パラメータに加え、内部メソッドは呼び出し対象オブジェクト（ターゲット）に常にアクセスできます。</p>
        <p>内部メソッドは必ずCompletion Recordを返します。これは、正常完了で返却型値を包むものか、throw完了です。</p>
        <emu-table id="table-essential-internal-methods" caption="本質的な内部メソッド" oldids="table-5">
          <table>
            <thead>
              <tr>
                <th>
                  内部メソッド
                </th>
                <th>
                  シグネチャ
                </th>
                <th>
                  説明
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[GetPrototypeOf]]
              </td>
              <td>
                ( ) <b>→</b> Object | Null
              </td>
              <td>
                このオブジェクトに継承プロパティを提供するオブジェクトを決定する。*null*値は継承プロパティが無いことを示す。
              </td>
            </tr>
            <tr>
              <td>
                [[SetPrototypeOf]]
              </td>
              <td>
                (Object | Null) <b>→</b> Boolean
              </td>
              <td>
                このオブジェクトを継承プロパティを提供する他のオブジェクトと関連付ける。*null*を渡すと継承プロパティが無いことを示す。操作が成功した場合は*true*、失敗した場合は*false*を返す。
              </td>
            </tr>
            <tr>
              <td>
                [[IsExtensible]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                このオブジェクトに追加プロパティの追加が許可されているかどうかを判定する。
              </td>
            </tr>
            <tr>
              <td>
                [[PreventExtensions]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                このオブジェクトに新しいプロパティ追加を制御する。操作が成功した場合は*true*、失敗した場合は*false*を返す。
              </td>
            </tr>
            <tr>
              <td>
                [[GetOwnProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Undefined | Property Descriptor
              </td>
              <td>
                このオブジェクト自身のプロパティでキーが_propertyKey_であるもののプロパティ記述子を返す。なければ*undefined*を返す。
              </td>
            </tr>
            <tr>
              <td>
                [[DefineOwnProperty]]
              </td>
              <td>
                (_propertyKey_, _PropertyDescriptor_) <b>→</b> Boolean
              </td>
              <td>
                キーが_propertyKey_である自身のプロパティを、_PropertyDescriptor_で記述される状態に新規作成または変更する。そのプロパティが作成/更新できれば*true*、できなければ*false*を返す。
              </td>
            </tr>
            <tr>
              <td>
                [[HasProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                このオブジェクトが_propertyKey_をキーに持つ自身または継承プロパティを既に持っているかどうかを示す真偽値を返す。
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                (_propertyKey_, _Receiver_) <b>→</b> <em>any</em>
              </td>
              <td>
                このオブジェクトから_propertyKey_のプロパティ値を返す。プロパティ値取得のためにECMAScriptコードの実行が必要な場合、_Receiver_が*this*値として使用される。
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                (_propertyKey_, _value_, _Receiver_) <b>→</b> Boolean
              </td>
              <td>
                このオブジェクトの_propertyKey_プロパティ値を_value_に設定する。値の設定にECMAScriptコードの実行が必要な場合、_Receiver_が*this*値として使われる。値の設定ができれば*true*、できなければ*false*を返す。
              </td>
            </tr>
            <tr>
              <td>
                [[Delete]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                このオブジェクト自身から_propertyKey_をキーに持つプロパティを削除する。削除できずまだ存在する場合は*false*、削除された場合や元々存在しない場合は*true*を返す。
              </td>
            </tr>
            <tr>
              <td>
                [[OwnPropertyKeys]]
              </td>
              <td>
                ( ) <b>→</b> プロパティキーのリスト
              </td>
              <td>
                オブジェクト自身の全てのプロパティキーのリストを返す。
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>は、関数として呼び出し可能なオブジェクトがサポートする追加の本質的な内部メソッドをまとめています。<dfn id="function-object" variants="function objects">関数オブジェクト</dfn>は[[Call]]内部メソッドをサポートするオブジェクトです。<dfn id="constructor" variants="constructors">コンストラクタ</dfn>は[[Construct]]内部メソッドをサポートするオブジェクトです。[[Construct]]をサポートするオブジェクトは[[Call]]もサポートしなければならず、全てのコンストラクタは関数オブジェクトとなります。したがって、コンストラクタは<em>コンストラクタ関数</em>または<em>コンストラクタ関数オブジェクト</em>とも呼ばれます。</p>
        <emu-table id="table-additional-essential-internal-methods-of-function-objects" caption="関数オブジェクトの追加本質的内部メソッド" oldids="table-6">
          <table>
            <thead>
              <tr>
                <th>
                  内部メソッド
                </th>
                <th>
                  シグネチャ
                </th>
                <th>
                  説明
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Call]]
              </td>
              <td>
                (<em>any</em>, <em>any</em>のリスト) <b>→</b> <em>any</em>
              </td>
              <td>
                このオブジェクトに関連付けられたコードを実行する。関数呼び出し式を通して呼び出される。引数は*this*値と、呼び出し式で渡された引数のリスト。[[Call]]を実装するオブジェクトは<em>呼び出し可能</em>です。
              </td>
            </tr>
            <tr>
              <td>
                [[Construct]]
              </td>
              <td>
                (<em>any</em>のリスト, Object) <b>→</b> Object
              </td>
              <td>
                オブジェクトを生成する。`new`演算子または`super`呼び出しで起動される。最初の引数はコンストラクタ呼び出しまたは`super`呼び出しの引数のリスト。2番目の引数は`new`演算子が最初に適用されたオブジェクト。[[Construct]]を実装するオブジェクトは<em>コンストラクタ</em>と呼ばれる。関数オブジェクトが必ずしもコンストラクタとは限らず、非コンストラクタ関数オブジェクトは[[Construct]]内部メソッドを持たない。
              </td>
            </tr>
          </table>
        </emu-table>
        <p>通常オブジェクトや標準エキゾチックオブジェクトの本質的内部メソッドの意味論は<emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>で定義されています。エキゾチックオブジェクトの内部メソッドの指定された使用が実装でサポートされていない場合、その使用は試みられると*TypeError*例外を投げなければなりません。</p>
      </emu-clause>

      <emu-clause id="sec-invariants-of-the-essential-internal-methods">
        <h1>本質的内部メソッドの不変条件</h1>
        <p>ECMAScriptエンジンのオブジェクトの内部メソッドは、以下に示す不変条件リストに準拠しなければなりません。通常のECMAScriptオブジェクトおよび本仕様の全標準エキゾチックオブジェクトはこれらの不変条件を維持します。ECMAScriptのProxyオブジェクトは、[[ProxyHandler]]オブジェクトでtrapを呼び出した結果に対するランタイムチェックによってこれらの不変条件を維持します。</p>
        <p>実装が提供するエキゾチックオブジェクトも、そのオブジェクトについてこれらの不変条件を維持しなければなりません。これらの不変条件に違反すると、ECMAScriptコードの挙動が予測不能になったり、セキュリティ問題が生じる場合があります。ただし、これらの不変条件への違反によって実装のメモリ安全性が損なわれてはなりません。</p>
        <p>実装は、本質的内部メソッドの不変条件を強制しないまま、その機能を代替インターフェイスで提供するなどして、不変条件を回避できるようにしてはなりません。</p>
        <h2>定義：</h2>
        <ul>
          <li>
            内部メソッドの<em>ターゲット</em>は、その内部メソッドが呼び出されるオブジェクトです。
          </li>
          <li>
            ターゲットが[[IsExtensible]]内部メソッドで*false*を返すこと、または[[PreventExtensions]]内部メソッドで*true*を返すことが観測された場合、ターゲットは<em>非拡張</em>とされます。
          </li>
          <li>
            <em>非存在</em>プロパティとは、非拡張ターゲットに自身プロパティとして存在しないプロパティです。
          </li>
          <li>
            <em>SameValue</em>への参照は、SameValueアルゴリズムの定義に従います。
          </li>
        </ul>
        <h2>戻り値：</h2>
        <p>いかなる内部メソッドも、以下いずれかのCompletion Record値を返さなければなりません：</p>
        <ul>
          <li>[[Type]] = ~normal~, [[Target]] = ~empty~, [[Value]] = 下記内部メソッドごとの「正常返却型」の値、または</li>
          <li>[[Type]] = ~throw~, [[Target]] = ~empty~, [[Value]] = 任意のECMAScript言語値</li>
        </ul>
        <emu-note>
          <p>内部メソッドはcontinue完了、break完了、return完了を返してはなりません。</p>
        </emu-note>
        <h2>[[GetPrototypeOf]] ( )</h2>
        <ul>
          <li>
            正常返却型はObjectまたはNullです。
          </li>
          <li>
            ターゲットが非拡張で、[[GetPrototypeOf]]が値_V_を返した場合、以後の[[GetPrototypeOf]]呼び出しも_V_とSameValueな値を返すべきです。
          </li>
        </ul>
        <emu-note>
          <p>オブジェクトのプロトタイプチェーンは有限長であるべきです（すなわち、任意のオブジェクトから[[GetPrototypeOf]]内部メソッドを再帰的に適用すると、最終的に*null*になるべき）。ただし、プロトタイプチェーンに通常オブジェクト定義でない[[GetPrototypeOf]]を使うエキゾチックオブジェクトが含まれる場合、この条件はオブジェクトレベルの不変条件として強制できません。循環したプロトタイプチェーンは、プロパティアクセス時に無限ループとなる場合があります。</p>
        </emu-note>
        <h2>[[SetPrototypeOf]] ( _V_ )</h2>
        <ul>
          <li>
            正常返却型はBooleanです。
          </li>
          <li>
            ターゲットが非拡張の場合、[[SetPrototypeOf]]は*false*を返さなければなりません。ただし_V_がターゲットの観測済み[[GetPrototypeOf]]値とSameValueの場合を除く。
          </li>
        </ul>
        <h2>[[IsExtensible]] ( )</h2>
        <ul>
          <li>
            正常返却型はBooleanです。
          </li>
          <li>
            [[IsExtensible]]が*false*を返した場合、以後の[[IsExtensible]]呼び出しも*false*を返さなければなりません。
          </li>
        </ul>
        <h2>[[PreventExtensions]] ( )</h2>
        <ul>
          <li>
            正常返却型はBooleanです。
          </li>
          <li>
            [[PreventExtensions]]が*true*を返した場合、以後の[[IsExtensible]]呼び出しは*false*を返し、ターゲットは非拡張とされます。
          </li>
        </ul>
        <h2>[[GetOwnProperty]] ( _P_ )</h2>
        <ul>
          <li>
            正常返却型はProperty DescriptorまたはUndefinedです。
          </li>
          <li>
            返却値がProperty Descriptorの場合、完全に埋められた記述子でなければなりません。
          </li>
          <li>
            _P_が非設定可能・非書き込み可能な自身データプロパティである場合、以後の[[GetOwnProperty]] ( _P_ )呼び出しは、_P_の[[Value]]属性がSameValueなProperty Descriptorを返さなければなりません。
          </li>
          <li>
            _P_の[[Writable]]と[[Value]]以外の属性が変化する可能性がある、またはプロパティが削除され得る場合、_P_の[[Configurable]]属性は*true*でなければなりません。
          </li>
          <li>
            [[Writable]]属性が*false*から*true*に変化し得る場合、[[Configurable]]属性は*true*でなければなりません。
          </li>
          <li>
            ターゲットが非拡張かつ_P_が非存在自身プロパティの場合、以後の[[GetOwnProperty]] (_P_)呼び出しは_P_を非存在として記述しなければならない（つまり*undefined*を返す）。
          </li>
        </ul>
        <emu-note>
          <p>3番目の不変条件の結果として、プロパティがデータプロパティで時間経過で値が変わる可能性がある場合、他の本質的内部メソッドで値の変更手段が公開されていなくても、[[Writable]]または[[Configurable]]属性のいずれかまたは両方を*true*にしなければなりません。</p>
        </emu-note>
        <h2>[[DefineOwnProperty]] ( _P_, _Desc_ )</h2>
        <ul>
          <li>
            正常返却型はBooleanです。
          </li>
          <li>
            _P_が過去に非設定可能自身プロパティと観測されていた場合、次のいずれかでない限り[[DefineOwnProperty]]は*false*を返さなければなりません：
            <ol>
              <li>
                _P_が書き込み可能データプロパティである。非設定可能な書き込み可能データプロパティは非設定可能な非書き込み可能データプロパティに変更できる。
              </li>
              <li>
                _Desc_の全属性が_P_の属性とSameValueである。
              </li>
            </ol>
          </li>
          <li>
            ターゲットが非拡張かつ_P_が非存在自身プロパティの場合、[[DefineOwnProperty]] (_P_, _Desc_)は*false*を返さなければならない。つまり非拡張ターゲットオブジェクトに新しいプロパティは追加できない。
          </li>
        </ul>
        <h2>[[HasProperty]] ( _P_ )</h2>
        <ul>
          <li>
            正常返却型はBooleanです。
          </li>
          <li>
            _P_が過去に非設定可能自身データまたはアクセサプロパティだった場合、[[HasProperty]]は*true*を返さなければなりません。
          </li>
        </ul>
        <h2>[[Get]] ( _P_, _Receiver_ )</h2>
        <ul>
          <li>
            正常返却型は任意のECMAScript言語型です。
          </li>
          <li>
            _P_が過去に非設定可能・非書き込み可能な自身データプロパティで値_V_を持っていた場合、[[Get]]は_V_とSameValueな値を返さなければなりません。
          </li>
          <li>
            _P_が過去に非設定可能な自身アクセサプロパティで[[Get]]属性が*undefined*だった場合、[[Get]]操作は*undefined*を返さなければなりません。
          </li>
        </ul>
        <h2>[[Set]] ( _P_, _V_, _Receiver_ )</h2>
        <ul>
          <li>
            正常返却型はBooleanです。
          </li>
          <li>
            _P_が過去に非設定可能・非書き込み可能な自身データプロパティだった場合、_V_が_P_の[[Value]]属性とSameValueでない限り[[Set]]は*false*を返さなければなりません。
          </li>
          <li>
            _P_が過去に非設定可能な自身アクセサプロパティで[[Set]]属性が*undefined*だった場合、[[Set]]操作は*false*を返さなければなりません。
          </li>
        </ul>
        <h2>[[Delete]] ( _P_ )</h2>
        <ul>
          <li>
            正常返却型はBooleanです。
          </li>
          <li>
            _P_が過去に非設定可能自身データまたはアクセサプロパティだった場合、[[Delete]]は*false*を返さなければなりません。
          </li>
        </ul>
        <h2>[[OwnPropertyKeys]] ( )</h2>
        <ul>
          <li>
            正常返却型はリストです。
          </li>
          <li>
            返却されたリストに重複エントリがあってはなりません。
          </li>
          <li>
            リストの各要素はプロパティキーでなければなりません。
          </li>
          <li>
            リストには、これまで観測された非設定可能自身プロパティのキーが必ず含まれていなければなりません。
          </li>
          <li>
            ターゲットが非拡張の場合、返却リストには[[GetOwnProperty]]で観測可能なターゲットの自身プロパティ全てのキーのみが含まれていなければなりません。
          </li>
        </ul>
        <h2>[[Call]] ( )</h2>
        <ul>
          <li>
            正常返却型は任意のECMAScript言語型です。
          </li>
        </ul>
        <h2>[[Construct]] ( )</h2>
        <ul>
          <li>
            正常返却型はObjectです。
          </li>
          <li>
            ターゲットは[[Call]]内部メソッドも持っていなければなりません。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>著名な組み込みオブジェクト</h1>
        <p>著名な組み込みオブジェクト（well-known intrinsics）は、本仕様のアルゴリズムで明示的に参照され、通常はレルムごとに異なる同一性を持つ組み込みオブジェクトです。特に明示されていない限り、各組み込みオブジェクトはレルムごとに類似したオブジェクトの集合に対応します。</p>
        <p>本仕様内では、%name%のような参照は、現在のレルムに関連付けられた対応する名前の組み込みオブジェクトを意味します。%name.a.b%のような参照は、組み込みオブジェクト%name%の*"a"*プロパティ値の*"b"*プロパティ値に、ECMAScriptコードが評価される前にアクセスしたかのような意味です。現在のレルムとその組み込みオブジェクトの決定については<emu-xref href="#sec-execution-contexts"></emu-xref>で説明されています。著名な組み込みオブジェクトは<emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>に一覧化されています。</p>
        <emu-table id="table-well-known-intrinsic-objects" caption="著名な組み込みオブジェクト" oldids="table-7">
          <table>
            <thead>
              <tr>
                <th>
                  組み込み名
                </th>
                <th>
                  グローバル名
                </th>
                <th>
                  ECMAScript言語との関連
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                `AggregateError`コンストラクタ（<emu-xref href="#sec-aggregate-error-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                Arrayコンストラクタ（<emu-xref href="#sec-array-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                ArrayBufferコンストラクタ（<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Array Iteratorオブジェクトのプロトタイプ（<emu-xref href="#sec-array-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Async-from-Sync Iteratorオブジェクトのプロトタイプ（<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                非同期関数オブジェクトのコンストラクタ（<emu-xref href="#sec-async-function-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                非同期ジェネレーター関数オブジェクトのコンストラクタ（<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                非同期ジェネレーターオブジェクトのプロトタイプ（<emu-xref href="#sec-asyncgenerator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                全ての標準組み込み非同期イテレータオブジェクトが間接的に継承するオブジェクト
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                `Atomics`オブジェクト（<emu-xref href="#sec-atomics-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                BigIntコンストラクタ（<emu-xref href="#sec-bigint-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                BigInt64Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                BigUint64Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                Booleanコンストラクタ（<emu-xref href="#sec-boolean-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                DataViewコンストラクタ（<emu-xref href="#sec-dataview-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                Dateコンストラクタ（<emu-xref href="#sec-date-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                `decodeURI`関数（<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                `decodeURIComponent`関数（<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                `encodeURI`関数（<emu-xref href="#sec-encodeuri-uri"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                `encodeURIComponent`関数（<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                Errorコンストラクタ（<emu-xref href="#sec-error-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                `eval`関数（<emu-xref href="#sec-eval-x"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                EvalErrorコンストラクタ（<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                FinalizationRegistryコンストラクタ（<emu-xref href="#sec-finalization-registry-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float16Array%
              </td>
              <td>
                `Float16Array`
              </td>
              <td>
                Float16Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                Float32Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                Float64Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                For-In Iteratorオブジェクトのプロトタイプ（<emu-xref href="#sec-for-in-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                Functionコンストラクタ（<emu-xref href="#sec-function-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                ジェネレーター関数オブジェクトのコンストラクタ（<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                ジェネレーターオブジェクトのプロトタイプ（<emu-xref href="#sec-generator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                Int8Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                Int16Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                Int32Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                `isFinite`関数（<emu-xref href="#sec-isfinite-number"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                `isNaN`関数（<emu-xref href="#sec-isnan-number"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Iterator%
              </td>
              <td>
                `Iterator`
              </td>
              <td>
                `Iterator`コンストラクタ（<emu-xref href="#sec-iterator-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %IteratorHelperPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator Helperオブジェクトのプロトタイプ（<emu-xref href="#sec-%iteratorhelperprototype%-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                `JSON`オブジェクト（<emu-xref href="#sec-json-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                Mapコンストラクタ（<emu-xref href="#sec-map-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Map Iteratorオブジェクトのプロトタイプ（<emu-xref href="#sec-map-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                `Math`オブジェクト（<emu-xref href="#sec-math-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                Numberコンストラクタ（<emu-xref href="#sec-number-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                Objectコンストラクタ（<emu-xref href="#sec-object-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                `parseFloat`関数（<emu-xref href="#sec-parsefloat-string"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                `parseInt`関数（<emu-xref href="#sec-parseint-string-radix"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                Promiseコンストラクタ（<emu-xref href="#sec-promise-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                Proxyコンストラクタ（<emu-xref href="#sec-proxy-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                RangeErrorコンストラクタ（<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                ReferenceErrorコンストラクタ（<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                `Reflect`オブジェクト（<emu-xref href="#sec-reflect-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                RegExpコンストラクタ（<emu-xref href="#sec-regexp-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                RegExp String Iteratorオブジェクトのプロトタイプ（<emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                Setコンストラクタ（<emu-xref href="#sec-set-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Set Iteratorオブジェクトのプロトタイプ（<emu-xref href="#sec-set-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                SharedArrayBufferコンストラクタ（<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                Stringコンストラクタ（<emu-xref href="#sec-string-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                String Iteratorオブジェクトのプロトタイプ（<emu-xref href="#sec-string-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                Symbolコンストラクタ（<emu-xref href="#sec-symbol-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                SyntaxErrorコンストラクタ（<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                必ず新しい%TypeError%インスタンスを投げる関数オブジェクト
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                全ての型付き配列コンストラクタのスーパークラス（<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                TypeErrorコンストラクタ（<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                Uint8Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                Uint8ClampedArrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                Uint16Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                Uint32Arrayコンストラクタ（<emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                URIErrorコンストラクタ（<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                WeakMapコンストラクタ（<emu-xref href="#sec-weakmap-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                WeakRefコンストラクタ（<emu-xref href="#sec-weak-ref-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                WeakSetコンストラクタ（<emu-xref href="#sec-weakset-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WrapForValidIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator.fromで返されるラップされたイテレータオブジェクトのプロトタイプ（<emu-xref href="#sec-%wrapforvaliditeratorprototype%-object"></emu-xref>）
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>追加のエントリは<emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>にあります。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript仕様型</h1>
    <p>仕様型は、ECMAScript言語構造やECMAScript言語型の意味論を記述するためにアルゴリズム内で使用されるメタ値を表します。仕様型にはReference Record、List、Completion Record、Property Descriptor、Environment Record、Abstract Closure、Data Blockが含まれます。仕様型の値は仕様上のアーティファクトであり、ECMAScript実装内の特定の実体に必ずしも対応しません。仕様型の値はECMAScript式評価の中間結果の記述に使われることがありますが、オブジェクトのプロパティやECMAScript言語変数の値として保存することはできません。</p>

    <emu-clause id="sec-enum-specification-type">
      <h1>Enum仕様型</h1>
      <p><dfn variants="enum,enums">Enum</dfn>は仕様内部の値であり、ECMAScriptコードから直接観測することはできません。Enumは~sans-serif~フォントで表記されます。例えば、Completion Recordの[[Type]]フィールドは~normal~、~return~、~throw~などの値を取ります。Enumは名前以外の特性を持ちません。Enumの名前は他のEnumと区別するためだけに存在し、コンテキストでの使い方や意味を暗示しません。</p>
    </emu-clause>

    <emu-clause id="sec-list-and-record-specification-type">
      <h1>ListおよびRecord仕様型</h1>
      <p><dfn variants="Lists">List</dfn>型は、`new`式や関数呼び出し、その他値の単純な順序付きリストが必要なアルゴリズムにおける引数リスト評価を説明するために使用されます。List型の値は個々の値を含むリスト要素の順序付き列です。これらの列の長さは任意です。リストの要素は0始まりのインデックスでランダムにアクセスできます。記法上の便宜として、List要素へのアクセスには配列風の構文が使えます。例えば、_arguments_[2]はList_arguments_の3番目の要素を表します。</p>
      <p>アルゴリズムがListの要素を順序指定なしで反復する場合、使用される順序はList内の要素の順序です。</p>
      <p>この仕様書内の記法上の便宜として、リテラル構文を用いて新しいList値を表現できます。例えば、« 1, 2 »は2つの要素を持ち、それぞれ特定の値で初期化されているList値を定義します。新しい空のListは« »で表現できます。</p>
      <p>この仕様書では、「_A_、_B_、...の<dfn id="list-concatenation">リスト結合</dfn>」という表現（各引数は空リストの場合もある）は、各引数の要素（順序通り）を連結した新しいList値を表します。</p>
      <p>List of Stringsに対して「<dfn id="lexicographic-code-unit-order">辞書式コードユニット順</dfn>で並べ替える」とは、短い文字列の長さまで各コードユニットの数値で比較し、全てが等しければ短い方を先に並べることを意味します。これは抽象操作IsLessThanで説明されています。</p>
      <p><dfn variants="Records">Record</dfn>型は、この仕様のアルゴリズム内でデータ集合を記述するために使われます。Record型の値は1つ以上の名前付きフィールドからなります。各フィールドの値はECMAScript言語値または仕様値です。フィールド名は常に二重角括弧で囲まれます（例：[[Value]]）。</p>
      <p>記法上の便宜として、Record値はオブジェクトリテラル風の構文で表現できます。例えば、{ [[Field1]]: 42, [[Field2]]: *false*, [[Field3]]: ~empty~ }は3つのフィールドを持ち、それぞれが特定の値で初期化されたRecord値を定義します。フィールド名の順序は重要ではありません。明示的に記載されていないフィールドは存在しないものとみなされます。</p>
      <p>仕様本文やアルゴリズムでは、Record値の特定フィールドを参照するためにドット記法が使われます。例えば、Rが前述のRecordの場合、R.[[Field2]]は「Rの[[Field2]]という名前のフィールド」を意味します。</p>
      <p>よく使われるRecordフィールド組み合わせのスキーマには名前が付けられ、その名前をリテラルRecord値の前に付けて、記述している特定の集合種別を識別することができます。例：PropertyDescriptor { [[Value]]: 42, [[Writable]]: *false*, [[Configurable]]: *true* }。</p>
    </emu-clause>

    <emu-clause id="sec-set-and-relation-specification-type">
      <h1>SetおよびRelation仕様型</h1>
      <p><em>Set</em>型は、メモリモデルで使用するための順序なし要素の集合を説明するために使われます。これはECMAScriptの同名コレクション型とは異なります。区別のため、ECMAScriptコレクションのインスタンスは常に「Setオブジェクト」と呼ばれます。Set型の値は単純な要素集合であり、同じ要素が複数回現れることはありません。Setには要素の追加・削除ができます。Set同士の和集合、積集合、差集合も可能です。</p>
      <p><dfn variants="Relations">Relation</dfn>型は、Setに対する制約を説明するために使われます。Relation型の値は、その値域からの順序付きペアのSetです。例えば、イベントに対するRelationは、イベントの順序付きペアの集合です。Relation_R_と値域内の2つの値_a_、_b_について、_a_ _R_ _b_は順序付きペア(_a_, _b_)が_R_に含まれることの略記です。Relationがある条件に関して<dfn id="least-relation">最小Relation</dfn>であるとは、その条件を満たす最小のRelationであることを意味します。</p>
      <p><dfn variants="strict partial orders">狭義半順序</dfn>は、Relation値_R_が以下を満たす場合です。</p>
      <ul>
        <li>
          <p>_R_の値域内の全ての_a_、_b_、_c_について：</p>
          <ul>
            <li>_a_ _R_ _a_であることはない</li>
            <li>_a_ _R_ _b_かつ_b_ _R_ _c_なら_a_ _R_ _c_</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>上記2つの性質は、それぞれ反射性の否定（非自反性）と推移性と呼ばれます。</p>
      </emu-note>
      <p><dfn variants="strict total orders">狭義全順序</dfn>は、Relation値_R_が以下を満たす場合です。</p>
      <ul>
        <li>
          <p>_R_の値域内の全ての_a_、_b_、_c_について：</p>
          <ul>
            <li>_a_が_b_であるか、_a_ _R_ _b_か、_b_ _R_ _a_である</li>
            <li>_a_ _R_ _a_であることはない</li>
            <li>_a_ _R_ _b_かつ_b_ _R_ _c_なら_a_ _R_ _c_</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>上記3つの性質は、それぞれ全域性、非自反性、推移性と呼ばれます。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-completion-record-specification-type">
      <h1>Completion Record仕様型</h1>
      <p><dfn variants="Completion Records">Completion Record</dfn>仕様型は、値や制御フロー（`break`、`continue`、`return`、`throw`による非局所的な制御移動）のランタイム伝播などを説明するために使われます。</p>
      <p>Completion Recordは<emu-xref href="#table-completion-record-fields"></emu-xref>で定義されたフィールドを持ちます。</p>
      <emu-table id="table-completion-record-fields" caption="Completion Recordフィールド" oldids="table-8">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              ~normal~、~break~、~continue~、~return~、~throw~
            </td>
            <td>
              発生したcompletionの種類。
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              Completion Record以外の任意の値
            </td>
            <td>
              生成された値。
            </td>
          </tr>
          <tr>
            <td>
              [[Target]]
            </td>
            <td>
              Stringまたは~empty~
            </td>
            <td>
              指定制御移動のターゲットラベル。
            </td>
          </tr>
        </table>
      </emu-table>
      <p>Completion Recordを指すために次の略称が用いられることがあります。</p>
      <ul>
        <li><dfn variants="normal completions">normal completion</dfn>は[[Type]]値が~normal~のCompletion Recordを指します。</li>
        <li><dfn variants="break completions">break completion</dfn>は[[Type]]値が~break~のCompletion Recordを指します。</li>
        <li><dfn variants="continue completions">continue completion</dfn>は[[Type]]値が~continue~のCompletion Recordを指します。</li>
        <li><dfn variants="return completions">return completion</dfn>は[[Type]]値が~return~のCompletion Recordを指します。</li>
        <li><dfn variants="throw completions">throw completion</dfn>は[[Type]]値が~throw~のCompletion Recordを指します。</li>
        <li><dfn variants="abrupt completions">abrupt completion</dfn>は[[Type]]値が~normal~以外のCompletion Recordを指します。</li>
        <li><dfn variants="normal completions containing">normal completion containing</dfn>は[[Value]]フィールドに指定された型の値を持つnormal completionを指します。</li>
      </ul>
      <p>この仕様で定義される呼び出し可能オブジェクトは、normal completionまたはthrow completionのみを返します。それ以外のCompletion Recordを返す場合は編集上の誤りです。</p>
      <p>実装定義の呼び出し可能オブジェクトもnormal completionまたはthrow completionのみを返さなければなりません。</p>

      <emu-clause id="sec-normalcompletion" type="abstract operation">
        <h1>
          NormalCompletion (
            _value_: Completion Record以外の任意の値,
          ): normal completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throwcompletion" type="abstract operation">
        <h1>
          ThrowCompletion (
            _value_: ECMAScript言語値,
          ): throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returncompletion" type="abstract operation">
        <h1>
          ReturnCompletion (
            _value_: ECMAScript言語値,
          ): return completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-updateempty" type="abstract operation">
        <h1>
          UpdateEmpty (
            _completionRecord_: Completion Record,
            _value_: Completion Record以外の任意の値,
          ): Completion Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _completionRecord_がreturn completionまたはthrow completionの場合、_completionRecord_.[[Value]]は~empty~でないことをアサートする。
          1. _completionRecord_.[[Value]]が~empty~でないなら、? _completionRecord_を返す。
          1. Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>Reference Record仕様型</h1>
      <p><dfn variants="Reference Records">Reference Record</dfn>型は、`delete`、`typeof`、代入演算子、`super`キーワードやその他の言語機能の動作を説明するために使われます。例えば、代入の左辺オペランドはReference Recordを生成することが期待されます。</p>
      <p>Reference Recordは解決済みの名前や（未解決の場合もある）プロパティバインディングであり、そのフィールドは<emu-xref href="#table-reference-record-fields"></emu-xref>で定義されます。</p>

      <emu-table id="table-reference-record-fields" caption="Reference Recordフィールド">
        <table>
          <thead>
            <tr>
              <th>フィールド名</th>
              <th>値</th>
              <th>意味</th>
            </tr>
          </thead>
          <tr>
            <td oldids="sec-getbase,ao-getbase">[[Base]]</td>
            <td>ECMAScript言語値、Environment Record、~unresolvable~</td>
            <td>バインディングを保持する値またはEnvironment Record。[[Base]]が~unresolvable~の場合、バインディングが解決できなかったことを示す。</td>
          </tr>
          <tr>
            <td oldids="sec-getreferencedname,ao-getreferencedname">[[ReferencedName]]</td>
            <td>ECMAScript言語値またはPrivate Name</td>
            <td>バインディング名。[[Base]]値がEnvironment Recordの場合は常にString。それ以外の場合、ToPropertyKeyが実行されるまではStringやSymbol以外のECMAScript言語値の場合もある。</td>
          </tr>
          <tr>
            <td oldids="sec-isstrictreference,ao-isstrictreference">[[Strict]]</td>
            <td>真偽値</td>
            <td>Reference Recordがstrict modeコードから生成された場合は*true*、それ以外は*false*。</td>
          </tr>
          <tr>
            <td>[[ThisValue]]</td>
            <td>ECMAScript言語値または~empty~</td>
            <td>~empty~でない場合、Reference Recordは`super`キーワードで表現されたプロパティバインディングを表す（<dfn id="super-reference-record" oldids="super-reference" variants="Super Reference Records">Super Reference Record</dfn>）となり、[[Base]]値はEnvironment Recordにならない。その場合、[[ThisValue]]フィールドはReference Record生成時の*this*値を保持する。</td>
          </tr>
        </table>
      </emu-table>

      <p>この仕様でReference Recordを操作するのに使われる抽象操作は以下の通りです：</p>

      <emu-clause id="sec-ispropertyreference" type="abstract operation" oldids="ao-ispropertyreference">
        <h1>
          IsPropertyReference (
            _V_: Reference Record,
          ): 真偽値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[Base]]が~unresolvable~なら*false*を返す。
          1. _V_.[[Base]]がEnvironment Recordなら*false*を返す、そうでなければ*true*を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunresolvablereference" type="abstract operation" oldids="ao-isunresolvablereference">
        <h1>
          IsUnresolvableReference (
            _V_: Reference Record,
          ): 真偽値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[Base]]が~unresolvable~なら*true*、そうでなければ*false*を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issuperreference" type="abstract operation" oldids="ao-issuperreference">
        <h1>
          IsSuperReference (
            _V_: Reference Record,
          ): 真偽値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[ThisValue]]が~empty~でないなら*true*、それ以外は*false*を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isprivatereference" type="abstract operation">
        <h1>
          IsPrivateReference (
            _V_: Reference Record,
          ): 真偽値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[ReferencedName]]がPrivate Nameなら*true*、それ以外は*false*を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvalue" type="abstract operation">
        <h1>
          GetValue (
            _V_: Reference RecordまたはECMAScript言語値,
          ): normal completion（ECMAScript言語値含む）またはabrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_がReference Recordでなければ_V_を返す。
          1. IsUnresolvableReference(_V_)が*true*なら*ReferenceError*例外を投げる。
          1. IsPropertyReference(_V_)が*true*なら
            1. [id="step-getvalue-toobject"] _baseObj_を? ToObject(_V_.[[Base]])とする。
            1. IsPrivateReference(_V_)が*true*なら
              1. ? PrivateGet(_baseObj_, _V_.[[ReferencedName]])を返す。
            1. _V_.[[ReferencedName]]がプロパティキーでない場合
              1. _V_.[[ReferencedName]]を? ToPropertyKey(_V_.[[ReferencedName]])に設定する。
            1. ? <emu-meta effects="user-code">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_))を返す。
          1. それ以外の場合
            1. _base_を_V_.[[Base]]とする。
            1. アサート：_base_はEnvironment Record。
            1. ? <emu-meta effects="user-code">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]])（<emu-xref href="#sec-environment-records"></emu-xref>参照）を返す。
        </emu-alg>
        <emu-note>
          <p>step <emu-xref href="#step-getvalue-toobject"></emu-xref>で生成されるオブジェクトは、上記抽象操作および通常オブジェクト[[Get]]内部メソッド以外からはアクセスできません。実装によっては、実際のオブジェクト生成を省略する場合もあります。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-putvalue" type="abstract operation">
        <h1>
          PutValue (
            _V_: Reference RecordまたはECMAScript言語値,
            _W_: ECMAScript言語値,
          ): normal completion（~unused~含む）またはabrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_がReference Recordでなければ*ReferenceError*例外を投げる。
          1. IsUnresolvableReference(_V_)が*true*なら
            1. _V_.[[Strict]]が*true*なら*ReferenceError*例外を投げる。
            1. _globalObj_をGetGlobalObject()とする。
            1. ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*)を実行する。
            1. ~unused~を返す。
          1. IsPropertyReference(_V_)が*true*なら
            1. [id="step-putvalue-toobject"] _baseObj_を? ToObject(_V_.[[Base]])とする。
            1. IsPrivateReference(_V_)が*true*なら
              1. ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_)を返す。
            1. _V_.[[ReferencedName]]がプロパティキーでない場合
              1. _V_.[[ReferencedName]]を? ToPropertyKey(_V_.[[ReferencedName]])に設定する。
            1. _succeeded_を? <emu-meta effects="user-code">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_))とする。
            1. _succeeded_が*false*かつ_V_.[[Strict]]が*true*なら*TypeError*例外を投げる。
            1. ~unused~を返す。
          1. それ以外の場合
            1. _base_を_V_.[[Base]]とする。
            1. アサート：_base_はEnvironment Record。
            1. ? <emu-meta effects="user-code">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]])（<emu-xref href="#sec-environment-records"></emu-xref>参照）を返す。
        </emu-alg>
        <emu-note>
          <p>step <emu-xref href="#step-putvalue-toobject"></emu-xref>で生成されるオブジェクトは、上記抽象操作および通常オブジェクト[[Set]]内部メソッド以外からはアクセスできません。実装によっては、実際のオブジェクト生成を省略する場合もあります。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getthisvalue" type="abstract operation">
        <h1>
          GetThisValue (
            _V_: Reference Record,
          ): ECMAScript言語値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsPropertyReference(_V_)が*true*であることをアサートする。
          1. IsSuperReference(_V_)が*true*なら_V_.[[ThisValue]]を返し、そうでなければ_V_.[[Base]]を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-initializereferencedbinding" type="abstract operation">
        <h1>
          InitializeReferencedBinding (
            _V_: Reference Record,
            _W_: ECMAScript言語値,
          ): normal completion（~unused~含む）またはabrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsUnresolvableReference(_V_)が*false*であることをアサートする。
          1. _base_を_V_.[[Base]]とする。
          1. アサート：_base_はEnvironment Record。
          1. ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_)を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makeprivatereference" type="abstract operation">
        <h1>
          MakePrivateReference (
            _baseValue_: ECMAScript言語値,
            _privateIdentifier_: String,
          ): Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _privateEnv_を実行中の実行コンテキストのPrivateEnvironmentとする。
          1. アサート：_privateEnv_は*null*ではない。
          1. _privateName_をResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_)とする。
          1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-descriptor-specification-type">
      <h1>Property Descriptor仕様型</h1>
      <p><dfn variants="Property Descriptors">Property Descriptor</dfn>型は、オブジェクトプロパティ属性の操作や具現化を説明するために使われます。Property Descriptorは0個以上のフィールドを持つRecordであり、各フィールド名は属性名、値は<emu-xref href="#sec-property-attributes"></emu-xref>で指定された属性値です。仕様内でProperty Descriptor Recordをリテラル記述する際のスキーマ名は「PropertyDescriptor」です。</p>
      <p>Property Descriptor値は、特定のフィールドの存在や使用に基づきデータProperty DescriptorとアクセサProperty Descriptorに分類できます。[[Value]]または[[Writable]]フィールドがあるものはデータProperty Descriptor、[[Get]]または[[Set]]フィールドがあるものはアクセサProperty Descriptorです。全てのProperty Descriptorは[[Enumerable]]や[[Configurable]]フィールドを持てます。Property Descriptor値はデータProperty DescriptorとアクセサProperty Descriptorの両方になることはできませんが、どちらでもない場合もあり（その場合は汎用Property Descriptor）、<dfn>完全なProperty Descriptor</dfn>はアクセサまたはデータProperty Descriptorのいずれかで、かつ対応する全フィールドが<emu-xref href="#table-object-property-attributes"></emu-xref>で定義されているものです。</p>
      <p>この仕様でProperty Descriptor値を操作するために使われる抽象操作は以下の通りです：</p>

      <emu-clause id="sec-isaccessordescriptor" type="abstract operation">
        <h1>
          IsAccessorDescriptor (
            _Desc_: Property Descriptor,
          ): 真偽値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_が[[Get]]フィールドを持つなら*true*を返す。
          1. _Desc_が[[Set]]フィールドを持つなら*true*を返す。
          1. *false*を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdatadescriptor" type="abstract operation">
        <h1>
          IsDataDescriptor (
            _Desc_: Property Descriptor,
          ): 真偽値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_が[[Value]]フィールドを持つなら*true*を返す。
          1. _Desc_が[[Writable]]フィールドを持つなら*true*を返す。
          1. *false*を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isgenericdescriptor" type="abstract operation">
        <h1>
          IsGenericDescriptor (
            _Desc_: Property Descriptor,
          ): 真偽値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsAccessorDescriptor(_Desc_)が*true*なら*false*を返す。
          1. IsDataDescriptor(_Desc_)が*true*なら*false*を返す。
          1. *true*を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-frompropertydescriptor" type="abstract operation">
        <h1>
          FromPropertyDescriptor (
            _Desc_: Property Descriptorまたは*undefined*,
          ): Objectまたは*undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_が*undefined*なら*undefined*を返す。
          1. _obj_をOrdinaryObjectCreate(%Object.prototype%)とする。
          1. アサート：_obj_は自身プロパティを持たない拡張可能な通常オブジェクト。
          1. _Desc_が[[Value]]フィールドを持つなら
            1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _Desc_.[[Value]])を実行する。
          1. _Desc_が[[Writable]]フィールドを持つなら
            1. ! CreateDataPropertyOrThrow(_obj_, *"writable"*, _Desc_.[[Writable]])を実行する。
          1. _Desc_が[[Get]]フィールドを持つなら
            1. ! CreateDataPropertyOrThrow(_obj_, *"get"*, _Desc_.[[Get]])を実行する。
          1. _Desc_が[[Set]]フィールドを持つなら
            1. ! CreateDataPropertyOrThrow(_obj_, *"set"*, _Desc_.[[Set]])を実行する。
          1. _Desc_が[[Enumerable]]フィールドを持つなら
            1. ! CreateDataPropertyOrThrow(_obj_, *"enumerable"*, _Desc_.[[Enumerable]])を実行する。
          1. _Desc_が[[Configurable]]フィールドを持つなら
            1. ! CreateDataPropertyOrThrow(_obj_, *"configurable"*, _Desc_.[[Configurable]])を実行する。
          1. _obj_を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-topropertydescriptor" type="abstract operation">
        <h1>
          ToPropertyDescriptor (
            _Obj_: ECMAScript言語値,
          ): normal completion（Property Descriptor含む）またはthrow completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Obj_がObjectでなければ*TypeError*例外を投げる。
          1. _desc_をフィールドなしの新しいProperty Descriptorとする。
          1. _hasEnumerable_を? HasProperty(_Obj_, *"enumerable"*)とする。
          1. _hasEnumerable_が*true*なら
            1. _enumerable_をToBoolean(? Get(_Obj_, *"enumerable"*))とする。
            1. _desc_.[[Enumerable]]に_enumerable_を設定する。
          1. _hasConfigurable_を? HasProperty(_Obj_, *"configurable"*)とする。
          1. _hasConfigurable_が*true*なら
            1. _configurable_をToBoolean(? Get(_Obj_, *"configurable"*))とする。
            1. _desc_.[[Configurable]]に_configurable_を設定する。
          1. _hasValue_を? HasProperty(_Obj_, *"value"*)とする。
          1. _hasValue_が*true*なら
            1. _value_を? Get(_Obj_, *"value"*)とする。
            1. _desc_.[[Value]]に_value_を設定する。
          1. _hasWritable_を? HasProperty(_Obj_, *"writable"*)とする。
          1. _hasWritable_が*true*なら
            1. _writable_をToBoolean(? Get(_Obj_, *"writable"*))とする。
            1. _desc_.[[Writable]]に_writable_を設定する。
          1. _hasGet_を? HasProperty(_Obj_, *"get"*)とする。
          1. _hasGet_が*true*なら
            1. _getter_を? Get(_Obj_, *"get"*)とする。
            1. IsCallable(_getter_)が*false*かつ_getter_が*undefined*でなければ*TypeError*例外を投げる。
            1. _desc_.[[Get]]に_getter_を設定する。
          1. _hasSet_を? HasProperty(_Obj_, *"set"*)とする。
          1. _hasSet_が*true*なら
            1. _setter_を? Get(_Obj_, *"set"*)とする。
            1. IsCallable(_setter_)が*false*かつ_setter_が*undefined*でなければ*TypeError*例外を投げる。
            1. _desc_.[[Set]]に_setter_を設定する。
          1. _desc_が[[Get]]フィールドを持つ、または[[Set]]フィールドを持つなら
            1. _desc_が[[Value]]フィールドを持つ、または[[Writable]]フィールドを持つなら*TypeError*例外を投げる。
          1. _desc_を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-completepropertydescriptor" type="abstract operation">
        <h1>
          CompletePropertyDescriptor (
            _Desc_: Property Descriptor,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _like_をRecord { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }とする。
          1. IsGenericDescriptor(_Desc_)が*true*またはIsDataDescriptor(_Desc_)が*true*なら
            1. _Desc_が[[Value]]フィールドを持たなければ_Desc_.[[Value]]に_like_.[[Value]]を設定する。
            1. _Desc_が[[Writable]]フィールドを持たなければ_Desc_.[[Writable]]に_like_.[[Writable]]を設定する。
          1. それ以外の場合
            1. _Desc_が[[Get]]フィールドを持たなければ_Desc_.[[Get]]に_like_.[[Get]]を設定する。
            1. _Desc_が[[Set]]フィールドを持たなければ_Desc_.[[Set]]に_like_.[[Set]]を設定する。
          1. _Desc_が[[Enumerable]]フィールドを持たなければ_Desc_.[[Enumerable]]に_like_.[[Enumerable]]を設定する。
          1. _Desc_が[[Configurable]]フィールドを持たなければ_Desc_.[[Configurable]]に_like_.[[Configurable]]を設定する。
          1. ~unused~を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-lexical-environment-and-environment-record-specification-types">
      <h1>Environment Record仕様型</h1>
      <p>Environment Record型は、入れ子関数やブロックにおける名前解決の動作を説明するために使われます。この型および操作は<emu-xref href="#sec-environment-records"></emu-xref>で定義されています。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-closure">
      <h1>Abstract Closure仕様型</h1>
      <p><dfn variants="Abstract Closures">Abstract Closure</dfn>仕様型は、アルゴリズム手順と値の集合をまとめて参照するために使われます。Abstract Closureはメタ値であり、_closure_(_arg1_, _arg2_)のような関数適用スタイルで呼び出されます。抽象操作と同様、呼び出しではAbstract Closureで記述されたアルゴリズム手順を実行します。</p>
      <p>Abstract Closureを生成するアルゴリズム手順では、"capture"という動詞とエイリアスのリストで値をキャプチャします。Abstract Closure生成時には各エイリアスに関連付けられた値をキャプチャします。Abstract Closureの呼び出しで実行されるアルゴリズム手順には、キャプチャした値をエイリアス名で参照します。</p>
      <p>Abstract ClosureがCompletion Recordを返す場合、それはnormal completionまたはthrow completionでなければなりません。</p>
      <p>Abstract Closureは他のアルゴリズムの一部としてインラインで生成され、次の例のように表されます。</p>
      <emu-alg example>
        1. _addend_を41とする。
        1. _closure_をパラメータ(_x_)で_addend_をキャプチャし、呼び出し時に次の手順を実行する新しいAbstract Closureとする：
          1. _x_ + _addend_を返す。
        1. _val_を_closure_(1)とする。
        1. アサート：_val_は42である。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-data-blocks">
      <h1>Data Block</h1>
      <p><dfn variants="Data Blocks">Data Block</dfn>仕様型は、個別かつ可変なバイトサイズ（8ビット）の数値値の列を説明するために使われます。<dfn variants="byte values">バイト値</dfn>は0から255までの整数です。Data Block値は、各バイトの初期値が0である固定サイズのバイト数で作成されます。</p>
      <p>記法上の便宜として、Data Block値の個々のバイトへのアクセスには配列風の構文が使えます。この記法は、Data Block値を0ベースの<emu-not-ref>integer-indexed</emu-not-ref>なバイトの列として表現します。例えば、_db_が5バイトのData Block値の場合、_db_[2]で3番目のバイトにアクセスできます。</p>
      <p>複数のエージェントが同時に参照可能なメモリ上のデータブロックは<dfn variants="Shared Data Blocks">Shared Data Block</dfn>と呼ばれます。Shared Data Blockは同一性（Shared Data Block値の等価性判定のため）は<em>アドレス非依存</em>です。つまり、ブロックがどの仮想アドレスにマップされているかではなく、そのブロックが表すメモリ位置集合に結びついています。2つのデータブロックは、含む位置集合が等しい場合のみ等価であり、そうでなければ等価ではなく、位置集合の共通部分は空です。Shared Data BlockはData Blockと区別されます。</p>
      <p>Shared Data Blockの意味論は、メモリモデルによるShared Data Blockイベントを使って定義されます。以下の抽象操作はShared Data Blockイベントを導入し、評価意味論とメモリモデルのイベント意味論のインターフェースとなります。イベントは候補実行を形成し、メモリモデルがそれにフィルタをかけます。完全な意味論についてはメモリモデルを参照してください。</p>
      <p>Shared Data BlockイベントはRecordでモデル化され、メモリモデルで定義されています。</p>
      <p>この仕様でData Block値を操作するために使われる抽象操作は以下の通りです：</p>

      <emu-clause id="sec-createbytedatablock" type="abstract operation">
        <h1>
          CreateByteDataBlock (
            _size_: 非負整数,
          ): normal completion（Data Block含む）またはthrow completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _size_ > 2<sup>53</sup> - 1なら*RangeError*例外を投げる。
          1. _db_を_size_バイトからなる新しいData Block値とする。作成不可能なら*RangeError*例外を投げる。
          1. _db_の全バイトを0に設定する。
          1. _db_を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createsharedbytedatablock" type="abstract operation">
        <h1>
          CreateSharedByteDataBlock (
            _size_: 非負整数,
          ): normal completion（Shared Data Block含む）またはthrow completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _db_を_size_バイトからなる新しいShared Data Block値とする。作成不可能なら*RangeError*例外を投げる。
          1. _execution_を周囲エージェントのAgent Recordの[[CandidateExecution]]フィールドとする。
          1. _eventsRecord_を_agent_のAgent Events Record（_execution_.[[EventsRecords]]中で[[AgentSignifier]]がAgentSignifier()となるもの）とする。
          1. _zero_を« 0 »とする。
          1. _db_の各インデックス_i_について：
            1. WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ }を_eventsRecord_.[[EventList]]に追加する。
          1. _db_を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-copydatablockbytes" type="abstract operation">
        <h1>
          CopyDataBlockBytes (
            _toBlock_: Data BlockまたはShared Data Block,
            _toIndex_: 非負整数,
            _fromBlock_: Data BlockまたはShared Data Block,
            _fromIndex_: 非負整数,
            _count_: 非負整数,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _fromBlock_と_toBlock_が異なる値であることをアサートする。
          1. _fromSize_を_fromBlock_のバイト数とする。
          1. _fromIndex_ + _count_ ≤ _fromSize_をアサートする。
          1. _toSize_を_toBlock_のバイト数とする。
          1. _toIndex_ + _count_ ≤ _toSize_をアサートする。
          1. _count_ > 0の間、繰り返す：
            1. _fromBlock_がShared Data Blockの場合
              1. _execution_を周囲エージェントのAgent Recordの[[CandidateExecution]]フィールドとする。
              1. _eventsRecord_を_agent_のAgent Events Record（_execution_.[[EventsRecords]]中で[[AgentSignifier]]がAgentSignifier()となるもの）とする。
              1. _bytes_を、非決定的に選ばれたバイト値を唯一の要素とするListとする。
              1. 注：実装では、_bytes_は基底ハードウェアで非アトミックな読込命令の結果。非決定性は、弱い一貫性ハードウェアの観測可能挙動を記述するメモリモデルの意味論的規定。
              1. _readEvent_をReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }とする。
              1. _readEvent_を_eventsRecord_.[[EventList]]に追加する。
              1. Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ }を_execution_.[[ChosenValues]]に追加する。
              1. _toBlock_がShared Data Blockなら
                1. WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ }を_eventsRecord_.[[EventList]]に追加する。
              1. それ以外の場合
                1. _toBlock_[_toIndex_]に_bytes_[0]を設定する。
            1. それ以外の場合
              1. _toBlock_がShared Data Blockでないことをアサートする。
              1. _toBlock_[_toIndex_]に_fromBlock_[_fromIndex_]を設定する。
            1. _toIndex_を_toIndex_ + 1に設定する。
            1. _fromIndex_を_fromIndex_ + 1に設定する。
            1. _count_を_count_ - 1に設定する。
          1. ~unused~を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-privateelement-specification-type">
      <h1>PrivateElement仕様型</h1>
      <p>PrivateElement型は、privateクラスフィールド・メソッド・アクセサの仕様で使用されるRecordです。Property Descriptorはprivate要素には使われませんが、privateフィールドは非設定可能・非列挙・書き込み可能なデータプロパティ、privateメソッドは非設定可能・非列挙・非書き込み可能なデータプロパティ、privateアクセサは非設定可能・非列挙なアクセサプロパティと同様に振る舞います。</p>
      <p>PrivateElement型の値は、<emu-xref href="#table-privateelement-fields"></emu-xref>で定義されたフィールドを持つRecord値です。これらの値は<dfn variants="PrivateElement">PrivateElement</dfn>と呼ばれます。</p>
      <emu-table id="table-privateelement-fields" caption="PrivateElementフィールド">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                [[Kind]]フィールドが存在する場合の値
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Key]]
            </td>
            <td>
              全て
            </td>
            <td>
              Private Name
            </td>
            <td>
              フィールド・メソッド・アクセサの名前。
            </td>
          </tr>
          <tr>
            <td>
              [[Kind]]
            </td>
            <td>
              全て
            </td>
            <td>
              ~field~、~method~、~accessor~
            </td>
            <td>
              要素の種類。
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              ~field~と~method~
            </td>
            <td>
              ECMAScript言語値
            </td>
            <td>
              フィールドの値。
            </td>
          </tr>
          <tr>
            <td>
              [[Get]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              関数オブジェクトまたは*undefined*
            </td>
            <td>
              privateアクセサのgetter。
            </td>
          </tr>
          <tr>
            <td>
              [[Set]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              関数オブジェクトまたは*undefined*
            </td>
            <td>
              privateアクセサのsetter。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-classfielddefinition-record-specification-type">
      <h1>ClassFieldDefinition Record仕様型</h1>
      <p>ClassFieldDefinition型はクラスフィールドの仕様で使用されるRecordです。</p>
      <p>ClassFieldDefinition型の値は、<emu-xref href="#table-classfielddefinition-fields"></emu-xref>で定義されたフィールドを持つRecord値です。これらの値は<dfn variants="ClassFieldDefinition Record">ClassFieldDefinition Record</dfn>と呼ばれます。</p>
      <emu-table id="table-classfielddefinition-fields" caption="ClassFieldDefinition Recordフィールド">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Name]]
            </td>
            <td>
              Private Name、String、Symbol
            </td>
            <td>
              フィールドの名前。
            </td>
          </tr>
          <tr>
            <td>
              [[Initializer]]
            </td>
            <td>
              ECMAScript関数オブジェクトまたは~empty~
            </td>
            <td>
              フィールドの初期化子（あれば）。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-private-names">
      <h1>Private Name</h1>
      <p><dfn variants="Private Names">Private Name</dfn>仕様型は、他のPrivate Nameと区別される（たとえ他と区別できない場合でも）グローバルに一意な値を表し、privateクラス要素（フィールド・メソッド・アクセサ）のキーとなります。各Private Nameは不変な[[Description]]内部スロットを持ち、値はStringです。Private NameはECMAScriptオブジェクトにPrivateFieldAddまたはPrivateMethodOrAccessorAddでインストールでき、PrivateGetやPrivateSetで読み書きできます。</p>
    </emu-clause>

    <emu-clause id="sec-classstaticblockdefinition-record-specification-type">
      <h1>ClassStaticBlockDefinition Record仕様型</h1>
      <p><dfn variants="ClassStaticBlockDefinition Records">ClassStaticBlockDefinition Record</dfn>は、クラスのstatic初期化ブロック用実行コードをカプセル化するRecord値です。</p>
      <p>ClassStaticBlockDefinition Recordは<emu-xref href="#table-classstaticblockdefinition-record-fields"></emu-xref>で挙げられるフィールドを持ちます。</p>
      <emu-table id="table-classstaticblockdefinition-record-fields" caption="ClassStaticBlockDefinition Recordフィールド">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BodyFunction]]
            </td>
            <td>
              ECMAScript関数オブジェクト
            </td>
            <td>
              クラスのstatic初期化時に呼び出される関数オブジェクト。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>抽象操作</h1>
  <p>これらの操作はECMAScript言語の一部ではなく、ECMAScript言語の意味論を仕様化する助けのためだけにここで定義される。その他、より専門的な抽象操作は本仕様全体で定義されている。</p>

  <emu-clause id="sec-type-conversion">
    <h1>型変換</h1>
    <p>ECMAScript言語は必要に応じて暗黙的な自動型変換を行う。特定の構文要素の意味論を明確化するため、変換用の抽象操作集合を定義すると便利である。変換抽象操作は多態的であり、任意のECMAScript言語型の値を受け取ることができる。ただし他の仕様型はこれらの操作では使用しない。</p>
    <p>BigInt型はECMAScript言語において暗黙の変換を持たない。プログラマは他の型から値を変換する際に明示的にBigIntを呼び出す必要がある。</p>

    <emu-clause id="sec-toprimitive" type="abstract operation" oldids="table-9">
      <h1>
        ToPrimitive (
        _input_: ECMAScript言語値,
        省略可能 _preferredType_: ~string~ または ~number~,
        ): ECMAScript言語値を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_input_ 引数を非 Object 型へ変換する。オブジェクトが複数の基本型へ変換可能な場合、オプションのヒント _preferredType_ を使ってその型を優先できる。</dd>
      </dl>
      <emu-alg>
        1. _input_ が Object であるなら
          1. _exoticToPrim_ を ? GetMethod(_input_, %Symbol.toPrimitive%) とする。
          1. _exoticToPrim_ が *undefined* でないなら
            1. _preferredType_ が存在しないなら
              1. _hint_ を *"default"* とする。
            1. そうでなく _preferredType_ が ~string~ なら
              1. _hint_ を *"string"* とする。
            1. それ以外
              1. アサート: _preferredType_ は ~number~ である。
              1. _hint_ を *"number"* とする。
            1. _result_ を ? Call(_exoticToPrim_, _input_, « _hint_ ») とする。
            1. _result_ が Object でないなら _result_ を返す。
            1. *TypeError* 例外を投げる。
          1. _preferredType_ が存在しないなら _preferredType_ を ~number~ とする。
          1. ? OrdinaryToPrimitive(_input_, _preferredType_) を返す。
        1. _input_ を返す。
      </emu-alg>
      <emu-note>
        <p>ヒントなしで ToPrimitive が呼び出された場合、一般的にはヒントが ~number~ であったかのように振る舞う。しかし、オブジェクトは %Symbol.toPrimitive% メソッドを定義することでこの挙動を上書きできる。本仕様で定義されるオブジェクトのうち既定の ToPrimitive 挙動を上書きするのは Date（<emu-xref href="#sec-date.prototype-%symbol.toprimitive%"></emu-xref> 参照）と Symbol オブジェクト（<emu-xref href="#sec-symbol.prototype-%symbol.toprimitive%"></emu-xref> 参照）のみである。Date はヒント不在を ~string~ として扱う。</p>
      </emu-note>

      <emu-clause id="sec-ordinarytoprimitive" type="abstract operation">
        <h1>
          OrdinaryToPrimitive (
            _O_: Object,
            _hint_: ~string~ または ~number~,
          ): ECMAScript言語値を含む normal completion あるいは throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _hint_ が ~string~ なら
            1. _methodNames_ を « *"toString"*, *"valueOf"* » とする。
          1. それ以外
            1. _methodNames_ を « *"valueOf"*, *"toString"* » とする。
          1. _methodNames_ の各要素 _name_ について
            1. _method_ を ? Get(_O_, _name_) とする。
            1. IsCallable(_method_) が *true* なら
              1. _result_ を ? Call(_method_, _O_) とする。
              1. _result_ が Object でないなら _result_ を返す。
          1. *TypeError* 例外を投げる。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toboolean" oldids="table-toboolean-conversions,sec-IsHTMLDDA-internal-slot-to-boolean" type="abstract operation">
      <h1>
        ToBoolean (
          _argument_: ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を Boolean 型の値へ変換する。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が Boolean なら _argument_ を返す。
        1. _argument_ が *undefined*, *null*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *NaN*, *0*<sub>ℤ</sub>, または空文字列のいずれかなら *false* を返す。
        1. [id="step-to-boolean-web-compat-insertion-point", normative-optional] ホストが Web ブラウザまたは <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref> をサポートする場合
          1. _argument_ が Object でかつ [[IsHTMLDDA]] 内部スロットを持つなら *false* を返す。
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumeric" type="abstract operation">
      <h1>
        ToNumeric (
          _value_: ECMAScript言語値,
        ): Number または BigInt を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_value_ を Number か BigInt に変換して返す。</dd>
      </dl>
      <emu-alg>
        1. _primValue_ を ? ToPrimitive(_value_, ~number~) とする。
        1. _primValue_ が BigInt なら _primValue_ を返す。
        1. ? <emu-meta suppress-effects="user-code">ToNumber(_primValue_)</emu-meta> を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumber" oldids="table-tonumber-conversions" type="abstract operation">
      <h1>
        ToNumber (
          _argument_: ECMAScript言語値,
        ): Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を Number 型の値へ変換する。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が Number なら _argument_ を返す。
        1. _argument_ が Symbol か BigInt のいずれかなら *TypeError* 例外を投げる。
        1. _argument_ が *undefined* なら *NaN* を返す。
        1. _argument_ が *null* または *false* なら *+0*<sub>𝔽</sub> を返す。
        1. _argument_ が *true* なら *1*<sub>𝔽</sub> を返す。
        1. _argument_ が String なら StringToNumber(_argument_) を返す。
        1. アサート: _argument_ は Object である。
        1. _primValue_ を ? ToPrimitive(_argument_, ~number~) とする。
        1. アサート: _primValue_ は Object でない。
        1. ? ToNumber(_primValue_) を返す。
      </emu-alg>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>文字列型への ToNumber の適用</h1>
        <p>抽象操作 StringToNumber は次の文法を用いて String 値を Number 値へ変換する方法を規定する。</p>
        <h2>構文</h2>
        <emu-grammar type="definition">
          StringNumericLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrNumericLiteral StrWhiteSpace?

          StrWhiteSpace :::
            StrWhiteSpaceChar StrWhiteSpace?

          StrWhiteSpaceChar :::
            WhiteSpace
            LineTerminator

          StrNumericLiteral :::
            StrDecimalLiteral
            NonDecimalIntegerLiteral[~Sep]

          StrDecimalLiteral :::
            StrUnsignedDecimalLiteral
            `+` StrUnsignedDecimalLiteral
            `-` StrUnsignedDecimalLiteral

          StrUnsignedDecimalLiteral :::
            `Infinity`
            DecimalDigits[~Sep] `.` DecimalDigits[~Sep]? ExponentPart[~Sep]?
            `.` DecimalDigits[~Sep] ExponentPart[~Sep]?
            DecimalDigits[~Sep] ExponentPart[~Sep]?
        </emu-grammar>
        <p>上で明示的に定義されていない文法記号は数値リテラルの字句文法（<emu-xref href="#sec-literals-numeric-literals"></emu-xref>）で用いられる定義を持つ。</p>
        <emu-note>
          <p>|StringNumericLiteral| の構文と |NumericLiteral| の構文には次の差異がある：</p>
          <ul>
            <li>|StringNumericLiteral| は前後にホワイトスペースや行終端を含めてもよい。</li>
            <li>10進 |StringNumericLiteral| は任意個の先頭 `0` を含めてもよい。</li>
            <li>10進 |StringNumericLiteral| は符号を示すため `+` または `-` を含めてもよい。</li>
            <li>空またはホワイトスペースのみの |StringNumericLiteral| は *+0*<sub>𝔽</sub> に変換される。</li>
            <li>`Infinity` と `-Infinity` は |StringNumericLiteral| として認識されるが |NumericLiteral| ではない。</li>
            <li>|StringNumericLiteral| は |BigIntLiteralSuffix| を含めることはできない。</li>
            <li>|StringNumericLiteral| は |NumericLiteralSeparator| を含めることはできない。</li>
          </ul>
        </emu-note>

        <emu-clause id="sec-stringtonumber" type="abstract operation">
          <h1>
            StringToNumber (
              _str_: String,
            ): Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _literal_ を ParseText(_str_, |StringNumericLiteral|) とする。
            1. _literal_ がエラーの List なら *NaN* を返す。
            1. _literal_ の StringNumericValue を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-stringnumericvalue" type="sdo" oldids="sec-runtime-semantics-mv-s">
          <h1>実行時意味論: StringNumericValue ( ): Number</h1>
          <dl class="header">
          </dl>
          <emu-note>
            <p>|StringNumericLiteral| を Number 値へ変換することは、|NumericLiteral| の NumericValue の決定（<emu-xref href="#sec-literals-numeric-literals"></emu-xref> 参照）と全体として類似するが、いくつか詳細は異なる。</p>
          </emu-note>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. *+0*<sub>𝔽</sub> を返す。
          </emu-alg>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. |StrNumericLiteral| の StringNumericValue を返す。
          </emu-alg>
          <emu-grammar>StrNumericLiteral ::: NonDecimalIntegerLiteral</emu-grammar>
          <emu-alg>
            1. 𝔽(|NonDecimalIntegerLiteral| の MV) を返す。
          </emu-alg>
          <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
          <emu-alg>
            1. _a_ を |StrUnsignedDecimalLiteral| の StringNumericValue とする。
            1. _a_ が *+0*<sub>𝔽</sub> なら *-0*<sub>𝔽</sub> を返す。
            1. -_a_ を返す。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
          <emu-alg>
            1. *+∞*<sub>𝔽</sub> を返す。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
          <emu-alg>
            1. _a_ を最初の |DecimalDigits| の MV とする。
            1. 2番目の |DecimalDigits| が存在するなら
              1. _b_ を2番目の |DecimalDigits| の MV とする。
              1. _n_ を2番目の |DecimalDigits| のコードポイント数とする。
            1. それ以外
              1. _b_ を 0 とする。
              1. _n_ を 0 とする。
            1. |ExponentPart| が存在するなら _e_ を |ExponentPart| の MV とし、そうでなければ _e_ を 0 とする。
            1. RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>) を返す。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. _b_ を |DecimalDigits| の MV とする。
            1. |ExponentPart| が存在するなら _e_ を |ExponentPart| の MV とし、そうでなければ _e_ を 0 とする。
            1. _n_ を |DecimalDigits| のコードポイント数とする。
            1. RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>) を返す。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. _a_ を |DecimalDigits| の MV とする。
            1. |ExponentPart| が存在するなら _e_ を |ExponentPart| の MV とし、そうでなければ _e_ を 0 とする。
            1. RoundMVResult(_a_ × 10<sup>_e_</sup>) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-roundmvresult" type="abstract operation">
          <h1>
            RoundMVResult (
              _n_: 数学的値,
            ): Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_n_ を実装依存の方法で Number に変換する。この抽象操作において、桁は 0 でないか左側に 0 でない桁があり右側にも 0 でない桁がある場合に有効とみなされる。また「数学的値の表現が表す数学的値」とは「数学的値の10進表現」の逆写像とする。</dd>
          </dl>
          <emu-alg>
            1. _n_ の10進表現が有効桁20桁以下なら 𝔽(_n_) を返す。
            1. _option1_ を _n_ の10進表現において20桁目より後の各有効桁を 0 に置き換えた表現が表す数学的値とする。
            1. _option2_ を _n_ の10進表現において20桁目より後の各有効桁を 0 に置き換え、20桁目を（必要なら桁上げしつつ）インクリメントした表現が表す数学的値とする。
            1. _chosen_ を実装依存に _option1_ または _option2_ から選ぶ。
            1. 𝔽(_chosen_) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tointegerorinfinity" type="abstract operation" oldids="sec-tointeger">
      <h1>
        ToIntegerOrInfinity (
          _argument_: ECMAScript言語値,
        ): 整数, +∞, -∞ のいずれかを含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を Number 値の小数部分切り捨て表現の整数、またはその Number 値が無限大の場合は +∞ / -∞ に変換する。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら 0 を返す。
        1. _number_ が *+∞*<sub>𝔽</sub> なら +∞ を返す。
        1. _number_ が *-∞*<sub>𝔽</sub> なら -∞ を返す。
        1. truncate(ℝ(_number_)) を返す。
      </emu-alg>
      <emu-note>
        𝔽(ToIntegerOrInfinity(_x_)) はいかなる _x_ に対しても *-0*<sub>𝔽</sub> を返さない。小数部の切り捨ては _x_ を数学的値に変換した後に行われる。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint32" type="abstract operation">
      <h1>
        ToInt32 (
          _argument_: ECMAScript言語値,
        ): 整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を 𝔽(-2<sup>31</sup>) から 𝔽(2<sup>31</sup> - 1) までの 2<sup>32</sup> 個の整数 Number 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が有限でない、または *+0*<sub>𝔽</sub> か *-0*<sub>𝔽</sub> のいずれかなら *+0*<sub>𝔽</sub> を返す。
        1. _int_ を truncate(ℝ(_number_)) とする。
        1. _int32bit_ を _int_ modulo 2<sup>32</sup> とする。
        1. _int32bit_ ≥ 2<sup>31</sup> なら 𝔽(_int32bit_ - 2<sup>32</sup>) を返し、そうでなければ 𝔽(_int32bit_) を返す。
      </emu-alg>
      <emu-note>
        <p>上記 ToInt32 定義により:</p>
        <ul>
          <li>ToInt32 抽象操作は冪等であり、その結果に再適用しても値は変わらない。</li>
          <li>全ての _x_ について ToInt32(ToUint32(_x_)) は ToInt32(_x_) と同じ値。（この性質を保つため *+∞*<sub>𝔽</sub> と *-∞*<sub>𝔽</sub> は *+0*<sub>𝔽</sub> に写る。）</li>
          <li>ToInt32 は *-0*<sub>𝔽</sub> を *+0*<sub>𝔽</sub> に写す。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-touint32" type="abstract operation">
      <h1>
        ToUint32 (
          _argument_: ECMAScript言語値,
        ): 整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を *+0*<sub>𝔽</sub> から 𝔽(2<sup>32</sup> - 1) までの 2<sup>32</sup> 個の整数 Number 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が有限でない、または *+0*<sub>𝔽</sub> か *-0*<sub>𝔽</sub> のいずれかなら *+0*<sub>𝔽</sub> を返す。
        1. _int_ を truncate(ℝ(_number_)) とする。
        1. _int32bit_ を _int_ modulo 2<sup>32</sup> とする。
        1. [id="step-touint32-return"] 𝔽(_int32bit_) を返す。
      </emu-alg>
      <emu-note>
        <p>上記 ToUint32 定義により:</p>
        <ul>
          <li>ステップ <emu-xref href="#step-touint32-return"></emu-xref> が ToUint32 と ToInt32 の唯一の差異。</li>
          <li>ToUint32 抽象操作は冪等である。</li>
          <li>全ての _x_ について ToUint32(ToInt32(_x_)) は ToUint32(_x_) と同じ値。（この性質を保つため *+∞*<sub>𝔽</sub> と *-∞*<sub>𝔽</sub> は *+0*<sub>𝔽</sub> に写る。）</li>
          <li>ToUint32 は *-0*<sub>𝔽</sub> を *+0*<sub>𝔽</sub> に写す。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint16" type="abstract operation">
      <h1>
        ToInt16 (
          _argument_: ECMAScript言語値,
        ): 整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を 𝔽(-2<sup>15</sup>) から 𝔽(2<sup>15</sup> - 1) までの 2<sup>16</sup> 個の整数 Number 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が有限でない、または *+0*<sub>𝔽</sub> か *-0*<sub>𝔽</sub> のいずれかなら *+0*<sub>𝔽</sub> を返す。
        1. _int_ を truncate(ℝ(_number_)) とする。
        1. _int16bit_ を _int_ modulo 2<sup>16</sup> とする。
        1. _int16bit_ ≥ 2<sup>15</sup> なら 𝔽(_int16bit_ - 2<sup>16</sup>) を返し、そうでなければ 𝔽(_int16bit_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint16" type="abstract operation">
      <h1>
        ToUint16 (
          _argument_: ECMAScript言語値,
        ): 整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を *+0*<sub>𝔽</sub> から 𝔽(2<sup>16</sup> - 1) までの 2<sup>16</sup> 個の整数 Number 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が有限でない、または *+0*<sub>𝔽</sub> か *-0*<sub>𝔽</sub> のいずれかなら *+0*<sub>𝔽</sub> を返す。
        1. _int_ を truncate(ℝ(_number_)) とする。
        1. [id="step-touint16-mod"] _int16bit_ を _int_ modulo 2<sup>16</sup> とする。
        1. 𝔽(_int16bit_) を返す。
      </emu-alg>
      <emu-note>
        <p>上記 ToUint16 定義により:</p>
        <ul>
          <li>ステップ <emu-xref href="#step-touint16-mod"></emu-xref> における 2<sup>16</sup> の代入が ToUint32 との唯一の差異。</li>
          <li>ToUint16 は *-0*<sub>𝔽</sub> を *+0*<sub>𝔽</sub> に写す。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint8" type="abstract operation">
      <h1>
        ToInt8 (
          _argument_: ECMAScript言語値,
        ): 整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を *-128*<sub>𝔽</sub> から *127*<sub>𝔽</sub> までの 2<sup>8</sup> 個の整数 Number 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が有限でない、または *+0*<sub>𝔽</sub> か *-0*<sub>𝔽</sub> のいずれかなら *+0*<sub>𝔽</sub> を返す。
        1. _int_ を truncate(ℝ(_number_)) とする。
        1. _int8bit_ を _int_ modulo 2<sup>8</sup> とする。
        1. _int8bit_ ≥ 2<sup>7</sup> なら 𝔽(_int8bit_ - 2<sup>8</sup>) を返し、そうでなければ 𝔽(_int8bit_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8" type="abstract operation">
      <h1>
        ToUint8 (
          _argument_: ECMAScript言語値,
        ): 整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を *+0*<sub>𝔽</sub> から *255*<sub>𝔽</sub> までの 2<sup>8</sup> 個の整数 Number 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が有限でない、または *+0*<sub>𝔽</sub> か *-0*<sub>𝔽</sub> のいずれかなら *+0*<sub>𝔽</sub> を返す。
        1. _int_ を truncate(ℝ(_number_)) とする。
        1. _int8bit_ を _int_ modulo 2<sup>8</sup> とする。
        1. 𝔽(_int8bit_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8clamp" type="abstract operation">
      <h1>
        ToUint8Clamp (
          _argument_: ECMAScript言語値,
        ): 整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を *+0*<sub>𝔽</sub> から *255*<sub>𝔽</sub> の範囲に丸め及びクランプし 2<sup>8</sup> 個の整数 Number 値のいずれかにする。</dd>
      </dl>
      <emu-alg>
        1. _number_ を ? ToNumber(_argument_) とする。
        1. _number_ が *NaN* なら *+0*<sub>𝔽</sub> を返す。
        1. _mv_ を _number_ の拡張数学的値とする。
        1. _clamped_ を _mv_ を 0 と 255 の間にクランプした結果とする。
        1. _f_ を floor(_clamped_) とする。
        1. _clamped_ &lt; _f_ + 0.5 なら 𝔽(_f_) を返す。
        1. _clamped_ > _f_ + 0.5 なら 𝔽(_f_ + 1) を返す。
        1. _f_ が偶数なら 𝔽(_f_) を返し、そうでなければ 𝔽(_f_ + 1) を返す。
      </emu-alg>
      <emu-note>
        <p>他の多くの整数変換操作と異なり ToUint8Clamp は非整数値を切り捨てではなく丸める。また “round half to even” であり <emu-xref href="#sec-math.round">`Math.round`</emu-xref> の “round half up” とは異なる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-tobigint" type="abstract operation">
      <h1>
        ToBigInt (
          _argument_: ECMAScript言語値,
        ): BigInt を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を BigInt 値へ変換する。Number からの暗黙変換が必要となる場合は例外を投げる。</dd>
      </dl>
      <emu-alg>
        1. _prim_ を ? ToPrimitive(_argument_, ~number~) とする。
        1. <emu-xref href="#table-tobigint"></emu-xref> において _prim_ が対応する値を返す。
      </emu-alg>
      <emu-table id="table-tobigint" caption="BigInt 変換">
        <table>
          <thead>
            <tr>
              <th>
                引数型
              </th>
              <th>
                結果
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              *TypeError* 例外を投げる。
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              *TypeError* 例外を投げる。
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              _prim_ が *true* なら `1n` を、_prim_ が *false* なら `0n` を返す。
            </td>
          </tr>
          <tr>
            <td>
              BigInt
            </td>
            <td>
              _prim_ を返す。
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              *TypeError* 例外を投げる。
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              <emu-alg>
                1. _n_ を StringToBigInt(_prim_) とする。
                1. _n_ が *undefined* なら *SyntaxError* 例外を投げる。
                1. _n_ を返す。
              </emu-alg>
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              *TypeError* 例外を投げる。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-stringtobigint" type="abstract operation">
      <h1>
        StringToBigInt (
          _str_: String,
        ): BigInt または *undefined*
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _literal_ を ParseText(_str_, |StringIntegerLiteral|) とする。
        1. _literal_ がエラーの List なら *undefined* を返す。
        1. _mv_ を _literal_ の MV とする。
        1. アサート: _mv_ は整数。
        1. ℤ(_mv_) を返す。
      </emu-alg>

      <emu-clause id="sec-stringintegerliteral-grammar">
        <h1>StringIntegerLiteral 文法</h1>
        <p>StringToBigInt は以下の文法を用いる。</p>
        <h2>構文</h2>
        <emu-grammar type="definition">
          StringIntegerLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?

          StrIntegerLiteral :::
            SignedInteger[~Sep]
            NonDecimalIntegerLiteral[~Sep]
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-mv-for-stringintegerliteral">
        <h1>実行時意味論: MV</h1>
        <ul>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace?</emu-grammar> の MV は 0。
          </li>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?</emu-grammar> の MV は |StrIntegerLiteral| の MV。
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tobigint64" type="abstract operation">
      <h1>
        ToBigInt64 (
          _argument_: ECMAScript言語値,
        ): BigInt を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を ℤ(-2<sup>63</sup>) から ℤ(2<sup>63</sup> - 1) までの 2<sup>64</sup> 個の BigInt 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _n_ を ? ToBigInt(_argument_) とする。
        1. _int64bit_ を ℝ(_n_) modulo 2<sup>64</sup> とする。
        1. _int64bit_ ≥ 2<sup>63</sup> なら ℤ(_int64bit_ - 2<sup>64</sup>) を返し、そうでなければ ℤ(_int64bit_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tobiguint64" type="abstract operation">
      <h1>
        ToBigUint64 (
          _argument_: ECMAScript言語値,
        ): BigInt を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を *0*<sub>ℤ</sub> から ℤ(2<sup>64</sup> - 1) までの 2<sup>64</sup> 個の BigInt 値のいずれかに変換する。</dd>
      </dl>
      <emu-alg>
        1. _n_ を ? ToBigInt(_argument_) とする。
        1. _int64bit_ を ℝ(_n_) modulo 2<sup>64</sup> とする。
        1. ℤ(_int64bit_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tostring" oldids="table-tostring-conversions" type="abstract operation">
      <h1>
        ToString (
          _argument_: ECMAScript言語値,
        ): String を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を String 型の値へ変換する。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が String なら _argument_ を返す。
        1. _argument_ が Symbol なら *TypeError* 例外を投げる。
        1. _argument_ が *undefined* なら *"undefined"* を返す。
        1. _argument_ が *null* なら *"null"* を返す。
        1. _argument_ が *true* なら *"true"* を返す。
        1. _argument_ が *false* なら *"false"* を返す。
        1. _argument_ が Number なら Number::toString(_argument_, 10) を返す。
        1. _argument_ が BigInt なら BigInt::toString(_argument_, 10) を返す。
        1. アサート: _argument_ は Object である。
        1. _primValue_ を ? ToPrimitive(_argument_, ~string~) とする。
        1. アサート: _primValue_ は Object でない。
        1. ? ToString(_primValue_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-toobject" type="abstract operation" oldids="table-toobject-conversions,table-13">
      <h1>
        ToObject (
          _argument_: ECMAScript言語値,
        ): Object を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を Object 型の値へ変換する。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が *undefined* または *null* のいずれかなら *TypeError* 例外を投げる。
        1. _argument_ が Boolean なら [[BooleanData]] 内部スロットに _argument_ を設定した新しい Boolean オブジェクトを返す。Boolean オブジェクトの説明は <emu-xref href="#sec-boolean-objects"></emu-xref> を参照。
        1. _argument_ が Number なら [[NumberData]] 内部スロットに _argument_ を設定した新しい Number オブジェクトを返す。説明は <emu-xref href="#sec-number-objects"></emu-xref> 参照。
        1. _argument_ が String なら [[StringData]] 内部スロットに _argument_ を設定した新しい String オブジェクトを返す。説明は <emu-xref href="#sec-string-objects"></emu-xref> 参照。
        1. _argument_ が Symbol なら [[SymbolData]] 内部スロットに _argument_ を設定した新しい Symbol オブジェクトを返す。説明は <emu-xref href="#sec-symbol-objects"></emu-xref> 参照。
        1. _argument_ が BigInt なら [[BigIntData]] 内部スロットに _argument_ を設定した新しい BigInt オブジェクトを返す。説明は <emu-xref href="#sec-bigint-objects"></emu-xref> 参照。
        1. アサート: _argument_ は Object である。
        1. _argument_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-topropertykey" type="abstract operation">
      <h1>
        ToPropertyKey (
          _argument_: ECMAScript言語値,
        ): プロパティキーを含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ をプロパティキーとして使用可能な値へ変換する。</dd>
      </dl>
      <emu-alg>
        1. _key_ を ? ToPrimitive(_argument_, ~string~) とする。
        1. _key_ が Symbol なら
          1. _key_ を返す。
        1. ! ToString(_key_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tolength" type="abstract operation">
      <h1>
        ToLength (
          _argument_: ECMAScript言語値,
        ): 非負整数 Number を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ を配列風オブジェクトの length として適した非負整数 Number にクランプし切り捨てる。</dd>
      </dl>
      <emu-alg>
        1. _len_ を ? ToIntegerOrInfinity(_argument_) とする。
        1. _len_ ≤ 0 なら *+0*<sub>𝔽</sub> を返す。
        1. 𝔽(min(_len_, 2<sup>53</sup> - 1)) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canonicalnumericindexstring" type="abstract operation">
      <h1>
        CanonicalNumericIndexString (
          _argument_: String,
        ): Number または *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ が *"-0"* であるか、ある Number 値 _n_ について ToString(_n_) と正確に一致するなら、対応する Number 値を返す。それ以外は *undefined* を返す。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が *"-0"* なら *-0*<sub>𝔽</sub> を返す。
        1. _n_ を ! ToNumber(_argument_) とする。
        1. ! ToString(_n_) が _argument_ と等しいなら _n_ を返す。
        1. *undefined* を返す。
      </emu-alg>
      <p><dfn variants="canonical numeric strings">正規数値文字列</dfn>とは CanonicalNumericIndexString 抽象操作が *undefined* を返さない任意の String のこと。</p>
    </emu-clause>

    <emu-clause id="sec-toindex" type="abstract operation">
      <h1>
        ToIndex (
          _value_: ECMAScript言語値,
        ): 非負整数を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_value_ を整数に変換し、それが非負かつ整数インデックスに対応するならその整数を返す。そうでなければ例外を投げる。</dd>
      </dl>
      <emu-alg>
        1. _integer_ を ? ToIntegerOrInfinity(_value_) とする。
        1. _integer_ が 0 から 2<sup>53</sup> - 1 までの範囲にないなら *RangeError* 例外を投げる。
        1. _integer_ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>テストおよび比較操作</h1>

    <emu-clause id="sec-requireobjectcoercible" type="abstract operation" oldids="table-requireobjectcoercible-results,table-14">
      <h1>
        RequireObjectCoercible (
          _argument_: ECMAScript言語値,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ が ToObject により Object へ変換できない値ならエラーを投げる。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が *undefined* または *null* のいずれかなら *TypeError* 例外を投げる。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isarray" type="abstract operation">
      <h1>
        IsArray (
          _argument_: ECMAScript言語値,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _argument_ が Object でないなら *false* を返す。
        1. _argument_ が Array エキゾチックオブジェクトなら *true* を返す。
        1. _argument_ が Proxy エキゾチックオブジェクトなら
          1. ? ValidateNonRevokedProxy(_argument_) を実行する。
          1. _proxyTarget_ を _argument_.[[ProxyTarget]] とする。
          1. ? IsArray(_proxyTarget_) を返す。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iscallable" type="abstract operation">
      <h1>
        IsCallable (
          _argument_: ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ が [[Call]] 内部メソッドを持つ呼び出し可能関数か判定する。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が Object でないなら *false* を返す。
        1. _argument_ が [[Call]] 内部メソッドを持つなら *true* を返す。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isconstructor" type="abstract operation">
      <h1>
        IsConstructor (
          _argument_: ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_ が [[Construct]] 内部メソッドを持つ関数オブジェクトか判定する。</dd>
      </dl>
      <emu-alg>
        1. _argument_ が Object でないなら *false* を返す。
        1. _argument_ が [[Construct]] 内部メソッドを持つなら *true* を返す。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isextensible-o" type="abstract operation">
      <h1>
        IsExtensible (
          _O_: Object,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_ に追加のプロパティを加えられるか判定する。</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[IsExtensible]]</emu-meta>() を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isregexp" type="abstract operation">
      <h1>
        IsRegExp (
          _argument_: ECMAScript言語値,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _argument_ が Object でないなら *false* を返す。
        1. _matcher_ を ? Get(_argument_, %Symbol.match%) とする。
        1. _matcher_ が *undefined* でないなら ToBoolean(_matcher_) を返す。
        1. _argument_ が [[RegExpMatcher]] 内部スロットを持つなら *true* を返す。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstringwellformedunicode" type="abstract operation">
      <h1>
        静的意味論: IsStringWellFormedUnicode (
        _string_: String,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_string_ を <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> に記述される UTF-16 符号化コードポイント列として解釈し、それが <a href="http://www.unicode.org/glossary/#well_formed_code_unit_sequence">well formed</a> な UTF-16 シーケンスか判定する。</dd>
      </dl>
      <emu-alg>
        1. _len_ を _string_ の長さとする。
        1. _k_ を 0 とする。
        1. _k_ &lt; _len_ の間繰り返す
          1. _cp_ を CodePointAt(_string_, _k_) とする。
          1. _cp_.[[IsUnpairedSurrogate]] が *true* なら *false* を返す。
          1. _k_ を _k_ + _cp_.[[CodeUnitCount]] に設定する。
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sametype" type="abstract operation">
      <h1>
        SameType (
          _x_: ECMAScript言語値,
          _y_: ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>2つの引数が同じ型かどうか判定する。</dd>
      </dl>
      <emu-alg>
        1. _x_ が *undefined* かつ _y_ が *undefined* なら *true* を返す。
        1. _x_ が *null* かつ _y_ が *null* なら *true* を返す。
        1. _x_ が Boolean かつ _y_ が Boolean なら *true* を返す。
        1. _x_ が Number かつ _y_ が Number なら *true* を返す。
        1. _x_ が BigInt かつ _y_ が BigInt なら *true* を返す。
        1. _x_ が Symbol かつ _y_ が Symbol なら *true* を返す。
        1. _x_ が String かつ _y_ が String なら *true* を返す。
        1. _x_ が Object かつ _y_ が Object なら *true* を返す。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-samevalue" type="abstract operation">
      <h1>
        SameValue (
          _x_: ECMAScript言語値,
          _y_: ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>2つの引数が同じ値かどうか判定する。</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_) が *false* なら *false* を返す。
        1. _x_ が Number なら
          1. Number::sameValue(_x_, _y_) を返す。
        1. SameValueNonNumber(_x_, _y_) を返す。
      </emu-alg>
      <emu-note>
        <p>このアルゴリズムは *NaN* 値を同等とみなし *+0*<sub>𝔽</sub> と *-0*<sub>𝔽</sub> を区別する点で IsStrictlyEqual アルゴリズムと異なる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluezero" type="abstract operation">
      <h1>
        SameValueZero (
          _x_: ECMAScript言語値,
          _y_: ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>2つの引数が同じ値か（*+0*<sub>𝔽</sub> と *-0*<sub>𝔽</sub> の差異を無視して）判定する。</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_) が *false* なら *false* を返す。
        1. _x_ が Number なら
          1. Number::sameValueZero(_x_, _y_) を返す。
        1. SameValueNonNumber(_x_, _y_) を返す。
      </emu-alg>
      <emu-note>
        <p>SameValueZero は *+0*<sub>𝔽</sub> と *-0*<sub>𝔽</sub> を同等と扱う点のみ SameValue と異なる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" type="abstract operation" oldids="sec-samevaluenonnumeric">
      <h1>
        SameValueNonNumber (
          _x_: Number でない ECMAScript言語値,
          _y_: Number でない ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. アサート: SameType(_x_, _y_) は *true*。
        1. _x_ が *undefined* または *null* のいずれかなら *true* を返す。
        1. _x_ が BigInt なら
          1. BigInt::equal(_x_, _y_) を返す。
        1. _x_ が String なら
          1. _x_ と _y_ が同じ長さで同じ位置に同じコードユニットを持つなら *true* を返し、そうでなければ *false* を返す。
        1. _x_ が Boolean なら
          1. _x_ と _y_ がともに *true* またはともに *false* なら *true* を返し、そうでなければ *false* を返す。
        1. 注: 他の全ての ECMAScript 言語値は同一性で比較される。
        1. _x_ が _y_ なら *true* を返し、そうでなければ *false* を返す。
      </emu-alg>
      <emu-note>
        説明のため、一部のケースは必要ではないが個別に扱っている。
      </emu-note>
      <emu-note>
        "_x_ が _y_" の詳細は <emu-xref href="#sec-identity"></emu-xref> で述べる。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islessthan" type="abstract operation" oldids="sec-abstract-relational-comparison">
      <h1>
        IsLessThan (
          _x_: ECMAScript言語値,
          _y_: ECMAScript言語値,
          _LeftFirst_: Boolean,
        ): Boolean または *undefined* を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>比較 _x_ &lt; _y_ の意味論を提供し、*true* / *false* / *undefined*（少なくとも一方が *NaN* を示す）を返す。_LeftFirst_ フラグは副作用の可視性を伴う操作の順序を制御するために使われ、ECMAScript が左から右への評価順を規定しているため必要。_LeftFirst_ が *true* のとき _x_ は _y_ より左に現れる式に対応し、*false* のときは逆でその場合操作は _y_ が先に行われる。</dd>
      </dl>
      <emu-alg>
        1. _LeftFirst_ が *true* なら
          1. _px_ を ? ToPrimitive(_x_, ~number~) とする。
          1. _py_ を ? ToPrimitive(_y_, ~number~) とする。
        1. それ以外
          1. 注: 評価順維持のため順序を反転する必要がある。
          1. _py_ を ? ToPrimitive(_y_, ~number~) とする。
          1. _px_ を ? ToPrimitive(_x_, ~number~) とする。
        1. [id="step-arc-string-check"] _px_ が String かつ _py_ が String なら
          1. _lx_ を _px_ の長さとする。
          1. _ly_ を _py_ の長さとする。
          1. 0 ≤ _i_ &lt; min(_lx_, _ly_) なる各整数 _i_ について昇順で
            1. _cx_ を _px_ のインデックス _i_ にあるコードユニットの数値とする。
            1. _cy_ を _py_ のインデックス _i_ にあるコードユニットの数値とする。
            1. _cx_ &lt; _cy_ なら *true* を返す。
            1. _cx_ > _cy_ なら *false* を返す。
          1. _lx_ &lt; _ly_ なら *true* を返し、そうでなければ *false* を返す。
        1. それ以外
          1. _px_ が BigInt かつ _py_ が String なら
            1. _ny_ を StringToBigInt(_py_) とする。
            1. _ny_ が *undefined* なら *undefined* を返す。
            1. BigInt::lessThan(_px_, _ny_) を返す。
          1. _px_ が String かつ _py_ が BigInt なら
            1. _nx_ を StringToBigInt(_px_) とする。
            1. _nx_ が *undefined* なら *undefined* を返す。
            1. BigInt::lessThan(_nx_, _py_) を返す。
          1. 注: _px_, _py_ はプリミティブなので評価順は重要でない。
          1. _nx_ を ? <emu-meta suppress-effects="user-code">ToNumeric(_px_)</emu-meta> とする。
          1. _ny_ を ? <emu-meta suppress-effects="user-code">ToNumeric(_py_)</emu-meta> とする。
          1. SameType(_nx_, _ny_) が *true* なら
            1. _nx_ が Number なら
              1. Number::lessThan(_nx_, _ny_) を返す。
            1. それ以外
              1. アサート: _nx_ は BigInt。
              1. BigInt::lessThan(_nx_, _ny_) を返す。
          1. アサート: (_nx_ が BigInt かつ _ny_ が Number) または (_nx_ が Number かつ _ny_ が BigInt)。
          1. _nx_ または _ny_ が *NaN* なら *undefined* を返す。
          1. _nx_ が *-∞*<sub>𝔽</sub> または _ny_ が *+∞*<sub>𝔽</sub> なら *true* を返す。
          1. _nx_ が *+∞*<sub>𝔽</sub> または _ny_ が *-∞*<sub>𝔽</sub> なら *false* を返す。
          1. ℝ(_nx_) &lt; ℝ(_ny_) なら *true* を返し、そうでなければ *false* を返す。
      </emu-alg>
      <emu-note>
        <p>ステップ <emu-xref href="#step-arc-string-check"></emu-xref> は、加算演算子 `+` を扱うアルゴリズム（<emu-xref href="#sec-applystringornumericbinaryoperator"></emu-xref>）のステップ <emu-xref href="#step-binary-op-string-check"></emu-xref> と、論理和ではなく論理積を用いる点で異なる。</p>
      </emu-note>
      <emu-note>
        <p>文字列の比較は UTF-16 コードユニット値列に対する単純な辞書式順序を使用する。Unicode 仕様で定義される文字や文字列の意味的な等価性や照合順序は考慮しない。そのため Unicode Standard 上正規等価だが正規化形式が異なる文字列は不等と判定され得る。またサロゲートペアを含む文字列ではコードユニット順序はコードポイント順序と異なる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islooselyequal" type="abstract operation" oldids="sec-abstract-equality-comparison,sec-IsHTMLDDA-internal-slot-aec">
      <h1>
        IsLooselyEqual (
          _x_: ECMAScript言語値,
          _y_: ECMAScript言語値,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`==` 演算子の意味論を提供する。</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_) が *true* なら
          1. IsStrictlyEqual(_x_, _y_) を返す。
        1. _x_ が *null* かつ _y_ が *undefined* なら *true* を返す。
        1. _x_ が *undefined* かつ _y_ が *null* なら *true* を返す。
        1. [id="step-abstract-equality-comparison-web-compat-insertion-point", normative-optional] ホストが Web ブラウザまたは <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref> をサポートする場合
          1. _x_ が Object で [[IsHTMLDDA]] 内部スロットを持ち、_y_ が *undefined* または *null* なら *true* を返す。
          1. _x_ が *undefined* または *null* で _y_ が Object かつ [[IsHTMLDDA]] 内部スロットを持つなら *true* を返す。
        1. _x_ が Number かつ _y_ が String なら ! IsLooselyEqual(_x_, ! ToNumber(_y_)) を返す。
        1. _x_ が String かつ _y_ が Number なら ! IsLooselyEqual(! ToNumber(_x_), _y_) を返す。
        1. _x_ が BigInt かつ _y_ が String なら
          1. _n_ を StringToBigInt(_y_) とする。
          1. _n_ が *undefined* なら *false* を返す。
          1. ! IsLooselyEqual(_x_, _n_) を返す。
        1. _x_ が String かつ _y_ が BigInt なら ! IsLooselyEqual(_y_, _x_) を返す。
        1. _x_ が Boolean なら ! IsLooselyEqual(! ToNumber(_x_), _y_) を返す。
        1. _y_ が Boolean なら ! IsLooselyEqual(_x_, ! ToNumber(_y_)) を返す。
        1. _x_ が String, Number, BigInt, Symbol のいずれかで _y_ が Object なら ! IsLooselyEqual(_x_, ? ToPrimitive(_y_)) を返す。
        1. _x_ が Object で _y_ が String, Number, BigInt, Symbol のいずれかなら ! IsLooselyEqual(? ToPrimitive(_x_), _y_) を返す。
        1. _x_ が BigInt かつ _y_ が Number, または _x_ が Number かつ _y_ が BigInt なら
          1. _x_ が有限でないまたは _y_ が有限でないなら *false* を返す。
          1. ℝ(_x_) = ℝ(_y_) なら *true* を返し、そうでなければ *false* を返す。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstrictlyequal" type="abstract operation" oldids="sec-strict-equality-comparison">
      <h1>
        IsStrictlyEqual (
          _x_: ECMAScript言語値,
          _y_: ECMAScript言語値,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`===` 演算子の意味論を提供する。</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_) が *false* なら *false* を返す。
        1. _x_ が Number なら
          1. Number::equal(_x_, _y_) を返す。
        1. SameValueNonNumber(_x_, _y_) を返す。
      </emu-alg>
      <emu-note>
        <p>このアルゴリズムは符号付きゼロと NaN の扱いにおいて SameValue アルゴリズムと異なる。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-objects">
    <h1>オブジェクトに対する操作</h1>

    <emu-clause id="sec-makebasicobject" type="abstract operation">
      <h1>
        MakeBasicObject (
          _internalSlotsList_: 内部スロット名の List,
        ): Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>通常オブジェクトとエキゾチックオブジェクトを含む、アルゴリズム的に作られる全ての ECMAScript オブジェクトの起源である。全オブジェクト生成で共通する手順を切り出し、生成を集約する。</dd>
      </dl>

      <emu-alg>
        1. _internalSlotsList_ を _internalSlotsList_ と « [[PrivateElements]] » のリスト結合に設定する。
        1. _internalSlotsList_ 内の各名前に対応する内部スロットを持つ新規オブジェクト _obj_ を作成する。
        1. 注: <emu-xref href="#sec-object-internal-methods-and-internal-slots" title></emu-xref> で述べるように特記ない限り各内部スロットの初期値は *undefined*。
        1. _obj_.[[PrivateElements]] を空の新しい List に設定する。
        1. _obj_ の本質的内部メソッドを <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> で規定される既定の通常オブジェクト定義に設定する。
        1. アサート: 呼び出し側が _obj_ の [[GetPrototypeOf]] と [[SetPrototypeOf]] の両方を上書きしない場合、_internalSlotsList_ は [[Prototype]] を含む。
        1. アサート: 呼び出し側が _obj_ の [[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]] の全てを上書きしない場合、_internalSlotsList_ は [[Extensible]] を含む。
        1. _internalSlotsList_ が [[Extensible]] を含むなら _obj_.[[Extensible]] を *true* に設定する。
        1. _obj_ を返す。
      </emu-alg>

      <emu-note>
        <p>本仕様内でエキゾチックオブジェクトは ArrayCreate や BoundFunctionCreate のような抽象操作で、まず MakeBasicObject を呼び基本オブジェクトを得てから内部メソッドの一部または全部を上書きして作成される。エキゾチックオブジェクト生成をカプセル化するため、本質的内部メソッドはそれら操作以外では変更されない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-get-o-p" type="abstract operation">
      <h1>
        Get (
          _O_: Object,
          _P_: プロパティキー,
        ): ECMAScript言語値を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの特定プロパティの値を取得するために使用される。</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _O_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getv" type="abstract operation">
      <h1>
        GetV (
          _V_: ECMAScript言語値,
          _P_: プロパティキー,
        ): ECMAScript言語値を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ECMAScript言語値の特定プロパティの値を取得するために使用される。値がオブジェクトでない場合、値の型に適切なラッパーオブジェクトを用いてプロパティ探索が行われる。</dd>
      </dl>
      <emu-alg>
        1. _O_ を ? ToObject(_V_) とする。
        1. ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _V_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-set-o-p-v-throw" type="abstract operation">
      <h1>
        Set (
          _O_: Object,
          _P_: プロパティキー,
          _V_: ECMAScript言語値,
          _Throw_: Boolean,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの特定プロパティの値を設定するために用いられる。_V_ は新しい値。</dd>
      </dl>
      <emu-alg>
        1. _success_ を ? <emu-meta effects="user-code">_O_.[[Set]]</emu-meta>(_P_, _V_, _O_) とする。
        1. _success_ が *false* かつ _Throw_ が *true* なら *TypeError* 例外を投げる。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdataproperty" type="abstract operation">
      <h1>
        CreateDataProperty (
          _O_: Object,
          _P_: プロパティキー,
          _V_: ECMAScript言語値,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの新しい自身プロパティを生成するために使用される。</dd>
      </dl>
      <emu-alg>
        1. _newDesc_ を PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* } とする。
        1. ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _newDesc_) を返す。
      </emu-alg>
      <emu-note>
        <p>この抽象操作は ECMAScript の代入演算子で作られるプロパティと同じ既定属性を持つプロパティを生成する。通常プロパティは未存在であり、存在し非設定可能または _O_ が拡張不可能なら [[DefineOwnProperty]] は *false* を返す。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createdatapropertyorthrow" type="abstract operation">
      <h1>
        CreateDataPropertyOrThrow (
          _O_: Object,
          _P_: プロパティキー,
          _V_: ECMAScript言語値,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの新しい自身プロパティを生成する。要求された更新が行えない場合 *TypeError* を投げる。</dd>
      </dl>
      <emu-alg>
        1. _success_ を ? CreateDataProperty(_O_, _P_, _V_) とする。
        1. _success_ が *false* なら *TypeError* 例外を投げる。
        1. ~unused~ を返す。
      </emu-alg>
      <emu-note>
        <p>属性は代入演算子によって生成されるプロパティの既定値と同じ。存在済みで非設定可能または _O_ が拡張不可能なら [[DefineOwnProperty]] は *false* を返し本操作は *TypeError* を投げる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createnonenumerabledatapropertyorthrow" type="abstract operation">
      <h1>
        CreateNonEnumerableDataPropertyOrThrow (
          _O_: Object,
          _P_: プロパティキー,
          _V_: ECMAScript言語値,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>通常オブジェクトの列挙不可な新しい自身プロパティを生成する。</dd>
      </dl>
      <emu-alg>
        1. アサート: _O_ は非設定可能プロパティを持たない通常で拡張可能なオブジェクト。
        1. _newDesc_ を PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } とする。
        1. ! DefinePropertyOrThrow(_O_, _P_, _newDesc_) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
      <emu-note>
        <p>代入演算子既定と同じだが列挙不可。通常存在しないが存在しても DefinePropertyOrThrow は正常完了する。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-definepropertyorthrow" type="abstract operation">
      <h1>
        DefinePropertyOrThrow (
          _O_: Object,
          _P_: プロパティキー,
          _desc_: Property Descriptor,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの [[DefineOwnProperty]] 内部メソッドを呼び、要求された更新が行えない場合 *TypeError* を投げる。</dd>
      </dl>
      <emu-alg>
        1. _success_ を ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _desc_) とする。
        1. _success_ が *false* なら *TypeError* 例外を投げる。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-deletepropertyorthrow" type="abstract operation">
      <h1>
        DeletePropertyOrThrow (
          _O_: Object,
          _P_: プロパティキー,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの特定自身プロパティを削除する。プロパティが設定可能でない場合例外を投げる。</dd>
      </dl>
      <emu-alg>
        1. _success_ を ? <emu-meta effects="user-code">_O_.[[Delete]]</emu-meta>(_P_) とする。
        1. _success_ が *false* なら *TypeError* 例外を投げる。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getmethod" type="abstract operation">
      <h1>
        GetMethod (
          _V_: ECMAScript言語値,
          _P_: プロパティキー,
        ): 関数オブジェクトまたは *undefined* を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>プロパティ値が関数であることが期待される場合に ECMAScript 言語値の特定プロパティ値を取得する。</dd>
      </dl>
      <emu-alg>
        1. _func_ を ? GetV(_V_, _P_) とする。
        1. _func_ が *undefined* または *null* のいずれかなら *undefined* を返す。
        1. IsCallable(_func_) が *false* なら *TypeError* 例外を投げる。
        1. _func_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasproperty" type="abstract operation">
      <h1>
        HasProperty (
          _O_: Object,
          _P_: プロパティキー,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトが指定キーのプロパティ（自身または継承）を持つか判定する。</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[HasProperty]]</emu-meta>(_P_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasownproperty" type="abstract operation">
      <h1>
        HasOwnProperty (
          _O_: Object,
          _P_: プロパティキー,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトが指定キーの自身プロパティを持つか判定する。</dd>
      </dl>
      <emu-alg>
        1. _desc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
        1. _desc_ が *undefined* なら *false* を返す。
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-call" type="abstract operation">
      <h1>
        Call (
        _F_: ECMAScript言語値,
        _V_: ECMAScript言語値,
        省略可能 _argumentsList_: ECMAScript言語値の List,
        ): ECMAScript言語値を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>関数オブジェクトの [[Call]] 内部メソッドを呼ぶために用いる。_F_ が関数、_V_ が *this* 値、_argumentsList_ が内部メソッドに渡す引数列。_argumentsList_ が無ければ空の新 List を用いる。</dd>
      </dl>
      <emu-alg>
        1. _argumentsList_ が存在しないなら _argumentsList_ を空の新 List に設定する。
        1. IsCallable(_F_) が *false* なら *TypeError* 例外を投げる。
        1. ? <emu-meta effects="user-code">_F_.[[Call]]</emu-meta>(_V_, _argumentsList_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-construct" type="abstract operation">
      <h1>
        Construct (
        _F_: constructor,
        省略可能 _argumentsList_: ECMAScript言語値の List,
        省略可能 _newTarget_: constructor,
        ): Object を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>関数オブジェクトの [[Construct]] 内部メソッドを呼ぶために用いる。_argumentsList_ と _newTarget_ は内部メソッドに対応する引数として渡される。_argumentsList_ が無い場合空の新 List、_newTarget_ が無い場合 _F_ を用いる。</dd>
      </dl>
      <emu-alg>
        1. _newTarget_ が存在しないなら _newTarget_ を _F_ に設定する。
        1. _argumentsList_ が存在しないなら _argumentsList_ を空の新 List に設定する。
        1. ? <emu-meta effects="user-code">_F_.[[Construct]]</emu-meta>(_argumentsList_, _newTarget_) を返す。
      </emu-alg>
      <emu-note>
        <p>_newTarget_ が無い場合、この操作は `new F(...argumentsList)` と同等。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-setintegritylevel" type="abstract operation">
      <h1>
        SetIntegrityLevel (
          _O_: Object,
          _level_: ~sealed~ または ~frozen~,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの自身プロパティ集合を固定するために使用。</dd>
      </dl>
      <emu-alg>
        1. _status_ を ? _O_.[[PreventExtensions]]() とする。
        1. _status_ が *false* なら *false* を返す。
        1. _keys_ を ? _O_.[[OwnPropertyKeys]]() とする。
        1. _level_ が ~sealed~ なら
          1. _keys_ の各要素 _k_ について
            1. ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* }) を実行する。
        1. それ以外
          1. アサート: _level_ は ~frozen~。
          1. _keys_ の各要素 _k_ について
            1. _currentDesc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_) とする。
            1. _currentDesc_ が *undefined* でないなら
              1. IsAccessorDescriptor(_currentDesc_) が *true* なら
                1. _desc_ を PropertyDescriptor { [[Configurable]]: *false* } とする。
              1. それ以外
                1. _desc_ を PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* } とする。
              1. ? DefinePropertyOrThrow(_O_, _k_, _desc_) を実行する。
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-testintegritylevel" type="abstract operation">
      <h1>
        TestIntegrityLevel (
          _O_: Object,
          _level_: ~sealed~ または ~frozen~,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>オブジェクトの自身プロパティ集合が固定されているか判定する。</dd>
      </dl>
      <emu-alg>
        1. _extensible_ を ? IsExtensible(_O_) とする。
        1. _extensible_ が *true* なら *false* を返す。
        1. 注: オブジェクトが拡張可能ならプロパティは調べない。
        1. _keys_ を ? _O_.[[OwnPropertyKeys]]() とする。
        1. _keys_ の各要素 _k_ について
          1. _currentDesc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_) とする。
          1. _currentDesc_ が *undefined* でないなら
            1. _currentDesc_.[[Configurable]] が *true* なら *false* を返す。
            1. _level_ が ~frozen~ かつ IsDataDescriptor(_currentDesc_) が *true* なら
              1. _currentDesc_.[[Writable]] が *true* なら *false* を返す。
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createarrayfromlist" type="abstract operation">
      <h1>
        CreateArrayFromList (
          _elements_: ECMAScript言語値の List,
        ): Array
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>要素が _elements_ によって与えられる Array を生成する。</dd>
      </dl>
      <emu-alg>
        1. _array_ を ! ArrayCreate(0) とする。
        1. _n_ を 0 とする。
        1. _elements_ の各要素 _e_ について
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_) を実行する。
          1. _n_ を _n_ + 1 に設定する。
        1. _array_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-lengthofarraylike" type="abstract operation">
      <h1>
        LengthOfArrayLike (
          _obj_: Object,
        ): 非負整数を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>配列風オブジェクトの *"length"* プロパティの値を返す。</dd>
      </dl>
      <emu-alg>
        1. ℝ(? ToLength(? Get(_obj_, *"length"*))) を返す。
      </emu-alg>
      <p><dfn variants="array-like objects">配列風オブジェクト</dfn>とはこの操作が normal completion を返す任意のオブジェクト。</p>
      <emu-note>
        通常配列風オブジェクトは整数インデックス名プロパティを持つがこの定義の要件ではない。
      </emu-note>
      <emu-note>
        Array と String オブジェクトは配列風オブジェクトの例である。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createlistfromarraylike" type="abstract operation">
      <h1>
        CreateListFromArrayLike (
        _obj_: ECMAScript言語値,
        省略可能 _validElementTypes_: ~all~ または ~property-key~,
        ): ECMAScript言語値の List を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_obj_ のインデックス付きプロパティから要素を取得して List 値を生成する。_validElementTypes_ は要素として許可される値の型を示す。</dd>
      </dl>
      <emu-alg>
        1. _validElementTypes_ が存在しないなら _validElementTypes_ を ~all~ とする。
        1. _obj_ が Object でないなら *TypeError* 例外を投げる。
        1. _len_ を ? LengthOfArrayLike(_obj_) とする。
        1. _list_ を空の新 List とする。
        1. _index_ を 0 とする。
        1. _index_ &lt; _len_ の間繰り返す
          1. _indexName_ を ! ToString(𝔽(_index_)) とする。
          1. _next_ を ? Get(_obj_, _indexName_) とする。
          1. _validElementTypes_ が ~property-key~ かつ _next_ がプロパティキーでないなら *TypeError* 例外を投げる。
          1. _next_ を _list_ に追加する。
          1. _index_ を _index_ + 1 に設定する。
        1. _list_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-invoke" type="abstract operation">
      <h1>
        Invoke (
        _V_: ECMAScript言語値,
        _P_: プロパティキー,
        省略可能 _argumentsList_: ECMAScript言語値の List,
        ): ECMAScript言語値を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ECMAScript言語値のメソッドプロパティを呼び出すために用いる。_V_ はプロパティ探索点かつ呼び出しの *this* 値。_argumentsList_ はメソッドに渡す引数列。省略時は空 List。</dd>
      </dl>

      <emu-alg>
        1. _argumentsList_ が存在しないなら _argumentsList_ を空の新 List に設定する。
        1. _func_ を ? GetV(_V_, _P_) とする。
        1. ? Call(_func_, _V_, _argumentsList_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryhasinstance" type="abstract operation">
      <h1>
        OrdinaryHasInstance (
          _C_: ECMAScript言語値,
          _O_: ECMAScript言語値,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_ が _C_ により提供されるインスタンスオブジェクト継承パスから継承しているかの既定アルゴリズムを実装する。</dd>
      </dl>
      <emu-alg>
        1. IsCallable(_C_) が *false* なら *false* を返す。
        1. _C_ が [[BoundTargetFunction]] 内部スロットを持つなら
          1. _BC_ を _C_.[[BoundTargetFunction]] とする。
          1. ? InstanceofOperator(_O_, _BC_) を返す。
        1. _O_ が Object でないなら *false* を返す。
        1. _P_ を ? Get(_C_, *"prototype"*) とする。
        1. _P_ が Object でないなら *TypeError* 例外を投げる。
        1. 繰り返し
          1. _O_ を ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() に設定する。
          1. _O_ が *null* なら *false* を返す。
          1. SameValue(_P_, _O_) が *true* なら *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-speciesconstructor" type="abstract operation">
      <h1>
        SpeciesConstructor (
          _O_: Object,
          _defaultConstructor_: constructor,
        ): constructor を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_ から派生する新オブジェクト生成に用いるべきコンストラクタを取得する。_defaultConstructor_ は %Symbol.species% プロパティが _O_ から辿れない場合に使用するコンストラクタ。</dd>
      </dl>
      <emu-alg>
        1. _C_ を ? Get(_O_, *"constructor"*) とする。
        1. _C_ が *undefined* なら _defaultConstructor_ を返す。
        1. _C_ が Object でないなら *TypeError* 例外を投げる。
        1. _S_ を ? Get(_C_, %Symbol.species%) とする。
        1. _S_ が *undefined* または *null* のいずれかなら _defaultConstructor_ を返す。
        1. IsConstructor(_S_) が *true* なら _S_ を返す。
        1. *TypeError* 例外を投げる。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-enumerableownproperties" type="abstract operation" oldids="sec-enumerableownpropertynames">
      <h1>
        EnumerableOwnProperties (
          _O_: Object,
          _kind_: ~key~, ~value~, ~key+value~,
        ): ECMAScript言語値の List を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _ownKeys_ を ? <emu-meta effects="user-code">_O_.[[OwnPropertyKeys]]</emu-meta>() とする。
        1. _results_ を空の新 List とする。
        1. _ownKeys_ の各要素 _key_ について
          1. _key_ が String なら
            1. _desc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_) とする。
            1. _desc_ が *undefined* でなく _desc_.[[Enumerable]] が *true* なら
              1. _kind_ が ~key~ なら
                1. _key_ を _results_ に追加する。
              1. それ以外
                1. _value_ を ? Get(_O_, _key_) とする。
                1. _kind_ が ~value~ なら
                  1. _value_ を _results_ に追加する。
                1. それ以外
                  1. アサート: _kind_ は ~key+value~。
                  1. _entry_ を CreateArrayFromList(« _key_, _value_ ») とする。
                  1. _entry_ を _results_ に追加する。
        1. _results_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getfunctionrealm" type="abstract operation">
      <h1>
        GetFunctionRealm (
          _obj_: 関数オブジェクト,
        ): Realm Record を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _obj_ が [[Realm]] 内部スロットを持つなら
          1. _obj_.[[Realm]] を返す。
        1. _obj_ が bound function エキゾチックオブジェクトなら
          1. _boundTargetFunction_ を _obj_.[[BoundTargetFunction]] とする。
          1. ? GetFunctionRealm(_boundTargetFunction_) を返す。
        1. _obj_ が Proxy エキゾチックオブジェクトなら
          1. ? ValidateNonRevokedProxy(_obj_) を実行する。
          1. _proxyTarget_ を _obj_.[[ProxyTarget]] とする。
          1. アサート: _proxyTarget_ は関数オブジェクト。
          1. ? GetFunctionRealm(_proxyTarget_) を返す。
        1. [id="step-getfunctionrealm-default-return"] 現在の Realm Record を返す。
      </emu-alg>
      <emu-note>
        <p>ステップ <emu-xref href="#step-getfunctionrealm-default-return"></emu-xref> に到達するのは [[Realm]] 内部スロットを持たない非標準 function エキゾチックオブジェクトの場合のみ。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-copydataproperties" type="abstract operation">
      <h1>
        CopyDataProperties (
          _target_: Object,
          _source_: ECMAScript言語値,
          _excludedItems_: プロパティキーの List,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _source_ が *undefined* または *null* のいずれかなら ~unused~ を返す。
        1. _from_ を ! ToObject(_source_) とする。
        1. _keys_ を ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]</emu-meta>() とする。
        1. _keys_ の各要素 _nextKey_ について
          1. _excluded_ を *false* とする。
          1. _excludedItems_ の各要素 _e_ について
            1. SameValue(_e_, _nextKey_) が *true* なら
              1. _excluded_ を *true* に設定する。
          1. _excluded_ が *false* なら
            1. _desc_ を ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_) とする。
            1. _desc_ が *undefined* でなく _desc_.[[Enumerable]] が *true* なら
              1. _propValue_ を ? Get(_from_, _nextKey_) とする。
              1. ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
      <emu-note>
        <p>ここに渡される target は常に新規作成オブジェクトで、エラー時に直接アクセスされない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-privateelementfind" type="abstract operation">
      <h1>
        PrivateElementFind (
          _O_: Object,
          _P_: Private Name,
        ): PrivateElement または ~empty~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _O_.[[PrivateElements]] が PrivateElement _pe_ を含み _pe_.[[Key]] が _P_ であるなら
          1. _pe_ を返す。
        1. ~empty~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatefieldadd" type="abstract operation">
      <h1>
        PrivateFieldAdd (
          _O_: Object,
          _P_: Private Name,
          _value_: ECMAScript言語値,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ホストが Web ブラウザなら
          1. ? HostEnsureCanAddPrivateElement(_O_) を実行する。
        1. _entry_ を PrivateElementFind(_O_, _P_) とする。
        1. _entry_ が ~empty~ でないなら *TypeError* 例外を投げる。
        1. PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ } を _O_.[[PrivateElements]] に追加する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatemethodoraccessoradd" type="abstract operation">
      <h1>
        PrivateMethodOrAccessorAdd (
          _O_: Object,
          _method_: PrivateElement,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. アサート: _method_.[[Kind]] は ~method~ または ~accessor~ のいずれか。
        1. ホストが Web ブラウザなら
          1. ? HostEnsureCanAddPrivateElement(_O_) を実行する。
        1. _entry_ を PrivateElementFind(_O_, _method_.[[Key]]) とする。
        1. _entry_ が ~empty~ でないなら *TypeError* 例外を投げる。
        1. _method_ を _O_.[[PrivateElements]] に追加する。
        1. ~unused~ を返す。
      </emu-alg>
      <emu-note>
        <p>private メソッドとアクセサの値はインスタンス間で共有され、この操作は新しいコピーを作成しない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostensurecanaddprivateelement" type="host-defined abstract operation">
      <h1>
        HostEnsureCanAddPrivateElement (
          _O_: Object,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ホスト環境が特定のホスト定義エキゾチックオブジェクトへの private 要素追加を禁止できるようにする。</dd>
      </dl>
      <p>HostEnsureCanAddPrivateElement の実装は次の要件に従わなければならない:</p>
      <ul>
        <li>_O_ がホスト定義エキゾチックオブジェクトでなければ、この抽象操作は NormalCompletion(~unused~) を返し他の手順を行わない。</li>
        <li>同じ引数での任意の2回の呼び出しは同種の Completion Record を返す。</li>
      </ul>
      <p>既定実装は NormalCompletion(~unused~) を返す。</p>
      <p>この抽象操作は Web ブラウザの ECMAScript ホストのみが呼び出す。</p>
    </emu-clause>

    <emu-clause id="sec-privateget" type="abstract operation">
      <h1>
        PrivateGet (
          _O_: Object,
          _P_: Private Name,
        ): ECMAScript言語値を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _entry_ を PrivateElementFind(_O_, _P_) とする。
        1. _entry_ が ~empty~ なら *TypeError* 例外を投げる。
        1. _entry_.[[Kind]] が ~field~ または ~method~ のいずれかなら
          1. _entry_.[[Value]] を返す。
        1. アサート: _entry_.[[Kind]] は ~accessor~。
        1. _entry_.[[Get]] が *undefined* なら *TypeError* 例外を投げる。
        1. _getter_ を _entry_.[[Get]] とする。
        1. ? Call(_getter_, _O_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privateset" type="abstract operation">
      <h1>
        PrivateSet (
          _O_: Object,
          _P_: Private Name,
          _value_: ECMAScript言語値,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _entry_ を PrivateElementFind(_O_, _P_) とする。
        1. _entry_ が ~empty~ なら *TypeError* 例外を投げる。
        1. _entry_.[[Kind]] が ~field~ なら
          1. _entry_.[[Value]] を _value_ に設定する。
        1. それ以外で _entry_.[[Kind]] が ~method~ なら
          1. *TypeError* 例外を投げる。
        1. それ以外
          1. アサート: _entry_.[[Kind]] は ~accessor~。
          1. _entry_.[[Set]] が *undefined* なら *TypeError* 例外を投げる。
          1. _setter_ を _entry_.[[Set]] とする。
          1. ? Call(_setter_, _O_, « _value_ ») を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definefield" type="abstract operation">
      <h1>
        DefineField (
          _receiver_: Object,
          _fieldRecord_: ClassFieldDefinition Record,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _fieldName_ を _fieldRecord_.[[Name]] とする。
        1. _initializer_ を _fieldRecord_.[[Initializer]] とする。
        1. _initializer_ が ~empty~ でないなら
          1. _initValue_ を ? Call(_initializer_, _receiver_) とする。
        1. それ以外
          1. _initValue_ を *undefined* とする。
        1. _fieldName_ が Private Name なら
          1. ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_) を実行する。
        1. それ以外
          1. アサート: _fieldName_ はプロパティキー。
          1. ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializeinstanceelements" type="abstract operation">
      <h1>
        InitializeInstanceElements (
          _O_: Object,
          _constructor_: ECMAScript 関数オブジェクト,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _methods_ を _constructor_.[[PrivateMethods]] とする。
        1. _methods_ の各 PrivateElement _method_ について
          1. ? PrivateMethodOrAccessorAdd(_O_, _method_) を実行する。
        1. _fields_ を _constructor_.[[Fields]] とする。
        1. _fields_ の各要素 _fieldRecord_ について
          1. ? DefineField(_O_, _fieldRecord_) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-add-value-to-keyed-group" type="abstract operation">
      <h1>
        AddValueToKeyedGroup (
          _groups_: [[Key]] (ECMAScript言語値) と [[Elements]] (ECMAScript言語値の List) フィールドを持つ Record の List,
          _key_: ECMAScript言語値,
          _value_: ECMAScript言語値,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _groups_ の各 Record { [[Key]], [[Elements]] } _g_ について
          1. SameValue(_g_.[[Key]], _key_) が *true* なら
            1. アサート: _groups_ のうちこの条件を満たす要素は正確に1つ。
            1. _value_ を _g_.[[Elements]] に追加する。
            1. ~unused~ を返す。
        1. _group_ を Record { [[Key]]: _key_, [[Elements]]: « _value_ » } とする。
        1. _group_ を _groups_ に追加する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-groupby" type="abstract operation">
      <h1>
        GroupBy (
          _items_: ECMAScript言語値,
          _callback_: ECMAScript言語値,
          _keyCoercion_: ~property~ または ~collection~,
        ): [[Key]] と [[Elements]] フィールドを持つ Record の List を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ? RequireObjectCoercible(_items_) を実行する。
        1. IsCallable(_callback_) が *false* なら *TypeError* 例外を投げる。
        1. _groups_ を空の新 List とする。
        1. _iteratorRecord_ を ? GetIterator(_items_, ~sync~) とする。
        1. _k_ を 0 とする。
        1. 繰り返し
          1. _k_ ≥ 2<sup>53</sup> - 1 なら
            1. _error_ を ThrowCompletion(新規 *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iteratorRecord_, _error_) を返す。
          1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
          1. _next_ が ~done~ なら
            1. _groups_ を返す。
          1. _value_ を _next_ とする。
          1. _key_ を Completion(Call(_callback_, *undefined*, « _value_, 𝔽(_k_) »)) とする。
          1. IfAbruptCloseIterator(_key_, _iteratorRecord_)。
          1. _keyCoercion_ が ~property~ なら
            1. _key_ を Completion(ToPropertyKey(_key_)) とする。
            1. IfAbruptCloseIterator(_key_, _iteratorRecord_)。
          1. それ以外
            1. アサート: _keyCoercion_ は ~collection~。
            1. _key_ を CanonicalizeKeyedCollectionKey(_key_) に設定する。
          1. AddValueToKeyedGroup(_groups_, _key_, _value_) を実行する。
          1. _k_ を _k_ + 1 に設定する。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-SetterThatIgnoresPrototypeProperties" type="abstract operation">
      <h1>
        SetterThatIgnoresPrototypeProperties (
          _thisValue_: ECMAScript言語値,
          _home_: Object,
          _p_: プロパティキー,
          _v_: ECMAScript言語値,
        ): ~unused~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _thisValue_ が Object でないなら
          1. *TypeError* 例外を投げる。
        1. SameValue(_thisValue_, _home_) が *true* なら
          1. 注: ここで投げることは strict mode で _home_ オブジェクト上の非書き込み可能データプロパティへの代入をエミュレートする。
          1. *TypeError* 例外を投げる。
        1. _desc_ を ? _thisValue_.[[GetOwnProperty]](_p_) とする。
        1. _desc_ が *undefined* なら
          1. ? CreateDataPropertyOrThrow(_thisValue_, _p_, _v_) を実行する。
        1. それ以外
          1. ? Set(_thisValue_, _p_, _v_, *true*) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-iterator-objects">
    <h1>イテレータオブジェクトに対する操作</h1>
    <p>共通反復インターフェイス（<emu-xref href="#sec-iteration"></emu-xref>）を参照。</p>

    <emu-clause id="sec-iterator-records">
      <h1>Iterator Record</h1>
      <p><dfn variants="Iterator Records">Iterator Record</dfn> はイテレータまたは非同期イテレータとその `next` メソッドをカプセル化するための Record 値。</p>
      <p>Iterator Record は <emu-xref href="#table-iterator-record-fields"></emu-xref> に示すフィールドを持つ。</p>
      <emu-table id="table-iterator-record-fields" caption="Iterator Record フィールド">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Iterator]]
            </td>
            <td>
              Object
            </td>
            <td>
              イテレータまたは非同期イテレータインターフェイスに準拠するオブジェクト。
            </td>
          </tr>
          <tr>
            <td>
              [[NextMethod]]
            </td>
            <td>
              ECMAScript言語値
            </td>
            <td>
              [[Iterator]] オブジェクトの `next` メソッド。
            </td>
          </tr>
          <tr>
            <td>
              [[Done]]
            </td>
            <td>
              Boolean
            </td>
            <td>
              イテレータが完了またはクローズされたか。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-getiteratordirect" type="abstract operation">
      <h1>
        GetIteratorDirect (
          _obj_: Object,
        ): Iterator Record を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _nextMethod_ を ? Get(_obj_, *"next"*) とする。
        1. _iteratorRecord_ を Iterator Record { [[Iterator]]: _obj_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* } とする。
        1. _iteratorRecord_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorfrommethod" type="abstract operation">
      <h1>
        GetIteratorFromMethod (
          _obj_: ECMAScript言語値,
          _method_: 関数オブジェクト,
        ): Iterator Record を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _iterator_ を ? Call(_method_, _obj_) とする。
        1. _iterator_ が Object でないなら *TypeError* 例外を投げる。
        1. ? GetIteratorDirect(_iterator_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiterator" type="abstract operation">
      <h1>
        GetIterator (
          _obj_: ECMAScript言語値,
          _kind_: ~sync~ または ~async~,
        ): Iterator Record を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _kind_ が ~async~ なら
          1. _method_ を ? GetMethod(_obj_, %Symbol.asyncIterator%) とする。
          1. _method_ が *undefined* なら
            1. _syncMethod_ を ? GetMethod(_obj_, %Symbol.iterator%) とする。
            1. _syncMethod_ が *undefined* なら *TypeError* 例外を投げる。
            1. _syncIteratorRecord_ を ? GetIteratorFromMethod(_obj_, _syncMethod_) とする。
            1. CreateAsyncFromSyncIterator(_syncIteratorRecord_) を返す。
        1. それ以外
          1. _method_ を ? GetMethod(_obj_, %Symbol.iterator%) とする。
        1. _method_ が *undefined* なら *TypeError* 例外を投げる。
        1. ? GetIteratorFromMethod(_obj_, _method_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorflattenable" type="abstract operation">
      <h1>
        GetIteratorFlattenable (
          _obj_: ECMAScript言語値,
          _primitiveHandling_: ~iterate-string-primitives~ または ~reject-primitives~,
        ): Iterator Record を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _obj_ が Object でないなら
          1. _primitiveHandling_ が ~reject-primitives~ なら *TypeError* 例外を投げる。
          1. アサート: _primitiveHandling_ は ~iterate-string-primitives~。
          1. _obj_ が String でないなら *TypeError* 例外を投げる。
        1. _method_ を ? GetMethod(_obj_, %Symbol.iterator%) とする。
        1. _method_ が *undefined* なら
          1. _iterator_ を _obj_ とする。
        1. それ以外
          1. _iterator_ を ? Call(_method_, _obj_) とする。
        1. _iterator_ が Object でないなら *TypeError* 例外を投げる。
        1. ? GetIteratorDirect(_iterator_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratornext" type="abstract operation">
      <h1>
        IteratorNext (
        _iteratorRecord_: Iterator Record,
        省略可能 _value_: ECMAScript言語値,
        ): Object を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _value_ が存在しないなら
          1. _result_ を Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]])) とする。
        1. それ以外
          1. _result_ を Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »)) とする。
        1. _result_ が throw completion なら
          1. _iteratorRecord_.[[Done]] を *true* に設定する。
          1. ? _result_ を返す。
        1. _result_ を ! _result_ に設定する。
        1. _result_ が Object でないなら
          1. _iteratorRecord_.[[Done]] を *true* に設定する。
          1. *TypeError* 例外を投げる。
        1. _result_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorcomplete" type="abstract operation">
      <h1>
        IteratorComplete (
          _iteratorResult_: Object,
        ): Boolean を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ToBoolean(? Get(_iteratorResult_, *"done"*)) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorvalue" type="abstract operation">
      <h1>
        IteratorValue (
          _iteratorResult_: Object,
        ): ECMAScript言語値を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ? Get(_iteratorResult_, *"value"*) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstep" type="abstract operation">
      <h1>
        IteratorStep (
          _iteratorRecord_: Iterator Record,
        ): Object または ~done~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_iteratorRecord_.[[NextMethod]] を呼び次の値を要求し、イテレータが終端なら ~done~ を、そうでなければ次の値を含む IteratorResult オブジェクトを返す。</dd>
      </dl>
      <emu-alg>
        1. _result_ を ? IteratorNext(_iteratorRecord_) とする。
        1. _done_ を Completion(IteratorComplete(_result_)) とする。
        1. _done_ が throw completion なら
          1. _iteratorRecord_.[[Done]] を *true* に設定する。
          1. ? _done_ を返す。
        1. _done_ を ! _done_ に設定する。
        1. _done_ が *true* なら
          1. _iteratorRecord_.[[Done]] を *true* に設定する。
          1. ~done~ を返す。
        1. _result_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstepvalue" type="abstract operation">
      <h1>
        IteratorStepValue (
          _iteratorRecord_: Iterator Record,
        ): ECMAScript言語値 または ~done~ を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_iteratorRecord_.[[NextMethod]] を呼び次の値を要求し、イテレータ終端なら ~done~、値があれば IteratorResult からその値を返す。</dd>
      </dl>
      <emu-alg>
        1. _result_ を ? IteratorStep(_iteratorRecord_) とする。
        1. _result_ が ~done~ なら
          1. ~done~ を返す。
        1. _value_ を Completion(IteratorValue(_result_)) とする。
        1. _value_ が throw completion なら
          1. _iteratorRecord_.[[Done]] を *true* に設定する。
        1. ? _value_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorclose" type="abstract operation">
      <h1>
        IteratorClose (
          _iteratorRecord_: Iterator Record,
          _completion_: Completion Record,
        ): Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>イテレータが完了状態に達した際に通常行う処理を実行するよう通知する。</dd>
      </dl>
      <emu-alg>
        1. アサート: _iteratorRecord_.[[Iterator]] は Object。
        1. _iterator_ を _iteratorRecord_.[[Iterator]] とする。
        1. _innerResult_ を Completion(GetMethod(_iterator_, *"return"*)) とする。
        1. _innerResult_ が normal completion なら
          1. _return_ を _innerResult_.[[Value]] とする。
          1. _return_ が *undefined* なら ? _completion_ を返す。
          1. _innerResult_ を Completion(Call(_return_, _iterator_)) に設定する。
        1. _completion_ が throw completion なら ? _completion_ を返す。
        1. _innerResult_ が throw completion なら ? _innerResult_ を返す。
        1. _innerResult_.[[Value]] が Object でないなら *TypeError* 例外を投げる。
        1. ? _completion_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ifabruptcloseiterator" aoid="IfAbruptCloseIterator">
      <h1>IfAbruptCloseIterator ( _value_, _iteratorRecord_ )</h1>
      <p>IfAbruptCloseIterator は Iterator Record を用いるアルゴリズム手順列の省略記法。次の形式のステップ:</p>
      <emu-alg>
        1. IfAbruptCloseIterator(_value_, _iteratorRecord_)。
      </emu-alg>
      <p>は次と同じ意味を持つ:</p>
      <emu-alg>
        1. アサート: _value_ は Completion Record。
        1. _value_ が abrupt completion なら ? IteratorClose(_iteratorRecord_, _value_) を返す。
        1. それ以外なら _value_ を ! _value_ に設定する。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asynciteratorclose" type="abstract operation">
      <h1>
        AsyncIteratorClose (
          _iteratorRecord_: Iterator Record,
          _completion_: Completion Record,
        ): Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>非同期イテレータが完了状態に達した際に通常行う処理を実行するよう通知する。</dd>
      </dl>
      <emu-alg>
        1. アサート: _iteratorRecord_.[[Iterator]] は Object。
        1. _iterator_ を _iteratorRecord_.[[Iterator]] とする。
        1. _innerResult_ を Completion(GetMethod(_iterator_, *"return"*)) とする。
        1. _innerResult_ が normal completion なら
          1. _return_ を _innerResult_.[[Value]] とする。
          1. _return_ が *undefined* なら ? _completion_ を返す。
          1. _innerResult_ を Completion(Call(_return_, _iterator_)) に設定する。
          1. _innerResult_ が normal completion なら _innerResult_ を Completion(Await(_innerResult_.[[Value]])) に設定する。
        1. _completion_ が throw completion なら ? _completion_ を返す。
        1. _innerResult_ が throw completion なら ? _innerResult_ を返す。
        1. _innerResult_.[[Value]] が Object でないなら *TypeError* 例外を投げる。
        1. ? _completion_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createiterresultobject" type="abstract operation">
      <h1>
        CreateIteratorResultObject (
          _value_: ECMAScript言語値,
          _done_: Boolean,
        ): IteratorResult インターフェイスに準拠する Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>IteratorResult インターフェイスに準拠するオブジェクトを生成する。</dd>
      </dl>
      <emu-alg>
        1. _obj_ を OrdinaryObjectCreate(%Object.prototype%) とする。
        1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _value_) を実行する。
        1. ! CreateDataPropertyOrThrow(_obj_, *"done"*, _done_) を実行する。
        1. _obj_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createlistiteratorRecord" type="abstract operation" oldids="sec-createlistiterator,sec-listiteratornext-functions,sec-listiterator-next">
      <h1>
        CreateListIteratorRecord (
          _list_: ECMAScript言語値の List,
        ): Iterator Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_list_ の連続要素を返す [[NextMethod]] を持つ Iterator Record を生成する。</dd>
      </dl>
      <emu-alg>
        1. _closure_ をパラメータ無しで _list_ をキャプチャし呼び出し時に次を行う新しい Abstract Closure とする:
          1. _list_ の各要素 _E_ について
            1. ? GeneratorYield(CreateIteratorResultObject(_E_, *false*)) を実行する。
          1. NormalCompletion(*undefined*) を返す。
        1. _iterator_ を CreateIteratorFromClosure(_closure_, ~empty~, %Iterator.prototype%) とする。
        1. Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorPrototype.next%, [[Done]]: *false* } を返す。
      </emu-alg>
      <emu-note>
        <p>List イテレータオブジェクトは ECMAScript コードから直接アクセスできない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-iteratortolist" oldids="sec-iterabletolist" type="abstract operation">
      <h1>
        IteratorToList (
          _iteratorRecord_: Iterator Record,
        ): ECMAScript言語値の List を含む normal completion あるいは throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _values_ を空の新 List とする。
        1. 繰り返し
          1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
          1. _next_ が ~done~ なら
            1. _values_ を返す。
          1. _next_ を _values_ に追加する。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>構文指向操作 (Syntax-Directed Operations)</h1>
  <p>本節で定義されるものに加えて、特化した構文指向操作が本仕様全体で定義されている。</p>

  <emu-clause id="sec-evaluation" type="sdo">
    <h1>実行時意味論: Evaluation ( ): Completion Record</h1>
    <dl class="header">
      <dt>effects</dt>
      <dd>user-code</dd>
    </dl>
    <emu-note>
      この操作の定義は本仕様の「ECMAScript Language」各節に分散している。各定義は関連する生成規則 (production) が定義出現する直後に現れる。
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis">
    <h1>スコープ解析 (Scope Analysis)</h1>

    <emu-clause id="sec-static-semantics-boundnames" oldids="sec-identifiers-static-semantics-boundnames,sec-let-and-const-declarations-static-semantics-boundnames,sec-variable-statement-static-semantics-boundnames,sec-destructuring-binding-patterns-static-semantics-boundnames,sec-for-in-and-for-of-statements-static-semantics-boundnames,sec-function-definitions-static-semantics-boundnames,sec-arrow-function-definitions-static-semantics-boundnames,sec-generator-function-definitions-static-semantics-boundnames,sec-async-generator-function-definitions-static-semantics-boundnames,sec-class-definitions-static-semantics-boundnames,sec-async-function-definitions-static-semantics-BoundNames,sec-async-arrow-function-definitions-static-semantics-BoundNames,sec-imports-static-semantics-boundnames,sec-exports-static-semantics-boundnames" type="sdo">
      <h1>静的意味論: BoundNames ( ): 文字列の List</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* は、モジュールの default export に別名が存在しない場合に、そのモジュールの default export を表すための合成（synthetic）名として本仕様内で用いられる。この名前でモジュールの [[Environment]] にエントリが作成され対応する値を保持し、当該モジュールについて <emu-xref href="#sec-resolveexport" title></emu-xref> を呼び *"default"* という export を解決すると、[[BindingName]] が *"\*default\*"* の ResolvedBinding Record を返し、それがモジュールの [[Environment]] 内で前述の値へ解決される。これは仕様記述の簡便さのみを目的としており、無名の default export を他の export と同様に解決できるようにするためである。この *"\*default\*"* 文字列が ECMAScript コードやモジュールリンクアルゴリズムからアクセスされることは決してない。</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. |Identifier| の StringValue を唯一の要素とする List を返す。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. « *"yield"* » を返す。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. « *"await"* » を返す。
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. |BindingList| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. _names1_ を |BindingList| の BoundNames とする。
        1. _names2_ を |LexicalBinding| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. |BindingPattern| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. _names1_ を |VariableDeclarationList| の BoundNames とする。
        1. _names2_ を |VariableDeclaration| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. |BindingPattern| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _names1_ を |BindingPropertyList| の BoundNames とする。
        1. _names2_ を |BindingRestProperty| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingRestElement| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. _names1_ を |BindingElementList| の BoundNames とする。
        1. _names2_ を |BindingRestElement| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. _names1_ を |BindingPropertyList| の BoundNames とする。
        1. _names2_ を |BindingProperty| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. _names1_ を |BindingElementList| の BoundNames とする。
        1. _names2_ を |BindingElisionElement| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingPattern| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. |ForBinding| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. _names1_ を |FormalParameterList| の BoundNames とする。
        1. _names2_ を |FunctionRestParameter| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. _names1_ を |FormalParameterList| の BoundNames とする。
        1. _names2_ を |FormalParameter| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ を |CoverParenthesizedExpressionAndArrowParameterList| が被覆する |ArrowFormalParameters| とする。
        1. _formals_ の BoundNames を返す。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » を返す。
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » を返す。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » を返す。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |BindingIdentifier| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » を返す。
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. _head_ を |CoverCallExpressionAndAsyncArrowHead| が被覆する |AsyncArrowHead| とする。
        1. _head_ の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
      <emu-alg>
        1. |ImportClause| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. _names1_ を |ImportedDefaultBinding| の BoundNames とする。
        1. _names2_ を |NameSpaceImport| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. _names1_ を |ImportedDefaultBinding| の BoundNames とする。
        1. _names2_ を |NamedImports| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. _names1_ を |ImportsList| の BoundNames とする。
        1. _names2_ を |ImportSpecifier| の BoundNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. |ImportedBinding| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. |VariableStatement| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. _declarationNames_ を |HoistableDeclaration| の BoundNames とする。
        1. _declarationNames_ に *"\*default\*"* が含まれないなら *"\*default\*"* を _declarationNames_ に追加する。
        1. _declarationNames_ を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. _declarationNames_ を |ClassDeclaration| の BoundNames とする。
        1. _declarationNames_ に *"\*default\*"* が含まれないなら *"\*default\*"* を _declarationNames_ に追加する。
        1. _declarationNames_ を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-declarationpart" type="sdo">
      <h1>静的意味論: DeclarationPart ( ): Parse Node</h1>
      <dl class="header">
      </dl>
      <emu-grammar>HoistableDeclaration : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| を返す。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : GeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. |GeneratorDeclaration| を返す。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncFunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |AsyncFunctionDeclaration| を返す。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncGeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. |AsyncGeneratorDeclaration| を返す。
      </emu-alg>
      <emu-grammar>Declaration : ClassDeclaration</emu-grammar>
      <emu-alg>
        1. |ClassDeclaration| を返す。
      </emu-alg>
      <emu-grammar>Declaration : LexicalDeclaration</emu-grammar>
      <emu-alg>
        1. |LexicalDeclaration| を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" oldids="sec-let-and-const-declarations-static-semantics-isconstantdeclaration,sec-function-definitions-static-semantics-isconstantdeclaration,sec-generator-function-definitions-static-semantics-isconstantdeclaration,sec-async-generator-function-definitions-static-semantics-isconstantdeclaration,sec-class-definitions-static-semantics-isconstantdeclaration,sec-async-function-definitions-static-semantics-IsConstantDeclaration,sec-exports-static-semantics-isconstantdeclaration" type="sdo">
      <h1>静的意味論: IsConstantDeclaration ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. |LetOrConst| の IsConstantDeclaration を返す。
      </emu-alg>
      <emu-grammar>LetOrConst : `let`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>LetOrConst : `const`</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-note>
        <p>`export default` |AssignmentExpression| を定数宣言として扱う必要はない。モジュールの default オブジェクトを参照する内部束縛名に代入できる構文は存在しないためである。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallydeclarednames" oldids="sec-block-static-semantics-lexicallydeclarednames,sec-switch-statement-static-semantics-lexicallydeclarednames,sec-labelled-statements-static-semantics-lexicallydeclarednames,sec-function-definitions-static-semantics-lexicallydeclarednames,sec-arrow-function-definitions-static-semantics-lexicallydeclarednames,sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames,sec-scripts-static-semantics-lexicallydeclarednames,sec-module-semantics-static-semantics-lexicallydeclarednames" type="sdo">
      <h1>静的意味論: LexicallyDeclaredNames ( ): 文字列の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_ を |StatementList| の LexicallyDeclaredNames とする。
        1. _names2_ を |StatementListItem| の LexicallyDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement| が <emu-grammar>Statement : LabelledStatement</emu-grammar> であれば、|LabelledStatement| の LexicallyDeclaredNames を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 最初の |CaseClauses| が存在するなら _names1_ をその LexicallyDeclaredNames、存在しないなら新しい空の List とする。
        1. _names2_ を |DefaultClause| の LexicallyDeclaredNames とする。
        1. 2番目の |CaseClauses| が存在するなら _names3_ をその LexicallyDeclaredNames、存在しないなら新しい空の List とする。
        1. _names1_, _names2_, _names3_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _names1_ を |CaseClauses| の LexicallyDeclaredNames とする。
        1. _names2_ を |CaseClause| の LexicallyDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその LexicallyDeclaredNames を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその LexicallyDeclaredNames を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem| の LexicallyDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelLexicallyDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelLexicallyDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelLexicallyDeclaredNames を返す。
      </emu-alg>
      <emu-note>
        <p>|Script| の最上位では function 宣言は lexical 宣言ではなく var 宣言として扱われる。</p>
      </emu-note>
      <emu-note>
        <p>|Module| の LexicallyDeclaredNames にはその全ての import された束縛の名前が含まれる。</p>
      </emu-note>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _names1_ を |ModuleItemList| の LexicallyDeclaredNames とする。
        1. _names2_ を |ModuleItem| の LexicallyDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. |ImportDeclaration| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration| が `export` |VariableStatement| であれば新しい空の List を返す。
        1. |ExportDeclaration| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
      <emu-alg>
        1. |StatementListItem| の LexicallyDeclaredNames を返す。
      </emu-alg>
      <emu-note>
        <p>|Module| の最上位では function 宣言は var 宣言ではなく lexical 宣言として扱われる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallyscopeddeclarations" oldids="sec-block-static-semantics-lexicallyscopeddeclarations,sec-switch-statement-static-semantics-lexicallyscopeddeclarations,sec-labelled-statements-static-semantics-lexicallyscopeddeclarations,sec-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations,sec-scripts-static-semantics-lexicallyscopeddeclarations,sec-module-semantics-static-semantics-lexicallyscopeddeclarations,sec-exports-static-semantics-lexicallyscopeddeclarations" type="sdo">
      <h1>静的意味論: LexicallyScopedDeclarations ( ): Parse Node の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |StatementList| の LexicallyScopedDeclarations とする。
        1. _declarations2_ を |StatementListItem| の LexicallyScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement| が <emu-grammar>Statement : LabelledStatement</emu-grammar> なら |LabelledStatement| の LexicallyScopedDeclarations を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration| の DeclarationPart を唯一の要素とする List を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 最初の |CaseClauses| が存在するなら _declarations1_ をその LexicallyScopedDeclarations、存在しないなら新しい空の List とする。
        1. _declarations2_ を |DefaultClause| の LexicallyScopedDeclarations とする。
        1. 2番目の |CaseClauses| が存在するなら _declarations3_ をその LexicallyScopedDeclarations、存在しないなら新しい空の List とする。
        1. _declarations1_, _declarations2_, _declarations3_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |CaseClauses| の LexicallyScopedDeclarations とする。
        1. _declarations2_ を |CaseClause| の LexicallyScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその LexicallyScopedDeclarations を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその LexicallyScopedDeclarations を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem| の LexicallyScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. « |FunctionDeclaration| » を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelLexicallyScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelLexicallyScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelLexicallyScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |ModuleItemList| の LexicallyScopedDeclarations とする。
        1. _declarations2_ を |ModuleItem| の LexicallyScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. DeclarationPart が |Declaration| である要素のみを持つ List を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. DeclarationPart が |HoistableDeclaration| である唯一の要素を持つ List を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. 唯一の要素が |ClassDeclaration| である List を返す。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. 唯一の要素がこの |ExportDeclaration| である List を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-vardeclarednames" oldids="sec-statement-semantics-static-semantics-vardeclarednames,sec-block-static-semantics-vardeclarednames,sec-variable-statement-static-semantics-vardeclarednames,sec-if-statement-static-semantics-vardeclarednames,sec-do-while-statement-static-semantics-vardeclarednames,sec-while-statement-static-semantics-vardeclarednames,sec-for-statement-static-semantics-vardeclarednames,sec-for-in-and-for-of-statements-static-semantics-vardeclarednames,sec-with-statement-static-semantics-vardeclarednames,sec-switch-statement-static-semantics-vardeclarednames,sec-labelled-statements-static-semantics-vardeclarednames,sec-try-statement-static-semantics-vardeclarednames,sec-function-definitions-static-semantics-vardeclarednames,sec-arrow-function-definitions-static-semantics-vardeclarednames,sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames,sec-scripts-static-semantics-vardeclarednames,sec-module-semantics-static-semantics-vardeclarednames" type="sdo">
      <h1>静的意味論: VarDeclaredNames ( ): 文字列の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_ を |StatementList| の VarDeclaredNames とする。
        1. _names2_ を |StatementListItem| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
      <emu-alg>
        1. |VariableDeclarationList| の BoundNames を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _names1_ を最初の |Statement| の VarDeclaredNames とする。
        1. _names2_ を2番目の |Statement| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. _names1_ を |VariableDeclarationList| の BoundNames とする。
        1. _names2_ を |Statement| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. _names1_ を « |ForBinding| » とする。
        1. _names2_ を |Statement| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-note>
        <p>本節は付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 最初の |CaseClauses| が存在するなら _names1_ をその VarDeclaredNames、存在しないなら新しい空の List とする。
        1. _names2_ を |DefaultClause| の VarDeclaredNames とする。
        1. 2番目の |CaseClauses| が存在するなら _names3_ をその VarDeclaredNames、存在しないなら新しい空の List とする。
        1. _names1_, _names2_, _names3_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _names1_ を |CaseClauses| の VarDeclaredNames とする。
        1. _names2_ を |CaseClause| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその VarDeclaredNames を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその VarDeclaredNames を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _names1_ を |Block| の VarDeclaredNames とする。
        1. _names2_ を |Catch| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _names1_ を |Block| の VarDeclaredNames とする。
        1. _names2_ を |Finally| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _names1_ を |Block| の VarDeclaredNames とする。
        1. _names2_ を |Catch| の VarDeclaredNames とする。
        1. _names3_ を |Finally| の VarDeclaredNames とする。
        1. _names1_, _names2_, _names3_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelVarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelVarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelVarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _names1_ を |ModuleItemList| の VarDeclaredNames とする。
        1. _names2_ を |ModuleItem| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration| が `export` |VariableStatement| であれば |ExportDeclaration| の BoundNames を返す。
        1. 新しい空の List を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-varscopeddeclarations" oldids="sec-statement-semantics-static-semantics-varscopeddeclarations,sec-block-static-semantics-varscopeddeclarations,sec-variable-statement-static-semantics-varscopeddeclarations,sec-if-statement-static-semantics-varscopeddeclarations,sec-do-while-statement-static-semantics-varscopeddeclarations,sec-while-statement-static-semantics-varscopeddeclarations,sec-for-statement-static-semantics-varscopeddeclarations,sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations,sec-with-statement-static-semantics-varscopeddeclarations,sec-switch-statement-static-semantics-varscopeddeclarations,sec-labelled-statements-static-semantics-varscopeddeclarations,sec-try-statement-static-semantics-varscopeddeclarations,sec-function-definitions-static-semantics-varscopeddeclarations,sec-arrow-function-definitions-static-semantics-varscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations,sec-scripts-static-semantics-varscopeddeclarations,sec-module-semantics-static-semantics-varscopeddeclarations" type="sdo">
      <h1>静的意味論: VarScopedDeclarations ( ): Parse Node の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |StatementList| の VarScopedDeclarations とする。
        1. _declarations2_ を |StatementListItem| の VarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclaration</emu-grammar>
      <emu-alg>
        1. « |VariableDeclaration| » を返す。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |VariableDeclarationList| の VarScopedDeclarations とする。
        1. _declarations1_ と « |VariableDeclaration| » のリスト結合を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_ を最初の |Statement| の VarScopedDeclarations とする。
        1. _declarations2_ を2番目の |Statement| の VarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |VariableDeclarationList| の VarScopedDeclarations とする。
        1. _declarations2_ を |Statement| の VarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. _declarations1_ を « |ForBinding| » とする。
        1. _declarations2_ を |Statement| の VarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-note>
        <p>本節は付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 最初の |CaseClauses| が存在するなら _declarations1_ をその VarScopedDeclarations、存在しないなら新しい空の List とする。
        1. _declarations2_ を |DefaultClause| の VarScopedDeclarations とする。
        1. 2番目の |CaseClauses| が存在するなら _declarations3_ をその VarScopedDeclarations、存在しないなら新しい空の List とする。
        1. _declarations1_, _declarations2_, _declarations3_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |CaseClauses| の VarScopedDeclarations とする。
        1. _declarations2_ を |CaseClause| の VarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその VarScopedDeclarations を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するならその VarScopedDeclarations を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement| が <emu-grammar>Statement : LabelledStatement</emu-grammar> なら |Statement| の VarScopedDeclarations を返す。
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. « |FunctionDeclaration| » を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelVarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelVarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の TopLevelVarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |ModuleItemList| の VarScopedDeclarations とする。
        1. _declarations2_ を |ModuleItem| の VarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration| が `export` |VariableStatement| であれば |VariableStatement| の VarScopedDeclarations を返す。
        1. 新しい空の List を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallydeclarednames" oldids="sec-block-static-semantics-toplevellexicallydeclarednames,sec-labelled-statements-static-semantics-toplevellexicallydeclarednames" type="sdo">
      <h1>静的意味論: TopLevelLexicallyDeclaredNames ( ): 文字列の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_ を |StatementList| の TopLevelLexicallyDeclaredNames とする。
        1. _names2_ を |StatementListItem| の TopLevelLexicallyDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration| が <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> であれば
          1. 新しい空の List を返す。
        1. |Declaration| の BoundNames を返す。
      </emu-alg>
      <emu-note>
        <p>関数またはスクリプトの最上位では function 宣言は lexical 宣言ではなく var 宣言として扱われる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallyscopeddeclarations" oldids="sec-block-static-semantics-toplevellexicallyscopeddeclarations,sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations" type="sdo">
      <h1>静的意味論: TopLevelLexicallyScopedDeclarations ( ): Parse Node の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |StatementList| の TopLevelLexicallyScopedDeclarations とする。
        1. _declarations2_ を |StatementListItem| の TopLevelLexicallyScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration| が <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> であれば
          1. 新しい空の List を返す。
        1. « |Declaration| » を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvardeclarednames" oldids="sec-block-static-semantics-toplevelvardeclarednames,sec-labelled-statements-static-semantics-toplevelvardeclarednames" type="sdo">
      <h1>静的意味論: TopLevelVarDeclaredNames ( ): 文字列の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_ を |StatementList| の TopLevelVarDeclaredNames とする。
        1. _names2_ を |StatementListItem| の TopLevelVarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration| が <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> であれば
          1. |HoistableDeclaration| の BoundNames を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement| が <emu-grammar>Statement : LabelledStatement</emu-grammar> なら |Statement| の TopLevelVarDeclaredNames を返す。
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-note>
        <p>関数またはスクリプトの最上位では内部の function 宣言は var 宣言として扱われる。</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem| の TopLevelVarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement| が <emu-grammar>Statement : LabelledStatement</emu-grammar> なら |Statement| の TopLevelVarDeclaredNames を返す。
        1. |Statement| の VarDeclaredNames を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| の BoundNames を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvarscopeddeclarations" oldids="sec-block-static-semantics-toplevelvarscopeddeclarations,sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations" type="sdo">
      <h1>静的意味論: TopLevelVarScopedDeclarations ( ): Parse Node の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_ を |StatementList| の TopLevelVarScopedDeclarations とする。
        1. _declarations2_ を |StatementListItem| の TopLevelVarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement| が <emu-grammar>Statement : LabelledStatement</emu-grammar> なら |Statement| の TopLevelVarScopedDeclarations を返す。
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration| が <emu-grammar>Declaration : HoistableDeclaration</emu-grammar> であれば
          1. _declaration_ を |HoistableDeclaration| の DeclarationPart とする。
          1. « _declaration_ » を返す。
        1. 新しい空の List を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem| の TopLevelVarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement| が <emu-grammar>Statement : LabelledStatement</emu-grammar> なら |Statement| の TopLevelVarScopedDeclarations を返す。
        1. |Statement| の VarScopedDeclarations を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. « |FunctionDeclaration| » を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-labels">
    <h1>ラベル (Labels)</h1>

    <emu-clause id="sec-static-semantics-containsduplicatelabels" oldids="sec-statement-semantics-static-semantics-containsduplicatelabels,sec-block-static-semantics-containsduplicatelabels,sec-if-statement-static-semantics-containsduplicatelabels,sec-do-while-statement-static-semantics-containsduplicatelabels,sec-while-statement-static-semantics-containsduplicatelabels,sec-for-statement-static-semantics-containsduplicatelabels,sec-for-in-and-for-of-statements-static-semantics-containsduplicatelabels,sec-with-statement-static-semantics-containsduplicatelabels,sec-switch-statement-static-semantics-containsduplicatelabels,sec-labelled-statements-static-semantics-containsduplicatelabels,sec-try-statement-static-semantics-containsduplicatelabels,sec-function-definitions-static-semantics-containsduplicatelabels,sec-module-semantics-static-semantics-containsduplicatelabels" type="sdo">
      <h1>
        静的意味論: ContainsDuplicateLabels (
        _labelSet_: 文字列の List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_ を |StatementList| の ContainsDuplicateLabels (引数 _labelSet_) とする。
        1. _hasDuplicates_ が *true* なら *true* を返す。
        1. |StatementListItem| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasDuplicate_ を 最初の |Statement| の ContainsDuplicateLabels (引数 _labelSet_) とする。
        1. _hasDuplicate_ が *true* なら *true* を返す。
        1. 2番目の |Statement| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-note>
        <p>本節は付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 最初の |CaseClauses| が存在するなら
          1. 最初の |CaseClauses| の ContainsDuplicateLabels (引数 _labelSet_) が *true* なら *true* を返す。
        1. |DefaultClause| の ContainsDuplicateLabels (引数 _labelSet_) が *true* なら *true* を返す。
        1. 2番目の |CaseClauses| が存在しないなら *false* を返す。
        1. 2番目の |CaseClauses| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_ を |CaseClauses| の ContainsDuplicateLabels (引数 _labelSet_) とする。
        1. _hasDuplicates_ が *true* なら *true* を返す。
        1. |CaseClause| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するなら |StatementList| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するなら |StatementList| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_ を |LabelIdentifier| の StringValue とする。
        1. _labelSet_ が _label_ を含むなら *true* を返す。
        1. _newLabelSet_ を _labelSet_ と « _label_ » のリスト結合とする。
        1. |LabelledItem| の ContainsDuplicateLabels (引数 _newLabelSet_) を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_ を |Block| の ContainsDuplicateLabels (引数 _labelSet_) とする。
        1. _hasDuplicates_ が *true* なら *true* を返す。
        1. |Catch| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_ を |Block| の ContainsDuplicateLabels (引数 _labelSet_) とする。
        1. _hasDuplicates_ が *true* なら *true* を返す。
        1. |Finally| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block| の ContainsDuplicateLabels (引数 _labelSet_) が *true* なら *true* を返す。
        1. |Catch| の ContainsDuplicateLabels (引数 _labelSet_) が *true* なら *true* を返す。
        1. |Finally| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_ を |ModuleItemList| の ContainsDuplicateLabels (引数 _labelSet_) とする。
        1. _hasDuplicates_ が *true* なら *true* を返す。
        1. |ModuleItem| の ContainsDuplicateLabels (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedbreaktarget" oldids="sec-statement-semantics-static-semantics-containsundefinedbreaktarget,sec-block-static-semantics-containsundefinedbreaktarget,sec-if-statement-static-semantics-containsundefinedbreaktarget,sec-do-while-statement-static-semantics-containsundefinedbreaktarget,sec-while-statement-static-semantics-containsundefinedbreaktarget,sec-for-statement-static-semantics-containsundefinedbreaktarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedbreaktarget,sec-break-statement-static-semantics-containsundefinedbreaktarget,sec-with-statement-static-semantics-containsundefinedbreaktarget,sec-switch-statement-static-semantics-containsundefinedbreaktarget,sec-labelled-statements-static-semantics-containsundefinedbreaktarget,sec-try-statement-static-semantics-containsundefinedbreaktarget,sec-function-definitions-static-semantics-containsundefinedbreaktarget,sec-module-semantics-static-semantics-containsundefinedbreaktarget" type="sdo">
      <h1>
        静的意味論: ContainsUndefinedBreakTarget (
        _labelSet_: 文字列の List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |StatementList| の ContainsUndefinedBreakTarget (引数 _labelSet_) とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |StatementListItem| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を 最初の |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. 2番目の |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-note>
        <p>本節は付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
      </emu-note>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _labelSet_ が |LabelIdentifier| の StringValue を含まないなら *true* を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 最初の |CaseClauses| が存在するなら
          1. 最初の |CaseClauses| の ContainsUndefinedBreakTarget (引数 _labelSet_) が *true* なら *true* を返す。
        1. |DefaultClause| の ContainsUndefinedBreakTarget (引数 _labelSet_) が *true* なら *true* を返す。
        1. 2番目の |CaseClauses| が存在しないなら *false* を返す。
        1. 2番目の |CaseClauses| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |CaseClauses| の ContainsUndefinedBreakTarget (引数 _labelSet_) とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |CaseClause| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するなら |StatementList| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するなら |StatementList| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_ を |LabelIdentifier| の StringValue とする。
        1. _newLabelSet_ を _labelSet_ と « _label_ » のリスト結合とする。
        1. |LabelledItem| の ContainsUndefinedBreakTarget (引数 _newLabelSet_) を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |Block| の ContainsUndefinedBreakTarget (引数 _labelSet_) とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |Catch| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |Block| の ContainsUndefinedBreakTarget (引数 _labelSet_) とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |Finally| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block| の ContainsUndefinedBreakTarget (引数 _labelSet_) が *true* なら *true* を返す。
        1. |Catch| の ContainsUndefinedBreakTarget (引数 _labelSet_) が *true* なら *true* を返す。
        1. |Finally| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |ModuleItemList| の ContainsUndefinedBreakTarget (引数 _labelSet_) とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |ModuleItem| の ContainsUndefinedBreakTarget (引数 _labelSet_) を返す。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedcontinuetarget" oldids="sec-statement-semantics-static-semantics-containsundefinedcontinuetarget,sec-block-static-semantics-containsundefinedcontinuetarget,sec-if-statement-static-semantics-containsundefinedcontinuetarget,sec-do-while-statement-static-semantics-containsundefinedcontinuetarget,sec-while-statement-static-semantics-containsundefinedcontinuetarget,sec-for-statement-static-semantics-containsundefinedcontinuetarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedcontinuetarget,sec-continue-statement-static-semantics-containsundefinedcontinuetarget,sec-with-statement-static-semantics-containsundefinedcontinuetarget,sec-switch-statement-static-semantics-containsundefinedcontinuetarget,sec-labelled-statements-static-semantics-containsundefinedcontinuetarget,sec-try-statement-static-semantics-containsundefinedcontinuetarget,sec-function-definitions-static-semantics-containsundefinedcontinuetarget,sec-module-semantics-static-semantics-containsundefinedcontinuetarget" type="sdo">
      <h1>
        静的意味論: ContainsUndefinedContinueTarget (
        _iterationSet_: 文字列の List,
        _labelSet_: 文字列の List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>Statement : BlockStatement</emu-grammar>
      <emu-alg>
        1. |BlockStatement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. _newIterationSet_ を _iterationSet_ と _labelSet_ のリスト結合とする。
        1. |IterationStatement| の ContainsUndefinedContinueTarget (引数 _newIterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |StatementList| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |StatementListItem| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を 最初の |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. 2番目の |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-note>
        <p>本節は付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
      </emu-note>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _iterationSet_ が |LabelIdentifier| の StringValue を含まないなら *true* を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 最初の |CaseClauses| が存在するなら
          1. 最初の |CaseClauses| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») が *true* なら *true* を返す。
        1. |DefaultClause| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») が *true* なら *true* を返す。
        1. 2番目の |CaseClauses| が存在しないなら *false* を返す。
        1. 2番目の |CaseClauses| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |CaseClauses| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |CaseClause| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するなら |StatementList| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList| が存在するなら |StatementList| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_ を |LabelIdentifier| の StringValue とする。
        1. _newLabelSet_ を _labelSet_ と « _label_ » のリスト結合とする。
        1. |LabelledItem| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と _newLabelSet_) を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |Block| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |Catch| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |Block| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |Finally| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») が *true* なら *true* を返す。
        1. |Catch| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») が *true* なら *true* を返す。
        1. |Finally| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_ を |ModuleItemList| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») とする。
        1. _hasUndefinedLabels_ が *true* なら *true* を返す。
        1. |ModuleItem| の ContainsUndefinedContinueTarget (引数 _iterationSet_ と « ») を返す。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-function-name-inference">
    <h1>関数名の推論 (Function Name Inference)</h1>

    <emu-clause id="sec-static-semantics-hasname" oldids="sec-semantics-static-semantics-hasname,sec-function-definitions-static-semantics-hasname,sec-arrow-function-definitions-static-semantics-hasname,sec-generator-function-definitions-static-semantics-hasname,sec-async-generator-function-definitions-static-semantics-hasname,sec-class-definitions-static-semantics-hasname,sec-async-function-definitions-static-semantics-HasName,sec-async-arrow-function-definitions-static-semantics-HasName" type="sdo">
      <h1>静的意味論: HasName ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_ を |CoverParenthesizedExpressionAndArrowParameterList| によって被覆される |ParenthesizedExpression| とする。<br>
        1. IsFunctionDefinition of _expr_ が *false* なら *false* を返す。<br>
        1. _expr_ の HasName を返す。
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ArrowFunction :
          ArrowParameters `=>` ConciseBody

        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody

        ClassExpression :
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier ClassTail
      </emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isfunctiondefinition" oldids="sec-semantics-static-semantics-isfunctiondefinition,sec-grouping-operator-static-semantics-isfunctiondefinition,sec-static-semantics-static-semantics-isfunctiondefinition,sec-update-expressions-static-semantics-isfunctiondefinition,sec-unary-operators-static-semantics-isfunctiondefinition,sec-exp-operator-static-semantics-isfunctiondefinition,sec-multiplicative-operators-static-semantics-isfunctiondefinition,sec-additive-operators-static-semantics-isfunctiondefinition,sec-bitwise-shift-operators-static-semantics-isfunctiondefinition,sec-relational-operators-static-semantics-isfunctiondefinition,sec-equality-operators-static-semantics-isfunctiondefinition,sec-binary-bitwise-operators-static-semantics-isfunctiondefinition,sec-binary-logical-operators-static-semantics-isfunctiondefinition,sec-conditional-operator-static-semantics-isfunctiondefinition,sec-assignment-operators-static-semantics-isfunctiondefinition,sec-comma-operator-static-semantics-isfunctiondefinition,sec-function-definitions-static-semantics-isfunctiondefinition,sec-generator-function-definitions-static-semantics-isfunctiondefinition,sec-async-generator-function-definitions-static-semantics-isfunctiondefinition,sec-class-definitions-static-semantics-isfunctiondefinition,sec-async-function-definitions-static-semantics-IsFunctionDefinition" type="sdo">
      <h1>静的意味論: IsFunctionDefinition ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_ を |CoverParenthesizedExpressionAndArrowParameterList| によって被覆される |ParenthesizedExpression| とする。<br>
        1. _expr_ の IsFunctionDefinition を返す。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          RegularExpressionLiteral
          TemplateLiteral

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        AssignmentExpression :
          ArrowFunction
          AsyncArrowFunction

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier? ClassTail
      </emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isanonymousfunctiondefinition" type="abstract operation">
      <h1>
        静的意味論: IsAnonymousFunctionDefinition (
        _expr_: |AssignmentExpression| 生成句ノード, |Initializer| 生成句ノード, または |Expression| 生成句ノード,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>引数が名前を束縛しない関数定義かどうかを判定する。</dd>
      </dl>
      <emu-alg>
        1. IsFunctionDefinition of _expr_ が *false* なら *false* を返す。<br>
        1. _hasName_ を HasName of _expr_ とする。<br>
        1. _hasName_ が *true* なら *false* を返す。<br>
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isidentifierref" oldids="sec-semantics-static-semantics-isidentifierref,sec-static-semantics-static-semantics-isidentifierref" type="sdo">
      <h1>静的意味論: IsIdentifierRef ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
          CoverParenthesizedExpressionAndArrowParameterList

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-namedevaluation" oldids="sec-grouping-operator-runtime-semantics-namedevaluation,sec-function-definitions-runtime-semantics-namedevaluation,sec-arrow-function-definitions-runtime-semantics-namedevaluation,sec-generator-function-definitions-runtime-semantics-namedevaluation,sec-asyncgenerator-definitions-namedevaluation,sec-class-definitions-runtime-semantics-namedevaluation,sec-async-function-definitions-runtime-semantics-namedevaluation,sec-async-arrow-function-definitions-runtime-semantics-namedevaluation" type="sdo">
      <h1>
        実行時意味論: NamedEvaluation (
        _name_: プロパティキーまたは Private Name,
        ): 関数オブジェクトを含む正常完了または異常完了
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_ を |CoverParenthesizedExpressionAndArrowParameterList| によって被覆される |ParenthesizedExpression| とする。<br>
        1. 引数 _name_ で _expr_ の NamedEvaluation を ? 付きで返す。
      </emu-alg>
      <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
      <emu-alg>
        1. アサート: IsAnonymousFunctionDefinition(|Expression|) は *true*。<br>
        1. 引数 _name_ で |Expression| の NamedEvaluation を ? 付きで返す。
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 引数 _name_ で |FunctionExpression| の InstantiateOrdinaryFunctionExpression を返す。
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 引数 _name_ で |GeneratorExpression| の InstantiateGeneratorFunctionExpression を返す。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _name_ で |AsyncGeneratorExpression| の InstantiateAsyncGeneratorFunctionExpression を返す。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _name_ で |AsyncFunctionExpression| の InstantiateAsyncFunctionExpression を返す。
      </emu-alg>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. 引数 _name_ で |ArrowFunction| の InstantiateArrowFunctionExpression を返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 引数 _name_ で |AsyncArrowFunction| の InstantiateAsyncArrowFunctionExpression を返す。
      </emu-alg>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. _sourceText_ を |ClassExpression| によりマッチしたソーステキストとする。<br>
        1. 引数 *undefined*, _name_, _sourceText_ で |ClassTail| の ClassDefinitionEvaluation を ? 付きで返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        静的意味論: Contains (
        _symbol_: 文法記号,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>以下に列挙されていない本仕様中のすべての文法生成規則の代替は、暗黙的に次の既定の Contains 定義を持つ:</p>
      <emu-alg>
        1. この生成句ノードの各子ノード _child_ について:
          1. _child_ が _symbol_ のインスタンスであるなら *true* を返す。
          1. _child_ が非終端記号のインスタンスなら
            1. _contained_ を _child_ Contains _symbol_ の結果とする。
            1. _contained_ が *true* なら *true* を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-note>
        <p>部分構造に依存する静的意味規則は一般に関数定義内部を調べない。</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <emu-alg>
        1. _symbol_ が |ClassBody| なら *true* を返す。<br>
        1. _symbol_ が |ClassHeritage| なら
          1. |ClassHeritage| が存在するなら *true*、そうでなければ *false* を返す。
        1. |ClassHeritage| が存在するなら
          1. |ClassHeritage| Contains _symbol_ が *true* なら *true* を返す。
        1. 引数 _symbol_ で |ClassBody| の ComputedPropertyContains の結果を返す。
      </emu-alg>
      <emu-note>
        <p>部分構造に依存する静的意味規則は一般にクラス本体内部（|PropertyName| 以外）を調べない。</p>
      </emu-note>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-note>
        <p>部分構造に依存する静的意味規則は一般に `static` 初期化ブロック内部を調べない。</p>
      </emu-note>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _symbol_ が |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` のいずれでもないなら *false* を返す。<br>
        1. |ArrowParameters| Contains _symbol_ が *true* なら *true* を返す。<br>
        1. |ConciseBody| Contains _symbol_ を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ を |CoverParenthesizedExpressionAndArrowParameterList| により被覆される |ArrowFormalParameters| とする。<br>
        1. _formals_ Contains _symbol_ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _symbol_ が |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` のいずれでもないなら *false* を返す。<br>
        1. |AsyncConciseBody| Contains _symbol_ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _symbol_ が |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` のいずれでもないなら *false* を返す。<br>
        1. _head_ を |CoverCallExpressionAndAsyncArrowHead| により被覆される |AsyncArrowHead| とする。<br>
        1. _head_ Contains _symbol_ が *true* なら *true* を返す。<br>
        1. |AsyncConciseBody| Contains _symbol_ を返す。
      </emu-alg>
      <emu-note>
        <p>Contains は |ArrowFunction| や |AsyncArrowFunction| 内での `new.target`, `this`, `super` 使用を検出するために用いられる。</p>
      </emu-note>
      <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
      <emu-alg>
        1. _symbol_ が |MethodDefinition| なら *true* を返す。<br>
        1. 引数 _symbol_ で |MethodDefinition| の ComputedPropertyContains の結果を返す。
      </emu-alg>
      <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |MemberExpression| Contains _symbol_ が *true* なら *true* を返す。<br>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. _symbol_ が 予約語 `super` であるなら *true* を返す。<br>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |CallExpression| Contains _symbol_ が *true* なら *true* を返す。<br>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |OptionalChain| Contains _symbol_ が *true* なら *true* を返す。<br>
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-computedpropertycontains" oldids="sec-object-initializer-static-semantics-computedpropertycontains,sec-method-definitions-static-semantics-computedpropertycontains,sec-generator-function-definitions-static-semantics-computedpropertycontains,sec-async-generator-function-definitions-static-semantics-computedpropertycontains,sec-class-definitions-static-semantics-computedpropertycontains,sec-async-function-definitions-static-semantics-ComputedPropertyContains" type="sdo">
      <h1>
        静的意味論: ComputedPropertyContains (
        _symbol_: 文法記号,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ClassElementName : PrivateIdentifier

        PropertyName : LiteralPropertyName
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
      <emu-alg>
        1. |ComputedPropertyName| Contains _symbol_ の結果を返す。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _symbol_ で |ClassElementName| の ComputedPropertyContains の結果を返す。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 引数 _symbol_ で |ClassElementName| の ComputedPropertyContains の結果を返す。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 引数 _symbol_ で |ClassElementName| の ComputedPropertyContains の結果を返す。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _inList_ を 引数 _symbol_ で |ClassElementList| の ComputedPropertyContains とする。<br>
        1. _inList_ が *true* なら *true* を返す。<br>
        1. 引数 _symbol_ で |ClassElement| の ComputedPropertyContains の結果を返す。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _symbol_ で |ClassElementName| の ComputedPropertyContains の結果を返す。
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. 引数 _symbol_ で |ClassElementName| の ComputedPropertyContains の結果を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>その他 (Miscellaneous)</h1>
    <p>これらの操作は仕様全体の複数箇所で使用される。</p>

    <emu-clause id="sec-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        実行時意味論: InstantiateFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record または *null*,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _env_, _privateEnv_ で |FunctionDeclaration| の InstantiateOrdinaryFunctionObject を返す。
      </emu-alg>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _env_, _privateEnv_ で |GeneratorDeclaration| の InstantiateGeneratorFunctionObject を返す。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _env_, _privateEnv_ で |AsyncGeneratorDeclaration| の InstantiateAsyncGeneratorFunctionObject を返す。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _env_, _privateEnv_ で |AsyncFunctionDeclaration| の InstantiateAsyncFunctionObject を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindinginitialization" oldids="sec-identifiers-runtime-semantics-bindinginitialization,sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization" type="sdo">
      <h1>
        実行時意味論: BindingInitialization (
        _value_: ECMAScript 言語値,
        _environment_: Environment Record または *undefined*,
        ): ~unused~ を含む正常完了または異常完了
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_environment_ に *undefined* が渡されるのは、初期化値の代入に PutValue 操作を用いることを示す。これは `var` 文と（いくつかの）非 strict 関数の仮引数リストの場合である（<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref> 参照）。その場合、束縛は初期化子の評価前に巻き上げられ事前初期化される。</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. _name_ を |Identifier| の StringValue とする。<br>
        1. ? InitializeBoundName(_name_, _value_, _environment_) を返す。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. ? InitializeBoundName(*"yield"*, _value_, _environment_) を返す。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. ? InitializeBoundName(*"await"*, _value_, _environment_) を返す。
      </emu-alg>
      <emu-grammar>BindingPattern : ObjectBindingPattern</emu-grammar>
      <emu-alg>
        1. ? RequireObjectCoercible(_value_) を実行する。<br>
        1. 引数 _value_, _environment_ で |ObjectBindingPattern| の BindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>BindingPattern : ArrayBindingPattern</emu-grammar>
      <emu-alg>
        1. _iteratorRecord_ を ? GetIterator(_value_, ~sync~) とする。<br>
        1. _result_ を Completion( 引数 _iteratorRecord_, _environment_ で |ArrayBindingPattern| の IteratorBindingInitialization ) とする。<br>
        1. _iteratorRecord_.[[Done]] が *false* なら ? IteratorClose(_iteratorRecord_, _result_) を返す。<br>
        1. ? _result_ を返す。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. ~unused~ を返す。
      </emu-alg>
      <emu-grammar>
        ObjectBindingPattern :
          `{` BindingPropertyList `}`
          `{` BindingPropertyList `,` `}`
      </emu-grammar>
      <emu-alg>
        1. 引数 _value_, _environment_ で |BindingPropertyList| の PropertyBindingInitialization を ? 付きで実行する。<br>
        1. ~unused~ を返す。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _excludedNames_ を空の新 List とする。<br>
        1. 引数 _value_, _environment_, _excludedNames_ で |BindingRestProperty| の RestBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _excludedNames_ を 引数 _value_, _environment_ で |BindingPropertyList| の PropertyBindingInitialization (結果は ? ) とする。<br>
        1. 引数 _value_, _environment_, _excludedNames_ で |BindingRestProperty| の RestBindingInitialization を ? 付きで返す。
      </emu-alg>

      <emu-clause id="sec-initializeboundname" type="abstract operation">
        <h1>
          InitializeBoundName (
            _name_: String,
            _value_: ECMAScript 言語値,
            _environment_: Environment Record または *undefined*,
          ): ~unused~ を含む正常完了または異常完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _environment_ が *undefined* でないなら
            1. ! _environment_.InitializeBinding(_name_, _value_) を実行する。
            1. ~unused~ を返す。
          1. それ以外
            1. _lhs_ を ? ResolveBinding(_name_) とする。
            1. ? PutValue(_lhs_, _value_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" oldids="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization,sec-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-async-arrow-function-definitions-IteratorBindingInitialization" type="sdo">
      <h1>
        実行時意味論: IteratorBindingInitialization (
        _iteratorRecord_: Iterator Record,
        _environment_: Environment Record または *undefined*,
        ): ~unused~ を含む正常完了または異常完了
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_environment_ に *undefined* が渡される場合は初期化値の代入に PutValue を使うことを示し、これは非 strict 関数の仮引数リストで発生する。その場合、同名パラメータの複数存在可能性に対処するため事前初期化される。</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. ~unused~ を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. 引数 _iteratorRecord_ で |Elision| の IteratorDestructuringAssignmentEvaluation を ? 付きで返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |Elision| が存在するなら
          1. 引数 _iteratorRecord_ で |Elision| の IteratorDestructuringAssignmentEvaluation を ? 付きで実行する。
        1. 引数 _iteratorRecord_, _environment_ で |BindingRestElement| の IteratorBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. 引数 _iteratorRecord_, _environment_ で |BindingElementList| の IteratorBindingInitialization を ? 付きで実行する。<br>
        1. 引数 _iteratorRecord_ で |Elision| の IteratorDestructuringAssignmentEvaluation を ? 付きで返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 引数 _iteratorRecord_, _environment_ で |BindingElementList| の IteratorBindingInitialization を ? 付きで実行する。<br>
        1. |Elision| が存在するなら
          1. 引数 _iteratorRecord_ で |Elision| の IteratorDestructuringAssignmentEvaluation を ? 付きで実行する。
        1. 引数 _iteratorRecord_, _environment_ で |BindingRestElement| の IteratorBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. 引数 _iteratorRecord_, _environment_ で |BindingElementList| の IteratorBindingInitialization を ? 付きで実行する。<br>
        1. 引数 _iteratorRecord_, _environment_ で |BindingElisionElement| の IteratorBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. 引数 _iteratorRecord_ で |Elision| の IteratorDestructuringAssignmentEvaluation を ? 付きで実行する。<br>
        1. 引数 _iteratorRecord_, _environment_ で |BindingElement| の IteratorBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. _bindingId_ を |BindingIdentifier| の StringValue とする。<br>
        1. _lhs_ を ? ResolveBinding(_bindingId_, _environment_) とする。<br>
        1. _v_ を *undefined* とする。<br>
        1. _iteratorRecord_.[[Done]] が *false* なら
          1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
          1. _next_ が ~done~ でないなら
            1. _v_ を _next_ に設定する。
        1. |Initializer| が存在し _v_ が *undefined* なら
          1. IsAnonymousFunctionDefinition(|Initializer|) が *true* なら
            1. _v_ を ? NamedEvaluation(|Initializer|, 引数 _bindingId_) に設定する。
          1. それ以外
            1. _defaultValue_ を ? Evaluation(|Initializer|) とする。
            1. _v_ を ? GetValue(_defaultValue_) に設定する。
        1. _environment_ が *undefined* なら ? PutValue(_lhs_, _v_) を返す。
        1. ? InitializeReferencedBinding(_lhs_, _v_) を返す。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. _v_ を *undefined* とする。<br>
        1. _iteratorRecord_.[[Done]] が *false* なら
          1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
          1. _next_ が ~done~ でないなら
            1. _v_ を _next_ に設定する。
        1. |Initializer| が存在し _v_ が *undefined* なら
          1. _defaultValue_ を ? Evaluation(|Initializer|) とする。
          1. _v_ を ? GetValue(_defaultValue_) に設定する。
        1. 引数 _v_, _environment_ で |BindingPattern| の BindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. _lhs_ を ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_) とする。<br>
        1. _A_ を ! ArrayCreate(0) とする。<br>
        1. _n_ を 0 とする。<br>
        1. 繰り返し
          1. _next_ を ~done~ とする。
          1. _iteratorRecord_.[[Done]] が *false* なら
            1. _next_ を ? IteratorStepValue(_iteratorRecord_) に設定する。
          1. _next_ が ~done~ なら
            1. _environment_ が *undefined* なら ? PutValue(_lhs_, _A_) を返す。
            1. ? InitializeReferencedBinding(_lhs_, _A_) を返す。
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_) を実行する。
          1. _n_ を _n_ + 1 に設定する。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. _A_ を ! ArrayCreate(0) とする。<br>
        1. _n_ を 0 とする。<br>
        1. 繰り返し
          1. _next_ を ~done~ とする。
          1. _iteratorRecord_.[[Done]] が *false* なら
            1. _next_ を ? IteratorStepValue(_iteratorRecord_) に設定する。
          1. _next_ が ~done~ なら
            1. 引数 _A_, _environment_ で |BindingPattern| の BindingInitialization を ? 付きで返す。
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_) を実行する。
          1. _n_ を _n_ + 1 に設定する。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. ~unused~ を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 引数 _iteratorRecord_, _environment_ で |FormalParameterList| の IteratorBindingInitialization を ? 付きで実行する。<br>
        1. 引数 _iteratorRecord_, _environment_ で |FunctionRestParameter| の IteratorBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 引数 _iteratorRecord_, _environment_ で |FormalParameterList| の IteratorBindingInitialization を ? 付きで実行する。<br>
        1. 引数 _iteratorRecord_, _environment_ で |FormalParameter| の IteratorBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. _v_ を *undefined* とする。<br>
        1. アサート: _iteratorRecord_.[[Done]] は *false*。<br>
        1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。<br>
        1. _next_ が ~done~ でないなら
          1. _v_ を _next_ に設定する。
        1. 引数 _v_, _environment_ で |BindingIdentifier| の BindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ を |CoverParenthesizedExpressionAndArrowParameterList| により被覆される |ArrowFormalParameters| とする。<br>
        1. 引数 _iteratorRecord_, _environment_ で _formals_ の IteratorBindingInitialization を ? 付きで返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. _v_ を *undefined* とする。<br>
        1. アサート: _iteratorRecord_.[[Done]] は *false*。<br>
        1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。<br>
        1. _next_ が ~done~ でないなら
          1. _v_ を _next_ に設定する。
        1. 引数 _v_, _environment_ で |BindingIdentifier| の BindingInitialization を ? 付きで返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-assignmenttargettype" oldids="sec-identifiers-static-semantics-assignmenttargettype,sec-identifiers-static-semantics-isvalidsimpleassignmenttarget,sec-semantics-static-semantics-assignmenttargettype,sec-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-grouping-operator-static-semantics-assignmenttargettype,sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget,sec-static-semantics-static-semantics-assignmenttargettype,sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-update-expressions-static-semantics-assignmenttargettype,sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget,sec-unary-operators-static-semantics-assignmenttargettype,sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget,sec-exp-operator-static-semantics-assignmenttargettype,sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget,sec-multiplicative-operators-static-semantics-assignmenttargettype,sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget,sec-additive-operators-static-semantics-assignmenttargettype,sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget,sec-bitwise-shift-operators-static-semantics-assignmenttargettype,sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget,sec-relational-operators-static-semantics-assignmenttargettype,sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget,sec-equality-operators-static-semantics-assignmenttargettype,sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-bitwise-operators-static-semantics-assignmenttargettype,sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-logical-operators-static-semantics-assignmenttargettype,sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget,sec-conditional-operator-static-semantics-assignmenttargettype,sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget,sec-assignment-operators-static-semantics-assignmenttargettype,sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget,sec-comma-operator-static-semantics-assignmenttargettype,sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget" type="sdo">
      <h1>静的意味論: AssignmentTargetType ( ): ~simple~, ~web-compat~, または ~invalid~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. IsStrict(this |IdentifierReference|) が *true* かつ |Identifier| の StringValue が *"eval"* または *"arguments"* のいずれかなら ~invalid~ を返す。<br>
        1. ~simple~ を返す。
      </emu-alg>
      <emu-grammar>
        IdentifierReference :
          `yield`
          `await`

        CallExpression :
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MemberExpression `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. ~simple~ を返す。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          CoverParenthesizedExpressionAndArrowParameterList
      </emu-grammar>
      <emu-alg>
        1. _expr_ を |CoverParenthesizedExpressionAndArrowParameterList| によって被覆される |ParenthesizedExpression| とする。<br>
        1. _expr_ の AssignmentTargetType を返す。
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. [id="step-assignmenttargettype-web-compat", normative-optional] ホストが Web ブラウザ又は <emu-xref href="#sec-runtime-errors-for-function-call-assignment-targets" title></emu-xref> をサポートし、かつ IsStrict(this |CallExpression|) が *false* なら
          1. ~web-compat~ を返す。
        1. ~invalid~ を返す。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral

        CallExpression :
          SuperCall
          ImportCall
          CallExpression TemplateLiteral

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression TemplateLiteral
          `new` MemberExpression Arguments

        NewTarget :
          `new` `.` `target`

        ImportMeta :
          `import` `.` `meta`

        LeftHandSideExpression :
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. ~invalid~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-propname" oldids="sec-object-initializer-static-semantics-propname,sec-method-definitions-static-semantics-propname,sec-generator-function-definitions-static-semantics-propname,sec-async-generator-function-definitions-static-semantics-propname,sec-class-definitions-static-semantics-propname,sec-async-function-definitions-static-semantics-PropName" type="sdo">
      <h1>静的意味論: PropName ( ): String または ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
      <emu-alg>
        1. |IdentifierReference| の StringValue を返す。
      </emu-alg>
      <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. |PropertyName| の PropName を返す。
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : IdentifierName

        AttributeKey : IdentifierName
      </emu-grammar>
      <emu-alg>
        1. |IdentifierName| の StringValue を返す。
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : StringLiteral

        AttributeKey : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. |StringLiteral| の SV を返す。
      </emu-alg>
      <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
      <emu-alg>
        1. _nbr_ を |NumericLiteral| の NumericValue とする。<br>
        1. ! ToString(_nbr_) を返す。
      </emu-alg>
      <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName| の PropName を返す。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName| の PropName を返す。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName| の PropName を返す。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName| の PropName を返す。
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName| の PropName を返す。
      </emu-alg>
      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>実行可能コードと実行コンテキスト (Executable Code and Execution Contexts)</h1>

  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>環境レコード (Environment Records)</h1>
    <p><dfn variants="Environment Records">Environment Record</dfn> は、ECMAScript コードの字句上の入れ子（レキシカル）構造に基づいて |Identifier| と特定の変数・関数との関連付けを定義するために用いられる仕様上の型である。通常、Environment Record は |FunctionDeclaration|、|BlockStatement|、または |TryStatement| の |Catch| 節といった ECMAScript コードの特定の構文構造に関連付けられる。そのようなコードが評価されるたびに、そのコードが生成する識別子束縛を記録する新しい Environment Record が作成される。</p>
    <p>すべての Environment Record は [[OuterEnv]] フィールドを持ち、これは *null* か、外側の Environment Record への参照である。これは Environment Record 値の論理的な入れ子をモデル化するために使われる。ある（内側の）Environment Record の外側参照は、その内側 Environment Record を論理的に囲む Environment Record への参照である。外側の Environment Record もまた自身の外側 Environment Record を持ちうる。1 つの Environment Record は複数の内側 Environment Record の外側環境として機能することがある。例えば、ある |FunctionDeclaration| が 2 つのネストした |FunctionDeclaration| を含む場合、それぞれのネストした関数の Environment Record の外側 Environment Record は、その囲む関数の現在の評価の Environment Record になる。</p>
    <p>Environment Record は純粋に仕様上のメカニズムであり、ECMAScript 実装の特定の成果物に対応する必要はない。ECMAScript プログラムがそれらの値に直接アクセスまたは操作することは不可能である。</p>

    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>Environment Record 型階層 (The Environment Record Type Hierarchy)</h1>
      <p>Environment Record は、Environment Record が抽象クラスであり 3 つの具象サブクラス（Declarative Environment Record、Object Environment Record、Global Environment Record）を持つ、単純なオブジェクト指向階層に存在するものと考えられる。Function Environment Record と Module Environment Record は Declarative Environment Record のサブクラスである。</p>
      <ul>
        <li>
          <p>Environment Record (抽象)</p>
          <ul>
            <li>
              <p><em>Declarative Environment Record</em> は、|FunctionDeclaration|、|VariableDeclaration|、|Catch| 節など、識別子束縛を直接 ECMAScript 言語値に関連付ける ECMAScript 言語構文要素の効果を定義するために使用される。</p>
              <ul>
                <li>
                  <p><em>Function Environment Record</em> は ECMAScript 関数オブジェクトの呼び出しに対応し、その関数内のトップレベル宣言に対する束縛を含む。これは新しい `this` 束縛を確立する場合がある。また `super` メソッド呼び出しをサポートするために必要な状態を捕捉する。</p>
                </li>
                <li>
                  <p><em>Module Environment Record</em> は |Module| のトップレベル宣言に対する束縛を含む。また |Module| によって明示的に import された束縛も含む。その [[OuterEnv]] は Global Environment Record である。</p>
                </li>
              </ul>
            </li>
            <li>
              <p><em>Object Environment Record</em> は、|WithStatement| のように、識別子束縛をあるオブジェクトのプロパティに関連付ける ECMAScript 要素の効果を定義するために使用される。</p>
            </li>
            <li>
              <p><em>Global Environment Record</em> は |Script| のグローバル宣言に使用される。外側環境を持たず、その [[OuterEnv]] は *null* である。識別子束縛があらかじめ投入されている場合があり、また関連するグローバルオブジェクトを含み、そのプロパティがグローバル環境の識別子束縛の一部を提供する。ECMAScript コードの実行に伴って、追加のプロパティがグローバルオブジェクトに追加されたり、初期プロパティが変更されたりする可能性がある。</p>
            </li>
          </ul>
        </li>
      </ul>

      <p>Environment Record 抽象クラスは、<emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> に定義される抽象仕様メソッドを含む。これらの抽象メソッドは、各具象サブクラスに固有の具体的アルゴリズムを持つ。</p>
      <emu-table id="table-abstract-methods-of-environment-records" caption="環境レコードの抽象メソッド (Abstract Methods of Environment Records)" oldids="table-15">
        <table>
          <thead>
            <tr>
              <th>
                メソッド (Method)
              </th>
              <th>
                目的 (Purpose)
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              Environment Record が文字列値 _N_ の束縛を持つか判定する。持つなら *true*、持たないなら *false* を返す。
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              Environment Record に新しい未初期化の可変束縛を作成する。文字列値 _N_ は束縛名のテキスト。Boolean 引数 _D_ が *true* の場合、その束縛は後で削除可能。
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              Environment Record に新しい未初期化の不変束縛を作成する。文字列値 _N_ は束縛名のテキスト。_S_ が *true* の場合、初期化後に設定しようとすると、参照する操作の strict モード設定に関わらず常に例外を投げる。
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V)
            </td>
            <td>
              既に存在し未初期化の束縛の値を設定する。文字列値 _N_ は束縛名のテキスト。_V_ は任意の ECMAScript 言語型の値。
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              既存の可変束縛の値を設定する。_N_ は束縛名。_V_ は任意の ECMAScript 言語型の値。_S_ が *true* で束縛を設定できない場合 *TypeError* を投げる。
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              既存束縛の値を返す。_N_ は束縛名。_S_ は strict モードコード（または strict セマンティクスが必要な参照）を識別する。_S_ が *true* で束縛が存在しないなら *ReferenceError*。束縛が存在するが未初期化なら _S_ に関係なく *ReferenceError* を投げる。
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              束縛を削除する。存在し削除成功なら *true*、削除できなければ *false*。存在しないなら *true*。
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              `this` 束縛を確立するか判定。確立するなら *true*、しないなら *false*。
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              `super` メソッド束縛を確立するか判定。確立するなら *true*、しないなら *false*。*true* の場合、その Environment Record は Function Environment Record であることを含意する（逆は必ずしも成立しない）。
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              この Environment Record が `with` 文に関連付くなら with オブジェクトを返し、それ以外は *undefined* を返す。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>宣言的環境レコード (Declarative Environment Records)</h1>
        <p>各 <dfn variants="Declarative Environment Records">Declarative Environment Record</dfn> は、変数、定数、let、class、module、import、および / または function 宣言を含む ECMAScript プログラムスコープに関連付けられる。Declarative Environment Record は、そのスコープ内の宣言によって定義される識別子集合を束縛する。</p>

        <emu-clause id="sec-declarative-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean を含む正常完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>引数の識別子がそのレコードで束縛される識別子の一つかどうかを判定する。</dd>
          </dl>
          <emu-alg>
            1. _envRec_ が _N_ の束縛を持つなら *true* を返す。
            1. *false* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~ を含む正常完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>未初期化の新しい可変束縛 _N_ を作成する。_envRec_ に _N_ の既存束縛があってはならない。_D_ が *true* の場合、その新しい束縛は削除対象としてマークされる。</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_ はまだ _N_ の束縛を持たない。
            1. _envRec_ に _N_ の未初期化可変束縛を作成する。_D_ が *true* なら、後続の DeleteBinding 呼び出しで削除可能であることを記録する。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: String,
              _S_: Boolean,
            ): ~unused~ を含む正常完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>未初期化の新しい不変束縛 _N_ を作成する。既存束縛は存在してはならない。_S_ が *true* の場合、新しい束縛を strict 束縛としてマークする。</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_ はまだ _N_ の束縛を持たない。
            1. _envRec_ に _N_ の未初期化不変束縛を作成する。_S_ が *true* なら strict 束縛であることを記録する。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 言語値,
            ): ~unused~ を含む正常完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ を持つ識別子の現在の未初期化束縛に値 _V_ を設定するために使用される。未初期化束縛が既に存在しなければならない。</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_ は _N_ の未初期化束縛を持つ。
            1. _envRec_ における _N_ の束縛値を _V_ に設定する。
            1. <emu-not-ref>Record</emu-not-ref> その束縛が初期化されたことを記録する。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 言語値,
              _S_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ の可変束縛値を _V_ に変更しようとする。通常束縛は既存だが、まれに存在しない場合がある。束縛が不変束縛で _S_ が *true* のとき *TypeError* を投げる。</dd>
          </dl>
          <emu-alg>
            1. [id="step-setmutablebinding-missing-binding"] _envRec_ が _N_ の束縛を持たない場合、
              1. _S_ が *true* なら *ReferenceError* 例外を投げる。
              1. ! _envRec_.CreateMutableBinding(_N_, *true*) を実行。
              1. ! _envRec_.InitializeBinding(_N_, _V_) を実行。
              1. ~unused~ を返す。
            1. _envRec_ における _N_ の束縛が strict 束縛なら _S_ を *true* に設定。
            1. _envRec_ における _N_ の束縛が未初期化なら
              1. *ReferenceError* 例外を投げる。
            1. そうでなく _envRec_ における _N_ が可変束縛なら
              1. その束縛値を _V_ に変更する。
            1. それ以外
              1. アサート: 不変束縛の値を変更しようとしている。
              1. _S_ が *true* なら *TypeError* 例外を投げる。
            1. ~unused~ を返す。
          </emu-alg>
          <emu-note>
            <p>ステップ <emu-xref href="#step-setmutablebinding-missing-binding"></emu-xref> で束縛が存在しない状況を生む ECMAScript コード例:</p>
            <pre><code class="javascript">function f() { eval("var x; x = (delete x, 0);"); }</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 言語値を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ の束縛値を返す。束縛が存在し未初期化である場合は、_S_ の値に関わらず *ReferenceError* を投げる。</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_ は _N_ の束縛を持つ。
            1. _envRec_ における _N_ の束縛が未初期化なら *ReferenceError* 例外を投げる。
            1. 現在 _envRec_ で _N_ に束縛されている値を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean を含む正常完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>削除対象として明示的に指定された束縛のみ削除できる。</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_ は _N_ の束縛を持つ。
            1. _envRec_ における _N_ の束縛が削除不可なら *false* を返す。
            1. _envRec_ から _N_ の束縛を除去する。
            1. *true* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* を返す。
          </emu-alg>
          <emu-note>
            <p>通常の Declarative Environment Record（Function Environment Record でも Module Environment Record でもないもの）は `this` 束縛を提供しない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* を返す。
          </emu-alg>
          <emu-note>
            <p>通常の Declarative Environment Record は `super` 束縛を提供しない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>オブジェクト環境レコード (Object Environment Records)</h1>
        <p>各 <dfn variants="Object Environment Records">Object Environment Record</dfn> は <em>binding object</em> と呼ばれるオブジェクトに関連付けられる。Object Environment Record は、その binding object のプロパティ名と直接対応する文字列識別子名の集合を束縛する。|IdentifierName| 形式でない文字列でないプロパティキーは束縛された識別子集合に含まれない。自身のプロパティと継承されたプロパティは [[Enumerable]] 属性の設定に関わらず集合に含まれる。プロパティは動的に追加・削除されうるため、Object Environment Record によって束縛される識別子集合は、プロパティを追加または削除する任意の操作の副作用として変化し得る。そのような副作用によって作成された束縛は、対応するプロパティの Writable 属性が *false* であっても可変束縛とみなされる。Object Environment Record には不変束縛は存在しない。</p>
        <p>`with` 文（<emu-xref href="#sec-with-statement"></emu-xref>）のために作成される Object Environment Record は、関数呼び出しで使用する暗黙の *this* 値として binding object を提供できる。この能力は Boolean フィールド [[IsWithEnvironment]] によって制御される。</p>
        <p>Object Environment Record は <emu-xref href="#table-additional-fields-of-object-environment-records"></emu-xref> に列挙される追加状態フィールドを持つ。</p>
        <emu-table id="table-additional-fields-of-object-environment-records" caption="Object Environment Record の追加フィールド (Additional Fields of Object Environment Records)">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名 (Field Name)
                </th>
                <th>
                  値 (Value)
                </th>
                <th>
                  意味 (Meaning)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[BindingObject]]
              </td>
              <td>
                Object
              </td>
              <td>
                この Environment Record の binding object。
              </td>
            </tr>
            <tr>
              <td>
                [[IsWithEnvironment]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                この Environment Record が `with` 文のために作成されたかどうかを示す。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-object-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>関連付けられた binding object が名前 _N_ のプロパティを持つか判定する。</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_ を _envRec_.[[BindingObject]] とする。
            1. _foundBinding_ を ? HasProperty(_bindingObject_, _N_) とする。
            1. _foundBinding_ が *false* なら *false* を返す。
            1. _envRec_.[[IsWithEnvironment]] が *false* なら *true* を返す。
            1. _unscopables_ を ? Get(_bindingObject_, %Symbol.unscopables%) とする。
            1. _unscopables_ が Object なら
              1. _blocked_ を ToBoolean(? Get(_unscopables_, _N_)) とする。
              1. _blocked_ が *true* なら *false* を返す。
            1. *true* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>Environment Record の binding object に名前 _N_ のプロパティを作成し、その値を *undefined* に初期化する。_D_ が *true* なら新プロパティの [[Configurable]] を *true* にし、そうでなければ *false* にする。</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_ を _envRec_.[[BindingObject]] とする。
            1. ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }) を実行。
            1. ~unused~ を返す。
          </emu-alg>
          <emu-note>
            <p>通常 _envRec_ は _N_ の束縛を持たないが、持つ場合には DefinePropertyOrThrow のセマンティクスにより既存束縛が置換・シャドウされるか、または急な完了が返ることがある。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>Object Environment Record の CreateImmutableBinding 具体メソッドは本仕様では使用されない。</p>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 言語値,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ の現在の束縛値を _V_ に設定する。</dd>
          </dl>
          <emu-alg>
            1. ? <emu-meta effects="user-code">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*) を実行。
            1. ~unused~ を返す。
          </emu-alg>
          <emu-note>
            <p>本仕様では Object Environment Record に対する CreateMutableBinding の全使用は直後に同じ名前で InitializeBinding を呼び出す。したがって初期化状態は明示的に追跡しない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 言語値,
              _S_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>関連する binding object のプロパティ _N_ の値を _V_ に設定しようとする。通常 _N_ のプロパティは既に存在するが、存在しないか書き込み不可の場合、エラー処理は _S_ に依存する。</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_ を _envRec_.[[BindingObject]] とする。
            1. _stillExists_ を ? HasProperty(_bindingObject_, _N_) とする。
            1. _stillExists_ が *false* かつ _S_ が *true* なら *ReferenceError* 例外を投げる。
            1. ? Set(_bindingObject_, _N_, _V_, _S_) を実行。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 言語値を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>関連 binding object のプロパティ _N_ の値を返す。プロパティは存在するはずだが存在しない場合、結果は _S_ に依存する。</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_ を _envRec_.[[BindingObject]] とする。
            1. _value_ を ? HasProperty(_bindingObject_, _N_) とする。
            1. _value_ が *false* なら
              1. _S_ が *false* なら *undefined* を返し、そうでなければ *ReferenceError* 例外を投げる。
            1. ? Get(_bindingObject_, _N_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>[[Configurable]] 属性が *true* の環境オブジェクトプロパティに対応する束縛のみ削除できる。</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_ を _envRec_.[[BindingObject]] とする。
            1. ? <emu-meta effects="user-code">_bindingObject_.[[Delete]]</emu-meta>(_N_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* を返す。
          </emu-alg>
          <emu-note>
            <p>Object Environment Record は `this` 束縛を提供しない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* を返す。
          </emu-alg>
          <emu-note>
            <p>Object Environment Record は `super` 束縛を提供しない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): Object または *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[IsWithEnvironment]] が *true* なら _envRec_.[[BindingObject]] を返す。
            1. そうでなければ *undefined* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-function-environment-records" oldids="function-environment">
        <h1>関数環境レコード (Function Environment Records)</h1>
        <p><dfn variants="Function Environment Records">Function Environment Record</dfn> は、関数のトップレベルスコープを表し、かつその関数が |ArrowFunction| でない場合 `this` 束縛を提供する Declarative Environment Record である。関数が |ArrowFunction| でなく `super` を参照する場合、その Function Environment Record は関数内部からの `super` メソッド呼び出しを実行するために使用される状態も含む。</p>
        <p>Function Environment Record は <emu-xref href="#table-additional-fields-of-function-environment-records"></emu-xref> に列挙される追加状態フィールドを持つ。</p>
        <emu-table id="table-additional-fields-of-function-environment-records" caption="Function Environment Record の追加フィールド (Additional Fields of Function Environment Records)" oldids="table-16">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名 (Field Name)
                </th>
                <th>
                  値 (Value)
                </th>
                <th>
                  意味 (Meaning)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ThisValue]]
              </td>
              <td>
                ECMAScript 言語値
              </td>
              <td>
                この関数呼び出しで使用される *this* 値。
              </td>
            </tr>
            <tr>
              <td>
                [[ThisBindingStatus]]
              </td>
              <td>
                ~lexical~, ~initialized~, または ~uninitialized~
              </td>
              <td>
                値が ~lexical~ の場合、これは |ArrowFunction| でありローカルな *this* 値を持たない。
              </td>
            </tr>
            <tr>
              <td>
                [[FunctionObject]]
              </td>
              <td>
                ECMAScript 関数オブジェクト
              </td>
              <td>
                この Environment Record を生成した呼び出し元の関数オブジェクト。
              </td>
            </tr>
            <tr>
              <td>
                [[NewTarget]]
              </td>
              <td>
                コンストラクタまたは *undefined*
              </td>
              <td>
                この Environment Record が [[Construct]] 内部メソッドで作成された場合、[[NewTarget]] はその [[Construct]] _newTarget_ パラメータの値。それ以外は *undefined*。
              </td>
            </tr>
          </table>
        </emu-table>
        <p>Function Environment Record は <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> に挙げる Declarative Environment Record メソッドすべてをサポートし、HasThisBinding と HasSuperBinding を除き同一の仕様を共有する。さらに <emu-xref href="#table-additional-methods-of-function-environment-records"></emu-xref> に示すメソッドをサポートする:</p>
        <emu-table id="table-additional-methods-of-function-environment-records" caption="Function Environment Record の追加メソッド (Additional Methods of Function Environment Records)" oldids="table-17">
          <table>
            <thead>
              <tr>
                <th>
                  メソッド (Method)
                </th>
                <th>
                  目的 (Purpose)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                この Environment Record の `this` 束縛の値を返す。未初期化なら *ReferenceError* を投げる。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-bindthisvalue" type="abstract operation">
          <h1>
            BindThisValue (
              _envRec_: Function Environment Record,
              _V_: ECMAScript 言語値,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_envRec_.[[ThisValue]] を設定し初期化済みであることを記録する。</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_.[[ThisBindingStatus]] は ~lexical~ ではない。
            1. _envRec_.[[ThisBindingStatus]] が ~initialized~ なら *ReferenceError* 例外を投げる。
            1. _envRec_.[[ThisValue]] を _V_ に設定する。
            1. _envRec_.[[ThisBindingStatus]] を ~initialized~ に設定する。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): Boolean</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[ThisBindingStatus]] が ~lexical~ なら *false*、そうでなければ *true* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): Boolean</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[ThisBindingStatus]] が ~lexical~ なら *false* を返す。
            1. _envRec_.[[FunctionObject]].[[HomeObject]] が *undefined* なら *false*、そうでなければ *true* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): ECMAScript 言語値を含む正常完了または throw 完了</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_.[[ThisBindingStatus]] は ~lexical~ ではない。
            1. _envRec_.[[ThisBindingStatus]] が ~uninitialized~ なら *ReferenceError* 例外を投げる。
            1. _envRec_.[[ThisValue]] を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-getsuperbase" type="abstract operation">
          <h1>
            GetSuperBase (
              _envRec_: Function Environment Record,
            ): Object, *null*, または *undefined*
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_envRec_ に束縛された `super` プロパティアクセスの基底オブジェクトを返す。値 *undefined* はそうしたアクセスが実行時エラーになることを示す。</dd>
          </dl>
          <emu-alg>
            1. _home_ を _envRec_.[[FunctionObject]].[[HomeObject]] とする。
            1. _home_ が *undefined* なら *undefined* を返す。
            1. アサート: _home_ は ordinary object。
            1. ! _home_.[[GetPrototypeOf]]() を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-global-environment-records" oldids="global-environment">
        <h1>グローバル環境レコード (Global Environment Records)</h1>
        <p><dfn variants="Global Environment Records">Global Environment Record</dfn> は、共通の realm で処理されるすべての ECMAScript |Script| 要素に共有される最も外側のスコープを表す。Global Environment Record は組み込みグローバル（<emu-xref href="#sec-global-object"></emu-xref>）、グローバルオブジェクトのプロパティ、および |Script| 内に現れるすべてのトップレベル宣言（<emu-xref href="#sec-static-semantics-toplevellexicallyscopeddeclarations"></emu-xref>, <emu-xref href="#sec-static-semantics-toplevelvarscopeddeclarations"></emu-xref>）に束縛を提供する。</p>
        <p>Global Environment Record は論理的には単一のレコードだが、Object Environment Record と Declarative Environment Record を包含する合成体として仕様化される。Object Environment Record の基底オブジェクトは関連する Realm Record のグローバルオブジェクトであり、これは Global Environment Record の GetThisBinding 具体メソッドが返す値である。Global Environment Record の Object Environment Record 部分は、すべての組み込みグローバル（<emu-xref href="#sec-global-object"></emu-xref>）およびグローバルコード内の |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、|AsyncGeneratorDeclaration|、|VariableStatement| によって導入される束縛を含む。それ以外のグローバルコード内の ECMAScript 宣言による束縛は Global Environment Record の Declarative Environment Record 部分に含まれる。</p>
        <p>プロパティはグローバルオブジェクト上に直接作成され得る。したがって Global Environment Record の Object Environment Record 部分は、宣言（|FunctionDeclaration| 等）によって明示的に作成された束縛と、グローバルオブジェクトのプロパティとして暗黙に作成された束縛の両方を含み得る。どの束縛が宣言によって明示的に作成されたものか識別するため、Global Environment Record は CreateGlobalVarBinding と CreateGlobalFunctionBinding 抽象操作で束縛された名前のリストを保持する。</p>
        <p>Global Environment Record は <emu-xref href="#table-additional-fields-of-global-environment-records"></emu-xref> に挙げる追加フィールドおよび <emu-xref href="#table-additional-methods-of-global-environment-records"></emu-xref> に挙げる追加メソッドを持つ。</p>
        <emu-table id="table-additional-fields-of-global-environment-records" caption="Global Environment Record の追加フィールド (Additional Fields of Global Environment Records)" oldids="table-18">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名 (Field Name)
                </th>
                <th>
                  値 (Value)
                </th>
                <th>
                  意味 (Meaning)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ObjectRecord]]
              </td>
              <td>
                Object Environment Record
              </td>
              <td>
                Binding object はグローバルオブジェクト。組み込みグローバルの束縛と、グローバルコード内の |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, |VariableDeclaration| 束縛を含む。
              </td>
            </tr>
            <tr>
              <td>
                [[GlobalThisValue]]
              </td>
              <td>
                Object
              </td>
              <td>
                グローバルスコープで `this` が返す値。ホストは任意の ECMAScript Object を提供可能。
              </td>
            </tr>
            <tr>
              <td>
                [[DeclarativeRecord]]
              </td>
              <td>
                Declarative Environment Record
              </td>
              <td>
                <emu-not-ref>Contains</emu-not-ref> グローバルコード内の全宣言（ただし |FunctionDeclaration| など一部を除く）の束縛。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-additional-methods-of-global-environment-records" caption="Global Environment Record の追加メソッド (Additional Methods of Global Environment Records)" oldids="table-19">
          <table>
            <thead>
              <tr>
                <th>
                  メソッド (Method)
                </th>
                <th>
                  目的 (Purpose)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                この Environment Record の `this` 束縛値を返す。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-global-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>引数の識別子がこのレコードで束縛される一つか判定する。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) が *true* なら *true* を返す。
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. ? <emu-meta effects="user-code">_ObjRec_.HasBinding</emu-meta>(_N_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>未初期化の新しい可変束縛 _N_ を作成する。束縛は関連 DeclarativeRecord に作成される。_N_ の束縛は既に存在してはならない。_D_ が *true* の場合、削除対象としてマークされる。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) が *true* なら *TypeError* 例外を投げる。
            1. ! _DclRec_.CreateMutableBinding(_N_, _D_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: String,
              _S_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>未初期化の新しい不変束縛 _N_ を作成する。_N_ の既存束縛は存在してはならない。_S_ が *true* なら strict 束縛としてマーク。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) が *true* なら *TypeError* 例外を投げる。
            1. ! _DclRec_.CreateImmutableBinding(_N_, _S_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 言語値,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ の未初期化束縛値を _V_ に設定する。未初期化束縛が既に存在する必要がある。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) が *true* なら
              1. ! _DclRec_.InitializeBinding(_N_, _V_) を返す。
            1. アサート: 束縛が存在するなら Object Environment Record にある。
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 言語値,
              _S_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ の現在の束縛値を _V_ に変更しようとする。不変束縛で _S_ が *true* なら *TypeError*。プロパティ _N_ が存在しないか書き込み不可の場合の処理は _S_ に依存。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) が *true* なら
              1. ? _DclRec_.SetMutableBinding(_N_, _V_, _S_) を返す。
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. ? <emu-meta effects="user-code">_ObjRec_.SetMutableBinding</emu-meta>(_N_, _V_, _S_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 言語値を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ の束縛値を返す。束縛が未初期化なら *ReferenceError*。プロパティ _N_ の存在や書き込み可否に関連するエラー処理は _S_ に依存。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) が *true* なら
              1. ? _DclRec_.GetBindingValue(_N_, _S_) を返す。
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. ? <emu-meta effects="user-code">_ObjRec_.GetBindingValue</emu-meta>(_N_, _S_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>削除対象として明示的に指定された束縛のみ削除できる。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) が *true* なら
              1. ! _DclRec_.DeleteBinding(_N_) を返す。
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. _globalObject_ を _ObjRec_.[[BindingObject]] とする。
            1. _existingProp_ を ? HasOwnProperty(_globalObject_, _N_) とする。
            1. _existingProp_ が *true* なら
              1. ? <emu-meta effects="user-code">_ObjRec_.DeleteBinding</emu-meta>(_N_) を返す。
            1. *true* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *true* を返す。
          </emu-alg>
          <emu-note>
            <p>Global Environment Record は常に `this` 束縛を提供する。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* を返す。
          </emu-alg>
          <emu-note>
            <p>Global Environment Record は `super` 束縛を提供しない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): Object を含む正常完了</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[GlobalThisValue]] を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-haslexicaldeclaration" type="abstract operation">
          <h1>
            HasLexicalDeclaration (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>引数の識別子が、|LexicalDeclaration| や |ClassDeclaration| のようなレキシカル宣言で _envRec_ に作成された束縛を持つか判定する。</dd>
          </dl>
          <emu-alg>
            1. _DclRec_ を _envRec_.[[DeclarativeRecord]] とする。
            1. ! _DclRec_.HasBinding(_N_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-hasrestrictedglobalproperty" type="abstract operation">
          <h1>
            HasRestrictedGlobalProperty (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>引数の識別子が、グローバルレキシカル束縛によってシャドウされてはならないグローバルオブジェクトのプロパティ名か判定する。</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. _globalObject_ を _ObjRec_.[[BindingObject]] とする。
            1. _existingProp_ を ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_) とする。
            1. _existingProp_ が *undefined* なら *false* を返す。
            1. _existingProp_.[[Configurable]] が *true* なら *false* を返す。
            1. *true* を返す。
          </emu-alg>
          <emu-note>
            <p>グローバルオブジェクト上には var や function 宣言ではなく直接作成されたプロパティが存在し得る。非 configurable なグローバルオブジェクトのプロパティと同名のグローバルレキシカル束縛は作成できない。*"undefined"* はその例である。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalvar" type="abstract operation">
          <h1>
            CanDeclareGlobalVar (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>同じ引数 _N_ で CreateGlobalVarBinding 呼び出しが成功するか判定する。冗長な var 宣言や既存グローバルオブジェクトプロパティに対する var 宣言は許可される。</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. _globalObject_ を _ObjRec_.[[BindingObject]] とする。
            1. _hasProperty_ を ? HasOwnProperty(_globalObject_, _N_) とする。
            1. _hasProperty_ が *true* なら *true* を返す。
            1. ? IsExtensible(_globalObject_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalfunction" type="abstract operation">
          <h1>
            CanDeclareGlobalFunction (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>同じ引数 _N_ で CreateGlobalFunctionBinding 呼び出しが成功するか判定する。</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. _globalObject_ を _ObjRec_.[[BindingObject]] とする。
            1. _existingProp_ を ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_) とする。
            1. _existingProp_ が *undefined* なら ? IsExtensible(_globalObject_) を返す。
            1. _existingProp_.[[Configurable]] が *true* なら *true* を返す。
            1. IsDataDescriptor(_existingProp_) が *true* かつ _existingProp_ が属性 { [[Writable]]: *true*, [[Enumerable]]: *true* } を持つなら *true* を返す。
            1. *false* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalvarbinding" type="abstract operation">
          <h1>
            CreateGlobalVarBinding (
              _envRec_: Global Environment Record,
              _N_: String,
              _D_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>関連する Object Environment Record に可変束縛を作成・初期化する。既存束縛があれば再利用され初期化済みとみなされる。</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. _globalObject_ を _ObjRec_.[[BindingObject]] とする。
            1. _hasProperty_ を ? HasOwnProperty(_globalObject_, _N_) とする。
            1. _extensible_ を ? IsExtensible(_globalObject_) とする。
            1. _hasProperty_ が *false* かつ _extensible_ が *true* なら
              1. ? <emu-meta effects="user-code">_ObjRec_.CreateMutableBinding</emu-meta>(_N_, _D_) を実行。
              1. ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, *undefined*) を実行。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalfunctionbinding" type="abstract operation">
          <h1>
            CreateGlobalFunctionBinding (
              _envRec_: Global Environment Record,
              _N_: String,
              _V_: ECMAScript 言語値,
              _D_: Boolean,
            ): ~unused~ を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>関連する Object Environment Record に可変束縛を作成・初期化する。既存束縛があれば置き換える。</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_ を _envRec_.[[ObjectRecord]] とする。
            1. _globalObject_ を _ObjRec_.[[BindingObject]] とする。
            1. _existingProp_ を ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_) とする。
            1. _existingProp_ が *undefined* または _existingProp_.[[Configurable]] が *true* なら
              1. _desc_ を PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ } とする。
            1. それ以外
              1. _desc_ を PropertyDescriptor { [[Value]]: _V_ } とする。
            1. ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_) を実行。
            1. [id="step-createglobalfunctionbinding-set"] ? Set(_globalObject_, _N_, _V_, *false*) を実行。
            1. ~unused~ を返す。
          </emu-alg>
          <emu-note>
            <p>グローバル関数宣言は常にグローバルオブジェクトの自身プロパティとして表現される。可能であれば既存の自身プロパティは標準的な属性値集合に再設定される。ステップ <emu-xref href="#step-createglobalfunctionbinding-set"></emu-xref> は InitializeBinding 具体メソッド呼び出しと等価であり、_globalObject_ が Proxy の場合同じ Proxy トラップ呼び出し列を生成する。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-module-environment-records" oldids="module-environment">
        <h1>モジュール環境レコード (Module Environment Records)</h1>
        <p><dfn variants="Module Environment Records">Module Environment Record</dfn> は ECMAScript |Module| の外側スコープを表す Declarative Environment Record である。通常の可変・不変束縛に加え、他の Environment Record に存在する対象束縛への間接アクセスを提供する不変の import 束縛も提供する。</p>
        <p>Module Environment Record は <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> に挙げる Declarative Environment Record メソッドのすべてをサポートし、GetBindingValue, DeleteBinding, HasThisBinding, GetThisBinding を除き同じ仕様を共有する。さらに <emu-xref href="#table-additional-methods-of-module-environment-records"></emu-xref> に示すメソッドをサポートする:</p>
        <emu-table id="table-additional-methods-of-module-environment-records" caption="Module Environment Record の追加メソッド (Additional Methods of Module Environment Records)" oldids="table-20">
          <table>
            <thead>
              <tr>
                <th>
                  メソッド (Method)
                </th>
                <th>
                  目的 (Purpose)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                この Environment Record の `this` 束縛値を返す。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-module-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 言語値を含む正常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>名前 _N_ の束縛値を返す。ただし束縛が間接束縛なら対象束縛値を返す。束縛が未初期化なら *ReferenceError* を投げる。</dd>
          </dl>
          <emu-alg>
            1. アサート: _S_ は *true*。
            1. アサート: _envRec_ は _N_ の束縛を持つ。
            1. _N_ の束縛が間接束縛なら
              1. _M_ と _N2_ をこの束縛作成時に提供された間接化値とする。
              1. _targetEnv_ を _M_.[[Environment]] とする。
              1. _targetEnv_ が ~empty~ なら *ReferenceError* 例外を投げる。
              1. ? <emu-meta effects="user-code">_targetEnv_.GetBindingValue</emu-meta>(_N2_, *true*) を返す。
            1. _envRec_ における _N_ の束縛が未初期化なら *ReferenceError* 例外を投げる。
            1. 現在 _envRec_ で _N_ に束縛されている値を返す。
          </emu-alg>
          <emu-note>
            <p>_S_ は常に *true*。|Module| は常に strict モードコードだからである。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>Module Environment Record の DeleteBinding 具体メソッドは本仕様では使用されない。</p>
          <emu-note>
            <p>Module Environment Record は strict コード内のみで使用され、strict コードでは delete 演算子が Module Environment Record 束縛へ解決される Reference Record に適用されることを早期エラー規則が防ぐ。<emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref> 参照。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *true* を返す。
          </emu-alg>
          <emu-note>
            <p>Module Environment Record は常に `this` 束縛を提供する。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): *undefined* を含む正常完了</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createimportbinding" type="abstract operation">
          <h1>
            CreateImportBinding (
              _envRec_: Module Environment Record,
              _N_: String,
              _M_: Module Record,
              _N2_: String,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>名前 _N_ の新しい初期化済み不変間接束縛を作成する。_envRec_ に _N_ の束縛は存在してはならない。_N2_ は _M_ の Module Environment Record に存在する束縛名。新束縛の値へのアクセスは対象束縛値を間接的にアクセスする。</dd>
          </dl>
          <emu-alg>
            1. アサート: _envRec_ はまだ _N_ の束縛を持たない。
            1. アサート: _M_.[[Environment]] のインスタンス化時、_N2_ の直接束縛を持つ。
            1. _envRec_ に _M_, _N2_ を対象とする _N_ の不変間接束縛を（初期化済みとして）作成する。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>環境レコード操作 (Environment Record Operations)</h1>
      <p>以下の抽象操作は本仕様で Environment Record を操作するために使用される:</p>

      <emu-clause id="sec-getidentifierreference" type="abstract operation">
        <h1>
          GetIdentifierReference (
            _env_: Environment Record または *null*,
            _name_: String,
            _strict_: Boolean,
          ): Reference Record を含む正常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _env_ が *null* なら
            1. Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } を返す。
          1. _exists_ を ? <emu-meta effects="user-code">_env_.HasBinding</emu-meta>(_name_) とする。
          1. _exists_ が *true* なら
            1. Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } を返す。
          1. それ以外
            1. _outer_ を _env_.[[OuterEnv]] とする。
            1. ? GetIdentifierReference(_outer_, _name_, _strict_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newdeclarativeenvironment" type="abstract operation">
        <h1>
          NewDeclarativeEnvironment (
            _E_: Environment Record または *null*,
          ): Declarative Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 绑定を含まない新しい Declarative Environment Record _env_ を生成する。
          1. _env_.[[OuterEnv]] を _E_ に設定。
          1. _env_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newobjectenvironment" type="abstract operation">
        <h1>
          NewObjectEnvironment (
            _O_: Object,
            _W_: Boolean,
            _E_: Environment Record または *null*,
          ): Object Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 新しい Object Environment Record _env_ を生成する。
          1. _env_.[[BindingObject]] を _O_ に設定。
          1. _env_.[[IsWithEnvironment]] を _W_ に設定。
          1. _env_.[[OuterEnv]] を _E_ に設定。
          1. _env_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newfunctionenvironment" type="abstract operation">
        <h1>
          NewFunctionEnvironment (
            _F_: ECMAScript 関数オブジェクト,
            _newTarget_: Object または *undefined*,
          ): Function Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 束縛を含まない新しい Function Environment Record _env_ を生成。
          1. _env_.[[FunctionObject]] を _F_ に設定。
          1. _F_.[[ThisMode]] が ~lexical~ なら _env_.[[ThisBindingStatus]] を ~lexical~ に設定。
          1. それ以外なら _env_.[[ThisBindingStatus]] を ~uninitialized~ に設定。
          1. _env_.[[NewTarget]] を _newTarget_ に設定。
          1. _env_.[[OuterEnv]] を _F_.[[Environment]] に設定。
          1. _env_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newglobalenvironment" type="abstract operation">
        <h1>
          NewGlobalEnvironment (
            _G_: Object,
            _thisValue_: Object,
          ): Global Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _objRec_ を NewObjectEnvironment(_G_, *false*, *null*) とする。
          1. _dclRec_ を NewDeclarativeEnvironment(*null*) とする。
          1. 新しい Global Environment Record _env_ を生成。
          1. _env_.[[ObjectRecord]] を _objRec_ に設定。
          1. _env_.[[GlobalThisValue]] を _thisValue_ に設定。
          1. _env_.[[DeclarativeRecord]] を _dclRec_ に設定。
          1. _env_.[[OuterEnv]] を *null* に設定。
          1. _env_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newmoduleenvironment" type="abstract operation">
        <h1>
          NewModuleEnvironment (
            _E_: Environment Record,
          ): Module Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 束縛を含まない新しい Module Environment Record _env_ を生成する。
          1. _env_.[[OuterEnv]] を _E_ に設定。
          1. _env_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-privateenvironment-records">
    <h1>PrivateEnvironment レコード</h1>
    <p><dfn id="privateenvironment-record" variants="PrivateEnvironment Records">PrivateEnvironment Record</dfn> は、ECMAScript コード内の |ClassDeclaration| および |ClassExpression| の字句上の入れ子構造に基づいて Private Name を追跡するための仕様上のメカニズムである。Environment Record に類似しているが別個のものである。各 PrivateEnvironment Record は 1 つの |ClassDeclaration| または |ClassExpression| に関連付けられる。そのようなクラスが評価されるたびに、そのクラスで宣言された Private Name を記録する新たな PrivateEnvironment Record が生成される。</p>
    <p>各 PrivateEnvironment Record は <emu-xref href="#table-privateenvironment-records"></emu-xref> で定義されるフィールドを持つ。</p>
    <emu-table id="table-privateenvironment-records" caption="PrivateEnvironment Record のフィールド (PrivateEnvironment Record Fields)">
      <table>
        <thead>
          <tr>
            <th>
              フィールド名
            </th>
            <th>
              値の型
            </th>
            <th>
              意味
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[OuterPrivateEnvironment]]
          </td>
          <td>
            PrivateEnvironment Record または *null*
          </td>
          <td>
            最も近い外側にあるクラスの PrivateEnvironment Record。関連付けられているクラスが他のいかなるクラスにも内包されていない場合は *null*。
          </td>
        </tr>
        <tr>
          <td>
            [[Names]]
          </td>
          <td>
            Private Name の List
          </td>
          <td>
            このクラスによって宣言された Private Name 群。
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-privateenvironment-record-operations">
      <h1>PrivateEnvironment Record の操作</h1>
      <p>本仕様で PrivateEnvironment Record を操作するために以下の抽象操作を用いる:</p>

      <emu-clause id="sec-newprivateenvironment" type="abstract operation">
        <h1>
          NewPrivateEnvironment (
            _outerPrivateEnv_: a PrivateEnvironment Record or *null*,
          ): a PrivateEnvironment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _names_ を新しい空の List とする。
          1. PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivateEnv_, [[Names]]: _names_ } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-resolve-private-identifier" type="abstract operation">
        <h1>
          ResolvePrivateIdentifier (
            _privateEnv_: a PrivateEnvironment Record,
            _identifier_: a String,
          ): a Private Name
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _names_ を _privateEnv_.[[Names]] とする。
          1. _names_ の各 Private Name _pn_ について、
            1. _pn_.[[Description]] が _identifier_ であるなら
              1. _pn_ を返す。
          1. _outerPrivateEnv_ を _privateEnv_.[[OuterPrivateEnvironment]] とする。
          1. アサート: _outerPrivateEnv_ は *null* ではない。
          1. ResolvePrivateIdentifier(_outerPrivateEnv_, _identifier_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-code-realms">
    <h1>Realm</h1>
    <p>評価される前に、すべての ECMAScript コードは <dfn id="realm" variants="realms">realm</dfn> に関連付けられなければならない。概念的には realm は一連の組み込みオブジェクト、ECMAScript のグローバル環境、そのグローバル環境のスコープ内で読み込まれるすべての ECMAScript コード、及びその他関連する状態とリソースから構成される。</p>
    <p>realm は本仕様では <emu-xref href="#table-realm-record-fields"></emu-xref> に示すフィールドを持つ <dfn id="realm-record" variants="Realm Records">Realm Record</dfn> として表現される:</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record のフィールド (Realm Record Fields)" oldids="table-21">
      <table>
        <thead>
          <tr>
            <th>
              フィールド名
            </th>
            <th>
              値
            </th>
            <th>
              意味
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[AgentSignifier]]
          </td>
          <td>
            agent signifier
          </td>
          <td>
            この realm を所有する agent
          </td>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td>
            フィールド名が intrinsic key で値がオブジェクトである Record
          </td>
          <td>
            この realm に関連付けられたコードが使用する intrinsic 値
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td>
            Object
          </td>
          <td>
            この realm の global object
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td>
            Global Environment Record
          </td>
          <td>
            この realm のグローバル環境
          </td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td>
            [[Site]] (|TemplateLiteral| Parse Node) と [[Array]] (Array) を持つ Record の List
          </td>
          <td>
            <p>テンプレートオブジェクトは各 realm ごとにその Realm Record の [[TemplateMap]] を用いて正規化される。各 [[Site]] は |TemplateLiteral| である Parse Node。対応する [[Array]] はタグ関数へ渡されるテンプレートオブジェクト。</p>
            <emu-note>Parse Node が到達不能となった場合、対応する [[Array]] も到達不能となり、実装がその組を [[TemplateMap]] から除去しても観測不可能である。</emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[LoadedModules]]
          </td>
          <td>
            LoadedModuleRequest Record の List
          </td>
          <td>
            <p>この realm が import した specifier 文字列から解決済み Module Record への写像。ModuleRequestsEqual(_r1_, _r2_) が *true* となる異なる Record _r1_ と _r2_ を 2 つ含まない。</p>
            <emu-note>
              HostLoadImportedModule (<emu-xref href="#note-HostLoadImportedModule-referrer-Realm-Record"></emu-xref>) で述べられるように、Realm Record の [[LoadedModules]] はアクティブな script や module が存在しない文脈で `import()` 式を実行する場合にのみ使用される。
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td>
            任意 (既定値 *undefined*)
          </td>
          <td>
            Realm Record に追加情報を関連付ける必要があるホストが使用するために予約されたフィールド。
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-initializehostdefinedrealm" type="abstract operation" oldids="sec-createrealm,sec-setrealmglobalobject">
      <h1>InitializeHostDefinedRealm ( ): ~unused~ を含む正常完了または throw 完了</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _realm_ を新しい Realm Record とする。
        1. CreateIntrinsics(_realm_) を実行。
        1. _realm_.[[AgentSignifier]] を AgentSignifier() に設定。
        1. _realm_.[[TemplateMap]] を新しい空の List に設定。
        1. _newContext_ を新しい実行コンテキストとする。
        1. _newContext_ の Function を *null* に設定。
        1. _newContext_ の Realm を _realm_ に設定。
        1. _newContext_ の ScriptOrModule を *null* に設定。
        1. 実行コンテキストスタックに _newContext_ を push する; _newContext_ が現在の実行コンテキストとなる。
        1. ホストが _realm_ の global object として奇異 (exotic) オブジェクトを要求する場合、
          1. _global_ をホスト定義の方法で作成されたそのようなオブジェクトとする。
        1. それ以外、
          1. _global_ を OrdinaryObjectCreate(_realm_.[[Intrinsics]].[[%Object.prototype%]]) とする。
        1. ホストが _realm_ のグローバルスコープにおける `this` 束縛が global object とは異なるオブジェクトを返すことを要求する場合、
          1. _thisValue_ をホスト定義の方法で作成されたそのようなオブジェクトとする。
        1. それ以外、
          1. _thisValue_ を _global_ とする。
        1. _realm_.[[GlobalObject]] を _global_ に設定。
        1. _realm_.[[GlobalEnv]] を NewGlobalEnvironment(_global_, _thisValue_) に設定。
        1. ? SetDefaultGlobalBindings(_realm_) を実行。
        1. ホスト定義のグローバルオブジェクトプロパティを _global_ 上に作成する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createintrinsics" type="abstract operation">
      <h1>
        CreateIntrinsics (
          _realmRec_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _realmRec_.[[Intrinsics]] を新しい Record に設定。
        1. [declared="steps,name,length,slots,prototype"] _realmRec_.[[Intrinsics]] のフィールドを <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref> に列挙される値で設定する。フィールド名は表の第 1 列の名前。各フィールドの値は、<emu-xref href="#sec-global-object"></emu-xref> から <emu-xref href="#sec-reflection"></emu-xref> の各節で定義されたとおりのプロパティ値で完全かつ再帰的に埋められた新しいオブジェクト値。すべてのオブジェクトプロパティ値は新たに作成されるオブジェクト値。ビルトイン関数オブジェクトとなる値はすべて CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) を実行して作成される。ここで _steps_ は本仕様で提供されるその関数の定義、_name_ は関数の *"name"* プロパティの初期値、_length_ は *"length"* プロパティの初期値、_slots_ はその関数に指定された内部スロット名（存在する場合）のリスト、_prototype_ はその関数の [[Prototype]] 内部スロットの指定値。intrinsic とそのプロパティの生成順序は未生成のオブジェクトに依存しないよう配慮しなければならない。
        1. AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_) を実行。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setdefaultglobalbindings" type="abstract operation">
      <h1>
        SetDefaultGlobalBindings (
          _realmRec_: a Realm Record,
        ): ~unused~ を含む正常完了または throw 完了
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _global_ を _realmRec_.[[GlobalObject]] とする。
        1. 節 <emu-xref href="#sec-global-object"></emu-xref> で指定される Global Object の各プロパティについて、
          1. _name_ をプロパティ名の String 値とする。
          1. _desc_ をそのプロパティに対して指定された属性を含む、完全に埋められたデータ Property Descriptor とする。<emu-xref href="#sec-function-properties-of-the-global-object"></emu-xref>、<emu-xref href="#sec-constructor-properties-of-the-global-object"></emu-xref>、または <emu-xref href="#sec-other-properties-of-the-global-object"></emu-xref> に列挙されたプロパティについては [[Value]] 属性の値は _realmRec_ から対応する intrinsic オブジェクト。
          1. ? DefinePropertyOrThrow(_global_, _name_, _desc_) を実行。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>実行コンテキスト (Execution Contexts)</h1>
    <p><dfn variants="execution contexts">execution context</dfn> は、ECMAScript 実装によるコードの実行時評価を追跡するために用いられる仕様デバイスである。任意の時点で、実際にコードを実行している agent ごとに高々 1 つの実行コンテキストが存在する。これをその agent の <dfn id="running-execution-context" variants="running execution contexts">実行中実行コンテキスト (running execution context)</dfn> と呼ぶ。本仕様中で実行中実行コンテキストへの参照は常に囲んでいる agent の実行中実行コンテキストを指す。</p>
    <p><dfn id="execution-context-stack" variants="execution context stacks">実行コンテキストスタック (execution context stack)</dfn> は実行コンテキストを追跡するために使用される。実行中実行コンテキストは常にこのスタックの最上位要素である。現在の実行中実行コンテキストに関連付く実行可能コードから、関連付いていない別の実行可能コードへ制御が移るたびに新しい実行コンテキストが生成される。新たな実行コンテキストはスタックに push され、実行中実行コンテキストとなる。</p>
    <p>実行コンテキストは、関連コードの実行進行状況を追跡するために必要な実装依存状態を保持する。各実行コンテキストは少なくとも <emu-xref href="#table-state-components-for-all-execution-contexts"></emu-xref> に列挙される状態コンポーネントを持つ。</p>
    <emu-table id="table-state-components-for-all-execution-contexts" caption="すべての実行コンテキストに共通の状態コンポーネント (State Components for All Execution Contexts)" oldids="table-22">
      <table>
        <thead>
          <tr>
            <th>
              コンポーネント
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            code evaluation state
          </td>
          <td>
            この実行コンテキストに関連するコードの評価・一時停止・再開を行うために必要なあらゆる状態。
          </td>
        </tr>
        <tr>
          <td>
            Function
          </td>
          <td>
            この実行コンテキストが関数オブジェクトのコードを評価しているなら、値はその関数オブジェクト。|Script| または |Module| のコードを評価しているなら値は *null*。
          </td>
        </tr>
        <tr>
          <td>
            Realm
          </td>
          <td>
            関連コードが ECMAScript リソースにアクセスする際の Realm Record。
          </td>
        </tr>
        <tr>
          <td>
            ScriptOrModule
          </td>
          <td>
            関連コードの起源となる Module Record または Script Record。起源となる script / module が存在しない (InitializeHostDefinedRealm で生成された元の実行コンテキスト等) 場合は *null*。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>実行中実行コンテキストによるコード評価は本仕様で定義された様々な地点で一時停止され得る。一度一時停止されると別の実行コンテキストが実行中実行コンテキストとなり自身のコード評価を開始し得る。後で一時停止中の実行コンテキストが再び実行中となり、以前に一時停止された地点から評価を継続し得る。実行中実行コンテキストの状態移行は通常スタック的 (LIFO) に行われるが、いくつかの ECMAScript 機能では非 LIFO の遷移が必要である。</p>
    <p>実行中実行コンテキストの Realm コンポーネントの値は <dfn id="current-realm">current Realm Record</dfn> とも呼ばれる。Function コンポーネントの値は <dfn id="active-function-object">active function object</dfn> とも呼ばれる。</p>
    <p><dfn id="ecmascript-code-execution-context" variants="ECMAScript code execution context">ECMAScript コード実行コンテキスト</dfn> は <emu-xref href="#table-additional-state-components-for-ecmascript-code-execution-contexts"></emu-xref> に列挙される追加状態コンポーネントを持つ。</p>
    <emu-table id="table-additional-state-components-for-ecmascript-code-execution-contexts" caption="ECMAScript コード実行コンテキストの追加状態コンポーネント (Additional State Components for ECMAScript Code Execution Contexts)" oldids="table-23">
      <table>
        <thead>
          <tr>
            <th>
              コンポーネント
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            この実行コンテキスト内のコードが識別子参照を解決するために使用する Environment Record。
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            この実行コンテキスト内の |VariableStatement| によって作成された束縛を保持する Environment Record。
          </td>
        </tr>
        <tr>
          <td>
            PrivateEnvironment
          </td>
          <td>
            最も近い外側のクラス内で |ClassElement| により生成された Private Name を保持する PrivateEnvironment Record。内包するクラスが無ければ *null*。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>実行コンテキストの LexicalEnvironment および VariableEnvironment コンポーネントは常に Environment Record である。</p>
    <p>Generator の評価を表す実行コンテキストは <emu-xref href="#table-additional-state-components-for-generator-execution-contexts"></emu-xref> に示す追加状態コンポーネントを持つ。</p>
    <emu-table id="table-additional-state-components-for-generator-execution-contexts" caption="Generator 実行コンテキストの追加状態コンポーネント (Additional State Components for Generator Execution Contexts)" oldids="table-24">
      <table>
        <thead>
          <tr>
            <th>
              コンポーネント
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Generator
          </td>
          <td>
            この実行コンテキストが評価している Generator。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>ほとんどの場合、本仕様のアルゴリズムが直接操作するのは実行中実行コンテキスト（スタック頂上）のみである。したがって「LexicalEnvironment」や「VariableEnvironment」という語が修飾なしに使われるとき、それは実行中実行コンテキストのそれらを指す。</p>
    <p>実行コンテキストは純粋に仕様上のメカニズムであり、ECMAScript 実装の特定成果物に対応する必要はない。ECMAScript コードから実行コンテキストへ直接アクセスや観測を行うことは不可能である。</p>

    <emu-clause id="sec-getactivescriptormodule" type="abstract operation">
      <h1>GetActiveScriptOrModule ( ): a Script Record, a Module Record, or *null*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>実行中実行コンテキストに基づき、実行中の script または module を決定するために用いられる。</dd>
      </dl>

      <emu-alg>
        1. 実行コンテキストスタックが空なら *null* を返す。
        1. _ec_ を、実行コンテキストスタック上で最上位から見て ScriptOrModule コンポーネントが *null* でない最初の実行コンテキストとする。
        1. そのような実行コンテキストが存在しなければ *null* を返し、存在するなら _ec_ の ScriptOrModule を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resolvebinding" type="abstract operation">
      <h1>
        ResolveBinding (
          _name_: a String,
          optional _env_: an Environment Record or *undefined*,
        ): either a normal completion containing a Reference Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_name_ の束縛を決定するために用いられる。_env_ は探索対象の Environment Record を明示的に与えるために使用できる。</dd>
      </dl>
      <emu-alg>
        1. _env_ が与えられていない、または _env_ が *undefined* なら
          1. _env_ を実行中実行コンテキストの LexicalEnvironment に設定する。
        1. アサート: _env_ は Environment Record である。
        1. _strict_ を評価されつつある構文生成規則に対する IsStrict の結果とする。
        1. ? GetIdentifierReference(_env_, _name_, _strict_) を返す。
      </emu-alg>
      <emu-note>
        <p>ResolveBinding の結果は常に [[ReferencedName]] フィールドが _name_ である Reference Record である。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-getthisenvironment" type="abstract operation">
      <h1>GetThisEnvironment ( ): an Environment Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>現在 `this` の束縛を提供している Environment Record を見つける。</dd>
      </dl>
      <emu-alg>
        1. _env_ を実行中実行コンテキストの LexicalEnvironment とする。
        1. [id="step-getthisenvironment-loop"] 繰り返し:
          1. _exists_ を _env_.HasThisBinding() とする。
          1. _exists_ が *true* なら _env_ を返す。
          1. _outer_ を _env_.[[OuterEnv]] とする。
          1. アサート: _outer_ は *null* ではない。
          1. _env_ を _outer_ に設定する。
      </emu-alg>
      <emu-note>
        <p>ステップ <emu-xref href="#step-getthisenvironment-loop"></emu-xref> のループは、連鎖が常に `this` 束縛を持つグローバル環境で終わるため必ず停止する。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-resolvethisbinding" type="abstract operation">
      <h1>ResolveThisBinding ( ): either a normal completion containing an ECMAScript language value or a throw completion</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>実行中実行コンテキストの LexicalEnvironment を用いてキーワード `this` の束縛を決定する。</dd>
      </dl>
      <emu-alg>
        1. _envRec_ を GetThisEnvironment() とする。
        1. ? _envRec_.GetThisBinding() を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getnewtarget" type="abstract operation">
      <h1>GetNewTarget ( ): an Object or *undefined*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>実行中実行コンテキストの LexicalEnvironment を用いて NewTarget 値を決定する。</dd>
      </dl>
      <emu-alg>
        1. _envRec_ を GetThisEnvironment() とする。
        1. アサート: _envRec_ は [[NewTarget]] フィールドを持つ。
        1. _envRec_.[[NewTarget]] を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getglobalobject" type="abstract operation">
      <h1>GetGlobalObject ( ): an Object</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>現在実行中の実行コンテキストが使用するグローバルオブジェクトを返す。</dd>
      </dl>
      <emu-alg>
        1. _currentRealm_ を current Realm Record とする。
        1. _currentRealm_.[[GlobalObject]] を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-jobs" oldids="sec-jobs-and-job-queues,sec-enqueuejob,sec-runjobs,job-queue">
    <h1>Job と Job をキューに入れるためのホスト操作 (Jobs and Host Operations to Enqueue Jobs)</h1>
    <p><dfn id="job" variants="Jobs">Job</dfn> とは、他の ECMAScript 計算が現在進行中でないときに ECMAScript 計算を開始する、引数を持たない Abstract Closure である。</p>
    <p>Job は特定の agent 内で ECMAScript ホスト環境によって実行がスケジュールされる。本仕様は、HostEnqueueGenericJob、HostEnqueueFinalizationRegistryCleanupJob、HostEnqueuePromiseJob、および HostEnqueueTimeoutJob というホストフックを記述し、Job をスケジュールする。これらのホストフックは、Job のスケジューリングに課される追加制約によって整理されている。ホストは追加で Job をスケジュールする抽象操作を定義してよい。そのような操作は Job Abstract Closure と realm（Realm Record または *null*）を引数に取る。Realm Record が与えられた場合、これらの操作は、その realm を所有する agent において、指定された将来時点でその realm において Job を実行するようスケジュールする。realm に *null* が与えられた場合、その Job は ECMAScript コードを評価しない。実装は以下の要件に従わなければならない:</p>

    <ul>
      <li>将来のある時点で、Job がスケジュールされた agent に実行中コンテキストが無く、その agent の実行コンテキストスタックが空であるとき、実装は以下を行わなければならない:
        <ol>
          <li>ホスト定義の準備ステップを実行する。</li>
          <li><emu-not-ref>Invoke</emu-not-ref> して Job Abstract Closure を呼び出す。</li>
          <li>ホスト定義の後片付けステップを実行し、その後で実行コンテキストスタックは空でなければならない。</li>
        </ol>
      </li>
      <li>任意の時点で 1 つの agent では同時に評価進行中となれる Job は高々 1 つである。</li>
      <li>ある Job の評価が開始したら、その agent で他のどの Job の評価が開始するよりも前に完了まで走り切らなければならない。</li>
      <li>Abstract Closure は正常完了を返さなければならず、エラー処理は自身で実装する。</li>
    </ul>

    <emu-note>
      ホスト環境はスケジューリングに関して Job を一様に扱う必要はない。例えば、Web ブラウザや Node.js は Promise 処理の Job を他の作業より高優先度で扱う。将来の機能追加により、必ずしも高優先度で扱われない新たな Job が追加されるかもしれない。
    </emu-note>

    <p>任意の時点で、_scriptOrModule_（Script Record、Module Record、または *null*）が次の条件をすべて満たすなら、その時点の <dfn id="job-activescriptormodule">active script or module</dfn> である:</p>
    <ul>
      <li>GetActiveScriptOrModule() が _scriptOrModule_ である。</li>
      <li>_scriptOrModule_ が Script Record または Module Record の場合、_ec_ を実行コンテキストスタック上で ScriptOrModule コンポーネントが _scriptOrModule_ である最上位の実行コンテキストとする。_ec_ の Realm コンポーネントは _scriptOrModule_.[[Realm]] である。</li>
    </ul>

    <p>任意の時点で、次の条件をすべて満たすとき、その実行は <dfn id="job-preparedtoevaluatecode">prepared to evaluate ECMAScript code</dfn> である:</p>
    <ul>
      <li>実行コンテキストスタックは空ではない。</li>
      <li>実行コンテキストスタック上で最上位の実行コンテキストの Realm コンポーネントは Realm Record である。</li>
    </ul>

    <emu-note>
      <p>ホスト環境は実行コンテキストを実行コンテキストスタックに push することでコード評価の準備を行うことができる。具体的な手順は実装定義である。</p>
      <p>Realm の具体的選択はホスト環境次第である。この初期実行コンテキストと Realm は、任意のコールバック関数が呼ばれる前にのみ使用される。Promise ハンドラのような Job 関連のコールバック関数が呼び出されると、その呼び出しは独自の実行コンテキストと Realm を push する。</p>
    </emu-note>

    <p>特定種類の Job には追加の適合要件が存在する。</p>

    <emu-clause id="sec-jobcallback-records">
      <h1>JobCallback Record</h1>
      <p><dfn variants="JobCallback Records">JobCallback Record</dfn> は関数オブジェクトとホスト定義値を格納するための Record 値である。ホストによってキューに入れられた Job を通じて呼び出される関数オブジェクトは追加のホスト定義コンテキストを持ち得る。その状態を伝播するために、Job Abstract Closure は関数オブジェクトを直接捕捉して呼び出すべきではない。代わりに HostMakeJobCallback と HostCallJobCallback を用いる。</p>
      <emu-note>
        <p>例えば WHATWG HTML 仕様 (<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>) は、ホスト定義値を用いて Promise コールバック用の incumbent settings object を伝播する。</p>
      </emu-note>
      <p>JobCallback Record は <emu-xref href="#table-jobcallback-records"></emu-xref> に列挙するフィールドを持つ。</p>
      <emu-table id="table-jobcallback-records" caption="JobCallback Record のフィールド (JobCallback Record Fields)">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Callback]]
            </td>
            <td>
              a function object
            </td>
            <td>
              Job が呼び出されたときに実行する関数。
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (default value is ~empty~)
            </td>
            <td>
              ホストが使用するために予約されたフィールド。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-hostmakejobcallback" type="host-defined abstract operation">
      <h1>
        HostMakeJobCallback (
          _callback_: a function object,
        ): a JobCallback Record
      </h1>
      <dl class="header">
      </dl>
      <p>HostMakeJobCallback の実装は次の要件に従わなければならない:</p>
      <ul>
        <li>[[Callback]] フィールドが _callback_ である JobCallback Record を返さなければならない。</li>
      </ul>
      <p>HostMakeJobCallback のデフォルト実装は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ } を返す。
      </emu-alg>
      <p>Web ブラウザではない ECMAScript ホストは HostMakeJobCallback のデフォルト実装を使用しなければならない。</p>
      <emu-note>
        <p>これは、コールバックが最終的にスケジュールされ実行される責任を持つ関数に渡される時点で呼ばれる。例えば `promise.then(thenAction)` はリアクション Job のスケジュール時ではなく `Promise.prototype.then` 呼び出し時に thenAction に対して MakeJobCallback を呼ぶ。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostcalljobcallback" type="host-defined abstract operation">
      <h1>
        HostCallJobCallback (
          _jobCallback_: a JobCallback Record,
          _V_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing an ECMAScript language value or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <p>HostCallJobCallback の実装は次の要件に従わなければならない:</p>
      <ul>
        <li>Call(_jobCallback_.[[Callback]], _V_, _argumentsList_) を実行しその結果を返さなければならない。</li>
      </ul>
      <emu-note>
        <p>この要件は、ホストが本仕様で定義される関数オブジェクトの [[Call]] の振る舞いを変更できないことを意味する。</p>
      </emu-note>
      <p>HostCallJobCallback のデフォルト実装は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. アサート: IsCallable(_jobCallback_.[[Callback]]) is *true*.
        1. ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_) を返す。
      </emu-alg>
      <p>Web ブラウザではない ECMAScript ホストは HostCallJobCallback のデフォルト実装を使用しなければならない。</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuegenericjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueGenericJob (
          _job_: a Job Abstract Closure,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_realm_.[[AgentSignifier]] で示される agent において realm _realm_ で将来のある時点に _job_ をスケジュールする。このアルゴリズムと共に用いられる Abstract Closure は、優先度や順序付けといった追加制約なくスケジュールされることを意図している。</dd>
      </dl>
      <p>HostEnqueueGenericJob の実装は <emu-xref href="#sec-jobs"></emu-xref> の要件に従わなければならない。</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuepromisejob" type="host-defined abstract operation">
      <h1>
        HostEnqueuePromiseJob (
          _job_: a Job Abstract Closure,
          _realm_: a Realm Record or *null*,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将来のある時点に _job_ をスケジュールする。このアルゴリズムと共に用いられる Abstract Closure は、Promise の処理に関連するか、さもなくば Promise 処理操作と同等の優先度でスケジュールされることを意図している。</dd>
      </dl>

      <p>HostEnqueuePromiseJob の実装は <emu-xref href="#sec-jobs"></emu-xref> の要件に加えて以下に従わなければならない:</p>
      <ul>
        <li>_realm_ が *null* でないなら、_job_ が呼び出されるたびに、その時点で ECMAScript コードを評価する準備が整うよう実装定義ステップを実行しなければならない。</li>
        <li>_scriptOrModule_ を HostEnqueuePromiseJob が呼び出された時点での GetActiveScriptOrModule() とする。_realm_ が *null* でないなら、_job_ が呼び出されるたびに、その呼び出しの時点で _scriptOrModule_ が active script or module であるよう実装定義ステップを実行しなければならない。</li>
        <li>Job はそれらをスケジュールした HostEnqueuePromiseJob 呼び出しと同じ順序で実行されなければならない。</li>
      </ul>

      <emu-note>
        <p>NewPromiseResolveThenableJob が返す Job の _realm_ は通常 _then_ 関数オブジェクトに対して GetFunctionRealm を呼び出した結果である。NewPromiseReactionJob が返す Job の _realm_ は、ハンドラが *undefined* でない場合そのハンドラに対して GetFunctionRealm を呼び出した結果が通常使われる。ハンドラが *undefined* の場合、_realm_ は *null*。どちらの種類の Job でも、GetFunctionRealm が異常終了する（例: revoke 済み Proxy に対して呼び出された）とき、_realm_ はその GetFunctionRealm 呼び出し時の現在の Realm Record となる。_realm_ が *null* の場合、ユーザ ECMAScript コードは評価されず、新しい ECMAScript オブジェクト（例えば Error オブジェクト）は生成されない。例えば WHATWG HTML 仕様 (<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>) はスクリプト実行可能性の確認および <a href="https://html.spec.whatwg.org/#entry">entry</a> の概念のために _realm_ を使用する。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostenqueuetimeoutjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueTimeoutJob (
          _timeoutJob_: a Job Abstract Closure,
          _realm_: a Realm Record,
          _milliseconds_: a non-negative finite Number,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_realm_.[[AgentSignifier]] で示される agent の realm _realm_ において、少なくとも _milliseconds_ ミリ秒後に _timeoutJob_ を実行するようスケジュールする。</dd>
      </dl>
      <p>HostEnqueueTimeoutJob の実装は <emu-xref href="#sec-jobs"></emu-xref> の要件に従わなければならない。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agents">
    <h1>Agent</h1>

    <p><dfn id="agent" variants="agents">agent</dfn> は一組の ECMAScript 実行コンテキスト、実行コンテキストスタック、実行中実行コンテキスト、<dfn id="agent-record" variants="Agent Records">Agent Record</dfn>、および <dfn id="executing-thread" variants="executing threads">executing thread</dfn> から構成される。executing thread を除き、agent の構成要素はその agent にのみ属する。</p>
    <p>agent の executing thread は他の agent と独立してその agent の実行コンテキスト上でアルゴリズムステップを実行する。ただし、[[CanBlock]] フィールドが *true* である Agent Record を持つ agent が共有していない限り、1 つの executing thread を複数の agent で共有してもよい。</p>
    <emu-note>
      <p>例えば一部の Web ブラウザでは、ブラウザウィンドウの複数の無関係なタブ間で単一の executing thread を共有する。</p>
    </emu-note>
    <p>agent の executing thread がアルゴリズムステップを実行している間、その agent はそれらのステップにとっての <dfn id="surrounding-agent" variants="surrounding agents">surrounding agent</dfn> である。ステップは surrounding agent を用いて、agent 内に保持された仕様レベルの実行オブジェクト（実行中実行コンテキスト、実行コンテキストスタック、Agent Record のフィールド）へアクセスする。</p>
    <p><dfn variants="agent signifiers">agent signifier</dfn> は Agent を識別するために用いられるグローバル一意の不透明値である。</p>
    <emu-table id="table-agent-record" caption="Agent Record のフィールド (Agent Record Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>a Boolean</td>
          <td>アルゴリズム GetValueFromBuffer と SetValueInBuffer で必要なときに <em>isLittleEndian</em> 引数の既定値として計算される値。選択は実装定義であり、実装にとって最も効率的な方を選ぶべき。この値が一度観測された後は変更できない。</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>a Boolean</td>
          <td>その agent がブロック可能かどうかを決定する。</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>an agent signifier</td>
          <td>agent クラスタ内で agent を一意に識別する。</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>a Boolean</td>
          <td>*true* の場合 1 <emu-not-ref>byte 値</emu-not-ref> 上のアトミック操作は lock-free、そうでなければ *false*。</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>a Boolean</td>
          <td>*true* の場合 2 <emu-not-ref>byte 値</emu-not-ref> 上のアトミック操作は lock-free、そうでなければ *false*。</td>
        </tr>
        <tr>
          <td>[[IsLockFree8]]</td>
          <td>a Boolean</td>
          <td>*true* の場合 8 <emu-not-ref>byte 値</emu-not-ref> 上のアトミック操作は lock-free、そうでなければ *false*。</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>a candidate execution Record</td>
          <td>メモリモデル参照。</td>
        </tr>
        <tr>
          <td>[[KeptAlive]]</td>
          <td>a List of either Objects or Symbols</td>
          <td>初期状態は空の新しい List。現在の Job の終了まで生存させるオブジェクトやシンボルのリスト。</td>
        </tr>
        <tr>
          <td>[[ModuleAsyncEvaluationCount]]</td>
          <td>an integer</td>
          <td>初期値 0。非同期または非同期依存を持つモジュールの [[AsyncEvaluationOrder]] フィールドに一意の増加値を割り当てるために用いられる。</td>
        </tr>
      </table>
    </emu-table>

    <p>[[Signifier]]、[[IsLockFree1]]、[[IsLockFree2]] の値は、一度クラスタ内のいずれかの agent により観測された後は変更できない。</p>

    <emu-note>
      <p>[[IsLockFree1]] と [[IsLockFree2]] の値は必ずしもハードウェアだけで決定されるわけではなく、時間経過や ECMAScript 実装間で異なりうる実装上の選択を反映することがある。</p>

      <p>[[IsLockFree4]] フィールドは存在しない: 4 バイトのアトミック操作は常に lock-free である。</p>

      <p>実際には、アトミック操作が何らかのロックを用いて実装されているなら、その操作は lock-free ではない。lock-free は wait-free を意味しない: lock-free なアトミック操作を完了するのに必要なマシンステップ数に上限はない。</p>

      <p>サイズ <em>n</em> のアトミックアクセスが lock-free であることは、同サイズの非アトミックアクセスの（知覚される）アトミシティについて何も意味しない。具体的には、非アトミックアクセスは複数のメモリアクセス列として実行され得る。詳細は ReadSharedMemory および WriteSharedMemory を参照。</p>
    </emu-note>

    <emu-note>
      <p>agent は仕様上のメカニズムであり、ECMAScript 実装の特定成果物に対応する必要はない。</p>
    </emu-note>

    <emu-clause id="sec-agentsignifier" type="abstract operation">
      <h1>AgentSignifier ( ): an agent signifier</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_ を surrounding agent の Agent Record とする。
        1. _AR_.[[Signifier]] を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-agentcansuspend" type="abstract operation">
      <h1>AgentCanSuspend ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_ を surrounding agent の Agent Record とする。
        1. _AR_.[[CanBlock]] を返す。
      </emu-alg>
      <emu-note>
        <p>環境によっては、特定の agent をサスペンドすることが妥当でない場合がある。例えば Web ブラウザ環境では、ドキュメントのメインイベントハンドリングスレッドのサスペンドを禁止しつつ、worker のイベントハンドリングスレッドはサスペンドを許容することが妥当かもしれない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-IncrementModuleAsyncEvaluationCount" type="abstract operation">
      <h1>IncrementModuleAsyncEvaluationCount ( ): an integer</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_ を surrounding agent の Agent Record とする。
        1. _count_ を _AR_.[[ModuleAsyncEvaluationCount]] とする。
        1. _AR_.[[ModuleAsyncEvaluationCount]] を _count_ + 1 に設定。
        1. _count_ を返す。
      </emu-alg>
      <emu-note>
        <p>この値は保留中モジュール間の相対評価順を追跡するためだけに使用される。実装は、保留中モジュールが無いときは [[ModuleAsyncEvaluationCount]] を観測不能な形で 0 にリセットしてよい。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agent-clusters">
    <h1>Agent Cluster</h1>

    <p><dfn variants="agent clusters">agent cluster</dfn> とは、共有メモリ操作によって通信可能な agent の極大集合である。</p>

    <emu-note>
      <p>異なる agent 内のプログラムは未規定の手段によってメモリを共有しうる。最小でも SharedArrayBuffer の裏付けメモリはクラスタ内の agent 間で共有可能である。</p>

      <p>メッセージパッシングで通信可能だがメモリを共有できない agent が存在するかもしれない。そのような agent は同じ agent cluster にはならない。</p>
    </emu-note>

    <p>すべての agent は正確に 1 つの agent cluster に属する。</p>

    <emu-note>
      <p>クラスタ内の agent が特定時点で全て生存している必要はない。agent <b>A</b> が agent <b>B</b> を生成し、その後 <b>A</b> が終了し <b>B</b> が agent <b>C</b> を生成した場合、<b>A</b> が <b>B</b> とメモリを共有し得て、<b>B</b> が <b>C</b> とメモリを共有し得るなら、3 つの agent は同一クラスタである。</p>
    </emu-note>

    <p>クラスタ内のすべての agent は、それぞれの Agent Record の [[LittleEndian]] フィールドについて同じ値を持たなければならない。</p>

    <emu-note>
      <p>クラスタ内で異なる [[LittleEndian]] 値を持つ agent があると、マルチバイトデータに対し共有メモリを使うのが困難になる。</p>
    </emu-note>

    <p>クラスタ内のすべての agent は、それぞれの Agent Record の [[IsLockFree1]] フィールドについて同じ値を持たなければならない; [[IsLockFree2]] フィールドについても同様。</p>

    <p>クラスタ内のすべての agent は、それぞれの Agent Record の [[Signifier]] フィールドについて互いに異なる値を持たなければならない。</p>

    <p>埋め込み環境 (embedding) は agent の知識や協力なしに agent を非アクティブ化（進行停止）またはアクティブ化（進行再開）してよい。埋め込み環境がそれを行う場合、クラスタ内で一部の agent を非アクティブ化したまま他を無期限にアクティブにしてはならない。</p>

    <emu-note>
      <p>上記制約の目的は、他の agent が非アクティブ化されたために agent がデッドロックまたはスターブする状況を避けることである。例えば、HTML shared worker がウィンドウ内ドキュメントと独立したライフタイムを持ち、その shared worker がそのような独立ドキュメントの dedicated worker とメモリ共有を許される場合、ドキュメントとその dedicated worker が dedicated worker がロックを保持した状態で非アクティブ化され（例えばドキュメントが履歴に保存される等）、shared worker がそのロック取得を試みた場合、shared worker は dedicated worker が再びアクティブ化されるまでブロックされる（場合によっては永久に）。その間、他ウィンドウから shared worker へアクセスしようとする他の worker はスターブする。</p>

      <p>この制約の含意は、埋め込み環境内で同一のサスペンド／ウェイク集団に属さない agent 同士ではメモリ共有が不可能になるということである。</p>
    </emu-note>

    <p>埋め込み環境は agent のクラスタ内の他の agent の事前の知識や協力なしに agent を終了させてもよい。agent が自身またはクラスタ内の他の agent のプログラム的作用によってではなくクラスタ外の要因によって終了させられる場合、埋め込み環境は 2 つの戦略のいずれかを選ばなければならない: すべての agent を終了させるか、またはクラスタ内の agent が協調できる信頼性のある API を提供し、クラスタの少なくとも 1 つの残存メンバが終了を検出できるようにし、終了データには終了した agent を識別する十分な情報を含める。</p>

    <emu-note>
      <p>その種の終了例: 別プロセスで動作する agent を OS またはユーザが終了させる; per-agent リソース計測が runaway と示したときに、他の agent と同一プロセスで動作する agent を埋め込み環境自身が終了させる、等。</p>
    </emu-note>

    <p>以下の仕様値およびそれらから推移的に到達可能な値はそれぞれ正確に 1 つの agent cluster に属する。</p>
    <ul>
      <li>candidate execution Record</li>
      <li>Shared Data Block</li>
      <li>WaiterList Record</li>
    </ul>

    <p>クラスタ内の任意の agent が ECMAScript コードを評価する前に、クラスタ内すべての agent の Agent Record の [[CandidateExecution]] フィールドは初期 candidate execution に設定される。初期 candidate execution は空の candidate execution で、[[EventsRecords]] フィールドは各 agent について、その [[AgentSignifier]] フィールドがその agent の agent signifier で、[[EventList]] と [[AgentSynchronizesWith]] フィールドが空の List である Agent Events Record を含む List である。</p>

    <emu-note>
      <p>agent cluster 内のすべての agent は Agent Record の [[CandidateExecution]] フィールド内で同じ candidate execution を共有する。candidate execution はメモリモデルで使用される仕様メカニズムである。</p>
    </emu-note>

    <emu-note>
      <p>agent cluster は仕様メカニズムであり、ECMAScript 実装の特定成果物に対応する必要はない。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-forward-progress">
    <h1>Forward Progress</h1>
    <p>agent が <em>forward progress を行う (make forward progress)</em> とは、本仕様に従って評価ステップを 1 つ実行することである。</p>
    <p>agent の実行中実行コンテキストが外部イベントを同期的かつ無期限に待機すると、その agent は <em>blocked</em> になる。この意味で blocked になり得るのは Agent Record の [[CanBlock]] フィールドが *true* の agent のみである。<em>unblocked</em> agent とは blocked でない agent である。</p>

    <p>実装は以下を保証しなければならない:</p>
    <ul>
      <li>専用 executing thread を持つ全ての unblocked agent は最終的に forward progress を行う</li>
      <li>executing thread を共有する agent の集合では、いずれか 1 つの agent が最終的に forward progress を行う</li>
      <li>agent はブロッキングを提供する明示的 API を通じて以外には、他の agent を blocked にしてはならない</li>
    </ul>

    <emu-note>
      <p>これは、メモリモデルの liveness 保証と共に、すべての ~seq-cst~ write が最終的に全 agent に観測されることを保証する。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-weakref-processing-model">
    <h1>WeakRef と FinalizationRegistry ターゲットの処理モデル (Processing Model of WeakRef and FinalizationRegistry Targets)</h1>

    <emu-clause id="sec-weakref-invariants">
      <h1>Objectives</h1>

      <p>本仕様は、任意のオブジェクトまたはシンボルがガーベジコレクトされることを保証しない。生存していないオブジェクトやシンボルは長時間後に解放されるか、全く解放されない可能性がある。このため、本仕様はガーベジコレクションによってトリガーされる挙動を記述する際に「may」という語を使用する。</p>

      <p>WeakRef および FinalizationRegistry のセマンティクスは、特定の時点で発生する 2 つの操作に基づいている:</p>

      <ul>
        <li>
          `WeakRef.prototype.deref` が呼び出されると、（*undefined* が返されないなら）参照対象は後続の同期的アクセスでも同じ値が返るよう生存保持される。このリストは ClearKeptObjects 抽象操作を用いて同期的作業が完了するとリセットされる。
        </li>

        <li>
          FinalizationRegistry に登録されたオブジェクトまたはシンボルが到達不能になったとき、同期 ECMAScript 実行が完了した後に、その FinalizationRegistry のクリーンアップコールバックの呼び出しが最終的に行われるかもしれない。FinalizationRegistry クリーンアップは CleanupFinalizationRegistry 抽象操作で実行される。
        </li>
      </ul>

      <p>これら（ClearKeptObjects と CleanupFinalizationRegistry）のいずれの動作も同期 ECMAScript 実行を割り込まない。ホストはより長い同期 ECMAScript 実行を組み立てる可能性があるため、本仕様は ClearKeptObjects および CleanupFinalizationRegistry のスケジューリングをホスト環境に委ねる。</p>

      <p>一部 ECMAScript 実装は、ECMAScript がアイドルである間も含め、バックグラウンドでガーベジコレクタを走らせる。ホスト環境に CleanupFinalizationRegistry のスケジューリングを任せることで、ホストは最終化作業を行うために ECMAScript 実行を再開し、保持された値を解放して全体的なメモリ使用量を削減し得る。</p>
    </emu-clause>

    <emu-clause id="sec-liveness">
      <h1>Liveness</h1>

      <p>オブジェクトやシンボルの集合 _S_ に対し、_S_ に関して <dfn>hypothetical WeakRef-oblivious</dfn> な実行とは、参照先が _S_ の要素である WeakRef の抽象操作 WeakRefDeref が常に *undefined* を返すような実行である。</p>

      <emu-note>
        WeakRef-obliviousness と liveness は 2 つの概念を捉える。(1) WeakRef 自体は参照対象を生存させない。(2) liveness に循環が存在しても値が生存であることを意味しない。具体的には _v_ の liveness 判定が WeakRef 参照先 _r_ の liveness 判定に依存する場合、_r_ の liveness は _v_ の liveness を仮定できず、そうすると循環的推論になる。
      </emu-note>
      <emu-note>
        WeakRef-obliviousness が個々の値ではなく値の集合に対して定義されるのは循環を考慮するためである。個々の値に対して定義すると、循環内の WeakRef 参照先は、その同一性が循環内の他の WeakRef 参照先を介してのみ観測されるにもかかわらず、生存と考えられてしまう。
      </emu-note>
      <emu-note>
        口語的には、個々のオブジェクトまたはシンボルは、それを含むすべての集合が live であれば live であると言う。
      </emu-note>

      <p>評価中の任意の時点で、オブジェクトやシンボルの集合 _S_ は以下の条件のいずれかを満たす場合 <dfn>live</dfn> と見なされる:</p>

      <ul>
        <li>
          _S_ の任意の要素が任意の agent の [[KeptAlive]] List に含まれている。
        </li>
        <li>
          _S_ に関して WeakRef-oblivious である有効な将来の仮想実行が存在し、その実行が _S_ 内の任意の値の同一性を観測する。
        </li>
      </ul>
      <emu-note>
        上記 2 番目の条件は、値の同一性が非 WeakRef 手段で観測可能であれば値は live であるという直感を捉える。値の同一性は厳密等価比較の観測や、値が Map のキーとして使用されることの観測によって観測され得る。
      </emu-note>
      <emu-note>
        <p>値がフィールド、内部スロット、またはプロパティに存在するという事実は、その値が live であることを意味しない。例えば、その値がプログラムに返されることが一度も無いなら観測できない。</p>

        <p>これは WeakMap のキー、WeakSet のメンバ、そして FinalizationRegistry Cell record の [[WeakRefTarget]] および [[UnregisterToken]] フィールドについても同様である。</p>

        <p>上記定義は、WeakMap のキーが live でないなら対応する value も必ずしも live とは限らないことを含意する。</p>
      </emu-note>
      <emu-note>
        Liveness はエンジンが空にしてはならない WeakRef を保証するための下限である。ここで定義する Liveness は決定不能である。実際にはエンジンは到達可能性などの保守的近似を用いる。実装には大きな裁量が期待される。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-execution">
      <h1>Execution</h1>

      <p>任意の時点で、オブジェクトやシンボルの集合 _S_ が live でない場合、ECMAScript 実装は以下のステップをアトミックに実行してもよい:</p>

      <emu-alg>
        1. _S_ の各要素 _value_ について
          1. _ref_.[[WeakRefTarget]] が _value_ である各 WeakRef _ref_ について
            1. _ref_.[[WeakRefTarget]] を ~empty~ に設定する。
          1. _fg_.[[Cells]] が Record _cell_ を含み、_cell_.[[WeakRefTarget]] が _value_ である各 FinalizationRegistry _fg_ について
            1. _cell_.[[WeakRefTarget]] を ~empty~ に設定する。
            1. 任意で HostEnqueueFinalizationRegistryCleanupJob(_fg_) を実行する。
          1. _map_.[[WeakMapData]] が Record _r_ を含み、_r_.[[Key]] が _value_ である各 WeakMap _map_ について
            1. _r_.[[Key]] を ~empty~ に設定する。
            1. _r_.[[Value]] を ~empty~ に設定する。
          1. _set_.[[WeakSetData]] が _value_ を含む各 WeakSet _set_ について
            1. 値が _value_ の要素を、値が ~empty~ の要素に置き換える。
      </emu-alg>

      <emu-note>
        <p>Liveness の定義と合わせて、本節は実装が WeakRef に関して適用してよい最適化を規定する。</p>

        <p>オブジェクトの同一性を観測せずにオブジェクトへアクセスすることは可能である。エスケープしないオブジェクトのプロパティに対するデッド変数除去やスカラ置換などの最適化が許可され、その同一性が観測されないオブジェクトを指す WeakRef を観測可能な形で空にすることが許される。</p>

        <p>一方、オブジェクトの同一性が観測可能で、そのオブジェクトが WeakRef の [[WeakRefTarget]] 内部スロットにある場合、WeakRef を観測可能に空にしてしまう再物質化 (rematerialization) などの最適化は禁じられる。</p>

        <p>HostEnqueueFinalizationRegistryCleanupJob の呼び出しは任意であるため、FinalizationRegistry に登録されたオブジェクトがその FinalizationRegistry 自体を生存保持するとは限らない。実装は、FinalizationRegistry 自体が死んだ場合やアプリケーション終了中など、任意の理由で FinalizationRegistry コールバックを省略してよい。</p>
      </emu-note>
      <emu-note>
        <p>実装は、非 live オブジェクトやシンボルの極大集合に対して WeakRef を必ずしも空にする義務はない。</p>
        <p>実装が WeakRef を空にするために非 live 集合 _S_ を選ぶ場合、本定義は _S_ 内のすべての値に対する WeakRef を同時に空にすることを要求する。言い換えると、値 _v_ を指す WeakRef を空にしながら、_v_ の値を観測しうる他の WeakRef を空にしないままにするのは非適合である。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-host-hooks">
      <h1>ホストフック (Host Hooks)</h1>

      <emu-clause id="sec-host-cleanup-finalization-registry" type="host-defined abstract operation">
        <h1>
          HostEnqueueFinalizationRegistryCleanupJob (
            _finalizationRegistry_: a FinalizationRegistry,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <p>_cleanupJob_ を、引数を持たず _finalizationRegistry_ を捕捉し、呼び出されたとき次のステップを実行する新しい Job Abstract Closure とする:</p>
        <emu-alg>
          1. _cleanupResult_ を Completion(CleanupFinalizationRegistry(_finalizationRegistry_)) とする。
          1. _cleanupResult_ が abrupt completion であるなら、エラー報告のためのホスト定義ステップを実行する。
          1. ~unused~ を返す。
        </emu-alg>
        <p>HostEnqueueFinalizationRegistryCleanupJob の実装は、可能なら _cleanupJob_ を将来時点で実行するようスケジュールする。また <emu-xref href="#sec-jobs"></emu-xref> の要件にも従わなければならない。</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-clear-kept-objects" type="abstract operation">
    <h1>ClearKeptObjects ( ): ~unused~</h1>
    <dl class="header">
      <dt>description</dt>
      <dd>ECMAScript 実装は同期的な ECMAScript 実行列が完了した際に ClearKeptObjects を呼び出すことが期待される。</dd>
    </dl>
    <emu-alg>
      1. _agentRecord_ を surrounding agent の Agent Record とする。
      1. _agentRecord_.[[KeptAlive]] を新しい空の List に設定する。
      1. ~unused~ を返す。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-addtokeptobjects" type="abstract operation">
    <h1>
      AddToKeptObjects (
        _value_: an Object or a Symbol,
      ): ~unused~
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. _agentRecord_ を surrounding agent の Agent Record とする。
      1. _agentRecord_.[[KeptAlive]] に _value_ を追加する。
      1. ~unused~ を返す。
    </emu-alg>
    <emu-note>
      抽象操作 AddToKeptObjects が対象となるオブジェクトまたはシンボルを引数に呼び出されると、その対象は ClearKeptObjects が呼び出されるまで対象を強参照し続けるリストに追加される。
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-cleanup-finalization-registry" type="abstract operation">
    <h1>
      CleanupFinalizationRegistry (
        _finalizationRegistry_: a FinalizationRegistry,
      ): either a normal completion containing ~unused~ or a throw completion
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. アサート: _finalizationRegistry_ は [[Cells]] および [[CleanupCallback]] 内部スロットを持つ。
      1. _callback_ を _finalizationRegistry_.[[CleanupCallback]] とする。
      1. _finalizationRegistry_.[[Cells]] が Record _cell_ を含み、かつ _cell_.[[WeakRefTarget]] が ~empty~ であるものが存在する間、実装は以下のステップを（任意のタイミングで）実行してよい:
        1. そのような _cell_ のいずれかを選ぶ。
        1. _finalizationRegistry_.[[Cells]] から _cell_ を取り除く。
        1. ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] ») を実行する。
      1. ~unused~ を返す。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-canbeheldweakly" type="abstract operation">
    <h1>
      CanBeHeldWeakly (
        _v_: an ECMAScript language value,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>_v_ が弱参照として利用に適している場合に限り *true* を返す。弱参照として利用に適した値のみが WeakMap のキー、WeakSet の要素、WeakRef の target、あるいは FinalizationRegistry の targets の 1 つになれる。</dd>
    </dl>
    <emu-alg>
      1. _v_ が Object であるなら *true* を返す。
      1. _v_ が Symbol でかつ KeyForSymbol(_v_) が *undefined* であるなら *true* を返す。
      1. *false* を返す。
    </emu-alg>
    <emu-note>
      <p><emu-xref href="#sec-identity">言語同一性 (language identity)</emu-xref> を持たない言語値は、事前の参照なしに生成し得るため弱参照としては不適切である。<emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> により生成された Symbol 値は他の Symbol と異なり言語同一性を持たず、弱参照として不適切である。<emu-xref href="#sec-well-known-symbols">Well-known symbols</emu-xref> は収集されない可能性が高いが、数が限定され多様な実装手法で管理可能であるため、弱参照として利用に適したものとして扱われる。しかし、live な WeakMap 内で well-known symbol に関連付けられた任意の値は収集されにくく、実装においてメモリ資源を「リーク」させる可能性がある。</p>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>通常オブジェクトとエキゾチックオブジェクトの挙動 (Ordinary and Exotic Objects Behaviours)</h1>

  <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots">
    <h1>通常オブジェクトの内部メソッドと内部スロット (Ordinary Object Internal Methods and Internal Slots)</h1>
    <p>すべての通常オブジェクトは [[Prototype]] という内部スロットを持つ。この内部スロットの値は *null* かオブジェクトであり、継承を実装するために用いられる。通常オブジェクト _O_ にプロパティ _P_ が存在せず、しかしその [[Prototype]] オブジェクトには存在する状況を仮定する。_P_ が [[Prototype]] オブジェクト上のデータプロパティを参照する場合、_O_ は取得アクセスにおいてそれを継承し、_P_ が _O_ 自身のプロパティであるかのように振る舞う。_P_ が [[Prototype]] オブジェクト上の書き込み可能なデータプロパティを参照する場合、_O_ 上で _P_ に値を設定すると _O_ 上に新しいデータプロパティ _P_ が作成される。_P_ が [[Prototype]] オブジェクト上の書き込み不可のデータプロパティを参照する場合、_O_ 上での _P_ への設定は失敗する。_P_ が [[Prototype]] オブジェクト上のアクセサプロパティを参照する場合、そのアクセサは取得および設定アクセスの両方について _O_ に継承される。</p>
    <p>すべての通常オブジェクトは Boolean 値を取る [[Extensible]] 内部スロットを持ち、これは <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> で規定される拡張可能性に関する内部メソッドの不変条件を満たすために使用される。すなわち、一度オブジェクトの [[Extensible]] 内部スロットの値が *false* に設定されると、そのオブジェクトに新しいプロパティを追加したり、オブジェクトの [[Prototype]] 内部スロットの値を変更したり、後で [[Extensible]] の値を *true* に戻したりすることはできない。</p>
    <p>以下のアルゴリズム記述では、_O_ は通常オブジェクト、_P_ はプロパティキー値、_V_ は任意の ECMAScript 言語値、_Desc_ は Property Descriptor レコードであると仮定する。</p>
    <p>各通常オブジェクト内部メソッドは同名の抽象操作に委譲する。そのような抽象操作が別の内部メソッドに依存する場合、同名の抽象操作を直接呼ぶ代わりに _O_ 上で内部メソッドが呼び出される。これらのセマンティクスは、通常オブジェクト内部メソッドが適用された際に、エキゾチックオブジェクトではオーバーライドされた内部メソッドが呼ばれることを保証する。</p>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): Object か *null* を含む正常完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryGetPrototypeOf(_O_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinarygetprototypeof" type="abstract operation">
        <h1>
          OrdinaryGetPrototypeOf (
            _O_: an Object,
          ): an Object or *null*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Prototype]] を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): Boolean を含む正常完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinarySetPrototypeOf(_O_, _V_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinarysetprototypeof" type="abstract operation">
        <h1>
          OrdinarySetPrototypeOf (
            _O_: an Object,
            _V_: an Object or *null*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _current_ を _O_.[[Prototype]] とする。
          1. SameValue(_V_, _current_) が *true* なら *true* を返す。
          1. _extensible_ を _O_.[[Extensible]] とする。
          1. _extensible_ が *false* なら *false* を返す。
          1. _p_ を _V_ とする。
          1. _done_ を *false* とする。
          1. [id="step-ordinarysetprototypeof-loop"] _done_ が *false* の間、繰り返す:
            1. _p_ が *null* なら
              1. _done_ を *true* に設定する。
            1. そうでなく SameValue(_p_, _O_) が *true* なら
              1. *false* を返す。
            1. それ以外なら
              1. _p_.[[GetPrototypeOf]] が <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof"></emu-xref> で定義された通常オブジェクト内部メソッドでないなら _done_ を *true* に設定する。
              1. そうでなければ _p_ を _p_.[[Prototype]] に設定する。
          1. _O_.[[Prototype]] を _V_ に設定する。
          1. *true* を返す。
        </emu-alg>
        <emu-note>
          <p>ステップ <emu-xref href="#step-ordinarysetprototypeof-loop"></emu-xref> のループは、[[GetPrototypeOf]] と [[SetPrototypeOf]] に通常オブジェクト定義を用いるオブジェクトのみから成る任意のプロトタイプ連鎖に循環が存在しないことを保証する。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): Boolean を含む正常完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryIsExtensible(_O_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinaryisextensible" type="abstract operation">
        <h1>
          OrdinaryIsExtensible (
            _O_: an Object,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Extensible]] を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): *true* を含む正常完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryPreventExtensions(_O_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinarypreventextensions" type="abstract operation">
        <h1>
          OrdinaryPreventExtensions (
            _O_: an Object,
          ): *true*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Extensible]] を *false* に設定する。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): Property Descriptor か *undefined* を含む正常完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryGetOwnProperty(_O_, _P_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinarygetownproperty" type="abstract operation">
        <h1>
          OrdinaryGetOwnProperty (
            _O_: an Object,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_ がキー _P_ の自身のプロパティを持たないなら *undefined* を返す。
          1. フィールドを持たない新しい Property Descriptor _D_ を生成する。
          1. _X_ をキーが _P_ である _O_ の自身のプロパティとする。
          1. _X_ がデータプロパティなら
            1. _D_.[[Value]] を _X_.[[Value]] 属性の値に設定する。
            1. _D_.[[Writable]] を _X_.[[Writable]] 属性の値に設定する。
          1. それ以外
            1. アサート: _X_ はアクセサプロパティである。
            1. _D_.[[Get]] を _X_.[[Get]] 属性の値に設定する。
            1. _D_.[[Set]] を _X_.[[Set]] 属性の値に設定する。
          1. _D_.[[Enumerable]] を _X_.[[Enumerable]] 属性の値に設定する。
          1. _D_.[[Configurable]] を _X_.[[Configurable]] 属性の値に設定する。
          1. _D_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinarydefineownproperty" type="abstract operation">
        <h1>
          OrdinaryDefineOwnProperty (
            _O_: an Object,
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _current_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
          1. _extensible_ を ? IsExtensible(_O_) とする。
          1. ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iscompatiblepropertydescriptor" type="abstract operation">
        <h1>
          IsCompatiblePropertyDescriptor (
            _Extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _Current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ValidateAndApplyPropertyDescriptor(*undefined*, *""*, _Extensible_, _Desc_, _Current_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateandapplypropertydescriptor" type="abstract operation">
        <h1>
          ValidateAndApplyPropertyDescriptor (
            _O_: an Object or *undefined*,
            _P_: a property key,
            _extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_Desc_ が、指定された拡張可能性 _extensible_ と現行プロパティ _current_ を持つオブジェクトのプロパティとして <emu-xref href="#sec-invariants-of-the-essential-internal-methods">不変条件</emu-xref> を維持しつつ適用できる場合に限り *true* を返す。そのような適用が可能で _O_ が *undefined* でない場合、名前 _P_ のプロパティ（必要なら作成される）に対して実行される。</dd>
        </dl>
        <emu-alg>
          1. アサート: _P_ はプロパティキーである。
          1. _current_ が *undefined* なら
            1. _extensible_ が *false* なら *false* を返す。
            1. _O_ が *undefined* なら *true* を返す。
            1. IsAccessorDescriptor(_Desc_) が *true* なら
              1. オブジェクト _O_ に、_Desc_ に対応フィールドがあればその値、そうでなければその属性の <emu-xref href="#table-object-property-attributes">既定値</emu-xref> を [[Get]], [[Set]], [[Enumerable]], [[Configurable]] に設定した名前 _P_ の自身のアクセサプロパティを作成する。
            1. それ以外
              1. オブジェクト _O_ に、_Desc_ に対応フィールドがあればその値、そうでなければその属性の <emu-xref href="#table-object-property-attributes">既定値</emu-xref> を [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] に設定した名前 _P_ の自身のデータプロパティを作成する。
            1. *true* を返す。
          1. アサート: _current_ は完全に埋められた Property Descriptor である。
          1. _Desc_ がいかなるフィールドも持たないなら *true* を返す。
          1. _current_.[[Configurable]] が *false* なら
            1. _Desc_ が [[Configurable]] フィールドを持ちかつ _Desc_.[[Configurable]] が *true* なら *false* を返す。
            1. _Desc_ が [[Enumerable]] フィールドを持ちかつ _Desc_.[[Enumerable]] が _current_.[[Enumerable]] と異なるなら *false* を返す。
            1. IsGenericDescriptor(_Desc_) が *false* でかつ IsAccessorDescriptor(_Desc_) が IsAccessorDescriptor(_current_) と異なるなら *false* を返す。
            1. IsAccessorDescriptor(_current_) が *true* なら
              1. _Desc_ が [[Get]] フィールドを持ち SameValue(_Desc_.[[Get]], _current_.[[Get]]) が *false* なら *false* を返す。
              1. _Desc_ が [[Set]] フィールドを持ち SameValue(_Desc_.[[Set]], _current_.[[Set]]) が *false* なら *false* を返す。
            1. それ以外で _current_.[[Writable]] が *false* なら
              1. _Desc_ が [[Writable]] フィールドを持ち _Desc_.[[Writable]] が *true* なら *false* を返す。
              1. 注記: SameValue は他の手段で区別可能な *NaN* 値について *true* を返す。ここで返すことで _O_ の既存プロパティが変更されないことを保証する。
              1. _Desc_ が [[Value]] フィールドを持つなら SameValue(_Desc_.[[Value]], _current_.[[Value]]) を返す。
          1. _O_ が *undefined* でないなら
            1. IsDataDescriptor(_current_) が *true* かつ IsAccessorDescriptor(_Desc_) が *true* なら
              1. _Desc_ が [[Configurable]] フィールドを持つなら _configurable_ を _Desc_.[[Configurable]] とし、そうでなければ _configurable_ を _current_.[[Configurable]] とする。
              1. _Desc_ が [[Enumerable]] フィールドを持つなら _enumerable_ を _Desc_.[[Enumerable]] とし、そうでなければ _enumerable_ を _current_.[[Enumerable]] とする。
              1. オブジェクト _O_ の名前 _P_ のプロパティを、[[Configurable]] と [[Enumerable]] をそれぞれ _configurable_ と _enumerable_ に、[[Get]] と [[Set]] を _Desc_ に対応フィールドがあればその値、なければその属性の <emu-xref href="#table-object-property-attributes">既定値</emu-xref> に設定したアクセサプロパティに置き換える。
            1. それ以外で IsAccessorDescriptor(_current_) が *true* かつ IsDataDescriptor(_Desc_) が *true* なら
              1. _Desc_ が [[Configurable]] フィールドを持つなら _configurable_ を _Desc_.[[Configurable]] とし、そうでなければ _configurable_ を _current_.[[Configurable]] とする。
              1. _Desc_ が [[Enumerable]] フィールドを持つなら _enumerable_ を _Desc_.[[Enumerable]] とし、そうでなければ _enumerable_ を _current_.[[Enumerable]] とする。
              1. オブジェクト _O_ の名前 _P_ のプロパティを、[[Configurable]] と [[Enumerable]] をそれぞれ _configurable_ と _enumerable_ に、[[Value]] と [[Writable]] を _Desc_ に対応フィールドがあればその値、なければその属性の <emu-xref href="#table-object-property-attributes">既定値</emu-xref> に設定したデータプロパティに置き換える。
            1. それ以外の場合
              1. _Desc_ の各フィールドについて、オブジェクト _O_ の名前 _P_ のプロパティの対応する属性をそのフィールドの値に設定する。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryHasProperty(_O_, _P_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinaryhasproperty" type="abstract operation">
        <h1>
          OrdinaryHasProperty (
            _O_: an Object,
            _P_: a property key,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _hasOwn_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
          1. _hasOwn_ が *undefined* でないなら *true* を返す。
          1. _parent_ を ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() とする。
          1. _parent_ が *null* でないなら
            1. ? <emu-meta effects="user-code">_parent_.[[HasProperty]]</emu-meta>(_P_) を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): ECMAScript 言語値を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>

      <emu-alg>
        1. ? OrdinaryGet(_O_, _P_, _Receiver_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinaryget" type="abstract operation">
        <h1>
          OrdinaryGet (
            _O_: an Object,
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _desc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
          1. _desc_ が *undefined* なら
            1. _parent_ を ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() とする。
            1. _parent_ が *null* なら *undefined* を返す。
            1. ? <emu-meta effects="user-code">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_) を返す。
          1. IsDataDescriptor(_desc_) が *true* なら _desc_.[[Value]] を返す。
          1. アサート: IsAccessorDescriptor(_desc_) は *true* である。
          1. _getter_ を _desc_.[[Get]] とする。
          1. _getter_ が *undefined* なら *undefined* を返す。
          1. ? Call(_getter_, _Receiver_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinarySet(_O_, _P_, _V_, _Receiver_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinaryset" type="abstract operation">
        <h1>
          OrdinarySet (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _ownDesc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
          1. ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarysetwithowndescriptor" type="abstract operation">
        <h1>
          OrdinarySetWithOwnDescriptor (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
            _ownDesc_: a Property Descriptor or *undefined*,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _ownDesc_ が *undefined* なら
            1. _parent_ を ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() とする。
            1. _parent_ が *null* でないなら
              1. ? <emu-meta effects="user-code">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_) を返す。
            1. それ以外なら
              1. _ownDesc_ を PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* } に設定する。
          1. IsDataDescriptor(_ownDesc_) が *true* なら
            1. _ownDesc_.[[Writable]] が *false* なら *false* を返す。
            1. _Receiver_ が Object でないなら *false* を返す。
            1. _existingDescriptor_ を ? <emu-meta effects="user-code">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
            1. _existingDescriptor_ が *undefined* でないなら
              1. IsAccessorDescriptor(_existingDescriptor_) が *true* なら *false* を返す。
              1. _existingDescriptor_.[[Writable]] が *false* なら *false* を返す。
              1. _valueDesc_ を PropertyDescriptor { [[Value]]: _V_ } とする。
              1. ? <emu-meta effects="user-code">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_) を返す。
            1. それ以外なら
              1. アサート: _Receiver_ は現在プロパティ _P_ を持たない。
              1. ? CreateDataProperty(_Receiver_, _P_, _V_) を返す。
          1. アサート: IsAccessorDescriptor(_ownDesc_) は *true* である。
          1. _setter_ を _ownDesc_.[[Set]] とする。
          1. _setter_ が *undefined* なら *false* を返す。
          1. ? Call(_setter_, _Receiver_, « _V_ ») を実行する。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryDelete(_O_, _P_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinarydelete" type="abstract operation">
        <h1>
          OrdinaryDelete (
            _O_: an Object,
            _P_: a property key,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _desc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
          1. _desc_ が *undefined* なら *true* を返す。
          1. _desc_.[[Configurable]] が *true* なら
            1. 名前 _P_ の自身のプロパティを _O_ から除去する。
            1. *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): プロパティキーの List を含む正常完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>通常オブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryOwnPropertyKeys(_O_) を返す。
      </emu-alg>

      <emu-clause id="sec-ordinaryownpropertykeys" type="abstract operation">
        <h1>
          OrdinaryOwnPropertyKeys (
            _O_: an Object,
          ): a List of property keys
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _keys_ を新しい空の List とする。
          1. _O_ の各自身のプロパティキー _P_ で、_P_ が配列インデックスであるものについて、数値的インデックス昇順で:
            1. _keys_ に _P_ を追加する。
          1. _O_ の各自身のプロパティキー _P_ で、_P_ が String かつ配列インデックスでないものについて、作成順（時間順）昇順で:
            1. _keys_ に _P_ を追加する。
          1. _O_ の各自身のプロパティキー _P_ で、_P_ が Symbol であるものについて、作成順（時間順）昇順で:
            1. _keys_ に _P_ を追加する。
          1. _keys_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinaryobjectcreate" type="abstract operation" oldids="sec-objectcreate">
      <h1>
        OrdinaryObjectCreate (
          _proto_: an Object or *null*,
          optional _additionalInternalSlotsList_: a List of names of internal slots,
        ): an Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>新しい通常オブジェクトの実行時生成を規定するために使用される。_additionalInternalSlotsList_ には [[Prototype]] および [[Extensible]] に加えてオブジェクトの一部として定義されるべき追加内部スロットの名前が含まれる。_additionalInternalSlotsList_ が与えられない場合、新しい空の List が使用される。</dd>
      </dl>
      <emu-alg>
        1. _internalSlotsList_ を « [[Prototype]], [[Extensible]] » とする。
        1. _additionalInternalSlotsList_ が存在するなら _internalSlotsList_ を _internalSlotsList_ と _additionalInternalSlotsList_ のリスト結合結果に設定する。
        1. _O_ を MakeBasicObject(_internalSlotsList_) とする。
        1. _O_.[[Prototype]] を _proto_ に設定する。
        1. _O_ を返す。
      </emu-alg>

      <emu-note>
        <p>OrdinaryObjectCreate は MakeBasicObject を呼ぶ以上の多くをしないが、エキゾチックではない通常オブジェクトを生成する意図を示す。そのため本仕様内では、結果を非通常にする形で後から内部メソッドを変更するアルゴリズムからは呼ばれない。エキゾチックオブジェクトを生成する操作は直接 MakeBasicObject を呼び出す。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinarycreatefromconstructor" type="abstract operation">
      <h1>
        OrdinaryCreateFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
          optional _internalSlotsList_: a List of names of internal slots,
        ): Object を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>存在するならコンストラクタの *"prototype"* プロパティから取得した [[Prototype]] 値を持つ通常オブジェクトを生成する。存在しない場合 _intrinsicDefaultProto_ で名付けられた intrinsic が [[Prototype]] として使用される。_internalSlotsList_ には追加内部スロット名が含まれる。未指定の場合は空の List が使用される。</dd>
      </dl>
      <emu-alg>
        1. アサート: _intrinsicDefaultProto_ はこの仕様で定義された intrinsic オブジェクトの名前である。該当オブジェクトは [[Prototype]] 値として使用されることを意図した intrinsic でなければならない。
        1. _proto_ を ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_) とする。
        1. _internalSlotsList_ が存在するなら _slotsList_ を _internalSlotsList_ とし、そうでなければ _slotsList_ を新しい空の List とする。
        1. OrdinaryObjectCreate(_proto_, _slotsList_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getprototypefromconstructor" type="abstract operation">
      <h1>
        GetPrototypeFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
        ): Object を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>特定のコンストラクタに対応するオブジェクトを作成する際に使用すべき [[Prototype]] 値を決定する。値はコンストラクタの *"prototype"* プロパティから取得され、存在しない場合 _intrinsicDefaultProto_ で名付けられた intrinsic が [[Prototype]] に用いられる。</dd>
      </dl>
      <emu-alg>
        1. アサート: _intrinsicDefaultProto_ はこの仕様で定義された intrinsic オブジェクトの名前である。該当オブジェクトはオブジェクトの [[Prototype]] として使われることを意図した intrinsic でなければならない。
        1. _proto_ を ? Get(_constructor_, *"prototype"*) とする。
        1. _proto_ が Object でないなら
          1. _realm_ を ? GetFunctionRealm(_constructor_) とする。
          1. _proto_ を _realm_ の _intrinsicDefaultProto_ という名前の intrinsic オブジェクトに設定する。
        1. _proto_ を返す。
      </emu-alg>
      <emu-note>
        <p>_constructor_ が [[Prototype]] 値を提供しない場合、使用される既定値は実行中実行コンテキストではなく _constructor_ 関数の realm から取得される。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-requireinternalslot" type="abstract operation">
      <h1>
        RequireInternalSlot (
          _O_: an ECMAScript language value,
          _internalSlot_: an internal slot name,
        ): ~unused~ を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_ が Object であり、かつ指定された内部スロットを持つ場合を除いて例外を投げる。</dd>
      </dl>
      <emu-alg>
        1. _O_ が Object でないなら *TypeError* 例外を投げる。
        1. _O_ が _internalSlot_ 内部スロットを持たないなら *TypeError* 例外を投げる。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript 関数オブジェクト (ECMAScript Function Objects)</h1>
    <p>ECMAScript 関数オブジェクトは、レキシカル環境を閉じ込めたパラメータ化 ECMAScript コードをカプセル化し、そのコードの動的評価をサポートする。ECMAScript 関数オブジェクトは通常オブジェクトであり、他の通常オブジェクトと同じ内部スロットおよび内部メソッドを持つ。ECMAScript 関数オブジェクトのコードは strict mode コード（<emu-xref href="#sec-strict-mode-code"></emu-xref>）か非 strict コードのいずれかである。コードが strict mode コードである ECMAScript 関数オブジェクトは <dfn id="strict-function" variants="strict functions">strict function</dfn> と呼ばれる。コードが strict mode コードでないものは <dfn id="non-strict-function" variants="non-strict functions">non-strict function</dfn> と呼ばれる。</p>
    <p>[[Extensible]] と [[Prototype]] に加えて、ECMAScript 関数オブジェクトは <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> に列挙される内部スロットも持つ。</p>
    <emu-table id="table-internal-slots-of-ecmascript-function-objects" caption="ECMAScript 関数オブジェクトの内部スロット (Internal Slots of ECMAScript Function Objects)" oldids="table-27">
      <table>
        <thead>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[Environment]]
          </td>
          <td>
            an Environment Record
          </td>
          <td>
            関数がクロージャ化した Environment Record。関数のコードを評価する際の外側環境として使用される。
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateEnvironment]]
          </td>
          <td>
            a PrivateEnvironment Record or *null*
          </td>
          <td>
            関数がクロージャ化した Private Name 用の PrivateEnvironment Record。関数が構文上クラス内に含まれない場合は *null*。関数のコードを評価するときに内部クラスの外側 PrivateEnvironment として使用される。
          </td>
        </tr>
        <tr>
          <td>
            [[FormalParameters]]
          </td>
          <td>
            a Parse Node
          </td>
          <td>
            関数の仮引数リストを定義するソーステキストのルートパースノード。
          </td>
        </tr>
        <tr>
          <td>
            [[ECMAScriptCode]]
          </td>
          <td>
            a Parse Node
          </td>
          <td>
            関数本体を定義するソーステキストのルートパースノード。
          </td>
        </tr>
        <tr>
          <td>
            [[ConstructorKind]]
          </td>
          <td>
            ~base~ or ~derived~
          </td>
          <td>
            関数が派生クラスコンストラクタかどうか。
          </td>
        </tr>
        <tr>
          <td>
            [[Realm]]
          </td>
          <td>
            a Realm Record
          </td>
          <td>
            関数が生成された realm。関数評価時にアクセスされる intrinsic オブジェクトを提供する。
          </td>
        </tr>
        <tr>
          <td>
            [[ScriptOrModule]]
          </td>
          <td>
            a Script Record or a Module Record
          </td>
          <td>
            関数が生成された script または module。
          </td>
        </tr>
        <tr>
          <td>
            [[ThisMode]]
          </td>
          <td>
            ~lexical~, ~strict~, or ~global~
          </td>
          <td>
            関数の仮引数およびコード本体内での `this` 参照の解釈方法を定義する。~lexical~ は `this` がレキシカルに内包する関数の *this* 値を指すことを意味する。~strict~ は関数呼び出しで与えられた *this* 値をそのまま用いる。~global~ は *this* 値が *undefined* または *null* の場合グローバルオブジェクト参照と解釈し、その他の場合は ToObject に渡すことを意味する。
          </td>
        </tr>
        <tr>
          <td>
            [[Strict]]
          </td>
          <td>
            a Boolean
          </td>
          <td>
            strict function なら *true*、non-strict function なら *false*。
          </td>
        </tr>
        <tr>
          <td>
            [[HomeObject]]
          </td>
          <td>
            an Object
          </td>
          <td>
            関数が `super` を使用する場合、`super` プロパティ探索が開始されるオブジェクトを提供する [[GetPrototypeOf]] を持つオブジェクト。
          </td>
        </tr>
        <tr>
          <td>
            [[SourceText]]
          </td>
          <td>
            a sequence of Unicode code points
          </td>
          <td>
            関数を定義する <emu-xref href="#sec-source-text">source text</emu-xref>。
          </td>
        </tr>
        <tr>
          <td>
            [[Fields]]
          </td>
          <td>
            a List of ClassFieldDefinition Records
          </td>
          <td>
            関数がクラスである場合、その非 static field と対応する初期化子の Record のリスト。
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateMethods]]
          </td>
          <td>
            a List of PrivateElements
          </td>
          <td>
            関数がクラスである場合、その非 static private method と accessor を表すリスト。
          </td>
        </tr>
        <tr>
          <td>
            [[ClassFieldInitializerName]]
          </td>
          <td>
            a String, a Symbol, a Private Name, or ~empty~
          </td>
          <td>
            関数がクラスフィールドの初期化子として作成される場合、そのフィールドの NamedEvaluation で用いる名前。そうでなければ ~empty~。
          </td>
        </tr>
        <tr>
          <td>
            [[IsClassConstructor]]
          </td>
          <td>
            a Boolean
          </td>
          <td>
            関数が class constructor かどうか（*true* の場合、その [[Call]] 呼び出しは直ちに *TypeError* 例外を投げる）。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>すべての ECMAScript 関数オブジェクトはここで定義される [[Call]] 内部メソッドを持つ。コンストラクタでもある ECMAScript 関数は加えて [[Construct]] 内部メソッドを持つ。</p>

    <emu-clause id="sec-ecmascript-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 言語値を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>ECMAScript 関数オブジェクト _F_</dd>
      </dl>
      <emu-alg>
        1. _callerContext_ を実行中実行コンテキストとする。
        1. _calleeContext_ を PrepareForOrdinaryCall(_F_, *undefined*) とする。
        1. アサート: _calleeContext_ が現在の実行中実行コンテキストである。
        1. _F_.[[IsClassConstructor]] が *true* なら
          1. _error_ を新たに生成された *TypeError* オブジェクトとする。
          1. 注記: _error_ は _F_ の関連 Realm Record を持つ _calleeContext_ 内で生成される。
          1. 実行コンテキストスタックから _calleeContext_ を除去し _callerContext_ を実行中実行コンテキストとして復元する。
          1. ThrowCompletion(_error_) を返す。
        1. OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_) を実行する。
        1. _result_ を Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)) とする。
        1. [id="step-call-pop-context-stack"] 実行コンテキストスタックから _calleeContext_ を除去し _callerContext_ を実行中実行コンテキストとして復元する。
        1. _result_ が return completion なら _result_.[[Value]] を返す。
        1. アサート: _result_ は throw completion である。
        1. ? _result_ を返す。
      </emu-alg>
      <emu-note>
        <p>ステップ <emu-xref href="#step-call-pop-context-stack"></emu-xref> で _calleeContext_ が実行コンテキストスタックから除去されるとき、到達可能な Generator により後で再開のためにサスペンド保持されている場合は破棄されてはならない。</p>
      </emu-note>

      <emu-clause id="sec-prepareforordinarycall" type="abstract operation">
        <h1>
          PrepareForOrdinaryCall (
            _F_: an ECMAScript function object,
            _newTarget_: an Object or *undefined*,
          ): an execution context
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _callerContext_ を実行中実行コンテキストとする。
          1. _calleeContext_ を新しい ECMAScript コード実行コンテキストとする。
          1. _calleeContext_ の Function を _F_ に設定する。
          1. _calleeRealm_ を _F_.[[Realm]] とする。
          1. _calleeContext_ の Realm を _calleeRealm_ に設定する。
          1. _calleeContext_ の ScriptOrModule を _F_.[[ScriptOrModule]] に設定する。
          1. _localEnv_ を NewFunctionEnvironment(_F_, _newTarget_) とする。
          1. _calleeContext_ の LexicalEnvironment を _localEnv_ に設定する。
          1. _calleeContext_ の VariableEnvironment を _localEnv_ に設定する。
          1. _calleeContext_ の PrivateEnvironment を _F_.[[PrivateEnvironment]] に設定する。
          1. _callerContext_ がまだサスペンドされていないなら _callerContext_ をサスペンドする。
          1. 実行コンテキストスタックに _calleeContext_ を push する；_calleeContext_ が実行中実行コンテキストとなる。
          1. 注記: この地点以降に生成される例外オブジェクトは _calleeRealm_ に関連付けられる。
          1. _calleeContext_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallbindthis" type="abstract operation">
        <h1>
          OrdinaryCallBindThis (
            _F_: an ECMAScript function object,
            _calleeContext_: an execution context,
            _thisArgument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _thisMode_ を _F_.[[ThisMode]] とする。
          1. _thisMode_ が ~lexical~ なら ~unused~ を返す。
          1. _calleeRealm_ を _F_.[[Realm]] とする。
          1. _localEnv_ を _calleeContext_ の LexicalEnvironment とする。
          1. _thisMode_ が ~strict~ なら
            1. _thisValue_ を _thisArgument_ とする。
          1. それ以外
            1. _thisArgument_ が *undefined* か *null* のいずれかなら
              1. _globalEnv_ を _calleeRealm_.[[GlobalEnv]] とする。
              1. アサート: _globalEnv_ は Global Environment Record である。
              1. _thisValue_ を _globalEnv_.[[GlobalThisValue]] とする。
            1. それ以外
              1. _thisValue_ を ! ToObject(_thisArgument_) とする。
              1. 注記: ToObject は _calleeRealm_ を用いてラッパーオブジェクトを生成する。
          1. アサート: _localEnv_ は Function Environment Record である。
          1. アサート: 次のステップは _localEnv_.[[ThisBindingStatus]] が ~initialized~ でないため決して abrupt completion を返さない。
          1. ! BindThisValue(_localEnv_, _thisValue_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-evaluatebody" type="sdo">
        <h1>
          Runtime Semantics: EvaluateBody (
            _functionObject_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
        <emu-alg>
          1. |FunctionBody| の EvaluateFunctionBody を引数 _functionObject_ および _argumentsList_ で評価し ? を付して結果を返す。
        </emu-alg>
        <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
        <emu-alg>
          1. |ConciseBody| の EvaluateConciseBody を引数 _functionObject_ および _argumentsList_ で評価し ? を付して結果を返す。
        </emu-alg>
        <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. |GeneratorBody| の EvaluateGeneratorBody を引数 _functionObject_ および _argumentsList_ で評価し ? を付して結果を返す。
        </emu-alg>
        <emu-grammar>
          AsyncGeneratorBody : FunctionBody
        </emu-grammar>
        <emu-alg>
          1. |AsyncGeneratorBody| の EvaluateAsyncGeneratorBody を引数 _functionObject_ および _argumentsList_ で評価し ? を付して結果を返す。
        </emu-alg>
        <emu-grammar>
          AsyncFunctionBody : FunctionBody
        </emu-grammar>
        <emu-alg>
          1. |AsyncFunctionBody| の EvaluateAsyncFunctionBody を引数 _functionObject_ および _argumentsList_ で評価し ? を付して結果を返す。
        </emu-alg>
        <emu-grammar>
          AsyncConciseBody : ExpressionBody
        </emu-grammar>
        <emu-alg>
          1. |AsyncConciseBody| の EvaluateAsyncConciseBody を引数 _functionObject_ および _argumentsList_ で評価し ? を付して結果を返す。
        </emu-alg>
        <emu-grammar>
          Initializer :
            `=` AssignmentExpression
        </emu-grammar>
        <emu-alg>
          1. アサート: _argumentsList_ は空である。
          1. アサート: _functionObject_.[[ClassFieldInitializerName]] は ~empty~ ではない。
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) が *true* なら
            1. _value_ を |Initializer| の NamedEvaluation を引数 _functionObject_.[[ClassFieldInitializerName]] で行い ? を付して得られる値とする。
          1. それ以外
            1. _rhs_ を |AssignmentExpression| の Evaluation を ? 付きで行った結果とする。
            1. _value_ を ? GetValue(_rhs_) とする。
          1. ReturnCompletion(_value_) を返す。
        </emu-alg>
        <emu-note>
          <p>フィールド初期化子は関数境界を構成するが、FunctionDeclarationInstantiation を呼び出しても観測可能な効果はないため省略される。</p>
        </emu-note>
        <emu-grammar>
          ClassStaticBlockBody : ClassStaticBlockStatementList
        </emu-grammar>
        <emu-alg>
          1. アサート: _argumentsList_ は空である。
          1. |ClassStaticBlockBody| の EvaluateClassStaticBlockBody を引数 _functionObject_ で評価し ? を付して結果を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallevaluatebody" type="abstract operation">
        <h1>
          OrdinaryCallEvaluateBody (
            _F_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _F_.[[ECMAScriptCode]] の EvaluateBody を引数 _F_ および _argumentsList_ で評価し ? を付して結果を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): Object を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>ECMAScript 関数オブジェクト _F_</dd>
      </dl>
      <emu-alg>
        1. _callerContext_ を実行中実行コンテキストとする。
        1. _kind_ を _F_.[[ConstructorKind]] とする。
        1. _kind_ が ~base~ なら
          1. _thisArgument_ を ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*) とする。
        1. _calleeContext_ を PrepareForOrdinaryCall(_F_, _newTarget_) とする。
        1. アサート: _calleeContext_ が現在の実行中実行コンテキストである。
        1. _kind_ が ~base~ なら
          1. OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_) を実行する。
          1. _initializeResult_ を Completion(InitializeInstanceElements(_thisArgument_, _F_)) とする。
          1. _initializeResult_ が abrupt completion なら
            1. 実行コンテキストスタックから _calleeContext_ を除去し _callerContext_ を実行中実行コンテキストとして復元する。
            1. ? _initializeResult_ を返す。
        1. _constructorEnv_ を _calleeContext_ の LexicalEnvironment とする。
        1. _result_ を Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)) とする。
        1. 実行コンテキストスタックから _calleeContext_ を除去し _callerContext_ を実行中実行コンテキストとして復元する。
        1. _result_ が throw completion なら
          1. ? _result_ を返す。
        1. アサート: _result_ は return completion である。
        1. _result_.[[Value]] が Object なら _result_.[[Value]] を返す。
        1. _kind_ が ~base~ なら _thisArgument_ を返す。
        1. _result_.[[Value]] が *undefined* でないなら *TypeError* 例外を投げる。
        1. _thisBinding_ を ? _constructorEnv_.GetThisBinding() とする。
        1. アサート: _thisBinding_ は Object である。
        1. _thisBinding_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryfunctioncreate" type="abstract operation" oldids="sec-functionallocate,sec-functioninitialize,sec-functioncreate,sec-generatorfunctioncreate,sec-asyncgeneratorfunctioncreate,sec-async-functions-abstract-operations-async-function-create">
      <h1>
        OrdinaryFunctionCreate (
          _functionPrototype_: an Object,
          _sourceText_: a sequence of Unicode code points,
          _ParameterList_: a Parse Node,
          _Body_: a Parse Node,
          _thisMode_: ~lexical-this~ or ~non-lexical-this~,
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>新しい関数を（既定の [[Call]] 内部メソッドと、後で MakeConstructor などの操作によって追加されうる場合を除き [[Construct]] 内部メソッドなしで）実行時生成することを規定する。_sourceText_ は生成対象関数の構文定義のソーステキストである。</dd>
      </dl>
      <emu-alg>
        1. _internalSlotsList_ を <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> に列挙された内部スロットとする。
        1. _F_ を OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_) とする。
        1. _F_.[[Call]] を <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> で規定される定義に設定する。
        1. _F_.[[SourceText]] を _sourceText_ に設定する。
        1. _F_.[[FormalParameters]] を _ParameterList_ に設定する。
        1. _F_.[[ECMAScriptCode]] を _Body_ に設定する。
        1. _Strict_ を IsStrict(_Body_) とする。
        1. _F_.[[Strict]] を _Strict_ に設定する。
        1. _thisMode_ が ~lexical-this~ なら _F_.[[ThisMode]] を ~lexical~ に設定する。
        1. それ以外で _Strict_ が *true* なら _F_.[[ThisMode]] を ~strict~ に設定する。
        1. それ以外なら _F_.[[ThisMode]] を ~global~ に設定する。
        1. _F_.[[IsClassConstructor]] を *false* に設定する。
        1. _F_.[[Environment]] を _env_ に設定する。
        1. _F_.[[PrivateEnvironment]] を _privateEnv_ に設定する。
        1. _F_.[[ScriptOrModule]] を GetActiveScriptOrModule() に設定する。
        1. _F_.[[Realm]] を current Realm Record に設定する。
        1. _F_.[[HomeObject]] を *undefined* に設定する。
        1. _F_.[[Fields]] を新しい空の List に設定する。
        1. _F_.[[PrivateMethods]] を新しい空の List に設定する。
        1. _F_.[[ClassFieldInitializerName]] を ~empty~ に設定する。
        1. _len_ を _ParameterList_ の ExpectedArgumentCount とする。
        1. SetFunctionLength(_F_, _len_) を実行する。
        1. _F_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addrestrictedfunctionproperties" type="abstract operation">
      <h1>
        AddRestrictedFunctionProperties (
          _F_: a function object,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. アサート: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] が存在し初期化済みである。
        1. _thrower_ を _realm_.[[Intrinsics]].[[%ThrowTypeError%]] とする。
        1. ! DefinePropertyOrThrow(_F_, *"caller"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
        1. ! DefinePropertyOrThrow(_F_, *"arguments"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
        1. ~unused~ を返す。
      </emu-alg>

      <emu-clause id="sec-%throwtypeerror%">
        <h1>%ThrowTypeError% ( )</h1>
        <p>この関数は <dfn>%ThrowTypeError%</dfn> intrinsic オブジェクトである。</p>
        <p>各 realm ごとに一度定義される匿名の組み込み関数オブジェクトである。</p>
        <p>呼び出されたとき次の手順を実行する:</p>
        <emu-alg>
          1. *TypeError* 例外を投げる。
        </emu-alg>
        <p>この関数の [[Extensible]] 内部スロットの値は *false* である。</p>
        <p>この関数の *"length"* プロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
        <p>この関数の *"name"* プロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-makeconstructor" type="abstract operation">
      <h1>
        MakeConstructor (
          _F_: an ECMAScript function object or a built-in function object,
          optional _writablePrototype_: a Boolean,
          optional _prototype_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ をコンストラクタに変換する。</dd>
      </dl>
      <emu-alg>
        1. _F_ が ECMAScript 関数オブジェクトなら
          1. アサート: IsConstructor(_F_) は *false*。
          1. アサート: _F_ は *"prototype"* 自身プロパティを持たない拡張可能オブジェクトである。
          1. _F_.[[Construct]] を <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> で規定される定義に設定する。
        1. それ以外
          1. _F_.[[Construct]] を <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> で規定される定義に設定する。
        1. _F_.[[ConstructorKind]] を ~base~ に設定する。
        1. _writablePrototype_ が与えられていなければ _writablePrototype_ を *true* に設定する。
        1. _prototype_ が与えられていないなら
          1. _prototype_ を OrdinaryObjectCreate(%Object.prototype%) に設定する。
          1. ! DefinePropertyOrThrow(_prototype_, *"constructor"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeclassconstructor" type="abstract operation">
      <h1>
        MakeClassConstructor (
          _F_: an ECMAScript function object,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. アサート: _F_.[[IsClassConstructor]] は *false*。
        1. _F_.[[IsClassConstructor]] を *true* に設定する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makemethod" type="abstract operation">
      <h1>
        MakeMethod (
          _F_: an ECMAScript function object,
          _homeObject_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ を method として構成する。</dd>
      </dl>
      <emu-alg>
        1. アサート: _homeObject_ は通常オブジェクトである。
        1. _F_.[[HomeObject]] を _homeObject_ に設定する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definemethodproperty" oldids="sec-createmethodproperty" type="abstract operation">
      <h1>
        DefineMethodProperty (
          _homeObject_: an Object,
          _key_: a property key or Private Name,
          _closure_: a function object,
          _enumerable_: a Boolean,
        ): PrivateElement または ~unused~ を含む正常完了、または abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. アサート: _homeObject_ は通常で拡張可能なオブジェクトである。
        1. _key_ が Private Name なら
          1. PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ } を返す。
        1. それ以外
          1. _desc_ を PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* } とする。
          1. ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_) を実行する。
          1. 注記: DefinePropertyOrThrow は _key_ が *"prototype"* であるクラス static method の定義を試みる場合のみ abrupt completion を返しうる。
          1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionname" type="abstract operation">
      <h1>
        SetFunctionName (
          _F_: a function object,
          _name_: a property key or Private Name,
          optional _prefix_: a String,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ に *"name"* プロパティを追加する。</dd>
      </dl>
      <emu-alg>
        1. アサート: _F_ は *"name"* 自身プロパティを持たない拡張可能オブジェクトである。
        1. _name_ が Symbol なら
          1. _description_ を _name_.[[Description]] とする。
          1. _description_ が *undefined* なら _name_ を空文字列に設定する。
          1. それ以外なら _name_ を *"["*, _description_, *"]"* の文字列連結に設定する。
        1. それ以外で _name_ が Private Name なら
          1. _name_ を _name_.[[Description]] に設定する。
        1. _F_ が [[InitialName]] 内部スロットを持つなら
          1. _F_.[[InitialName]] を _name_ に設定する。
        1. _prefix_ が与えられているなら
          1. _name_ を _prefix_、コード単位 0x0020 (SPACE)、_name_ の連結に設定する。
          1. _F_ が [[InitialName]] 内部スロットを持つなら
            1. 注記: 以下のステップでの選択は本抽象操作呼び出し毎に独立に行われる。
            1. 任意で _F_.[[InitialName]] を _name_ に設定してよい。
        1. ! DefinePropertyOrThrow(_F_, *"name"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionlength" type="abstract operation">
      <h1>
        SetFunctionLength (
          _F_: a function object,
          _length_: a non-negative integer or +&infin;,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ に *"length"* プロパティを追加する。</dd>
      </dl>
      <emu-alg>
        1. アサート: _F_ は *"length"* 自身プロパティを持たない拡張可能オブジェクトである。
        1. ! DefinePropertyOrThrow(_F_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-functiondeclarationinstantiation">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): ~unused~ を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ は実行コンテキストが確立される関数オブジェクトである。</dd>
      </dl>
      <emu-note>
        <p>ECMAScript 関数の評価のために実行コンテキストが確立されると、新しい Function Environment Record が作成され、各仮引数の束縛がその Environment Record にインスタンス化される。関数本体内の各宣言もインスタンス化される。関数の仮引数に既定値初期化子が含まれない場合、本体宣言は仮引数と同じ Environment Record 内にインスタンス化される。既定値パラメータ初期化子が存在する場合、本体宣言用に 2 つ目の Environment Record が作成される。仮引数および関数は FunctionDeclarationInstantiation の一部として初期化される。その他の束縛は関数本体の評価中に初期化される。</p>
      </emu-note>
      <p>呼び出されたとき次の手順を実行する:</p>
      <emu-alg>
        1. _calleeContext_ を実行中実行コンテキストとする。
        1. _code_ を _func_.[[ECMAScriptCode]] とする。
        1. _strict_ を _func_.[[Strict]] とする。
        1. _formals_ を _func_.[[FormalParameters]] とする。
        1. _parameterNames_ を _formals_ の BoundNames とする。
        1. _parameterNames_ が重複要素を持つなら _hasDuplicates_ を *true*、そうでなければ *false* とする。
        1. _simpleParameterList_ を IsSimpleParameterList of _formals_ とする。
        1. _hasParameterExpressions_ を ContainsExpression of _formals_ とする。
        1. _varNames_ を _code_ の VarDeclaredNames とする。
        1. _varDeclarations_ を _code_ の VarScopedDeclarations とする。
        1. _lexicalNames_ を _code_ の LexicallyDeclaredNames とする。
        1. _functionNames_ を新しい空の List とする。
        1. _functionsToInitialize_ を新しい空の List とする。
        1. _varDeclarations_ の各要素 _d_ について、List の逆順で:
          1. _d_ が |VariableDeclaration| でも |ForBinding| でも |BindingIdentifier| でもないなら
            1. アサート: _d_ は |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| のいずれかである。
            1. _fn_ を _d_ の BoundNames の唯一の要素とする。
            1. _functionNames_ が _fn_ を含まないなら
              1. _fn_ を _functionNames_ の先頭に挿入する。
              1. 注記: 同名の複数の関数宣言がある場合、最後の宣言が使用される。
              1. _d_ を _functionsToInitialize_ の先頭に挿入する。
        1. _argumentsObjectNeeded_ を *true* とする。
        1. _func_.[[ThisMode]] が ~lexical~ なら
          1. 注記: Arrow function は arguments オブジェクトを持たない。
          1. _argumentsObjectNeeded_ を *false* に設定する。
        1. それ以外で _parameterNames_ が *"arguments"* を含むなら
          1. _argumentsObjectNeeded_ を *false* に設定する。
        1. それ以外で _hasParameterExpressions_ が *false* なら
          1. _functionNames_ が *"arguments"* を含むか _lexicalNames_ が *"arguments"* を含むなら
            1. _argumentsObjectNeeded_ を *false* に設定する。
        1. _strict_ が *true* または _hasParameterExpressions_ が *false* なら
          1. 注記: strict mode コードでの `eval` 呼び出しは外側に可視な新しい束縛を生成できないため、仮引数には単一の Environment Record だけが必要。
          1. _env_ を _calleeContext_ の LexicalEnvironment とする。
        1. それ以外
          1. 注記: 形式パラメータリスト内の direct eval 呼び出しで生成される束縛がパラメータ宣言環境外になるよう別の Environment Record が必要。
          1. _calleeEnv_ を _calleeContext_ の LexicalEnvironment とする。
          1. _env_ を NewDeclarativeEnvironment(_calleeEnv_) とする。
          1. アサート: _calleeContext_ の VariableEnvironment と _calleeEnv_ は同じ Environment Record。
          1. _calleeContext_ の LexicalEnvironment を _env_ に設定する。
        1. _parameterNames_ の各 String _paramName_ について
          1. _alreadyDeclared_ を ! _env_.HasBinding(_paramName_) とする。
          1. 注記: 早期エラーにより重複パラメータ名はデフォルト値または rest パラメータを持たない non-strict 関数でのみ許される。
          1. _alreadyDeclared_ が *false* なら
            1. ! _env_.CreateMutableBinding(_paramName_, *false*) を実行する。
            1. _hasDuplicates_ が *true* なら
              1. ! _env_.InitializeBinding(_paramName_, *undefined*) を実行する。
        1. _argumentsObjectNeeded_ が *true* なら
          1. _strict_ が *true* または _simpleParameterList_ が *false* なら
            1. _ao_ を CreateUnmappedArgumentsObject(_argumentsList_) とする。
          1. それ以外
            1. 注記: mapped arguments オブジェクトは rest パラメータ・デフォルト値初期化子・分割代入パラメータを持たない non-strict 関数にのみ提供される。
            1. _ao_ を CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_) とする。
          1. _strict_ が *true* なら
            1. ! _env_.CreateImmutableBinding(*"arguments"*, *false*) を実行する。
            1. 注記: strict mode では早期エラーによりこの束縛への代入試行が防がれるため不変性は観測できない。
          1. それ以外
            1. ! _env_.CreateMutableBinding(*"arguments"*, *false*) を実行する。
          1. ! _env_.InitializeBinding(*"arguments"*, _ao_) を実行する。
          1. _parameterBindings_ を _parameterNames_ と « *"arguments"* » のリスト結合とする。
        1. それ以外
          1. _parameterBindings_ を _parameterNames_ とする。
        1. _iteratorRecord_ を CreateListIteratorRecord(_argumentsList_) とする。
        1. _hasDuplicates_ が *true* なら
          1. _usedEnv_ を *undefined* とする。
        1. それ以外
          1. _usedEnv_ を _env_ とする。
        1. 注記: 次のステップは ReturnCompletion を返しえない。expression 位置でそのような completion が生じる唯一の方法は |YieldExpression| の使用だが、これは <emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref> と <emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref> の Early Error 規則でパラメータリスト内で禁止される。
        1. ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _usedEnv_ を実行する。
        1. _hasParameterExpressions_ が *false* なら
          1. 注記: 仮引数とトップレベル var には単一 Environment Record でよい。
          1. _instantiatedVarNames_ を List _parameterBindings_ のコピーとする。
          1. _varNames_ の各要素 _n_ について
            1. _instantiatedVarNames_ が _n_ を含まないなら
              1. _n_ を _instantiatedVarNames_ に追加する。
              1. ! _env_.CreateMutableBinding(_n_, *false*) を実行する。
              1. ! _env_.InitializeBinding(_n_, *undefined*) を実行する。
          1. _varEnv_ を _env_ とする。
        1. それ以外
          1. 注記: 形式パラメータリスト内の式で生成されるクロージャが関数本体内の宣言を可視化しないよう別 Environment Record が必要。
          1. _varEnv_ を NewDeclarativeEnvironment(_env_) とする。
          1. _calleeContext_ の VariableEnvironment を _varEnv_ に設定する。
          1. _instantiatedVarNames_ を新しい空の List とする。
          1. _varNames_ の各要素 _n_ について
            1. _instantiatedVarNames_ が _n_ を含まないなら
              1. _n_ を _instantiatedVarNames_ に追加する。
              1. ! _varEnv_.CreateMutableBinding(_n_, *false*) を実行する。
              1. _parameterBindings_ が _n_ を含まない、または _functionNames_ が _n_ を含むなら
                1. _initialValue_ を *undefined* とする。
              1. それ以外
                1. _initialValue_ を ! _env_.GetBindingValue(_n_, *false*) とする。
              1. ! _varEnv_.InitializeBinding(_n_, _initialValue_) を実行する。
              1. 注記: 仮引数と同じ名前の var は初期的に対応する初期化済み仮引数と同じ値を持つ。
        1. _strict_ が *true* なら
          1. _lexEnv_ を _varEnv_ とする。
        1. それ以外
          1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point", normative-optional] ホストが web ブラウザであるか、または <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> をサポートするなら
            1. _code_ Contains _x_ が *true* である任意の |Block|, |CaseClause|, |DefaultClause| の |StatementList| に直接含まれる各 |FunctionDeclaration| _f_ について
              1. _F_ を _f_ の |BindingIdentifier| の StringValue とする。
              1. |FunctionDeclaration| _f_ を _F_ を |BindingIdentifier| とする |VariableStatement| に置き換えても _func_ に Early Errors を生じさせず、かつ _parameterNames_ が _F_ を含まないなら
                1. 注記: _F_ の var 束縛は VarDeclaredName、仮引数名、別の |FunctionDeclaration| のいずれでもない場合のみここでインスタンス化される。
                1. _instantiatedVarNames_ が _F_ を含まずかつ _F_ が *"arguments"* でないなら
                  1. ! _varEnv_.CreateMutableBinding(_F_, *false*) を実行する。
                  1. ! _varEnv_.InitializeBinding(_F_, *undefined*) を実行する。
                  1. _F_ を _instantiatedVarNames_ に追加する。
                1. [id="step-functiondeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_ が評価されるとき、<emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> で提供される |FunctionDeclaration| Evaluation アルゴリズムの代わりに次を行う:
                  1. _fEnv_ を実行中実行コンテキストの VariableEnvironment とする。
                  1. _bEnv_ を実行中実行コンテキストの LexicalEnvironment とする。
                  1. _fObj_ を ! _bEnv_.GetBindingValue(_F_, *false*) とする。
                  1. ! _fEnv_.SetMutableBinding(_F_, _fObj_, *false*) を実行する。
                  1. ~unused~ を返す。
          1. _lexEnv_ を NewDeclarativeEnvironment(_varEnv_) とする。
          1. 注記: Non-strict 関数はトップレベル lexical 宣言用に別の Environment Record を使用し、direct eval が eval コードで導入される var スコープ宣言が既存のトップレベル lexical 宣言と衝突するか判別できるようにする。strict 関数では strict direct eval がすべての宣言を新しい Environment Record に置くため不要。
        1. _calleeContext_ の LexicalEnvironment を _lexEnv_ に設定する。
        1. _lexDeclarations_ を _code_ の LexicallyScopedDeclarations とする。
        1. _lexDeclarations_ の各要素 _d_ について
          1. 注記: lexical に宣言された名前は function/generator 宣言、仮引数、var 名と同一になりえない。lexical 宣言された名前はここでインスタンス化されるが初期化されない。
          1. _d_ の BoundNames の各要素 _dn_ について
            1. IsConstantDeclaration of _d_ が *true* なら
              1. ! _lexEnv_.CreateImmutableBinding(_dn_, *true*) を実行する。
            1. それ以外
              1. ! _lexEnv_.CreateMutableBinding(_dn_, *false*) を実行する。
        1. _privateEnv_ を _calleeContext_ の PrivateEnvironment とする。
        1. _functionsToInitialize_ の各 Parse Node _f_ について
          1. _fn_ を _f_ の BoundNames の唯一の要素とする。
          1. _fo_ を InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_ とする。
          1. ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-function-objects">
    <h1>組み込み関数オブジェクト (Built-in Function Objects)</h1>
    <p>組み込み関数オブジェクトは通常オブジェクトであり、<emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> で定められる通常オブジェクトの要件を満たさなければならない。</p>
    <p>すべての通常オブジェクトに要求される内部スロット（<emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 参照）に加えて、組み込み関数オブジェクトは次の内部スロットも持たなければならない:</p>
    <ul>
      <li>[[Realm]]: その関数が生成された realm を表す Realm Record。</li>
      <li>[[InitialName]]: 関数の初期名である String。<emu-xref href="#sec-function.prototype.tostring"></emu-xref> で使用される。</li>
    </ul>
    <p>組み込み関数オブジェクトの [[Prototype]] 内部スロットの初期値は、特に指定がない限り %Function.prototype% である。</p>
    <p>組み込み関数オブジェクトは <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref> の定義に適合する [[Call]] 内部メソッドを持たなければならない。</p>
    <p>組み込み関数オブジェクトは “constructor” と記述される場合、または本仕様のあるアルゴリズムが明示的にその [[Construct]] 内部メソッドを設定する場合に限り [[Construct]] 内部メソッドを持つ。そうした [[Construct]] 内部メソッドは <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> の定義に適合しなければならない。</p>
    <p>実装は本仕様で定義されない追加の組み込み関数オブジェクトを提供してもよい。</p>

    <emu-clause id="sec-built-in-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 言語値を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>組み込み関数オブジェクト _F_</dd>
      </dl>
      <emu-alg>
        1. ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-built-in-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): Object を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>（このメソッドを持つ場合の）組み込み関数オブジェクト _F_</dd>
      </dl>
      <emu-alg>
        1. _result_ を ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_) とする。
        1. アサート: _result_ は Object である。
        1. _result_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-builtincallorconstruct" type="abstract operation">
      <h1>
        BuiltinCallOrConstruct (
          _F_: a built-in function object,
          _thisArgument_: an ECMAScript language value or ~uninitialized~,
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor or *undefined*,
        ): ECMAScript 言語値を含む正常完了または throw 完了
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _callerContext_ を実行中実行コンテキストとする。
        1. _callerContext_ がまだサスペンドされていないなら _callerContext_ をサスペンドする。
        1. _calleeContext_ を新しい実行コンテキストとする。
        1. _calleeContext_ の Function を _F_ に設定する。
        1. _calleeRealm_ を _F_.[[Realm]] とする。
        1. _calleeContext_ の Realm を _calleeRealm_ に設定する。
        1. _calleeContext_ の ScriptOrModule を *null* に設定する。
        1. 必要な実装定義の初期化を _calleeContext_ に対して行う。
        1. 実行コンテキストスタックに _calleeContext_ を push する；_calleeContext_ が実行中実行コンテキストとなる。
        1. [id="step-call-builtin-function-result"] _result_ を、_F_ の仕様に適合する形で _F_ を評価した結果である Completion Record とする。_thisArgument_ が ~uninitialized~ なら *this* 値は未初期化、それ以外の場合 _thisArgument_ が *this* 値を提供する。_argumentsList_ は名前付き引数を提供し、_newTarget_ は NewTarget 値を提供する。
        1. 注記: _F_ がこの文書内で定義されている場合、「_F_ の仕様」とはアルゴリズム手順や他の手段で指定されたその挙動である。
        1. 実行コンテキストスタックから _calleeContext_ を除去し _callerContext_ を実行中実行コンテキストとして復元する。
        1. ? _result_ を返す。
      </emu-alg>
      <emu-note>
        <p>_calleeContext_ が実行コンテキストスタックから除去されるとき、アクセス可能な Generator により後で再開するためサスペンド保持されている場合は破棄されてはならない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createbuiltinfunction" type="abstract operation">
      <h1>
        CreateBuiltinFunction (
          _behaviour_: an Abstract Closure, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification,
          _length_: a non-negative integer or +&infin;,
          _name_: a property key or a Private Name,
          _additionalInternalSlotsList_: a List of names of internal slots,
          optional _realm_: a Realm Record,
          optional _prototype_: an Object or *null*,
          optional _prefix_: a String,
        ): a built-in function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_additionalInternalSlotsList_ にはオブジェクトの一部として定義されなければならない追加内部スロット名が含まれる。この操作は組み込み関数オブジェクトを生成する。</dd>
      </dl>
      <emu-alg>
        1. _realm_ が与えられていなければ _realm_ を current Realm Record に設定する。
        1. _prototype_ が与えられていなければ _prototype_ を _realm_.[[Intrinsics]].[[%Function.prototype%]] に設定する。
        1. _internalSlotsList_ を、これから生成する組み込み関数オブジェクトに <emu-xref href="#sec-built-in-function-objects"></emu-xref> が要求するすべての内部スロット名を含む List とする。
        1. _additionalInternalSlotsList_ の要素を _internalSlotsList_ に追加する。
        1. _func_ を新しい組み込み関数オブジェクトとし、呼び出されたとき _behaviour_ で指定された対応パラメータに与えられた引数を渡して _behaviour_ に記述された動作を行うものとする。この新しい関数オブジェクトは名前が _internalSlotsList_ の要素である内部スロット群と [[InitialName]] 内部スロットを持つ。
        1. _func_.[[Prototype]] を _prototype_ に設定する。
        1. _func_.[[Extensible]] を *true* に設定する。
        1. _func_.[[Realm]] を _realm_ に設定する。
        1. _func_.[[InitialName]] を *null* に設定する。
        1. SetFunctionLength(_func_, _length_) を実行する。
        1. _prefix_ が与えられていないなら
          1. SetFunctionName(_func_, _name_) を実行する。
        1. それ以外
          1. SetFunctionName(_func_, _name_, _prefix_) を実行する。
        1. _func_ を返す。
      </emu-alg>
      <p>本仕様で定義される各組み込み関数は CreateBuiltinFunction 抽象操作を呼び出すことで生成される。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1>組み込みエキゾチックオブジェクトの内部メソッドとスロット (Built-in Exotic Object Internal Methods and Slots)</h1>
    <p>本仕様はいくつかの種類の組み込みエキゾチックオブジェクトを定義する。これらのオブジェクトは特定の状況を除いて一般に通常オブジェクトと同様に振る舞う。以下のエキゾチックオブジェクトは、下で明示的に別途指定される場合を除き通常オブジェクト内部メソッドを使用する:</p>

    <emu-clause id="sec-bound-function-exotic-objects">
      <h1>束縛関数エキゾチックオブジェクト (Bound Function Exotic Objects)</h1>
      <p>束縛関数エキゾチックオブジェクトは別の関数オブジェクトを包むエキゾチックオブジェクトである。束縛関数エキゾチックオブジェクトは呼び出し可能（[[Call]] 内部メソッドを持ち、[[Construct]] 内部メソッドを持つ場合がある）。束縛関数エキゾチックオブジェクトを呼び出すことは一般に包まれた関数の呼び出しをもたらす。</p>

      <p>オブジェクトの [[Call]] および（該当する場合）[[Construct]] 内部メソッドが以下の実装を使用し、その他の必須内部メソッドが <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> の定義を使用する場合、そのオブジェクトは <dfn id="bound-function-exotic-object" variants="bound function exotic objects">束縛関数エキゾチックオブジェクト</dfn> である。これらのメソッドは BoundFunctionCreate で設定される。</p>

      <p>束縛関数エキゾチックオブジェクトは <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> に列挙される ECMAScript 関数オブジェクトの内部スロットを持たない。代わりに [[Prototype]] と [[Extensible]] に加えて <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> に列挙される内部スロットを持つ。</p>
      <emu-table id="table-internal-slots-of-bound-function-exotic-objects" caption="束縛関数エキゾチックオブジェクトの内部スロット (Internal Slots of Bound Function Exotic Objects)" oldids="table-28">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BoundTargetFunction]]
            </td>
            <td>
              a callable Object
            </td>
            <td>
              包まれている関数オブジェクト。
            </td>
          </tr>
          <tr>
            <td>
              [[BoundThis]]
            </td>
            <td>
              an ECMAScript language value
            </td>
            <td>
              包まれた関数を呼ぶ際に常に *this* 値として渡される値。
            </td>
          </tr>
          <tr>
            <td>
              [[BoundArguments]]
            </td>
            <td>
              a List of ECMAScript language values
            </td>
            <td>
              包まれた関数へのあらゆる呼び出しで最初の引数として使用される要素のリスト。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-bound-function-exotic-objects-call-thisargument-argumentslist" type="internal method">
        <h1>
          [[Call]] (
            _thisArgument_: an ECMAScript language value,
            _argumentsList_: a List of ECMAScript language values,
          ): ECMAScript 言語値を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>束縛関数エキゾチックオブジェクト _F_</dd>
        </dl>
        <emu-alg>
          1. _target_ を _F_.[[BoundTargetFunction]] とする。
          1. _boundThis_ を _F_.[[BoundThis]] とする。
          1. _boundArgs_ を _F_.[[BoundArguments]] とする。
          1. _args_ を _boundArgs_ と _argumentsList_ のリスト結合とする。
          1. ? Call(_target_, _boundThis_, _args_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bound-function-exotic-objects-construct-argumentslist-newtarget" type="internal method">
        <h1>
          [[Construct]] (
            _argumentsList_: a List of ECMAScript language values,
            _newTarget_: a constructor,
          ): Object を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>束縛関数エキゾチックオブジェクト _F_</dd>
        </dl>
        <emu-alg>
          1. _target_ を _F_.[[BoundTargetFunction]] とする。
          1. アサート: IsConstructor(_target_) は *true*。
          1. _boundArgs_ を _F_.[[BoundArguments]] とする。
          1. _args_ を _boundArgs_ と _argumentsList_ のリスト結合とする。
          1. SameValue(_F_, _newTarget_) が *true* なら _newTarget_ を _target_ に設定する。
          1. ? Construct(_target_, _args_, _newTarget_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundfunctioncreate" type="abstract operation">
        <h1>
          BoundFunctionCreate (
            _targetFunction_: a function object,
            _boundThis_: an ECMAScript language value,
            _boundArgs_: a List of ECMAScript language values,
          ): function object を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>新しい束縛関数エキゾチックオブジェクトの生成を規定する。</dd>
        </dl>
        <emu-alg>
          1. _proto_ を ? <emu-meta effects="user-code">_targetFunction_.[[GetPrototypeOf]]</emu-meta>() とする。
          1. _internalSlotsList_ を « [[Prototype]], [[Extensible]] » と <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> に列挙される内部スロットのリスト結合とする。
          1. _obj_ を MakeBasicObject(_internalSlotsList_) とする。
          1. _obj_.[[Prototype]] を _proto_ に設定する。
          1. _obj_.[[Call]] を <emu-xref href="#sec-bound-function-exotic-objects-call-thisargument-argumentslist"></emu-xref> で述べるとおりに設定する。
          1. IsConstructor(_targetFunction_) が *true* なら
            1. _obj_.[[Construct]] を <emu-xref href="#sec-bound-function-exotic-objects-construct-argumentslist-newtarget"></emu-xref> で述べるとおりに設定する。
          1. _obj_.[[BoundTargetFunction]] を _targetFunction_ に設定する。
          1. _obj_.[[BoundThis]] を _boundThis_ に設定する。
          1. _obj_.[[BoundArguments]] を _boundArgs_ に設定する。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-exotic-objects">
      <h1>配列エキゾチックオブジェクト (Array Exotic Objects)</h1>
      <p>Array は配列インデックスプロパティキー（<emu-xref href="#sec-object-type"></emu-xref> 参照）に特別な扱いを与えるエキゾチックオブジェクトである。プロパティ名が配列インデックスであるプロパティは <em>要素 (element)</em> とも呼ばれる。すべての Array は設定不可 (*"length"*) プロパティを持ち、その値は常に 2<sup>32</sup> より厳密に小さい非負整数的 Number である。*"length"* プロパティの値は、自身の名前が配列インデックスであるすべての自身プロパティ名より数値的に大きい；Array の自身プロパティが生成または変更されたとき、この不変条件を維持するために他のプロパティが必要に応じ調整される。具体的には、名前が配列インデックスである自身プロパティが追加されるたび、必要なら *"length"* プロパティの値はその配列インデックスの数値値 + 1 に変更され；*"length"* プロパティの値が変更されるたび、新しい length 以上の値を持つ配列インデックス名の自身プロパティはすべて削除される。この制約は Array の自身プロパティにのみ適用され、そのプロトタイプから継承される *"length"* や配列インデックスプロパティには影響されない。</p>

      <p>オブジェクトの [[DefineOwnProperty]] 内部メソッドが以下の実装を使用し、他の必須内部メソッドが <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> の定義を使用する場合、そのオブジェクトは <dfn id="array-exotic-object" variants="Array exotic objects">Array エキゾチックオブジェクト</dfn>（単に Array）である。これらのメソッドは ArrayCreate で設定される。</p>

      <emu-clause id="sec-array-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>Array エキゾチックオブジェクト _A_</dd>
        </dl>
        <emu-alg>
          1. _P_ が *"length"* なら
            1. ? ArraySetLength(_A_, _Desc_) を返す。
          1. それ以外で _P_ が配列インデックスなら
            1. _lengthDesc_ を OrdinaryGetOwnProperty(_A_, *"length"*) とする。
            1. アサート: _lengthDesc_ は *undefined* ではない。
            1. アサート: IsDataDescriptor(_lengthDesc_) は *true*。
            1. アサート: _lengthDesc_.[[Configurable]] は *false*。
            1. _length_ を _lengthDesc_.[[Value]] とする。
            1. アサート: _length_ は非負整数的 Number である。
            1. _index_ を ! ToUint32(_P_) とする。
            1. _index_ ≥ _length_ かつ _lengthDesc_.[[Writable]] が *false* なら *false* を返す。
            1. _succeeded_ を ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_) とする。
            1. _succeeded_ が *false* なら *false* を返す。
            1. _index_ ≥ _length_ なら
              1. _lengthDesc_.[[Value]] を _index_ + *1*<sub>𝔽</sub> に設定する。
              1. _succeeded_ を ! OrdinaryDefineOwnProperty(_A_, *"length"*, _lengthDesc_) に設定する。
              1. アサート: _succeeded_ は *true*。
            1. *true* を返す。
          1. ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraycreate" type="abstract operation">
        <h1>
          ArrayCreate (
            _length_: a non-negative integer,
            optional _proto_: an Object,
          ): Array エキゾチックオブジェクトまたは throw 完了
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>新しい Array の生成を規定する。</dd>
        </dl>
        <emu-alg>
          1. _length_ > 2<sup>32</sup> - 1 なら *RangeError* 例外を投げる。
          1. _proto_ が与えられていなければ _proto_ を %Array.prototype% に設定する。
          1. _A_ を MakeBasicObject(« [[Prototype]], [[Extensible]] ») とする。
          1. _A_.[[Prototype]] を _proto_ に設定する。
          1. _A_.[[DefineOwnProperty]] を <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref> で規定されるとおりに設定する。
          1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行する。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arrayspeciescreate" type="abstract operation">
        <h1>
          ArraySpeciesCreate (
            _originalArray_: an Object,
            _length_: a non-negative integer,
          ): Object を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_originalArray_ から派生したコンストラクタ関数を用いて新しい Array または類似オブジェクトを生成することを規定する。コンストラクタが Array を返すことは強制されない。</dd>
        </dl>
        <emu-alg>
          1. _isArray_ を ? IsArray(_originalArray_) とする。
          1. _isArray_ が *false* なら ? ArrayCreate(_length_) を返す。
          1. _C_ を ? Get(_originalArray_, *"constructor"*) とする。
          1. IsConstructor(_C_) が *true* なら
            1. _thisRealm_ を current Realm Record とする。
            1. _realmC_ を ? GetFunctionRealm(_C_) とする。
            1. _thisRealm_ と _realmC_ が同じ Realm Record でないなら
              1. SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) が *true* なら _C_ を *undefined* に設定する。
          1. _C_ が Object なら
            1. _C_ を ? Get(_C_, %Symbol.species%) に設定する。
            1. _C_ が *null* なら _C_ を *undefined* に設定する。
          1. _C_ が *undefined* なら ? ArrayCreate(_length_) を返す。
          1. IsConstructor(_C_) が *false* なら *TypeError* 例外を投げる。
          1. ? Construct(_C_, « 𝔽(_length_) ») を返す。
        </emu-alg>
        <emu-note>
          <p>_originalArray_ が実行中実行コンテキストの realm ではない realm の標準組み込み Array コンストラクタを用いて生成されていた場合、実行中実行コンテキストの realm を用いて新しい Array が生成される。これは歴史的に `Array.prototype` メソッドがそのような動作をしていた Web ブラウザとの互換性を維持する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-arraysetlength" type="abstract operation">
        <h1>
          ArraySetLength (
            _A_: an Array,
            _Desc_: a Property Descriptor,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_ が [[Value]] フィールドを持たないなら
            1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _Desc_) を返す。
          1. _newLenDesc_ を _Desc_ のコピーとする。
          1. [id="step-arraysetlength-newlen"] _newLen_ を ? ToUint32(_Desc_.[[Value]]) とする。
          1. [id="step-arraysetlength-numberlen"] _numberLen_ を ? ToNumber(_Desc_.[[Value]]) とする。
          1. SameValueZero(_newLen_, _numberLen_) が *false* なら *RangeError* 例外を投げる。
          1. _newLenDesc_.[[Value]] を _newLen_ に設定する。
          1. _oldLenDesc_ を OrdinaryGetOwnProperty(_A_, *"length"*) とする。
          1. アサート: _oldLenDesc_ は *undefined* ではない。
          1. アサート: IsDataDescriptor(_oldLenDesc_) は *true*。
          1. アサート: _oldLenDesc_.[[Configurable]] は *false*。
          1. _oldLen_ を _oldLenDesc_.[[Value]] とする。
          1. _newLen_ ≥ _oldLen_ なら
            1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) を返す。
          1. _oldLenDesc_.[[Writable]] が *false* なら *false* を返す。
          1. _newLenDesc_ が [[Writable]] フィールドを持たないか _newLenDesc_.[[Writable]] が *true* なら
            1. _newWritable_ を *true* とする。
          1. それ以外
            1. 注記: [[Writable]] 属性を *false* に設定するのは、要素が削除できない場合に備えて遅延される。
            1. _newWritable_ を *false* とする。
            1. _newLenDesc_.[[Writable]] を *true* に設定する。
          1. _succeeded_ を ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) とする。
          1. _succeeded_ が *false* なら *false* を返す。
          1. _A_ の各自身プロパティキー _P_ で _P_ が配列インデックスかつ ! ToUint32(_P_) ≥ _newLen_ であるものについて、数値インデックス降順で:
            1. _deleteSucceeded_ を ! _A_.[[Delete]](_P_) とする。
            1. _deleteSucceeded_ が *false* なら
              1. _newLenDesc_.[[Value]] を ! ToUint32(_P_) + *1*<sub>𝔽</sub> に設定する。
              1. _newWritable_ が *false* なら _newLenDesc_.[[Writable]] を *false* に設定する。
              1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) を実行する。
              1. *false* を返す。
          1. _newWritable_ が *false* なら
            1. _succeeded_ を ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Writable]]: *false* }) に設定する。
            1. アサート: _succeeded_ は *true*。
          1. *true* を返す。
        </emu-alg>
        <emu-note>
          <p>ステップ <emu-xref href="#step-arraysetlength-newlen"></emu-xref> および <emu-xref href="#step-arraysetlength-numberlen"></emu-xref> では、_Desc_.[[Value]] がオブジェクトの場合その `valueOf` メソッドが 2 回呼び出される。これは本仕様第 2 版以降この効果を伴うよう規定されたレガシー動作である。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-exotic-objects">
      <h1>文字列エキゾチックオブジェクト (String Exotic Objects)</h1>
      <p>String オブジェクトは String 値をカプセル化し、その String 値の個々のコード単位要素に対応する仮想の整数インデックス付きデータプロパティを公開するエキゾチックオブジェクトである。String エキゾチックオブジェクトは常に *"length"* という名前のデータプロパティを持ち、その値はカプセル化された String 値の長さである。コード単位データプロパティと *"length"* プロパティはいずれも書き込み不可かつ設定不可である。</p>

      <p>オブジェクトの [[GetOwnProperty]]、[[DefineOwnProperty]]、[[OwnPropertyKeys]] 内部メソッドが以下の実装を使用し、他の必須内部メソッドが <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> の定義を使用する場合、そのオブジェクトは <dfn id="string-exotic-object" variants="String exotic objects">String エキゾチックオブジェクト</dfn>（単に String オブジェクト）である。これらのメソッドは StringCreate で設定される。</p>

      <p>String エキゾチックオブジェクトは通常オブジェクトと同じ内部スロットを持つ。また [[StringData]] 内部スロットを持つ。</p>

      <emu-clause id="sec-string-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor か *undefined* を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String エキゾチックオブジェクト _S_</dd>
        </dl>
        <emu-alg>
          1. _desc_ を OrdinaryGetOwnProperty(_S_, _P_) とする。
          1. _desc_ が *undefined* でないなら _desc_ を返す。
          1. StringGetOwnProperty(_S_, _P_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String エキゾチックオブジェクト _S_</dd>
        </dl>
        <emu-alg>
          1. _stringDesc_ を StringGetOwnProperty(_S_, _P_) とする。
          1. _stringDesc_ が *undefined* でないなら
            1. _extensible_ を _S_.[[Extensible]] とする。
            1. IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_) を返す。
          1. ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): プロパティキーの List を含む正常完了</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. _keys_ を新しい空の List とする。
          1. _str_ を _O_.[[StringData]] とする。
          1. アサート: _str_ は String である。
          1. _len_ を _str_ の長さとする。
          1. 0 ≤ _i_ < _len_ を満たす各整数 _i_ について昇順で:
            1. ! ToString(𝔽(_i_)) を _keys_ に追加する。
          1. _O_ の各自身プロパティキー _P_ で _P_ が配列インデックスかつ ! ToIntegerOrInfinity(_P_) ≥ _len_ であるものについて、数値インデックス昇順で:
            1. _P_ を _keys_ に追加する。
          1. _O_ の各自身プロパティキー _P_ で _P_ が String かつ配列インデックスでないものについて、作成順昇順で:
            1. _P_ を _keys_ に追加する。
          1. _O_ の各自身プロパティキー _P_ で _P_ が Symbol であるものについて、作成順昇順で:
            1. _P_ を _keys_ に追加する。
          1. _keys_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringcreate" type="abstract operation">
        <h1>
          StringCreate (
            _value_: a String,
            _prototype_: an Object,
          ): a String exotic object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>新しい String エキゾチックオブジェクトの生成を規定する。</dd>
        </dl>
        <emu-alg>
          1. _S_ を MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] ») とする。
          1. _S_.[[Prototype]] を _prototype_ に設定する。
          1. _S_.[[StringData]] を _value_ に設定する。
          1. _S_.[[GetOwnProperty]] を <emu-xref href="#sec-string-exotic-objects-getownproperty-p"></emu-xref> で規定されるとおりに設定する。
          1. _S_.[[DefineOwnProperty]] を <emu-xref href="#sec-string-exotic-objects-defineownproperty-p-desc"></emu-xref> で規定されるとおりに設定する。
          1. _S_.[[OwnPropertyKeys]] を <emu-xref href="#sec-string-exotic-objects-ownpropertykeys"></emu-xref> で規定されるとおりに設定する。
          1. _length_ を _value_ の長さとする。
          1. ! DefinePropertyOrThrow(_S_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行する。
          1. _S_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringgetownproperty" type="abstract operation">
        <h1>
          StringGetOwnProperty (
            _S_: an Object that has a [[StringData]] internal slot,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _P_ が String でなければ *undefined* を返す。
          1. _index_ を CanonicalNumericIndexString(_P_) とする。
          1. _index_ が整数的 Number でなければ *undefined* を返す。
          1. _index_ が *-0*<sub>𝔽</sub> または _index_ < *-0*<sub>𝔽</sub> なら *undefined* を返す。
          1. _str_ を _S_.[[StringData]] とする。
          1. アサート: _str_ は String。
          1. _len_ を _str_ の長さとする。
          1. ℝ(_index_) ≥ _len_ なら *undefined* を返す。
          1. _resultStr_ を _str_ の ℝ(_index_) から ℝ(_index_) + 1 までの部分文字列とする。
          1. PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* } を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arguments-exotic-objects">
      <h1>arguments エキゾチックオブジェクト (Arguments Exotic Objects)</h1>

      <p>ほとんどの ECMAScript 関数はそのコードに arguments オブジェクトを利用可能にする。関数定義の特性に応じて、その arguments オブジェクトは通常オブジェクトか arguments エキゾチックオブジェクトのいずれかである。arguments エキゾチックオブジェクトは、配列インデックスプロパティが関連 ECMAScript 関数の呼び出しでの仮引数束縛に対応付けられるエキゾチックオブジェクトである。</p>

      <p>オブジェクトの内部メソッドが以下の実装を使用し、ここで指定されないものが <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> の定義を使用する場合、そのオブジェクトは <dfn id="arguments-exotic-object" variants="arguments exotic objects">arguments エキゾチックオブジェクト</dfn> である。これらのメソッドは CreateMappedArgumentsObject で設定される。</p>

      <emu-note>
        <p>CreateUnmappedArgumentsObject はこの節にまとめられているが、通常オブジェクトを生成し arguments エキゾチックオブジェクトは生成しない。</p>
      </emu-note>

      <p>arguments エキゾチックオブジェクトは通常オブジェクトと同じ内部スロットを持つ。また [[ParameterMap]] 内部スロットを持つ。通常の arguments オブジェクトも常に *undefined* である [[ParameterMap]] 内部スロットを持つ。通常の arguments オブジェクトでは [[ParameterMap]] 内部スロットは `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) によりその識別にのみ使われる。</p>

      <emu-note>
        <p>対応する関数オブジェクトの仮引数数より小さい数値名を持つ arguments エキゾチックオブジェクトの整数インデックスデータプロパティは、初期状態で関数の実行コンテキスト内の対応する引数束縛の値を共有する。これはそのプロパティを変更すると対応する引数束縛の値も変わり、逆も同様であることを意味する。この対応はそのようなプロパティが削除され再定義された場合、またはアクセサプロパティに変換された場合に失われる。arguments オブジェクトが通常オブジェクトであれば、そのプロパティ値は単に関数に渡された引数のコピーであり、プロパティ値と仮引数値の動的リンクは存在しない。</p>
      </emu-note>
      <emu-note>
        <p>ParameterMap オブジェクトとそのプロパティ値は arguments オブジェクトと引数束縛間の対応を仕様化するための装置として使用される。ParameterMap オブジェクトやそのプロパティ値であるオブジェクトは ECMAScript コードから直接観測できない。実装は指定されたセマンティクスを実現するために実際にそれらを生成または使用する必要はない。</p>
      </emu-note>
      <emu-note>
        <p>通常の arguments オブジェクトはアクセス時に *TypeError* 例外を投げる設定不可のアクセサプロパティ *"callee"* を定義する。*"callee"* プロパティは non-strict 関数の一部にのみ生成される arguments エキゾチックオブジェクトではより特定の意味を持つ。通常バリアントでこのプロパティを定義するのは、適合実装が他のいかなる形でも定義しないことを保証するためである。</p>
      </emu-note>
      <emu-note>
        <p>arguments エキゾチックオブジェクトの実装は歴史的に *"caller"* というアクセサプロパティを含んでいた。ECMAScript 2017 以前、この仕様は通常 arguments オブジェクト上の投げる *"caller"* プロパティの定義を含んでいた。実装がもはやこの拡張を含まないため、ECMAScript 2017 は投げる *"caller"* アクセサの要件を削除した。</p>
      </emu-note>

      <emu-clause id="sec-arguments-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor か *undefined* を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments エキゾチックオブジェクト _args_</dd>
        </dl>
        <emu-alg>
          1. _desc_ を OrdinaryGetOwnProperty(_args_, _P_) とする。
          1. _desc_ が *undefined* なら *undefined* を返す。
          1. _map_ を _args_.[[ParameterMap]] とする。
          1. _isMapped_ を ! HasOwnProperty(_map_, _P_) とする。
          1. _isMapped_ が *true* なら
            1. _desc_.[[Value]] を ! Get(_map_, _P_) に設定する。
          1. _desc_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments エキゾチックオブジェクト _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ を _args_.[[ParameterMap]] とする。
          1. _isMapped_ を ! HasOwnProperty(_map_, _P_) とする。
          1. _newArgDesc_ を _Desc_ とする。
          1. _isMapped_ が *true* かつ IsDataDescriptor(_Desc_) が *true* の場合、
            1. _Desc_ が [[Value]] フィールドを持たず [[Writable]] フィールドを持ち _Desc_.[[Writable]] が *false* なら
              1. _newArgDesc_ を _Desc_ のコピーとする。
              1. _newArgDesc_.[[Value]] を ! Get(_map_, _P_) に設定する。
          1. _allowed_ を ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_) とする。
          1. _allowed_ が *false* なら *false* を返す。
          1. _isMapped_ が *true* なら
            1. IsAccessorDescriptor(_Desc_) が *true* なら
              1. ! _map_.[[Delete]](_P_) を実行する。
            1. それ以外
              1. _Desc_ が [[Value]] フィールドを持つなら
                1. アサート: arguments オブジェクトによりマップされる仮引数は常に書き込み可能であるため以下の Set は成功する。
                1. ! Set(_map_, _P_, _Desc_.[[Value]], *false*) を実行する。
              1. _Desc_ が [[Writable]] フィールドを持ち _Desc_.[[Writable]] が *false* なら
                1. ! _map_.[[Delete]](_P_) を実行する。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 言語値を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments エキゾチックオブジェクト _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ を _args_.[[ParameterMap]] とする。
          1. _isMapped_ を ! HasOwnProperty(_map_, _P_) とする。
          1. _isMapped_ が *false* なら
            1. ? OrdinaryGet(_args_, _P_, _Receiver_) を返す。
          1. それ以外
            1. アサート: _map_ は _P_ に対する仮引数マッピングを含む。
            1. ! Get(_map_, _P_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments エキゾチックオブジェクト _args_</dd>
        </dl>
        <emu-alg>
          1. SameValue(_args_, _Receiver_) が *false* なら
            1. _isMapped_ を *false* とする。
          1. それ以外
            1. _map_ を _args_.[[ParameterMap]] とする。
            1. _isMapped_ を ! HasOwnProperty(_map_, _P_) とする。
          1. _isMapped_ が *true* なら
            1. アサート: 以下の Set は成功する。なぜなら arguments オブジェクトによりマップされる仮引数は常に書き込み可能だからである。
            1. ! Set(_map_, _P_, _V_, *false*) を実行する。
          1. ? OrdinarySet(_args_, _P_, _V_, _Receiver_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments エキゾチックオブジェクト _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ を _args_.[[ParameterMap]] とする。
          1. _isMapped_ を ! HasOwnProperty(_map_, _P_) とする。
          1. _result_ を ? OrdinaryDelete(_args_, _P_) とする。
          1. _result_ が *true* かつ _isMapped_ が *true* なら
            1. ! _map_.[[Delete]](_P_) を実行する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createunmappedargumentsobject" type="abstract operation">
        <h1>
          CreateUnmappedArgumentsObject (
            _argumentsList_: a List of ECMAScript language values,
          ): an ordinary object
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _len_ を _argumentsList_ の要素数とする。
          1. _obj_ を OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] ») とする。
          1. _obj_.[[ParameterMap]] を *undefined* に設定する。
          1. ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
          1. _index_ を 0 とする。
          1. _index_ < _len_ の間繰り返す:
            1. _val_ を _argumentsList_[_index_] とする。
            1. ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_) を実行する。
            1. _index_ を _index_ + 1 に設定する。
          1. ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
          1. ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行する。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createmappedargumentsobject" type="abstract operation">
        <h1>
          CreateMappedArgumentsObject (
            _func_: an Object,
            _formals_: a Parse Node,
            _argumentsList_: a List of ECMAScript language values,
            _env_: an Environment Record,
          ): an arguments exotic object
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: _formals_ は rest パラメータ、任意の binding pattern、任意の initializer を含まず、重複識別子を含んでもよい。
          1. _len_ を _argumentsList_ の要素数とする。
          1. _obj_ を MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] ») とする。
          1. _obj_.[[GetOwnProperty]] を <emu-xref href="#sec-arguments-exotic-objects-getownproperty-p"></emu-xref> で規定されるとおりに設定する。
          1. _obj_.[[DefineOwnProperty]] を <emu-xref href="#sec-arguments-exotic-objects-defineownproperty-p-desc"></emu-xref> で規定されるとおりに設定する。
          1. _obj_.[[Get]] を <emu-xref href="#sec-arguments-exotic-objects-get-p-receiver"></emu-xref> で規定されるとおりに設定する。
          1. _obj_.[[Set]] を <emu-xref href="#sec-arguments-exotic-objects-set-p-v-receiver"></emu-xref> で規定されるとおりに設定する。
          1. _obj_.[[Delete]] を <emu-xref href="#sec-arguments-exotic-objects-delete-p"></emu-xref> で規定されるとおりに設定する。
          1. _obj_.[[Prototype]] を %Object.prototype% に設定する。
          1. _map_ を OrdinaryObjectCreate(*null*) とする。
          1. _obj_.[[ParameterMap]] を _map_ に設定する。
          1. _parameterNames_ を _formals_ の BoundNames とする。
          1. _numberOfParameters_ を _parameterNames_ の要素数とする。
          1. _index_ を 0 とする。
          1. _index_ < _len_ の間繰り返す:
            1. _val_ を _argumentsList_[_index_] とする。
            1. ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_) を実行する。
            1. _index_ を _index_ + 1 に設定する。
          1. ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
          1. _mappedNames_ を新しい空の List とする。
          1. _index_ を _numberOfParameters_ - 1 に設定する。
          1. _index_ ≥ 0 の間繰り返す:
            1. _name_ を _parameterNames_[_index_] とする。
            1. _mappedNames_ が _name_ を含まないなら
              1. _mappedNames_ に _name_ を追加する。
              1. _index_ < _len_ なら
                1. _g_ を MakeArgGetter(_name_, _env_) とする。
                1. _p_ を MakeArgSetter(_name_, _env_) とする。
                1. ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
            1. _index_ を _index_ - 1 に設定する。
          1. ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
          1. ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) を実行する。
          1. _obj_ を返す。
        </emu-alg>

        <emu-clause id="sec-makearggetter" type="abstract operation">
          <h1>
            MakeArgGetter (
              _name_: a String,
              _env_: an Environment Record,
            ): a function object
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_env_ において _name_ に束縛された値を返す組み込み関数オブジェクトを生成する。</dd>
          </dl>
          <emu-alg>
            1. _getterClosure_ を、新しい引数なし Abstract Closure とし、_name_ と _env_ を捕捉し呼び出されたとき次を行うものとする:
              1. NormalCompletion(! _env_.GetBindingValue(_name_, *false*)) を返す。
            1. _getter_ を CreateBuiltinFunction(_getterClosure_, 0, *""*, « ») とする。
            1. 注記: _getter_ は ECMAScript コードから直接アクセスされない。
            1. _getter_ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-makeargsetter" type="abstract operation">
          <h1>
            MakeArgSetter (
              _name_: a String,
              _env_: an Environment Record,
            ): a function object
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_env_ において _name_ に束縛された値を設定する組み込み関数オブジェクトを生成する。</dd>
          </dl>
          <emu-alg>
            1. _setterClosure_ を、パラメータ (_value_) を持ち _name_ と _env_ を捕捉し呼び出されたとき次を行う新しい Abstract Closure とする:
              1. NormalCompletion(! _env_.SetMutableBinding(_name_, _value_, *false*)) を返す。
            1. _setter_ を CreateBuiltinFunction(_setterClosure_, 1, *""*, « ») とする。
            1. 注記: _setter_ は ECMAScript コードから直接アクセスされない。
            1. _setter_ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-exotic-objects" oldids="sec-integer-indexed-exotic-objects">
      <h1>TypedArray エキゾチックオブジェクト (TypedArray Exotic Objects)</h1>
      <p>TypedArray は正準数値文字列であるプロパティキーを特別扱いし、そのうち境界内の整数インデックス集合を用いて均一型要素をインデックス付けし、残りがプロトタイプ連鎖走査を発生させずに欠落しているという不変条件を強制するエキゾチックオブジェクトである。</p>
      <emu-note>
        <p>任意の Number _n_ に対する ToString(_n_) は正準数値文字列であるため、実装は実際に文字列変換を行わずに Number を TypedArray のプロパティキーとして扱ってもよい。</p>
      </emu-note>
      <p>TypedArray は通常オブジェクトと同じ内部スロットを持ち、さらに [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] 内部スロットを持つ。</p>
      <p>オブジェクトの [[PreventExtensions]], [[GetOwnProperty]], [[HasProperty]], [[DefineOwnProperty]], [[Get]], [[Set]], [[Delete]], [[OwnPropertyKeys]] 内部メソッドが本節の定義を使用し、他の必須内部メソッドが <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> の定義を使用する場合、そのオブジェクトは <dfn id="typedarray" oldids="integer-indexed-exotic-object" variants="TypedArrays">TypedArray</dfn> である。これらのメソッドは TypedArrayCreate により設定される。</p>

      <emu-clause id="sec-typedarray-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): Boolean を含む正常完了</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 注記: <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> に規定される拡張可能性関連の不変条件は、基礎バッファがリサイズされ整数インデックス名のプロパティを獲得（または失い再獲得）し得る場合に *true* を返すことを許さない。
          1. IsTypedArrayFixedLength(_O_) が *false* なら *false* を返す。
          1. OrdinaryPreventExtensions(_O_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-getownproperty" oldids="sec-integer-indexed-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor か *undefined* を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が String なら
            1. _numericIndex_ を CanonicalNumericIndexString(_P_) とする。
            1. _numericIndex_ が *undefined* でないなら
              1. _value_ を TypedArrayGetElement(_O_, _numericIndex_) とする。
              1. _value_ が *undefined* なら *undefined* を返す。
              1. PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* } を返す。
          1. OrdinaryGetOwnProperty(_O_, _P_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-hasproperty" oldids="sec-integer-indexed-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が String なら
            1. _numericIndex_ を CanonicalNumericIndexString(_P_) とする。
            1. _numericIndex_ が *undefined* でないなら IsValidIntegerIndex(_O_, _numericIndex_) を返す。
          1. ? OrdinaryHasProperty(_O_, _P_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-defineownproperty" oldids="sec-integer-indexed-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が String なら
            1. _numericIndex_ を CanonicalNumericIndexString(_P_) とする。
            1. _numericIndex_ が *undefined* でないなら
              1. IsValidIntegerIndex(_O_, _numericIndex_) が *false* なら *false* を返す。
              1. _Desc_ が [[Configurable]] フィールドを持ち _Desc_.[[Configurable]] が *false* なら *false* を返す。
              1. _Desc_ が [[Enumerable]] フィールドを持ち _Desc_.[[Enumerable]] が *false* なら *false* を返す。
              1. IsAccessorDescriptor(_Desc_) が *true* なら *false* を返す。
              1. _Desc_ が [[Writable]] フィールドを持ち _Desc_.[[Writable]] が *false* なら *false* を返す。
              1. _Desc_ が [[Value]] フィールドを持つなら ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]]) を実行する。
              1. *true* を返す。
          1. ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-get" oldids="sec-integer-indexed-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 言語値を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が String なら
            1. _numericIndex_ を CanonicalNumericIndexString(_P_) とする。
            1. _numericIndex_ が *undefined* でないなら
              1. TypedArrayGetElement(_O_, _numericIndex_) を返す。
          1. ? OrdinaryGet(_O_, _P_, _Receiver_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-set" oldids="sec-integer-indexed-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が String なら
            1. _numericIndex_ を CanonicalNumericIndexString(_P_) とする。
            1. _numericIndex_ が *undefined* でないなら
              1. SameValue(_O_, _Receiver_) が *true* なら
                1. ? TypedArraySetElement(_O_, _numericIndex_, _V_) を実行する。
                1. *true* を返す。
              1. IsValidIntegerIndex(_O_, _numericIndex_) が *false* なら *true* を返す。
          1. ? OrdinarySet(_O_, _P_, _V_, _Receiver_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-delete" oldids="sec-integer-indexed-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が String なら
            1. _numericIndex_ を CanonicalNumericIndexString(_P_) とする。
            1. _numericIndex_ が *undefined* でないなら
              1. IsValidIntegerIndex(_O_, _numericIndex_) が *false* なら *true* を返す；そうでなければ *false* を返す。
          1. ! OrdinaryDelete(_O_, _P_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-ownpropertykeys" oldids="sec-integer-indexed-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): プロパティキーの List を含む正常完了</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _taRecord_ を MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~) とする。
          1. _keys_ を新しい空の List とする。
          1. IsTypedArrayOutOfBounds(_taRecord_) が *false* なら
            1. _length_ を TypedArrayLength(_taRecord_) とする。
            1. 0 ≤ _i_ < _length_ の各整数 _i_ について昇順で:
              1. ! ToString(𝔽(_i_)) を _keys_ に追加する。
          1. _O_ の各自身プロパティキー _P_ で _P_ が String かつ整数インデックスでないものについて、作成順昇順で:
            1. _P_ を _keys_ に追加する。
          1. _O_ の各自身プロパティキー _P_ で _P_ が Symbol であるものについて、作成順昇順で:
            1. _P_ を _keys_ に追加する。
          1. _keys_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-with-buffer-witness-records" oldids="sec-integer-indexed-object-with-buffer-witness-records">
        <h1>バッファ監視付き TypedArray レコード (TypedArray With Buffer Witness Records)</h1>
        <p><dfn variants="TypedArray With Buffer Witness Records">TypedArray With Buffer Witness Record</dfn> は、TypedArray と、ビュー対象バッファのキャッシュされたバイト長をカプセル化する Record 値である。Growable SharedArrayBuffer をビューしている場合に、そのバイト長データブロックの単一の共有メモリ読取イベントがあることを保証する助けとなる。</p>
        <p>TypedArray With Buffer Witness Record は <emu-xref href="#table-typedarray-with-buffer-witness-record-fields"></emu-xref> に列挙されるフィールドを持つ。</p>
        <emu-table id="table-typedarray-with-buffer-witness-record-fields" oldids="table-integer-indexed-object-with-buffer-witness-record-fields" caption="TypedArray With Buffer Witness Record Fields">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a TypedArray
              </td>
              <td>
                バッファのバイト長が読み出される TypedArray。
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                Record 作成時点のオブジェクトの [[ViewedArrayBuffer]] のバイト長。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-maketypedarraywithbufferwitnessrecord" oldids="sec-makeintegerindexedobjectwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeTypedArrayWithBufferWitnessRecord (
            _obj_: a TypedArray,
            _order_: ~seq-cst~ or ~unordered~,
          ): a TypedArray With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _buffer_ を _obj_.[[ViewedArrayBuffer]] とする。
          1. IsDetachedBuffer(_buffer_) が *true* なら
            1. _byteLength_ を ~detached~ とする。
          1. それ以外
            1. _byteLength_ を ArrayBufferByteLength(_buffer_, _order_) とする。
          1. TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraycreate" oldids="sec-integerindexedobjectcreate" type="abstract operation">
        <h1>
          TypedArrayCreate (
            _prototype_: an Object,
          ): a TypedArray
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>新しい TypedArray の生成を規定する。</dd>
        </dl>
        <emu-alg>
          1. _internalSlotsList_ を « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] » とする。
          1. _A_ を MakeBasicObject(_internalSlotsList_) とする。
          1. _A_.[[PreventExtensions]] を <emu-xref href="#sec-typedarray-preventextensions"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[GetOwnProperty]] を <emu-xref href="#sec-typedarray-getownproperty"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[HasProperty]] を <emu-xref href="#sec-typedarray-hasproperty"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[DefineOwnProperty]] を <emu-xref href="#sec-typedarray-defineownproperty"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[Get]] を <emu-xref href="#sec-typedarray-get"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[Set]] を <emu-xref href="#sec-typedarray-set"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[Delete]] を <emu-xref href="#sec-typedarray-delete"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[OwnPropertyKeys]] を <emu-xref href="#sec-typedarray-ownpropertykeys"></emu-xref> で規定されるとおりに設定する。
          1. _A_.[[Prototype]] を _prototype_ に設定する。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraybytelength" oldids="sec-integerindexedobjectbytelength" type="abstract operation">
        <h1>
          TypedArrayByteLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら 0 を返す。
          1. _length_ を TypedArrayLength(_taRecord_) とする。
          1. _length_ = 0 なら 0 を返す。
          1. _O_ を _taRecord_.[[Object]] とする。
          1. _O_.[[ByteLength]] が ~auto~ でないなら _O_.[[ByteLength]] を返す。
          1. _elementSize_ を TypedArrayElementSize(_O_) とする。
          1. _length_ × _elementSize_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraylength" oldids="sec-integerindexedobjectlength" type="abstract operation">
        <h1>
          TypedArrayLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: IsTypedArrayOutOfBounds(_taRecord_) は *false*。
          1. _O_ を _taRecord_.[[Object]] とする。
          1. _O_.[[ArrayLength]] が ~auto~ でないなら _O_.[[ArrayLength]] を返す。
          1. アサート: IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) は *false*。
          1. _byteOffset_ を _O_.[[ByteOffset]] とする。
          1. _elementSize_ を TypedArrayElementSize(_O_) とする。
          1. _byteLength_ を _taRecord_.[[CachedBufferByteLength]] とする。
          1. アサート: _byteLength_ は ~detached~ ではない。
          1. floor((_byteLength_ - _byteOffset_) / _elementSize_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayoutofbounds" oldids="sec-isintegerindexedobjectoutofbounds" type="abstract operation">
        <h1>
          IsTypedArrayOutOfBounds (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>オブジェクトの数値プロパティのいずれかが基礎バッファの境界外のインデックスを参照するかを確認する。</dd>
        </dl>
        <emu-alg>
          1. _O_ を _taRecord_.[[Object]] とする。
          1. _bufferByteLength_ を _taRecord_.[[CachedBufferByteLength]] とする。
          1. アサート: IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) は _bufferByteLength_ が ~detached~ の場合かつその場合に限り *true*。
          1. _bufferByteLength_ が ~detached~ なら *true* を返す。
          1. _byteOffsetStart_ を _O_.[[ByteOffset]] とする。
          1. _O_.[[ArrayLength]] が ~auto~ なら
            1. _byteOffsetEnd_ を _bufferByteLength_ とする。
          1. それ以外
            1. _elementSize_ を TypedArrayElementSize(_O_) とする。
            1. _byteOffsetEnd_ を _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_ とする。
          1. _byteOffsetStart_ > _bufferByteLength_ または _byteOffsetEnd_ > _bufferByteLength_ なら *true* を返す。
          1. 注記: 長さ 0 の TypedArray は境界外とは見なされない。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayfixedlength" type="abstract operation">
        <h1>
          IsTypedArrayFixedLength (
            _O_: a TypedArray,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[ArrayLength]] が ~auto~ なら *false* を返す。
          1. _buffer_ を _O_.[[ViewedArrayBuffer]] とする。
          1. IsFixedLengthArrayBuffer(_buffer_) が *false* かつ IsSharedArrayBuffer(_buffer_) が *false* なら *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isvalidintegerindex" type="abstract operation">
        <h1>
          IsValidIntegerIndex (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) が *true* なら *false* を返す。
          1. _index_ が整数的 Number でなければ *false* を返す。
          1. _index_ が *-0*<sub>𝔽</sub> または _index_ < *-0*<sub>𝔽</sub> なら *false* を返す。
          1. _taRecord_ を MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~) とする。
          1. 注記: _O_ の裏付けバッファが growable SharedArrayBuffer の場合、境界チェックは同期化操作ではない。
          1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *false* を返す。
          1. _length_ を TypedArrayLength(_taRecord_) とする。
          1. ℝ(_index_) ≥ _length_ なら *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraygetelement" oldids="sec-integerindexedelementget" type="abstract operation">
        <h1>
          TypedArrayGetElement (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Number, a BigInt, or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsValidIntegerIndex(_O_, _index_) が *false* なら *undefined* を返す。
          1. _offset_ を _O_.[[ByteOffset]] とする。
          1. _elementSize_ を TypedArrayElementSize(_O_) とする。
          1. _byteIndexInBuffer_ を (ℝ(_index_) × _elementSize_) + _offset_ とする。
          1. _elementType_ を TypedArrayElementType(_O_) とする。
          1. GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraysetelement" oldids="sec-integerindexedelementset" type="abstract operation">
        <h1>
          TypedArraySetElement (
            _O_: a TypedArray,
            _index_: a Number,
            _value_: an ECMAScript language value,
          ): ~unused~ を含む正常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[ContentType]] が ~bigint~ なら _numValue_ を ? ToBigInt(_value_) とする。
          1. それ以外は _numValue_ を ? ToNumber(_value_) とする。
          1. IsValidIntegerIndex(_O_, _index_) が *true* なら
            1. _offset_ を _O_.[[ByteOffset]] とする。
            1. _elementSize_ を TypedArrayElementSize(_O_) とする。
            1. _byteIndexInBuffer_ を (ℝ(_index_) × _elementSize_) + _offset_ とする。
            1. _elementType_ を TypedArrayElementType(_O_) とする。
            1. SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-note>
          <p>この操作は常に成功するように見えるが、TypedArray の末尾を超えて書こうとしたり、切り離された ArrayBuffer を裏付けとする TypedArray に書こうとした場合は何の効果もない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-isarraybufferviewoutofbounds" type="abstract operation">
        <h1>
          IsArrayBufferViewOutOfBounds (
            _O_: a TypedArray or a DataView,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>TypedArray の数値プロパティまたは DataView オブジェクトのメソッドのいずれかが基礎データブロック境界外のインデックス値を参照し得るかを確認する。上位仕様向け利便性のために存在する抽象操作。</dd>
        </dl>
        <emu-alg>
          1. _O_ が [[DataView]] 内部スロットを持つなら
            1. _viewRecord_ を MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~) とする。
            1. IsViewOutOfBounds(_viewRecord_) を返す。
          1. _taRecord_ を MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~) とする。
          1. IsTypedArrayOutOfBounds(_taRecord_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-module-namespace-exotic-objects">
      <h1>モジュール名前空間エキゾチックオブジェクト (Module Namespace Exotic Objects)</h1>
      <p>モジュール名前空間エキゾチックオブジェクトは ECMAScript |Module| からエクスポートされた束縛を公開するエキゾチックオブジェクトである（<emu-xref href="#sec-exports"></emu-xref> 参照）。モジュール名前空間エキゾチックオブジェクトの String キー自身プロパティと |Module| がエクスポートする束縛名には 1 対 1 の対応がある。エクスポートされた束縛には `export *` による間接エクスポートも含まれる。各 String 値自身プロパティキーは対応するエクスポート束縛名の StringValue である。これらはモジュール名前空間エキゾチックオブジェクトの唯一の String キー付きプロパティである。各プロパティは属性 { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* } を持つ。モジュール名前空間エキゾチックオブジェクトは拡張不可能である。</p>
      <p>オブジェクトの [[GetPrototypeOf]], [[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]], [[GetOwnProperty]], [[DefineOwnProperty]], [[HasProperty]], [[Get]], [[Set]], [[Delete]], [[OwnPropertyKeys]] 内部メソッドが本節の定義を使用し、他の必須内部メソッドが <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> の定義を使用する場合、そのオブジェクトは <dfn id="module-namespace-exotic-object" variants="module namespace exotic objects">モジュール名前空間エキゾチックオブジェクト</dfn> である。これらのメソッドは ModuleNamespaceCreate により設定される。</p>
      <p>モジュール名前空間エキゾチックオブジェクトは <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref> に定義される内部スロットを持つ。</p>
      <emu-table id="table-internal-slots-of-module-namespace-exotic-objects" caption="モジュール名前空間エキゾチックオブジェクトの内部スロット (Internal Slots of Module Namespace Exotic Objects)" oldids="table-29">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Module]]
            </td>
            <td>
              a Module Record
            </td>
            <td>
              この名前空間が公開するエクスポートを持つ Module Record。
            </td>
          </tr>
          <tr>
            <td>
              [[Exports]]
            </td>
            <td>
              a List of Strings
            </td>
            <td>
              このオブジェクトの自身プロパティとして公開されるエクスポートされた名前の String 値のリスト。コードユニットの辞書式順にソートされる。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-module-namespace-exotic-objects-getprototypeof" type="internal method">
        <h1>[[GetPrototypeOf]] ( ): *null* を含む正常完了</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト</dd>
        </dl>
        <emu-alg>
          1. *null* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): Boolean を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. ! SetImmutablePrototype(_O_, _V_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-isextensible" type="internal method">
        <h1>[[IsExtensible]] ( ): *false* を含む正常完了</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト</dd>
        </dl>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): *true* を含む正常完了</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト</dd>
        </dl>
        <emu-alg>
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor か *undefined* を含む正常完了、または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が Symbol なら OrdinaryGetOwnProperty(_O_, _P_) を返す。
          1. _exports_ を _O_.[[Exports]] とする。
          1. _exports_ が _P_ を含まないなら *undefined* を返す。
          1. _value_ を ? _O_.[[Get]](_P_, _O_) とする。
          1. PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が Symbol なら ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) を返す。
          1. _current_ を ? _O_.[[GetOwnProperty]](_P_) とする。
          1. _current_ が *undefined* なら *false* を返す。
          1. _Desc_ が [[Configurable]] フィールドを持ち _Desc_.[[Configurable]] が *true* なら *false* を返す。
          1. _Desc_ が [[Enumerable]] フィールドを持ち _Desc_.[[Enumerable]] が *false* なら *false* を返す。
          1. IsAccessorDescriptor(_Desc_) が *true* なら *false* を返す。
          1. _Desc_ が [[Writable]] フィールドを持ち _Desc_.[[Writable]] が *false* なら *false* を返す。
          1. _Desc_ が [[Value]] フィールドを持つなら SameValue(_Desc_.[[Value]], _current_.[[Value]]) を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): Boolean を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が Symbol なら ! OrdinaryHasProperty(_O_, _P_) を返す。
          1. _exports_ を _O_.[[Exports]] とする。
          1. _exports_ が _P_ を含むなら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 言語値を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が Symbol なら
            1. ! OrdinaryGet(_O_, _P_, _Receiver_) を返す。
          1. _exports_ を _O_.[[Exports]] とする。
          1. _exports_ が _P_ を含まないなら *undefined* を返す。
          1. _m_ を _O_.[[Module]] とする。
          1. _binding_ を _m_.ResolveExport(_P_) とする。
          1. アサート: _binding_ は ResolvedBinding Record。
          1. _targetModule_ を _binding_.[[Module]] とする。
          1. アサート: _targetModule_ は *undefined* ではない。
          1. _binding_.[[BindingName]] が ~namespace~ なら
            1. GetModuleNamespace(_targetModule_) を返す。
          1. _targetEnv_ を _targetModule_.[[Environment]] とする。
          1. _targetEnv_ が ~empty~ なら *ReferenceError* 例外を投げる。
          1. ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*) を返す。
        </emu-alg>
        <emu-note>
          <p>ResolveExport は副作用がない。同一の _exportName_, _resolveSet_ 引数組で呼ばれるたびに同じ結果を返さなければならない。実装は各モジュール名前空間エキゾチックオブジェクトの [[Exports]] について ResolveExport 結果を事前計算またはキャッシュしてもよい。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): *false* を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト</dd>
        </dl>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean を含む正常完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ が Symbol なら
            1. ! OrdinaryDelete(_O_, _P_) を返す。
          1. _exports_ を _O_.[[Exports]] とする。
          1. _exports_ が _P_ を含むなら *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): プロパティキーの List を含む正常完了</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>モジュール名前空間エキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. _exports_ を _O_.[[Exports]] とする。
          1. _symbolKeys_ を OrdinaryOwnPropertyKeys(_O_) とする。
          1. _exports_ と _symbolKeys_ のリスト結合を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulenamespacecreate" type="abstract operation">
        <h1>
          ModuleNamespaceCreate (
            _module_: a Module Record,
            _exports_: a List of Strings,
          ): a module namespace exotic object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>新しいモジュール名前空間エキゾチックオブジェクトの生成を規定する。</dd>
        </dl>
        <emu-alg>
          1. アサート: _module_.[[Namespace]] は ~empty~。
          1. _internalSlotsList_ を <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref> に列挙される内部スロットとする。
          1. _M_ を MakeBasicObject(_internalSlotsList_) とする。
          1. _M_ の必須内部メソッドを <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> で規定される定義に設定する。
          1. _M_.[[Module]] を _module_ に設定する。
          1. _sortedExports_ を _exports_ の要素をコードユニット辞書式順でソートした List とする。
          1. _M_.[[Exports]] を _sortedExports_ に設定する。
          1. <emu-xref href="#sec-module-namespace-objects"></emu-xref> の定義に対応する _M_ の自身プロパティを生成する。
          1. _module_.[[Namespace]] を _M_ に設定する。
          1. _M_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-immutable-prototype-exotic-objects">
      <h1>不変プロトタイプエキゾチックオブジェクト (Immutable Prototype Exotic Objects)</h1>
      <p>不変プロトタイプエキゾチックオブジェクトは、初期化後に変更されない [[Prototype]] 内部スロットを持つエキゾチックオブジェクトである。</p>

      <p>オブジェクトの [[SetPrototypeOf]] 内部メソッドが以下の実装を使用する場合、そのオブジェクトは <dfn id="immutable-prototype-exotic-object" variants="immutable prototype exotic objects">不変プロトタイプエキゾチックオブジェクト</dfn> である。（その他の必須内部メソッドは対象となる不変プロトタイプエキゾチックオブジェクトに応じて任意の実装を使用しうる。）</p>

      <emu-note>
        <p>他のエキゾチックオブジェクトと異なり、不変プロトタイプエキゾチックオブジェクト用の専用生成抽象操作は提供されない。これはそれらが %Object.prototype% とホスト環境でのみ使用され、ホスト環境では関連オブジェクトが他の点でもエキゾチックであり専用生成操作を必要とするためである。</p>
      </emu-note>

      <emu-clause id="sec-immutable-prototype-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>不変プロトタイプエキゾチックオブジェクト _O_</dd>
        </dl>
        <emu-alg>
          1. ? SetImmutablePrototype(_O_, _V_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set-immutable-prototype" type="abstract operation">
        <h1>
          SetImmutablePrototype (
            _O_: an Object,
            _V_: an Object or *null*,
          ): Boolean を含む正常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _current_ を ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() とする。
          1. SameValue(_V_, _current_) が *true* なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots">
    <h1>Proxy オブジェクトの内部メソッドと内部スロット (Proxy Object Internal Methods and Internal Slots)</h1>
    <p>Proxy オブジェクトは、本質的内部メソッドの一部が ECMAScript コードで部分的に実装されるエキゾチックオブジェクトである。すべての Proxy オブジェクトは [[ProxyHandler]] という内部スロットを持つ。[[ProxyHandler]] の値はプロキシの <em>ハンドラーオブジェクト (handler object)</em> と呼ばれるオブジェクトか *null* である。ハンドラーオブジェクトのメソッド（<emu-xref href="#table-proxy-handler-methods"></emu-xref> 参照）は、1 つ以上の Proxy オブジェクト内部メソッドの実装を拡張するために用いられうる。すべての Proxy オブジェクトはまた [[ProxyTarget]] という内部スロットを持ち、その値はオブジェクトまたは *null* である。このオブジェクトはプロキシの <em>ターゲットオブジェクト (target object)</em> と呼ばれる。</p>

    <p>オブジェクトの本質的内部メソッド（該当する場合は [[Call]] と [[Construct]] を含む）が本節の定義を使用する場合、そのオブジェクトは <dfn id="proxy-exotic-object" variants="Proxy exotic objects">Proxy エキゾチックオブジェクト</dfn> である。これらの内部メソッドは ProxyCreate により設定される。</p>

    <emu-table id="table-proxy-handler-methods" caption="Proxy ハンドラーメソッド (Proxy Handler Methods)" oldids="table-30">
      <table>
        <thead>
          <tr>
            <th>
              Internal Method
            </th>
            <th>
              Handler Method
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[GetPrototypeOf]]
          </td>
          <td>
            `getPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[SetPrototypeOf]]
          </td>
          <td>
            `setPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[IsExtensible]]
          </td>
          <td>
            `isExtensible`
          </td>
        </tr>
        <tr>
          <td>
            [[PreventExtensions]]
          </td>
          <td>
            `preventExtensions`
          </td>
        </tr>
        <tr>
          <td>
            [[GetOwnProperty]]
          </td>
          <td>
            `getOwnPropertyDescriptor`
          </td>
        </tr>
        <tr>
          <td>
            [[DefineOwnProperty]]
          </td>
          <td>
            `defineProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[HasProperty]]
          </td>
          <td>
            `has`
          </td>
        </tr>
        <tr>
          <td>
            [[Get]]
          </td>
          <td>
            `get`
          </td>
        </tr>
        <tr>
          <td>
            [[Set]]
          </td>
          <td>
            `set`
          </td>
        </tr>
        <tr>
          <td>
            [[Delete]]
          </td>
          <td>
            `deleteProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[OwnPropertyKeys]]
          </td>
          <td>
            `ownKeys`
          </td>
        </tr>
        <tr>
          <td>
            [[Call]]
          </td>
          <td>
            `apply`
          </td>
        </tr>
        <tr>
          <td>
            [[Construct]]
          </td>
          <td>
            `construct`
          </td>
        </tr>
      </table>
    </emu-table>
    <p>ハンドラーメソッドが Proxy オブジェクト内部メソッドの実装提供のために呼び出されるとき、ハンドラーメソッドにはプロキシのターゲットオブジェクトがパラメータとして渡される。プロキシのハンドラーオブジェクトは必ずしもすべての本質的内部メソッドに対応するメソッドを持つとは限らない。ハンドラーオブジェクトが内部トラップに対応するメソッドを持たない場合、プロキシ上の内部メソッド呼び出しは対応する内部メソッドをターゲットオブジェクト上で呼び出すことになる。</p>
    <p>Proxy オブジェクトの [[ProxyHandler]] および [[ProxyTarget]] 内部スロットはオブジェクト生成時に常に初期化され、通常は変更できない。いくつかの Proxy オブジェクトは後に <em>revoked（無効化）</em> できる形で生成される。プロキシが無効化されると、その [[ProxyHandler]] と [[ProxyTarget]] 内部スロットは *null* に設定され、その Proxy オブジェクトに対する後続の内部メソッド呼び出しは *TypeError* 例外を投げる。</p>
    <p>Proxy オブジェクトは内部メソッド実装を任意の ECMAScript コードで提供できるため、<emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> で定義される不変条件に違反するハンドラーメソッドを持つ Proxy オブジェクトを定義することが可能である。<emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> で定義される内部メソッド不変条件の一部は本質的整合性不変条件である。これらの不変条件は本節で規定される Proxy オブジェクト内部メソッドによって明示的に強制される。ECMAScript 実装はあらゆる不変条件違反が存在しても堅牢でなければならない。</p>
    <p>以下のアルゴリズム記述では、_O_ は ECMAScript Proxy オブジェクト、_P_ はプロパティキー値、_V_ は任意の ECMAScript 言語値、_Desc_ は Property Descriptor レコードであると仮定する。</p>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): Object か *null* を含む正常完了または throw 完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"getPrototypeOf"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() を返す。
        1. _handlerProto_ を ? Call(_trap_, _handler_, « _target_ ») とする。
        1. _handlerProto_ が Object でなく *null* でもないなら *TypeError* 例外を投げる。
        1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
        1. _extensibleTarget_ が *true* なら _handlerProto_ を返す。
        1. _targetProto_ を ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() とする。
        1. SameValue(_handlerProto_, _targetProto_) が *false* なら *TypeError* 例外を投げる。
        1. _handlerProto_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[GetPrototypeOf]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[GetPrototypeOf]] の結果は Object か *null* でなければならない。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能な場合、Proxy オブジェクトに適用した [[GetPrototypeOf]] はターゲットオブジェクトに適用した [[GetPrototypeOf]] と同じ値を返さなければならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"setPrototypeOf"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_V_) を返す。
        1. _booleanTrapResult_ を ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »)) とする。
        1. _booleanTrapResult_ が *false* なら *false* を返す。
        1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
        1. _extensibleTarget_ が *true* なら *true* を返す。
        1. _targetProto_ を ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() とする。
        1. SameValue(_V_, _targetProto_) が *false* なら *TypeError* 例外を投げる。
        1. *true* を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[SetPrototypeOf]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[SetPrototypeOf]] の結果は Boolean である。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能である場合、引数値はターゲットオブジェクトに適用した [[GetPrototypeOf]] の結果と同じでなければならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): Boolean を含む正常完了または throw 完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"isExtensible"*) とする。
        1. _trap_ が *undefined* なら
          1. ? IsExtensible(_target_) を返す。
        1. _booleanTrapResult_ を ToBoolean(? Call(_trap_, _handler_, « _target_ »)) とする。
        1. _targetResult_ を ? IsExtensible(_target_) とする。
        1. _booleanTrapResult_ が _targetResult_ と異なるなら *TypeError* 例外を投げる。
        1. _booleanTrapResult_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[IsExtensible]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[IsExtensible]] の結果は Boolean である。
          </li>
          <li>
            Proxy オブジェクトに適用した [[IsExtensible]] は、同じ引数でターゲットオブジェクトに適用した [[IsExtensible]] と同じ値を返さなければならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): Boolean を含む正常完了または throw 完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"preventExtensions"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta> を返す。
        1. _booleanTrapResult_ を ToBoolean(? Call(_trap_, _handler_, « _target_ »)) とする。
        1. _booleanTrapResult_ が *true* なら
          1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
          1. _extensibleTarget_ が *true* なら *TypeError* 例外を投げる。
        1. _booleanTrapResult_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[PreventExtensions]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[PreventExtensions]] の結果は Boolean である。
          </li>
          <li>
            Proxy オブジェクトに適用した [[PreventExtensions]] が *true* を返すのは、ターゲットオブジェクトに適用した [[IsExtensible]] が *false* の場合のみである。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): Property Descriptor か *undefined* を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"getOwnPropertyDescriptor"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) を返す。
        1. _trapResultObj_ を ? Call(_trap_, _handler_, « _target_, _P_ ») とする。
        1. _trapResultObj_ が Object でなく *undefined* でもないなら *TypeError* 例外を投げる。
        1. _targetDesc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
        1. _trapResultObj_ が *undefined* なら
          1. _targetDesc_ が *undefined* なら *undefined* を返す。
          1. _targetDesc_.[[Configurable]] が *false* なら *TypeError* 例外を投げる。
          1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
          1. _extensibleTarget_ が *false* なら *TypeError* 例外を投げる。
          1. *undefined* を返す。
        1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
        1. _resultDesc_ を ? ToPropertyDescriptor(_trapResultObj_) とする。
        1. CompletePropertyDescriptor(_resultDesc_) を実行する。
        1. _valid_ を IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_) とする。
        1. _valid_ が *false* なら *TypeError* 例外を投げる。
        1. _resultDesc_.[[Configurable]] が *false* なら
          1. _targetDesc_ が *undefined* または _targetDesc_.[[Configurable]] が *true* なら
            1. *TypeError* 例外を投げる。
          1. _resultDesc_ が [[Writable]] フィールドを持ちかつ _resultDesc_.[[Writable]] が *false* なら
            1. アサート: _targetDesc_ は [[Writable]] フィールドを持つ。
            1. _targetDesc_.[[Writable]] が *true* なら *TypeError* 例外を投げる。
        1. _resultDesc_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[GetOwnProperty]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[GetOwnProperty]] の結果は Object か *undefined* でなければならない。
          </li>
          <li>
            ターゲットオブジェクトに設定不可な自身プロパティとして存在する場合、そのプロパティを不存在と報告してはならない。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能であり、そのプロパティが自身プロパティとして存在する場合、そのプロパティを不存在と報告してはならない。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能でなく、かつそのプロパティがターゲットの自身プロパティに存在しない場合、存在すると報告してはならない。
          </li>
          <li>
            ターゲットオブジェクトに対応する設定不可な自身プロパティが存在しない限り、プロパティを設定不可と報告してはならない。
          </li>
          <li>
            対応するターゲットオブジェクトの設定不可・非書き込み自身プロパティが存在しない限り、プロパティを同時に設定不可かつ非書き込みと報告してはならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"defineProperty"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_P_, _Desc_) を返す。
        1. _descObj_ を FromPropertyDescriptor(_Desc_) とする。
        1. _booleanTrapResult_ を ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »)) とする。
        1. _booleanTrapResult_ が *false* なら *false* を返す。
        1. _targetDesc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
        1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
        1. _Desc_ が [[Configurable]] フィールドを持ちかつ _Desc_.[[Configurable]] が *false* なら
          1. _settingConfigFalse_ を *true* とする。
        1. それ以外
          1. _settingConfigFalse_ を *false* とする。
        1. _targetDesc_ が *undefined* なら
          1. _extensibleTarget_ が *false* なら *TypeError* 例外を投げる。
          1. _settingConfigFalse_ が *true* なら *TypeError* 例外を投げる。
        1. それ以外
          1. IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) が *false* なら *TypeError* 例外を投げる。
          1. _settingConfigFalse_ が *true* かつ _targetDesc_.[[Configurable]] が *true* なら *TypeError* 例外を投げる。
          1. IsDataDescriptor(_targetDesc_) が *true* かつ _targetDesc_.[[Configurable]] が *false* かつ _targetDesc_.[[Writable]] が *true* なら
            1. _Desc_ が [[Writable]] フィールドを持ちかつ _Desc_.[[Writable]] が *false* なら *TypeError* 例外を投げる。
        1. *true* を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[DefineOwnProperty]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[DefineOwnProperty]] の結果は Boolean である。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能ならプロパティは追加できない。
          </li>
          <li>
            対応する設定不可な自身プロパティがターゲット上に存在しない限り、プロパティを設定不可にできない。
          </li>
          <li>
            対応する設定不可かつ非書き込みな自身プロパティがターゲット上に存在しない限り、プロパティを設定不可かつ非書き込みにできない。
          </li>
          <li>
            対応するターゲットプロパティが存在する場合、その Property Descriptor を [[DefineOwnProperty]] でターゲットに適用しても例外は投げられない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"has"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_P_) を返す。
        1. _booleanTrapResult_ を ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)) とする。
        1. _booleanTrapResult_ が *false* なら
          1. _targetDesc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
          1. _targetDesc_ が *undefined* でないなら
            1. _targetDesc_.[[Configurable]] が *false* なら *TypeError* 例外を投げる。
            1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
            1. _extensibleTarget_ が *false* なら *TypeError* 例外を投げる。
        1. _booleanTrapResult_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[HasProperty]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[HasProperty]] の結果は Boolean である。
          </li>
          <li>
            ターゲットオブジェクトに設定不可な自身プロパティとして存在する場合、プロパティを不存在と報告してはならない。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能で、そのプロパティが自身プロパティとして存在する場合、プロパティを不存在と報告してはならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): ECMAScript 言語値を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"get"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_P_, _Receiver_) を返す。
        1. _trapResult_ を ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ ») とする。
        1. _targetDesc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
        1. _targetDesc_ が *undefined* でなくかつ _targetDesc_.[[Configurable]] が *false* なら
          1. IsDataDescriptor(_targetDesc_) が *true* かつ _targetDesc_.[[Writable]] が *false* なら
            1. SameValue(_trapResult_, _targetDesc_.[[Value]]) が *false* なら *TypeError* 例外を投げる。
          1. IsAccessorDescriptor(_targetDesc_) が *true* かつ _targetDesc_.[[Get]] が *undefined* なら
            1. _trapResult_ が *undefined* でないなら *TypeError* 例外を投げる。
        1. _trapResult_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[Get]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            対応するターゲットオブジェクトプロパティが非書き込み・設定不可な自身データプロパティである場合、報告される値はターゲットプロパティの値と同じでなければならない。
          </li>
          <li>
            対応するターゲットオブジェクトプロパティが設定不可な自身 accessor プロパティでその [[Get]] 属性が *undefined* の場合、報告される値は *undefined* でなければならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"set"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_) を返す。
        1. _booleanTrapResult_ を ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)) とする。
        1. _booleanTrapResult_ が *false* なら *false* を返す。
        1. _targetDesc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
        1. _targetDesc_ が *undefined* でなくかつ _targetDesc_.[[Configurable]] が *false* なら
          1. IsDataDescriptor(_targetDesc_) が *true* かつ _targetDesc_.[[Writable]] が *false* なら
            1. SameValue(_V_, _targetDesc_.[[Value]]) が *false* なら *TypeError* 例外を投げる。
          1. IsAccessorDescriptor(_targetDesc_) が *true* なら
            1. _targetDesc_.[[Set]] が *undefined* なら *TypeError* 例外を投げる。
        1. *true* を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[Set]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[Set]] の結果は Boolean である。
          </li>
          <li>
            対応するターゲットオブジェクトプロパティが非書き込み・設定不可な自身データプロパティである場合、その値と異なる値に変更することはできない。
          </li>
          <li>
            対応するターゲットオブジェクトプロパティが設定不可な自身 accessor プロパティでその [[Set]] 属性が *undefined* の場合、値を設定できない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): Boolean を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"deleteProperty"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_P_) を返す。
        1. _booleanTrapResult_ を ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)) とする。
        1. _booleanTrapResult_ が *false* なら *false* を返す。
        1. _targetDesc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
        1. _targetDesc_ が *undefined* なら *true* を返す。
        1. _targetDesc_.[[Configurable]] が *false* なら *TypeError* 例外を投げる。
        1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
        1. _extensibleTarget_ が *false* なら *TypeError* 例外を投げる。
        1. *true* を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[Delete]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[Delete]] の結果は Boolean である。
          </li>
          <li>
            ターゲットオブジェクトに設定不可な自身プロパティとして存在する場合、そのプロパティを削除済みと報告してはならない。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能でそのプロパティが自身プロパティとして存在する場合、そのプロパティを削除済みと報告してはならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): プロパティキーの List を含む正常完了または throw 完了</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"ownKeys"*) とする。
        1. _trap_ が *undefined* なら
          1. ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> を返す。
        1. _trapResultArray_ を ? Call(_trap_, _handler_, « _target_ ») とする。
        1. _trapResult_ を ? CreateListFromArrayLike(_trapResultArray_, ~property-key~) とする。
        1. _trapResult_ が重複要素を含むなら *TypeError* 例外を投げる。
        1. _extensibleTarget_ を ? IsExtensible(_target_) とする。
        1. _targetKeys_ を ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> とする。
        1. アサート: _targetKeys_ はプロパティキーの List である。
        1. アサート: _targetKeys_ は重複要素を含まない。
        1. _targetConfigurableKeys_ を新しい空の List とする。
        1. _targetNonconfigurableKeys_ を新しい空の List とする。
        1. _targetKeys_ の各要素 _key_ について
          1. _desc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_) とする。
          1. _desc_ が *undefined* でなくかつ _desc_.[[Configurable]] が *false* なら
            1. _key_ を _targetNonconfigurableKeys_ に追加する。
          1. それ以外
            1. _key_ を _targetConfigurableKeys_ に追加する。
        1. _extensibleTarget_ が *true* かつ _targetNonconfigurableKeys_ が空なら
          1. _trapResult_ を返す。
        1. _uncheckedResultKeys_ を _trapResult_ の要素からなる List とする。
        1. _targetNonconfigurableKeys_ の各要素 _key_ について
          1. _uncheckedResultKeys_ が _key_ を含まないなら *TypeError* 例外を投げる。
          1. _uncheckedResultKeys_ から _key_ を除去する。
        1. _extensibleTarget_ が *true* なら _trapResult_ を返す。
        1. _targetConfigurableKeys_ の各要素 _key_ について
          1. _uncheckedResultKeys_ が _key_ を含まないなら *TypeError* 例外を投げる。
          1. _uncheckedResultKeys_ から _key_ を除去する。
        1. _uncheckedResultKeys_ が空でないなら *TypeError* 例外を投げる。
        1. _trapResult_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy オブジェクトの [[OwnPropertyKeys]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[OwnPropertyKeys]] の結果は List である。
          </li>
          <li>
            返される List は重複要素を含まない。
          </li>
          <li>
            返される List の各要素はプロパティキーである。
          </li>
          <li>
            結果の List はターゲットオブジェクトのすべての設定不可な自身プロパティのキーを含まなければならない。
          </li>
          <li>
            ターゲットオブジェクトが拡張不可能である場合、結果の List はターゲットオブジェクトの自身プロパティすべてのキーのみを含まなければならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 言語値を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"apply"*) とする。
        1. _trap_ が *undefined* なら
          1. ? Call(_target_, _thisArgument_, _argumentsList_) を返す。
        1. _argArray_ を CreateArrayFromList(_argumentsList_) とする。
        1. ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ ») を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy エキゾチックオブジェクトは、その [[ProxyTarget]] 内部スロットの初期値が [[Call]] 内部メソッドを持つオブジェクトである場合にのみ [[Call]] 内部メソッドを持つ。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): Object を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy エキゾチックオブジェクト _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) を実行する。
        1. _target_ を _O_.[[ProxyTarget]] とする。
        1. アサート: IsConstructor(_target_) は *true*。
        1. _handler_ を _O_.[[ProxyHandler]] とする。
        1. アサート: _handler_ は Object である。
        1. _trap_ を ? GetMethod(_handler_, *"construct"*) とする。
        1. _trap_ が *undefined* なら
          1. ? Construct(_target_, _argumentsList_, _newTarget_) を返す。
        1. _argArray_ を CreateArrayFromList(_argumentsList_) とする。
        1. _newObj_ を ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ ») とする。
        1. _newObj_ が Object でないなら *TypeError* 例外を投げる。
        1. _newObj_ を返す。
      </emu-alg>
      <emu-note>
        <p>Proxy エキゾチックオブジェクトは、その [[ProxyTarget]] 内部スロットの初期値が [[Construct]] 内部メソッドを持つオブジェクトである場合にのみ [[Construct]] 内部メソッドを持つ。</p>
      </emu-note>
      <emu-note>
        <p>Proxy オブジェクトの [[Construct]] は以下の不変条件を強制する:</p>
        <ul>
          <li>
            [[Construct]] の結果は Object でなければならない。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-validatenonrevokedproxy" type="abstract operation">
      <h1>
        ValidateNonRevokedProxy (
          _proxy_: a Proxy exotic object,
        ): ~unused~ を含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_proxy_ が無効化されている場合 *TypeError* 例外を投げる。</dd>
      </dl>
      <emu-alg>
        1. _proxy_.[[ProxyTarget]] が *null* なら *TypeError* 例外を投げる。
        1. アサート: _proxy_.[[ProxyHandler]] は *null* ではない。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-proxycreate" type="abstract operation">
      <h1>
        ProxyCreate (
          _target_: an ECMAScript language value,
          _handler_: an ECMAScript language value,
        ): Proxy エキゾチックオブジェクトを含む正常完了または throw 完了
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>新しい Proxy オブジェクトの生成を規定する。</dd>
      </dl>
      <emu-alg>
        1. _target_ が Object でないなら *TypeError* 例外を投げる。
        1. _handler_ が Object でないなら *TypeError* 例外を投げる。
        1. _P_ を MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] ») とする。
        1. _P_ の本質的内部メソッド（[[Call]] と [[Construct]] を除く）を <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots"></emu-xref> で規定される定義に設定する。
        1. IsCallable(_target_) が *true* なら
          1. _P_.[[Call]] を <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist"></emu-xref> で規定されるとおりに設定する。
          1. IsConstructor(_target_) が *true* なら
            1. _P_.[[Construct]] を <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget"></emu-xref> で規定されるとおりに設定する。
        1. _P_.[[ProxyTarget]] を _target_ に設定する。
        1. _P_.[[ProxyHandler]] を _handler_ に設定する。
        1. _P_ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-source-code">
  <h1>ECMAScript 言語: ソーステキスト (ECMAScript Language: Source Text)</h1>

  <emu-clause id="sec-source-text">
    <h1>ソーステキスト (Source Text)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      SourceCharacter ::
        &gt; any Unicode code point
    </emu-grammar>
    <p><dfn>ECMAScript ソーステキスト</dfn> は Unicode 符号位置の列である。ECMAScript 文法で許容される箇所であれば、U+0000 から U+10FFFF までのすべての Unicode 符号位置（サロゲートコードポイントを含む）が ECMAScript ソーステキスト中に現れうる。ECMAScript ソーステキストを格納または交換するために実際に用いられるエンコーディングは本仕様にとって本質的ではない。外部的なソーステキストのエンコーディングに関わらず、適合する ECMAScript 実装はソーステキストを、各 |SourceCharacter| が 1 つの Unicode 符号位置であるような同値の |SourceCharacter| 値列として処理する。適合実装はソーステキストの正規化を行うこと、または正規化を行っているかのように振る舞うことを要求されない。</p>
    <p>結合文字シーケンスの構成要素は、利用者がその全体を 1 文字と捉える可能性があっても、個々の独立した Unicode 符号位置として扱われる。</p>
    <emu-note>
      <p>文字列リテラル、正規表現リテラル、テンプレートリテラル、および識別子においては、任意の Unicode 符号位置をその数値値を明示的に表す Unicode エスケープシーケンスで表現することもできる。コメント内では、そのようなエスケープシーケンスはコメントの一部として実質的に無視される。</p>
      <p>ECMAScript は Unicode エスケープシーケンスの挙動において Java プログラミング言語と異なる。例えば Java プログラムにおいて Unicode エスケープ `\\u000A` が単一行コメント内に現れた場合、それは行終端子（Unicode 符号位置 U+000A は LINE FEED (LF)）として解釈され、次の符号位置はそのコメントの一部ではなくなる。同様に Java の文字列リテラル内で `\\u000A` が現れると、それは文字列リテラル内に許可されない行終端子として解釈される——文字列リテラルの値に LF を含めるには `\\u000A` ではなく `\\n` と書かなければならない。ECMAScript プログラムでは、コメント中の Unicode エスケープシーケンスが解釈されることは決してなく、従ってコメント終端に寄与しない。同様に、ECMAScript プログラム内の文字列リテラル中に現れる Unicode エスケープシーケンスは常にリテラル内容に寄与し、行終端子として、あるいは文字列リテラルを終端させうる符号位置として解釈されることはない。</p>
    </emu-note>

    <emu-clause id="sec-utf16encodecodepoint" type="abstract operation" oldids="sec-utf16encoding,sec-codepointtoutf16codeunits">
      <h1>
        静的セマンティクス: UTF16EncodeCodePoint (
        _cp_: a Unicode code point,
        ): a String
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: 0 ≤ _cp_ ≤ 0x10FFFF.
        1. If _cp_ ≤ 0xFFFF, return the String value consisting of the code unit whose numeric value is _cp_.
        1. Let _cu1_ be the code unit whose numeric value is floor((_cp_ - 0x10000) / 0x400) + 0xD800.
        1. Let _cu2_ be the code unit whose numeric value is ((_cp_ - 0x10000) modulo 0x400) + 0xDC00.
        1. Return the string-concatenation of _cu1_ and _cu2_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointstostring" type="abstract operation" oldids="sec-utf16encode">
      <h1>
        静的セマンティクス: CodePointsToString (
        _text_: a sequence of Unicode code points,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_text_ を <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> で述べるように String 値へ変換する。</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be the empty String.
        1. For each code point _cp_ of _text_, do
          1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-utf16decodesurrogatepair" type="abstract operation" oldids="sec-utf16decode,utf16decodesurrogatepair">
      <h1>
        静的セマンティクス: UTF16SurrogatePairToCodePoint (
        _lead_: a code unit,
        _trail_: a code unit,
        ): a code point
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>UTF-16 サロゲートペアを形成する 2 つのコードユニットを 1 つのコードポイントへ変換する。</dd>
      </dl>
      <emu-alg>
        1. Assert: _lead_ is a leading surrogate and _trail_ is a trailing surrogate.
        1. Let _cp_ be (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000.
        1. Return the code point _cp_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointat" type="abstract operation">
      <h1>
        静的セマンティクス: CodePointAt (
        _string_: a String,
        _position_: a non-negative integer,
        ): a Record with fields [[CodePoint]] (a code point), [[CodeUnitCount]] (a positive integer), and [[IsUnpairedSurrogate]] (a Boolean)
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_string_ を <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> に記述される UTF-16 エンコードされたコードポイント列として解釈し、インデックス _position_ のコードユニットから始まる 1 つのコードポイントを読み取る。</dd>
      </dl>
      <emu-alg>
        1. Let _size_ be the length of _string_.
        1. Assert: _position_ ≥ 0 and _position_ &lt; _size_.
        1. Let _first_ be the code unit at index _position_ within _string_.
        1. Let _cp_ be the code point whose numeric value is the numeric value of _first_.
        1. If _first_ is neither a leading surrogate nor a trailing surrogate, then
          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }.
        1. If _first_ is a trailing surrogate or _position_ + 1 = _size_, then
          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.
        1. Let _second_ be the code unit at index _position_ + 1 within _string_.
        1. If _second_ is not a trailing surrogate, then
          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.
        1. Set _cp_ to UTF16SurrogatePairToCodePoint(_first_, _second_).
        1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-stringtocodepoints" type="abstract operation" oldids="sec-utf16decodestring">
      <h1>
        静的セマンティクス: StringToCodePoints (
        _string_: a String,
        ): a List of code points
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_string_ を <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> に記述される UTF-16 エンコードされた Unicode テキストとして解釈した結果得られる Unicode 符号位置列を返す。</dd>
      </dl>
      <emu-alg>
        1. Let _codePoints_ be a new empty List.
        1. Let _size_ be the length of _string_.
        1. Let _position_ be 0.
        1. Repeat, while _position_ &lt; _size_,
          1. Let _cp_ be CodePointAt(_string_, _position_).
          1. Append _cp_.[[CodePoint]] to _codePoints_.
          1. Set _position_ to _position_ + _cp_.[[CodeUnitCount]].
        1. Return _codePoints_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-parsetext" type="abstract operation">
      <h1>
        静的セマンティクス: ParseText (
        _sourceText_: a String or a sequence of Unicode code points,
        _goalSymbol_: a nonterminal in one of the ECMAScript grammars,
        ): a Parse Node or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _sourceText_ is a String, set _sourceText_ to StringToCodePoints(_sourceText_).
        1. Attempt to parse _sourceText_ using _goalSymbol_ as the goal symbol, and analyse the parse result for any early error conditions. Parsing and early error detection may be interleaved in an implementation-defined manner.
        1. If the parse succeeded and no early errors were found, return the Parse Node (an instance of _goalSymbol_) at the root of the parse tree resulting from the parse.
        1. Otherwise, return a List of one or more *SyntaxError* objects representing the parsing errors and/or early errors. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-defined, but at least one must be present.
      </emu-alg>
      <emu-note>
        <p>ある箇所に早期エラーが存在し、後続位置に構文エラーが存在するテキストを考える。パース後に早期エラー検査を行う実装は構文エラーを報告し、早期エラー検査へ進まないかもしれない。両者をインターリーブする実装は早期エラーを報告し構文エラー検出を行わないかもしれない。第三の実装は両方のエラーを報告するかもしれない。これらの挙動はいずれも適合である。</p>
      </emu-note>
      <emu-note>
        <p><emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> も参照のこと。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-types-of-source-code">
    <h1>ソースコードの種類 (Types of Source Code)</h1>
    <p>ECMAScript コードには 4 種類がある:</p>
    <ul>
      <li>
        <dfn>グローバルコード (Global code)</dfn> は ECMAScript |Script| として扱われるソーステキストである。特定の |Script| のグローバルコードには、|FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| の一部としてパースされるソーステキストは含まれない。
      </li>
      <li>
        <dfn>Eval コード (Eval code)</dfn> は組み込み `eval` 関数へ与えられたソーステキストである。より正確には、組み込み `eval` 関数のパラメータが String の場合、それは ECMAScript |Script| として扱われる。特定の `eval` 呼び出しにおける eval コードはその |Script| のグローバルコード部である。
      </li>
      <li>
        <p><dfn>関数コード (Function code)</dfn> は ECMAScript 関数オブジェクトの [[ECMAScriptCode]] および [[FormalParameters]] 内部スロット（<emu-xref href="#sec-ecmascript-function-objects"></emu-xref> 参照）の値を与えるためにパースされるソーステキストである。特定の ECMAScript 関数の関数コードには、入れ子の |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| の関数コードとしてパースされるソーステキストは含まれない。</p>
        <p>さらに、上記ソーステキストが次のようにパースされる場合:</p>
        <ul>
          <li>|FunctionDeclaration| または |FunctionExpression| の |FormalParameters| と |FunctionBody|,</li>
          <li>|GeneratorDeclaration| または |GeneratorExpression| の |FormalParameters| と |GeneratorBody|,</li>
          <li>|AsyncFunctionDeclaration| または |AsyncFunctionExpression| の |FormalParameters| と |AsyncFunctionBody|, あるいは</li>
          <li>|AsyncGeneratorDeclaration| または |AsyncGeneratorExpression| の |FormalParameters| と |AsyncGeneratorBody|,</li>
        </ul>
        <p>そのとき、その宣言または式の |BindingIdentifier|（存在する場合）にマッチしたソーステキストも対応する関数の関数コードに含まれる。</p>
      </li>
      <li>
        <dfn>モジュールコード (Module code)</dfn> は |ModuleBody| として提供されるソーステキストである。これはモジュール初期化時に直接評価されるコードである。特定モジュールのモジュールコードには、入れ子の |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| の一部としてパースされるソーステキストは含まれない。
      </li>
    </ul>
    <emu-note>
      <p>関数コードは一般に Function 定義（<emu-xref href="#sec-function-definitions"></emu-xref>）、Arrow Function 定義（<emu-xref href="#sec-arrow-function-definitions"></emu-xref>）、Method 定義（<emu-xref href="#sec-method-definitions"></emu-xref>）、Generator Function 定義（<emu-xref href="#sec-generator-function-definitions"></emu-xref>）、Async Function 定義（<emu-xref href="#sec-async-function-definitions"></emu-xref>）、Async Generator Function 定義（<emu-xref href="#sec-async-generator-function-definitions"></emu-xref>）、および Async Arrow Function（<emu-xref href="#sec-async-arrow-function-definitions"></emu-xref>）の本体として提供される。関数コードはまた Function コンストラクタ（<emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>）、GeneratorFunction コンストラクタ（<emu-xref href="#sec-generatorfunction"></emu-xref>）、AsyncFunction コンストラクタ（<emu-xref href="#sec-async-function-constructor-arguments"></emu-xref>）、AsyncGeneratorFunction コンストラクタ（<emu-xref href="#sec-asyncgeneratorfunction"></emu-xref>）への引数から導出される。</p>
    </emu-note>
    <emu-note>
      <p>|BindingIdentifier| を関数コードに含める実際上の効果は、その関数本体が "use strict" ディレクティブを含む関数の名前である |BindingIdentifier| に対して、周囲のコードが strict でない場合でも strict mode の Early Error が適用されることである。</p>
    </emu-note>

    <emu-clause id="sec-directive-prologues-and-the-use-strict-directive">
      <h1>ディレクティブプロローグと Use Strict ディレクティブ (Directive Prologues and the Use Strict Directive)</h1>
      <p><dfn id="directive-prologue" variants="Directive Prologues">ディレクティブプロローグ (Directive Prologue)</dfn> とは、|FunctionBody|, |ScriptBody|, または |ModuleBody| の先頭に現れる |StatementListItem| もしくは |ModuleItem| のうち、連続して並ぶ最長の |ExpressionStatement| 列であって、その列中の各 |ExpressionStatement| がセミコロンにより終端される（明示または自動セミコロン挿入 (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) により）純粋な |StringLiteral| トークンのみから構成されるものである。ディレクティブプロローグは空列であってもよい。</p>
      <p><dfn id="use-strict-directive" variants="Use Strict Directives">Use Strict ディレクティブ (Use Strict Directive)</dfn> は、その |StringLiteral| が正確に `"use strict"` または `'use strict'` のいずれかの符号位置列であるディレクティブプロローグ中の |ExpressionStatement| である。Use Strict ディレクティブは |EscapeSequence| や |LineContinuation| を含んではならない。</p>
      <p>ディレクティブプロローグは複数の Use Strict ディレクティブを含んでもよい。ただし実装はこれが発生した場合に警告を出してよい。</p>
      <emu-note>
        <p>ディレクティブプロローグの |ExpressionStatement| は包含している生成規則の評価中に通常どおり評価される。実装は、Use Strict ディレクティブではないがディレクティブプロローグ中に現れる |ExpressionStatement| に対し実装独自の意味を定義してよい。適切な通知手段が存在する場合、実装はディレクティブプロローグ内で Use Strict ディレクティブではなく、かつ実装により意味が定義されていない |ExpressionStatement| に遭遇した際、警告を発するべきである。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-strict-mode-code">
      <h1>Strict Mode コード (Strict Mode Code)</h1>
      <p>ECMAScript の構文単位は制限のない（非 strict）または strict モードの構文とセマンティクス（<emu-xref href="#sec-strict-variant-of-ecmascript"></emu-xref>）で処理されうる。コードは次の状況で <dfn>strict mode code</dfn> として解釈される:</p>
      <ul>
        <li>
          グローバルコードが、Use Strict ディレクティブを含むディレクティブプロローグで始まる場合。
        </li>
        <li>
          モジュールコードは常に strict mode code である。
        </li>
        <li>
          |ClassDeclaration| または |ClassExpression| の全ての部分は strict mode code である。
        </li>
        <li>
          Eval コードが Use Strict ディレクティブを含むディレクティブプロローグで始まる、またはその `eval` 呼び出しが strict mode code 内に含まれる直接 eval である場合。
        </li>
        <li>
          関数コードが、対応する |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction| が strict mode code 内に含まれる、またはその関数の [[ECMAScriptCode]] 内部スロットの値を生成するコードが Use Strict ディレクティブを含むディレクティブプロローグで始まる場合。
        </li>
        <li>
          Function, Generator, AsyncFunction, AsyncGenerator の各組み込みコンストラクタへ引数として与えられる関数コードが、最後の引数が String であり、それを処理した結果が Use Strict ディレクティブを含むディレクティブプロローグで始まる |FunctionBody| である場合。
        </li>
      </ul>
      <p>strict mode code でない ECMAScript コードは <dfn id="non-strict-code">non-strict code</dfn> と呼ばれる。</p>

      <emu-clause id="sec-isstrict" type="abstract operation">
        <h1>
          静的セマンティクス: IsStrict (
          _node_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If the source text matched by _node_ is strict mode code, return *true*; else return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-non-ecmascript-functions">
      <h1>非 ECMAScript 関数 (Non-ECMAScript Functions)</h1>
      <p>ECMAScript 実装は、評価挙動が ECMAScript ソーステキスト以外のホスト定義実行可能コード形式で記述される関数エキゾチックオブジェクトの評価をサポートしてよい。ある関数オブジェクトが ECMAScript コード内で定義されたか、組み込み関数であるかは、その関数オブジェクトが呼び出す／呼び出される ECMAScript コードの観点からは観測できない。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-lexical-grammar">
  <h1>ECMAScript 言語: 字句文法 (ECMAScript Language: Lexical Grammar)</h1>
  <p>ECMAScript の |Script| または |Module| のソーステキストはまず入力要素（トークン、行終端子、コメント、または空白）から成る列へと変換される。ソーステキストは左から右へ走査され、可能な限り最長の符号位置列が次の入力要素として逐次選択される。</p>
  <p>入力要素の識別がそれを消費する構文文法コンテキストに依存する状況がいくつか存在する。これは字句文法に複数の目標（goal）記号を必要とする。|InputElementHashbangOrRegExp| 目標は |Script| または |Module| の開始時に用いられる。|InputElementRegExpOrTemplateTail| 目標は |RegularExpressionLiteral|, |TemplateMiddle|, または |TemplateTail| が許可される構文文法コンテキストで用いられる。|InputElementRegExp| 目標記号は |RegularExpressionLiteral| が許可され、かつ |TemplateMiddle| と |TemplateTail| が許可されないすべての構文文法コンテキストで用いられる。|InputElementTemplateTail| 目標は |TemplateMiddle| または |TemplateTail| が許可され、 |RegularExpressionLiteral| が許可されないすべての構文文法コンテキストで用いられる。その他すべてのコンテキストでは |InputElementDiv| が字句目標記号として用いられる。</p>
  <emu-note>
    <p>複数の字句目標を用いることで自動セミコロン挿入に影響する字句的曖昧さが存在しないことを保証する。例えば、先頭に除算または除算代入、かつ先頭に |RegularExpressionLiteral| の両方が許容される構文文法コンテキストは存在しない。これはセミコロン挿入（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref> 参照）によって影響を受けない。以下の例のように:</p>
    <pre><code class="javascript">
      a = b
      /hi/g.exec(c).map(d);
    </code></pre>
    <p>|LineTerminator| の後の最初の非空白・非コメント符号位置が U+002F (SOLIDUS) であり、構文コンテキストが除算または除算代入を許可する場合、|LineTerminator| の位置にセミコロンは挿入されない。すなわち上の例は次と同じように解釈される:</p>
    <pre><code class="javascript">
      a = b / hi / g.exec(c).map(d);
    </code></pre>
  </emu-note>
  <h2>構文 (Syntax)</h2>
  <emu-grammar type="definition">
    InputElementDiv ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      RightBracePunctuator

    InputElementRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RightBracePunctuator
      RegularExpressionLiteral

    InputElementRegExpOrTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RegularExpressionLiteral
      TemplateSubstitutionTail

    InputElementTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      TemplateSubstitutionTail

    InputElementHashbangOrRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      HashbangComment
      RegularExpressionLiteral
  </emu-grammar>

  <emu-clause id="sec-unicode-format-control-characters">
    <h1>Unicode 形式制御文字 (Unicode Format-Control Characters)</h1>
    <p>Unicode 形式制御文字（すなわち Unicode 文字データベースにおける “Cf” カテゴリ、例えば LEFT-TO-RIGHT MARK や RIGHT-TO-LEFT MARK）は、上位プロトコル（マークアップ言語など）が存在しない場合にテキスト範囲の整形を制御するために使用される制御コードである。</p>
    <p>編集および表示を容易にするため、ソーステキスト内で形式制御文字を許可することは有用である。すべての形式制御文字はコメント内、ならびに文字列リテラル、テンプレートリテラル、正規表現リテラル内で使用できる。</p>
    <p>U+FEFF (ZERO WIDTH NO-BREAK SPACE) は主としてテキストの冒頭で Unicode であることを示し、テキストのエンコーディングとバイト順を検出するために用いられる形式制御文字である。この目的で用いられる &lt;ZWNBSP> 文字は、ファイル連結の結果などとしてテキスト開始後にも現れることがある。ECMAScript ソーステキストでは、コメント、文字列リテラル、テンプレートリテラル、正規表現リテラルの外側で &lt;ZWNBSP> 符号位置は空白文字として扱われる（<emu-xref href="#sec-white-space"></emu-xref> 参照）。</p>
  </emu-clause>

  <emu-clause id="sec-white-space">
    <h1>空白 (White Space)</h1>
    <p>空白符号位置はソーステキストの可読性を高め、トークン（分割不可能な字句単位）を相互に分離するために使用されるが、それ以外の点では意味を持たない。空白符号位置は任意の 2 つのトークンの間および入力の開始・末尾に現れうる。空白符号位置は |StringLiteral|, |RegularExpressionLiteral|, |Template|, |TemplateSubstitutionTail| の内部に現れ、その場合リテラル値を構成する有意味な符号位置として扱われる。また |Comment| 内に現れうるが、他の種類のトークン内部には現れない。</p>
    <p>ECMAScript の空白符号位置は <emu-xref href="#table-white-space-code-points"></emu-xref> に列挙される。</p>
    <emu-table id="table-white-space-code-points" caption="White Space Code Points" oldids="table-32">
      <table>
        <thead>
          <tr>
            <th>
              Code Points
            </th>
            <th>
              Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            <code>U+0009</code>
          </td>
          <td>
            CHARACTER TABULATION
          </td>
          <td>
            &lt;TAB>
          </td>
        </tr>
        <tr>
          <td>
            <code>U+000B</code>
          </td>
          <td>
            LINE TABULATION
          </td>
          <td>
            &lt;VT>
          </td>
        </tr>
        <tr>
          <td>
            <code>U+000C</code>
          </td>
          <td>
            FORM FEED (FF)
          </td>
          <td>
            &lt;FF>
          </td>
        </tr>
        <tr>
          <td>
            <code>U+FEFF</code>
          </td>
          <td>
            ZERO WIDTH NO-BREAK SPACE
          </td>
          <td>
            &lt;ZWNBSP>
          </td>
        </tr>
        <tr>
          <td>
            一般カテゴリ “Space_Separator” のいかなる符号位置
          </td>
          <td>
          </td>
          <td>
            &lt;USP>
          </td>
        </tr>
      </table>
    </emu-table>
    <emu-note>
      <p>U+0020 (SPACE) と U+00A0 (NO-BREAK SPACE) は &lt;USP> の一部である。</p>
    </emu-note>
    <emu-note>
      <p><emu-xref href="#table-white-space-code-points"></emu-xref> に列挙される符号位置を除き、ECMAScript |WhiteSpace| は Unicode “White_Space” プロパティを持つが一般カテゴリ “Space_Separator” (“Zs”) に分類されないすべての符号位置を意図的に除外する。</p>
    </emu-note>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      WhiteSpace ::
        &lt;TAB&gt;
        &lt;VT&gt;
        &lt;FF&gt;
        &lt;ZWNBSP&gt;
        &lt;USP&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-line-terminators">
    <h1>行終端子 (Line Terminators)</h1>
    <p>空白符号位置と同様に、行終端子符号位置はソーステキストの可読性を高め、トークンを相互に分離するために使用される。しかし空白符号位置と異なり、行終端子は構文文法の振る舞いに影響を及ぼす。一般に、行終端子は任意の 2 つのトークン間に現れうるが、構文文法により禁止される箇所がいくつか存在する。行終端子は自動セミコロン挿入（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）の過程にも影響する。行終端子は |StringLiteral|, |Template|, |TemplateSubstitutionTail| 以外のいかなるトークン内部にも現れない。&lt;LF> および &lt;CR> 行終端子は |LineContinuation| の一部である場合を除き |StringLiteral| トークン内部に現れない。</p>
    <p>行終端子は |MultiLineComment| 内には現れることができるが、|SingleLineComment| 内には現れない。</p>
    <p>行終端子は正規表現において `\s` クラスによりマッチされる空白符号位置集合に含まれる。</p>
    <p>ECMAScript の行終端子符号位置は <emu-xref href="#table-line-terminator-code-points"></emu-xref> に列挙される。</p>
    <emu-table id="table-line-terminator-code-points" caption="Line Terminator Code Points" oldids="table-33">
      <table>
        <thead>
          <tr>
            <th>
              Code Point
            </th>
            <th>
              Unicode Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            <code>U+000A</code>
          </td>
          <td>
            LINE FEED (LF)
          </td>
          <td>
            &lt;LF>
          </td>
        </tr>
        <tr>
          <td>
            <code>U+000D</code>
          </td>
          <td>
            CARRIAGE RETURN (CR)
          </td>
          <td>
            &lt;CR>
          </td>
        </tr>
        <tr>
          <td>
            <code>U+2028</code>
          </td>
          <td>
            LINE SEPARATOR
          </td>
          <td>
            &lt;LS>
          </td>
        </tr>
        <tr>
          <td>
            <code>U+2029</code>
          </td>
          <td>
            PARAGRAPH SEPARATOR
          </td>
          <td>
            &lt;PS>
          </td>
        </tr>
      </table>
    </emu-table>
    <p><emu-xref href="#table-line-terminator-code-points"></emu-xref> に示す Unicode 符号位置のみが行終端子として扱われる。その他の改行または行分割の Unicode 符号位置は行終端子とは扱われないが、<emu-xref href="#table-white-space-code-points"></emu-xref> に記述された要件を満たす場合は空白として扱われる。シーケンス &lt;CR>&lt;LF> は行終端子として一般的に使用される。行番号の報告目的においては一つの |SourceCharacter| と見なされるべきである。</p>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      LineTerminator ::
        &lt;LF&gt;
        &lt;CR&gt;
        &lt;LS&gt;
        &lt;PS&gt;

      LineTerminatorSequence ::
        &lt;LF&gt;
        &lt;CR&gt; [lookahead != &lt;LF&gt;]
        &lt;LS&gt;
        &lt;PS&gt;
        &lt;CR&gt; &lt;LF&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-comments">
    <h1>コメント (Comments)</h1>
    <p>コメントは単一行または複数行のいずれかである。複数行コメントは入れ子にできない。</p>
    <p>単一行コメントは |LineTerminator| 符号位置以外の任意の Unicode 符号位置を含むことができ、また一般規則としてトークンは常に可能な限り長くなるため、単一行コメントは `//` マーカーから行末までのすべての符号位置で構成される。ただし行末の |LineTerminator| は単一行コメントの一部とは見なされず、字句文法により別途認識され構文文法用の入力要素列の一部となる。これは重要な点であり、単一行コメントの有無が自動セミコロン挿入（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref> 参照）に影響しないことを意味する。</p>
    <p>コメントは空白のように振る舞い破棄されるが、|MultiLineComment| に行終端子符号位置が含まれる場合、構文文法によるパース目的ではそのコメント全体が一つの |LineTerminator| と見なされる。</p>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      Comment ::
        MultiLineComment
        SingleLineComment

      MultiLineComment ::
        `/*` MultiLineCommentChars? `*/`

      MultiLineCommentChars ::
        MultiLineNotAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      PostAsteriskCommentChars ::
        MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      MultiLineNotAsteriskChar ::
        SourceCharacter but not `*`

      MultiLineNotForwardSlashOrAsteriskChar ::
        SourceCharacter but not one of `/` or `*`

      SingleLineComment ::
        `//` SingleLineCommentChars?

      SingleLineCommentChars ::
        SingleLineCommentChar SingleLineCommentChars?

      SingleLineCommentChar ::
        SourceCharacter but not LineTerminator
    </emu-grammar>
    <p>この節のいくつかの生成規則は <emu-xref href="#sec-html-like-comments"></emu-xref> 節で代替定義が与えられる。</p>
  </emu-clause>

  <emu-clause id="sec-hashbang">
    <h1>ハッシュバンコメント (Hashbang Comments)</h1>

    <p>ハッシュバンコメントは位置依存であり、他の種類のコメントと同様に構文文法への入力要素列からは破棄される。</p>

    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      HashbangComment ::
        `#!` SingleLineCommentChars?
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-tokens">
    <h1>トークン (Tokens)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      CommonToken ::
        IdentifierName
        PrivateIdentifier
        Punctuator
        NumericLiteral
        StringLiteral
        Template
    </emu-grammar>
    <emu-note>
      <p>|DivPunctuator|, |RegularExpressionLiteral|, |RightBracePunctuator|, |TemplateSubstitutionTail| の生成規則は |CommonToken| 生成規則に含まれない追加トークンを導出する。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-names-and-keywords">
    <h1>名前とキーワード (Names and Keywords)</h1>
    <p>|IdentifierName| および |ReservedWord| は Unicode Standard Annex #31「Identifier and Pattern Syntax」で与えられる既定の識別子構文（わずかな修正付き）に従って解釈されるトークンである。|ReservedWord| は |IdentifierName| の列挙された部分集合である。構文文法は |Identifier| を |ReservedWord| ではない |IdentifierName| として定義する。Unicode 識別子文法は Unicode Standard が定義する文字プロパティに基づく。Unicode 標準の最新バージョンで指定カテゴリに属する Unicode 符号位置は、すべての適合 ECMAScript 実装によりそのカテゴリとして扱われなければならない。実装は Unicode 標準の後続版で定義された識別子用符号位置を認識してもよい。</p>
    <emu-note>
      <p>この規格は追加の特定符号位置を許可する: U+0024 (DOLLAR SIGN) および U+005F (LOW LINE) は |IdentifierName| 内の任意の位置で許可される。</p>
    </emu-note>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      PrivateIdentifier ::
        `#` IdentifierName

      IdentifierName ::
        IdentifierStart
        IdentifierName IdentifierPart

      IdentifierStart ::
        IdentifierStartChar
        `\` UnicodeEscapeSequence

      IdentifierPart ::
        IdentifierPartChar
        `\` UnicodeEscapeSequence

      IdentifierStartChar ::
        UnicodeIDStart
        `$`
        `_`

      IdentifierPartChar ::
        UnicodeIDContinue
        `$`

      // emu-format ignore
      AsciiLetter :: one of
        `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
        `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

      UnicodeIDStart ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Start&rdquo;

      UnicodeIDContinue ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Continue&rdquo;
    </emu-grammar>
    <p>非終端記号 |UnicodeEscapeSequence| の定義は <emu-xref href="#sec-literals-string-literals"></emu-xref> に示される。</p>
    <emu-note>
      <p>非終端記号 |IdentifierPart| は |UnicodeIDContinue| を通じて `_` を導出する。</p>
    </emu-note>
    <emu-note>
      <p>Unicode プロパティ “ID_Start” および “ID_Continue” の集合には、それぞれ “Other_ID_Start” および “Other_ID_Continue” プロパティを持つ符号位置が含まれる。</p>
    </emu-note>

    <emu-clause id="sec-identifier-names">
      <h1>識別子名 (Identifier Names)</h1>
      <p>Unicode エスケープシーケンスは |IdentifierName| 内で許可され、その場合 |UnicodeEscapeSequence| の IdentifierCodePoint に等しい一つの Unicode 符号位置として寄与する。|UnicodeEscapeSequence| に先行する `\` はいかなる符号位置も寄与しない。|UnicodeEscapeSequence| は、それが寄与する符号位置をエスケープ無しで書いた場合に無効となるような符号位置を |IdentifierName| に寄与するためには使用できない。言い換えると、` \` |UnicodeEscapeSequence| の並びをそれが寄与する |SourceCharacter| に置換した場合、結果は元の |IdentifierName| と同一の |SourceCharacter| 列を持つ有効な |IdentifierName| でなければならない。本仕様内の |IdentifierName| の解釈は、特定符号位置がエスケープシーケンスで与えられたかどうかに関わらず実際のコードポイントに基づく。</p>
      <p>Unicode 標準に従い正規等価な 2 つの |IdentifierName| は、各 |UnicodeEscapeSequence| を置換した後に完全に同じコードポイント列で表されない限り等しく<em>ない</em>。</p>

      <emu-clause id="sec-identifier-names-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>IdentifierStart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>|UnicodeEscapeSequence| の IdentifierCodePoint が |IdentifierStartChar| 字句文法生成規則でマッチされる Unicode 符号位置でなければ構文エラー。</li>
        </ul>
        <emu-grammar>IdentifierPart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>|UnicodeEscapeSequence| の IdentifierCodePoint が |IdentifierPartChar| 字句文法生成規則でマッチされる Unicode 符号位置でなければ構文エラー。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoints" type="sdo">
        <h1>静的セマンティクス: IdentifierCodePoints ( ): 符号位置の List</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierName :: IdentifierStart</emu-grammar>
        <emu-alg>
          1. _cp_ を |IdentifierStart| の IdentifierCodePoint とする。
          1. « _cp_ » を返す。
        </emu-alg>
        <emu-grammar>IdentifierName :: IdentifierName IdentifierPart</emu-grammar>
        <emu-alg>
          1. _cps_ を導出された |IdentifierName| の IdentifierCodePoints とする。
          1. _cp_ を |IdentifierPart| の IdentifierCodePoint とする。
          1. _cps_ と « _cp_ » のリスト結合を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoint" type="sdo">
        <h1>静的セマンティクス: IdentifierCodePoint ( ): 符号位置</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierStartChar| によりマッチされた符号位置を返す。
        </emu-alg>
        <emu-grammar>IdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierPartChar| によりマッチされた符号位置を返す。
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. |Hex4Digits| の MV の数値値を持つ符号位置を返す。
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. |CodePoint| の MV の数値値を持つ符号位置を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-keywords-and-reserved-words" oldids="sec-reserved-words,sec-keywords,sec-future-reserved-words">
      <h1>キーワードと予約語 (Keywords and Reserved Words)</h1>
      <p><dfn variants="keywords">キーワード (keyword)</dfn> とは |IdentifierName| にマッチしかつ構文上の用途（生成規則中に等幅フォントで文字通り出現する）を持つトークンである。ECMAScript のキーワードには `if`, `while`, `async`, `await` など多数が含まれる。</p>
      <p><dfn variants="reserved words">予約語 (reserved word)</dfn> とは識別子として使用できない |IdentifierName| である。多くのキーワードは予約語であるが、そうでないものもあり、また特定の文脈でのみ予約されるものもある。`if` と `while` は予約語である。`await` は async 関数およびモジュール内でのみ予約される。`async` は予約されていないため、変数名やラベルとして制限なく使用できる。</p>
      <p>この仕様は文法生成規則および早期エラールールの組み合わせを用いて、どの名前が有効な識別子でどれが予約語かを指定する。下記 |ReservedWord| 一覧内の `await` と `yield` を除くすべてのトークンは無条件に予約される。`await` と `yield` の例外は <emu-xref href="#sec-identifiers"></emu-xref> でパラメータ化された構文生成規則を用いて指定される。最後に、いくつかの早期エラールールが有効な識別子集合を制限する。<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-let-and-const-declarations-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-class-definitions-static-semantics-early-errors"></emu-xref> を参照。まとめると識別子名には 5 つの分類がある:</p>
      <ul>
        <li>
          <p>常に識別子として許可されキーワードではないもの（`Math`, `window`, `toString`, `_` など）;</p>
        </li>
        <li>
          <p>決して識別子として許可されないもの（`await` と `yield` を除く |ReservedWord|）;</p>
        </li>
        <li>
          <p>文脈的に識別子として許可されるもの（`await` と `yield`）;</p>
        </li>
        <li>
          <p>strict mode code で文脈的に識別子として不許可となるもの: `let`, `static`, `implements`, `interface`, `package`, `private`, `protected`, `public`;</p>
        </li>
        <li>
          <p>常に識別子として許可されるが、特定の構文生成規則中で |Identifier| が許可されない位置にキーワードとして現れるもの: `as`, `async`, `from`, `get`, `meta`, `of`, `set`, `target`。</p>
        </li>
      </ul>
      <p><dfn variants="conditional keywords">条件付きキーワード (conditional keyword)</dfn> または <dfn variants="contextual keywords">文脈的キーワード (contextual keyword)</dfn> という語がしばしば最後の 3 つのカテゴリに属するキーワードを指し、これらは文脈によって識別子またはキーワードとして使用できる。</p>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        // emu-format ignore
        ReservedWord :: one of
          `await`
          `break`
          `case` `catch` `class` `const` `continue`
          `debugger` `default` `delete` `do`
          `else` `enum` `export` `extends`
          `false` `finally` `for` `function`
          `if` `import` `in` `instanceof`
          `new` `null`
          `return`
          `super` `switch`
          `this` `throw` `true` `try` `typeof`
          `var` `void`
          `while` `with`
          `yield`
      </emu-grammar>
      <emu-note>
        <p><emu-xref href="#sec-grammar-notation"></emu-xref> に従い、文法内のキーワードは特定の |SourceCharacter| 列をリテラルにマッチする。キーワード中の符号位置は `\` |UnicodeEscapeSequence| で表現できない。</p>
        <p>|IdentifierName| は `\` |UnicodeEscapeSequence| を含み得るが、`els\u{65}` のように書いて “else” という名前の変数を宣言することはできない。<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref> にある早期エラールールが、予約語と同じ StringValue を持つ識別子を除外する。</p>
      </emu-note>
      <emu-note>
        <p>`enum` は現時点で本仕様においてキーワードとして使用されていない。これは将来の言語拡張でキーワードとして使用するために予約された <em>future reserved word</em> である。</p>
        <p>同様に、`implements`, `interface`, `package`, `private`, `protected`, `public` は strict mode code における future reserved words である。</p>
      </emu-note>
      <emu-note>
        <p>`arguments` および `eval` はキーワードではないが strict mode code でいくつかの制限を受ける。<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-static-semantics-assignmenttargettype"></emu-xref>, <emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-async-function-definitions-static-semantics-early-errors"></emu-xref> を参照。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-punctuators">
    <h1>句読点 (Punctuators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      Punctuator ::
        OptionalChainingPunctuator
        OtherPunctuator

      OptionalChainingPunctuator ::
        `?.` [lookahead &notin; DecimalDigit]

      // emu-format ignore
      OtherPunctuator :: one of
        `{` `(` `)` `[` `]`
        `.` `...` `;` `,`
        `&lt;` `&gt;` `&lt;=` `&gt;=`
        `==` `!=` `===` `!==`
        `+` `-` `*` `%` `**`
        `++` `--`
        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`
        `&amp;` `|` `^`
        `!` `~`
        `&amp;&amp;` `||` `??`
        `?` `:`
        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`
        `&amp;&amp;=` `||=` `??=`
        `=&gt;`

      DivPunctuator ::
        `/`
        `/=`

      RightBracePunctuator ::
        `}`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-ecmascript-language-lexical-grammar-literals">
    <h1>リテラル (Literals)</h1>

    <emu-clause id="sec-null-literals">
      <h1>null リテラル (Null Literals)</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        NullLiteral ::
          `null`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-boolean-literals">
      <h1>真偽値リテラル (Boolean Literals)</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        BooleanLiteral ::
          `true`
          `false`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-literals-numeric-literals" oldids="sec-additional-syntax-numeric-literals">
      <h1>数値リテラル (Numeric Literals)</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        NumericLiteralSeparator ::
          `_`

        NumericLiteral ::
          DecimalLiteral
          DecimalBigIntegerLiteral
          NonDecimalIntegerLiteral[+Sep]
          NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
          LegacyOctalIntegerLiteral

        DecimalBigIntegerLiteral ::
          `0` BigIntLiteralSuffix
          NonZeroDigit DecimalDigits[+Sep]? BigIntLiteralSuffix
          NonZeroDigit NumericLiteralSeparator DecimalDigits[+Sep] BigIntLiteralSuffix

        NonDecimalIntegerLiteral[Sep] ::
          BinaryIntegerLiteral[?Sep]
          OctalIntegerLiteral[?Sep]
          HexIntegerLiteral[?Sep]

        BigIntLiteralSuffix ::
          `n`

        DecimalLiteral ::
          DecimalIntegerLiteral `.` DecimalDigits[+Sep]? ExponentPart[+Sep]?
          `.` DecimalDigits[+Sep] ExponentPart[+Sep]?
          DecimalIntegerLiteral ExponentPart[+Sep]?

        DecimalIntegerLiteral ::
          `0`
          NonZeroDigit
          NonZeroDigit NumericLiteralSeparator? DecimalDigits[+Sep]
          NonOctalDecimalIntegerLiteral

        DecimalDigits[Sep] ::
          DecimalDigit
          DecimalDigits[?Sep] DecimalDigit
          [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

        DecimalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

        NonZeroDigit :: one of
          `1` `2` `3` `4` `5` `6` `7` `8` `9`

        ExponentPart[Sep] ::
          ExponentIndicator SignedInteger[?Sep]

        ExponentIndicator :: one of
          `e` `E`

        SignedInteger[Sep] ::
          DecimalDigits[?Sep]
          `+` DecimalDigits[?Sep]
          `-` DecimalDigits[?Sep]

        BinaryIntegerLiteral[Sep] ::
          `0b` BinaryDigits[?Sep]
          `0B` BinaryDigits[?Sep]

        BinaryDigits[Sep] ::
          BinaryDigit
          BinaryDigits[?Sep] BinaryDigit
          [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

        BinaryDigit :: one of
          `0` `1`

        OctalIntegerLiteral[Sep] ::
          `0o` OctalDigits[?Sep]
          `0O` OctalDigits[?Sep]

        OctalDigits[Sep] ::
          OctalDigit
          OctalDigits[?Sep] OctalDigit
          [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

        LegacyOctalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalIntegerLiteral OctalDigit

        NonOctalDecimalIntegerLiteral ::
          `0` NonOctalDigit
          LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
          NonOctalDecimalIntegerLiteral DecimalDigit

        LegacyOctalLikeDecimalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalLikeDecimalIntegerLiteral OctalDigit

        OctalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7`

        NonOctalDigit :: one of
          `8` `9`

        HexIntegerLiteral[Sep] ::
          `0x` HexDigits[?Sep]
          `0X` HexDigits[?Sep]

        HexDigits[Sep] ::
          HexDigit
          HexDigits[?Sep] HexDigit
          [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

        // emu-format ignore
        HexDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`
      </emu-grammar>
      <p>|NumericLiteral| に直続する |SourceCharacter| は |IdentifierStart| でも |DecimalDigit| でもあってはならない。</p>
      <emu-note>
        <p>例えば: `3in` はエラーであり、`3` と `in` の 2 つの入力要素ではない。</p>
      </emu-note>

      <emu-clause id="sec-numeric-literals-early-errors">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>
          NumericLiteral :: LegacyOctalIntegerLiteral

          DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
        </emu-grammar>
        <ul>
          <li>IsStrict(this production) が *true* なら構文エラー。</li>
        </ul>
        <emu-note>非 strict コードではこの構文は Legacy である。</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-mv" oldids="sec-additional-syntax-numeric-literals-status-semantics">
        <h1>静的セマンティクス: MV</h1>
        <p>数値リテラルは Number 型または BigInt 型の値を表す。</p>
        <ul>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits</emu-grammar> の MV は |DecimalIntegerLiteral| の MV に (|DecimalDigits| の MV × 10<sup>-_n_</sup>) を加えたもの。ここで _n_ は |NumericLiteralSeparator| の出現を除いた |DecimalDigits| の符号位置数。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart</emu-grammar> の MV は |DecimalIntegerLiteral| の MV × 10<sup>_e_</sup>（_e_ は |ExponentPart| の MV）。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits ExponentPart</emu-grammar> の MV は (|DecimalIntegerLiteral| の MV + (|DecimalDigits| の MV × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits</emu-grammar> の MV は |DecimalDigits| の MV × 10<sup>-_n_</sup>。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits ExponentPart</emu-grammar> の MV は |DecimalDigits| の MV × 10<sup>_e_ - _n_</sup>。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral ExponentPart</emu-grammar> の MV は |DecimalIntegerLiteral| の MV × 10<sup>_e_</sup>。
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: `0`</emu-grammar> の MV は 0。
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparator? DecimalDigits</emu-grammar> の MV は (|NonZeroDigit| の MV × 10<sup>_n_</sup>) + |DecimalDigits| の MV。
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits DecimalDigit</emu-grammar> の MV は (|DecimalDigits| の MV × 10) + |DecimalDigit| の MV。
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit</emu-grammar> の MV も (|DecimalDigits| の MV × 10) + |DecimalDigit| の MV。
          </li>
          <li>
            <emu-grammar>ExponentPart :: ExponentIndicator SignedInteger</emu-grammar> の MV は |SignedInteger| の MV。
          </li>
          <li>
            <emu-grammar>SignedInteger :: `-` DecimalDigits</emu-grammar> の MV は |DecimalDigits| の MV の負。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `0`</emu-grammar> / <emu-grammar>HexDigit :: `0`</emu-grammar> / <emu-grammar>OctalDigit :: `0`</emu-grammar> / <emu-grammar>LegacyOctalEscapeSequence :: `0`</emu-grammar> / <emu-grammar>BinaryDigit :: `0`</emu-grammar> の MV は 0。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `1`</emu-grammar> / <emu-grammar>NonZeroDigit :: `1`</emu-grammar> / <emu-grammar>HexDigit :: `1`</emu-grammar> / <emu-grammar>OctalDigit :: `1`</emu-grammar> / <emu-grammar>BinaryDigit :: `1`</emu-grammar> の MV は 1。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `2`</emu-grammar> / <emu-grammar>NonZeroDigit :: `2`</emu-grammar> / <emu-grammar>HexDigit :: `2`</emu-grammar> / <emu-grammar>OctalDigit :: `2`</emu-grammar> の MV は 2。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `3`</emu-grammar> / ... （以下同様に）`9` まで、指定通り 3,4,5,6,7,8,9。
          </li>
          <li>
            <emu-grammar>HexDigit :: `a`</emu-grammar> / `A` の MV は 10。
          </li>
          <li>
            <emu-grammar>HexDigit :: `b`</emu-grammar> / `B` の MV は 11。
          </li>
          <li>
            <emu-grammar>HexDigit :: `c`</emu-grammar> / `C` の MV は 12。
          </li>
          <li>
            <emu-grammar>HexDigit :: `d`</emu-grammar> / `D` の MV は 13。
          </li>
          <li>
            <emu-grammar>HexDigit :: `e`</emu-grammar> / `E` の MV は 14。
          </li>
          <li>
            <emu-grammar>HexDigit :: `f`</emu-grammar> / `F` の MV は 15。
          </li>
          <li>
            <emu-grammar>BinaryDigits :: BinaryDigits BinaryDigit</emu-grammar> の MV は (|BinaryDigits| の MV × 2) + |BinaryDigit| の MV。
          </li>
          <li>
            <emu-grammar>BinaryDigits :: BinaryDigits NumericLiteralSeparator BinaryDigit</emu-grammar> も同様。
          </li>
          <li>
            <emu-grammar>OctalDigits :: OctalDigits OctalDigit</emu-grammar> の MV は (|OctalDigits| の MV × 8) + |OctalDigit| の MV。
          </li>
          <li>
            <emu-grammar>OctalDigits :: OctalDigits NumericLiteralSeparator OctalDigit</emu-grammar> も同様。
          </li>
          <li>
            <emu-grammar>LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral OctalDigit</emu-grammar> の MV は (|LegacyOctalIntegerLiteral| の MV × 8) + |OctalDigit| の MV。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit</emu-grammar> の MV は (|LegacyOctalLikeDecimalIntegerLiteral| の MV × 10) + |NonOctalDigit| の MV。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral DecimalDigit</emu-grammar> の MV は (|NonOctalDecimalIntegerLiteral| の MV × 10) + |DecimalDigit| の MV。
          </li>
          <li>
            <emu-grammar>LegacyOctalLikeDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral OctalDigit</emu-grammar> の MV は (|LegacyOctalLikeDecimalIntegerLiteral| の MV × 10) + |OctalDigit| の MV。
          </li>
          <li>
            <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> の MV は (|HexDigits| の MV × 16) + |HexDigit| の MV。
          </li>
          <li>
            <emu-grammar>HexDigits :: HexDigits NumericLiteralSeparator HexDigit</emu-grammar> も同様。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-numericvalue" type="sdo">
        <h1>静的セマンティクス: NumericValue ( ): Number または BigInt</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NumericLiteral :: DecimalLiteral</emu-grammar>
        <emu-alg>
          1. RoundMVResult(|DecimalLiteral| の MV) を返す。
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 𝔽(|NonDecimalIntegerLiteral| の MV) を返す。
        </emu-alg>
        <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 𝔽(|LegacyOctalIntegerLiteral| の MV) を返す。
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. |NonDecimalIntegerLiteral| の MV に対応する BigInt 値を返す。
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: `0` BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. *0*<sub>ℤ</sub> を返す。
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. |NonZeroDigit| の MV に対応する BigInt 値を返す。
        </emu-alg>
        <emu-grammar>
          DecimalBigIntegerLiteral ::
            NonZeroDigit DecimalDigits BigIntLiteralSuffix
            NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
        </emu-grammar>
        <emu-alg>
          1. _n_ を |NumericLiteralSeparator| の出現を除いた |DecimalDigits| の符号位置数とする。
          1. _mv_ を (|NonZeroDigit| の MV × 10<sup>_n_</sup>) + |DecimalDigits| の MV とする。
          1. ℤ(_mv_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-string-literals" oldids="sec-additional-syntax-string-literals">
      <h1>文字列リテラル (String Literals)</h1>
      <emu-note>
        <p>文字列リテラルは単一または二重引用符で囲まれた 0 個以上の Unicode 符号位置である。Unicode 符号位置はエスケープシーケンスで表すこともできる。閉じ引用符、U+005C (REVERSE SOLIDUS), U+000D (CARRIAGE RETURN), U+000A (LINE FEED) 以外のすべての符号位置は文字列リテラル内にリテラルに記述可能である。任意の符号位置はエスケープシーケンスの形で出現可能である。文字列リテラルは ECMAScript String 値へと評価される。これらの String 値を生成する際、Unicode 符号位置は <emu-xref href="#sec-utf16encodecodepoint"></emu-xref> で定義されるように UTF-16 エンコードされる。基本多言語面に属するコードポイントは文字列の 1 つのコードユニット要素としてエンコードされ、それ以外は 2 つのコードユニット要素としてエンコードされる。</p>
      </emu-note>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        StringLiteral ::
          `"` DoubleStringCharacters? `"`
          `'` SingleStringCharacters? `'`

        DoubleStringCharacters ::
          DoubleStringCharacter DoubleStringCharacters?

        SingleStringCharacters ::
          SingleStringCharacter SingleStringCharacters?

        DoubleStringCharacter ::
          SourceCharacter but not one of `"` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        SingleStringCharacter ::
          SourceCharacter but not one of `'` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        LineContinuation ::
          `\` LineTerminatorSequence

        EscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          LegacyOctalEscapeSequence
          NonOctalDecimalEscapeSequence
          HexEscapeSequence
          UnicodeEscapeSequence

        CharacterEscapeSequence ::
          SingleEscapeCharacter
          NonEscapeCharacter

        SingleEscapeCharacter :: one of
          `'` `"` `\` `b` `f` `n` `r` `t` `v`

        NonEscapeCharacter ::
          SourceCharacter but not one of EscapeCharacter or LineTerminator

        EscapeCharacter ::
          SingleEscapeCharacter
          DecimalDigit
          `x`
          `u`

        LegacyOctalEscapeSequence ::
          `0` [lookahead &isin; { `8`, `9` }]
          NonZeroOctalDigit [lookahead &notin; OctalDigit]
          ZeroToThree OctalDigit [lookahead &notin; OctalDigit]
          FourToSeven OctalDigit
          ZeroToThree OctalDigit OctalDigit

        NonZeroOctalDigit ::
          OctalDigit but not `0`

        ZeroToThree :: one of
          `0` `1` `2` `3`

        FourToSeven :: one of
          `4` `5` `6` `7`

        NonOctalDecimalEscapeSequence :: one of
          `8` `9`

        HexEscapeSequence ::
          `x` HexDigit HexDigit

        UnicodeEscapeSequence ::
          `u` Hex4Digits
          `u{` CodePoint `}`

        Hex4Digits ::
          HexDigit HexDigit HexDigit HexDigit
      </emu-grammar>
      <p>非終端 |HexDigit| の定義は <emu-xref href="#sec-literals-numeric-literals"></emu-xref> に、|SourceCharacter| は <emu-xref href="#sec-source-text"></emu-xref> にある。</p>
      <emu-note>
        <p>&lt;LF> と &lt;CR> は |LineContinuation| の一部として空の符号位置列を生成する場合を除き文字列リテラル内に現れない。文字列リテラルの String 値にこれらを含める正しい方法は `\n` や `\u000A` などのエスケープシーケンスを用いることである。</p>
      </emu-note>

      <emu-clause id="sec-string-literals-early-errors">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>
          EscapeSequence ::
            LegacyOctalEscapeSequence
            NonOctalDecimalEscapeSequence
        </emu-grammar>
        <ul>
          <li>IsStrict(this production) が *true* なら構文エラー。</li>
        </ul>
        <emu-note>非 strict コードではこの構文は Legacy。</emu-note>
        <emu-note>
          <p>文字列リテラルは囲むコードを strict mode にする Use Strict ディレクティブより前に現れる可能性があるため、実装はそのようなリテラルに対して上記規則を適用する際注意しなければならない。例えば次のソーステキストは構文エラーを含む:</p>
          <pre><code class="javascript">
            function invalid() { "\7"; "use strict"; }
          </code></pre>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-sv" oldids="sec-string-literals-static-semantics-stringvalue,sec-additional-syntax-string-literals-static-semantics" type="sdo">
        <h1>静的セマンティクス: SV ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            <p>文字列リテラルは String 型の値を表す。SV は文字列リテラルの各部分に再帰的に適用され String 値を生成する。この過程で、文字列リテラル内の一部の Unicode 符号位置は下記または <emu-xref href="#sec-literals-numeric-literals"></emu-xref> に述べるように数学的値を持つものとして解釈される。</p>
          </dd>
        </dl>
        <ul>
          <li>
            <emu-grammar>StringLiteral :: `"` `"`</emu-grammar> の SV は空文字列。
          </li>
          <li>
            <emu-grammar>StringLiteral :: `'` `'`</emu-grammar> の SV は空文字列。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters</emu-grammar> の SV は |DoubleStringCharacter| の SV と |DoubleStringCharacters| の SV の連結。
          </li>
          <li>
            <emu-grammar>SingleStringCharacters :: SingleStringCharacter SingleStringCharacters</emu-grammar> の SV は同様。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: SourceCharacter but not one of `"` or `\` or LineTerminator</emu-grammar> の SV は |SourceCharacter| によりマッチされたコードポイントに UTF16EncodeCodePoint を行った結果。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: &lt;LS&gt;</emu-grammar> の SV はコードユニット 0x2028。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: &lt;PS&gt;</emu-grammar> の SV はコードユニット 0x2029。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: LineContinuation</emu-grammar> の SV は空文字列。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: SourceCharacter but not one of `'` or `\` or LineTerminator</emu-grammar> の SV も UTF16EncodeCodePoint の結果。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: &lt;LS&gt;</emu-grammar> の SV は 0x2028。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: &lt;PS&gt;</emu-grammar> の SV は 0x2029。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: LineContinuation</emu-grammar> の SV は空文字列。
          </li>
          <li>
            <emu-grammar>EscapeSequence :: `0`</emu-grammar> の SV はコードユニット 0x0000。
          </li>
          <li>
            <emu-grammar>CharacterEscapeSequence :: SingleEscapeCharacter</emu-grammar> の SV は <emu-xref href="#table-string-single-character-escape-sequences"></emu-xref> に従い決定されるコードユニット値。
          </li>
        </ul>
        <emu-table id="table-string-single-character-escape-sequences" caption="String Single Character Escape Sequences" oldids="table-34">
          <table>
            <thead>
              <tr>
                <th>
                  Escape Sequence
                </th>
                <th>
                  Code Unit Value
                </th>
                <th>
                  Unicode Character Name
                </th>
                <th>
                  Symbol
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                <code>\\b</code>
              </td>
              <td>
                <code>0x0008</code>
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                &lt;BS>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\t</code>
              </td>
              <td>
                <code>0x0009</code>
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\n</code>
              </td>
              <td>
                <code>0x000A</code>
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\v</code>
              </td>
              <td>
                <code>0x000B</code>
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\f</code>
              </td>
              <td>
                <code>0x000C</code>
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\r</code>
              </td>
              <td>
                <code>0x000D</code>
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\"</code>
              </td>
              <td>
                <code>0x0022</code>
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                <code>"</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\'</code>
              </td>
              <td>
                <code>0x0027</code>
              </td>
              <td>
                APOSTROPHE
              </td>
              <td>
                <code>'</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>\\\\</code>
              </td>
              <td>
                <code>0x005C</code>
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                <code>\\</code>
              </td>
            </tr>
          </table>
        </emu-table>
        <ul>
          <li>
            <emu-grammar>NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator</emu-grammar> の SV は UTF16EncodeCodePoint の結果。
          </li>
          <li>
            <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> の SV は |LegacyOctalEscapeSequence| の MV の数値値を持つコードユニット。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalEscapeSequence :: `8`</emu-grammar> の SV は 0x0038。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalEscapeSequence :: `9`</emu-grammar> の SV は 0x0039。
          </li>
          <li>
            <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> の SV は |HexEscapeSequence| の MV を数値値とするコードユニット。
          </li>
          <li>
            <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> の SV は |Hex4Digits| の MV を数値値とするコードユニット。
          </li>
          <li>
            <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> の SV は |CodePoint| の MV に UTF16EncodeCodePoint を行った結果。
          </li>
          <li>
            <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> の SV は 0x0000。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-string-literals-static-semantics-mv">
        <h1>静的セマンティクス: MV</h1>
        <ul>
          <li>
            <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit</emu-grammar> の MV は (8 × |ZeroToThree| の MV) + |OctalDigit| の MV。
          </li>
          <li>
            <emu-grammar>LegacyOctalEscapeSequence :: FourToSeven OctalDigit</emu-grammar> の MV は (8 × |FourToSeven| の MV) + |OctalDigit| の MV。
          </li>
          <li>
            <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit</emu-grammar> の MV は (64 × |ZeroToThree| の MV) + (8 × 最初の |OctalDigit| の MV) + 2 番目の |OctalDigit| の MV。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `0`</emu-grammar> の MV は 0。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `1`</emu-grammar> の MV は 1。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `2`</emu-grammar> の MV は 2。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `3`</emu-grammar> の MV は 3。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `4`</emu-grammar> の MV は 4。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `5`</emu-grammar> の MV は 5。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `6`</emu-grammar> の MV は 6。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `7`</emu-grammar> の MV は 7。
          </li>
          <li>
            <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> の MV は (16 × 最初の |HexDigit| の MV) + 2 番目の |HexDigit| の MV。
          </li>
          <li>
            <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> の MV は (0x1000 × 最初の |HexDigit| の MV) + (0x100 × 2 番目) + (0x10 × 3 番目) + 4 番目。
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-regular-expression-literals">
      <h1>正規表現リテラル (Regular Expression Literals)</h1>
      <emu-note>
        <p>正規表現リテラルは評価のたびに RegExp オブジェクト（<emu-xref href="#sec-regexp-regular-expression-objects"></emu-xref> 参照）へ変換される入力要素である。プログラム中の 2 つの正規表現リテラルは内容が同一でも `===` で等しくならない。RegExp オブジェクトは `new RegExp` またはコンストラクタ呼び出し（<emu-xref href="#sec-regexp-constructor"></emu-xref>）で実行時に生成することもできる。</p>
      </emu-note>
      <p>以下の生成規則は正規表現リテラルの構文を記述し、入力要素スキャナが正規表現リテラルの終端を見つけるために用いられる。|RegularExpressionBody| と |RegularExpressionFlags| を成すソーステキストは、その後より厳密な ECMAScript 正規表現文法（<emu-xref href="#sec-patterns"></emu-xref>）を用いて再度パースされる。</p>
      <p>実装は <emu-xref href="#sec-patterns"></emu-xref> で定義される ECMAScript 正規表現文法を拡張してもよいが、下に定義される |RegularExpressionBody| および |RegularExpressionFlags| 生成規則、またそれらが使用する生成規則を拡張してはならない。</p>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        RegularExpressionLiteral ::
          `/` RegularExpressionBody `/` RegularExpressionFlags

        RegularExpressionBody ::
          RegularExpressionFirstChar RegularExpressionChars

        RegularExpressionChars ::
          [empty]
          RegularExpressionChars RegularExpressionChar

        RegularExpressionFirstChar ::
          RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionChar ::
          RegularExpressionNonTerminator but not one of `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionBackslashSequence ::
          `\` RegularExpressionNonTerminator

        RegularExpressionNonTerminator ::
          SourceCharacter but not LineTerminator

        RegularExpressionClass ::
          `[` RegularExpressionClassChars `]`

        RegularExpressionClassChars ::
          [empty]
          RegularExpressionClassChars RegularExpressionClassChar

        RegularExpressionClassChar ::
          RegularExpressionNonTerminator but not one of `]` or `\`
          RegularExpressionBackslashSequence

        RegularExpressionFlags ::
          [empty]
          RegularExpressionFlags IdentifierPartChar
      </emu-grammar>
      <emu-note>
        <p>正規表現リテラルは空にできない。空の正規表現リテラルを表す代わりに `//` は単一行コメントを開始する。空の正規表現を指定するには `/(?:)/` を用いる。</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-bodytext" type="sdo">
        <h1>静的セマンティクス: BodyText ( ): ソーステキスト</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. |RegularExpressionBody| として認識されたソーステキストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-flagtext" type="sdo">
        <h1>静的セマンティクス: FlagText ( ): ソーステキスト</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. |RegularExpressionFlags| として認識されたソーステキストを返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literal-lexical-components">
      <h1>テンプレートリテラルの字句要素 (Template Literal Lexical Components)</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        Template ::
          NoSubstitutionTemplate
          TemplateHead

        NoSubstitutionTemplate ::
          ``` TemplateCharacters? ```

        TemplateHead ::
          ``` TemplateCharacters? `${`

        TemplateSubstitutionTail ::
          TemplateMiddle
          TemplateTail

        TemplateMiddle ::
          `}` TemplateCharacters? `${`

        TemplateTail ::
          `}` TemplateCharacters? ```

        TemplateCharacters ::
          TemplateCharacter TemplateCharacters?

        TemplateCharacter ::
          `$` [lookahead != `{`]
          `\` TemplateEscapeSequence
          `\` NotEscapeSequence
          LineContinuation
          LineTerminatorSequence
          SourceCharacter but not one of ``` or `\` or `$` or LineTerminator

        TemplateEscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          UnicodeEscapeSequence

        NotEscapeSequence ::
          `0` DecimalDigit
          DecimalDigit but not `0`
          `x` [lookahead &notin; HexDigit]
          `x` HexDigit [lookahead &notin; HexDigit]
          `u` [lookahead &notin; HexDigit] [lookahead != `{`]
          `u` HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` `{` [lookahead &notin; HexDigit]
          `u` `{` NotCodePoint [lookahead &notin; HexDigit]
          `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]

        NotCodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| > 0x10FFFF]

        CodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| &le; 0x10FFFF]
      </emu-grammar>
      <emu-note>
        <p>|TemplateSubstitutionTail| は |InputElementTemplateTail| の代替字句目標で用いられる。</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-tv" type="sdo" oldids="sec-static-semantics-tv-and-trv">
        <h1>静的セマンティクス: TV ( ): String または *undefined*</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>テンプレートリテラル構成要素は TV により String 型の値として解釈される。TV はテンプレートオブジェクトのインデックス付き構成要素（テンプレート値）を構成する。TV ではエスケープシーケンスはその Unicode 符号位置を UTF-16 のコードユニットに置換される。</dd>
        </dl>
        <ul>
          <li>
            <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> の TV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> の TV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> の TV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateTail :: `}` ```</emu-grammar> の TV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> の TV は |TemplateCharacter| または |TemplateCharacters| の TV が *undefined* なら *undefined*、そうでなければその連結。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> の TV は |SourceCharacter| にマッチしたコードポイントへ UTF16EncodeCodePoint を行った結果。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `$`</emu-grammar> の TV はコードユニット 0x0024。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> の TV は |TemplateEscapeSequence| の SV。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> の TV は *undefined*。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: LineTerminatorSequence</emu-grammar> の TV は |LineTerminatorSequence| の TRV。
          </li>
          <li>
            <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> の TV は空文字列。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-trv" type="sdo">
        <h1>静的セマンティクス: TRV ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>テンプレートリテラル構成要素は TRV により String 型の値として解釈される。TRV はテンプレートオブジェクトの raw 構成要素（テンプレート raw 値）を構築する。TRV は TV と似ているが、TRV ではエスケープシーケンスは字面通りのコード単位として扱われる点が異なる。</dd>
        </dl>
        <ul>
          <li>
            <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> の TRV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> の TRV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> の TRV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateTail :: `}` ```</emu-grammar> の TRV は空文字列。
          </li>
          <li>
            <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> の TRV は各 TRV の連結。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> の TRV は UTF16EncodeCodePoint の結果。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `$`</emu-grammar> の TRV は 0x0024。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> の TRV は 0x005C と |TemplateEscapeSequence| の TRV の連結。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> の TRV は 0x005C と |NotEscapeSequence| の TRV の連結。
          </li>
          <li>
            <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> の TRV は 0x0030。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `0` DecimalDigit</emu-grammar> の TRV は 0x0030 と |DecimalDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `x` [lookahead &notin; HexDigit]</emu-grammar> の TRV は 0x0078。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `x` HexDigit [lookahead &notin; HexDigit]</emu-grammar> の TRV は 0x0078 と |HexDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` [lookahead &notin; HexDigit] [lookahead != `{`]</emu-grammar> の TRV は 0x0075。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` HexDigit [lookahead &notin; HexDigit]</emu-grammar> の TRV は 0x0075 と |HexDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> の TRV は 0x0075 と最初および 2 番目の |HexDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> の TRV は 0x0075 と最初,2 番目,3 番目の |HexDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` `{` [lookahead &notin; HexDigit]</emu-grammar> の TRV は 0x0075 と 0x007B の連結。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` `{` NotCodePoint [lookahead &notin; HexDigit]</emu-grammar> の TRV は 0x0075, 0x007B, |NotCodePoint| の TRV の連結。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]</emu-grammar> の TRV は 0x0075, 0x007B, |CodePoint| の TRV の連結。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: one of `0` `9`</emu-grammar> の TRV は該当コードポイントを UTF16EncodeCodePoint した結果。
          </li>
          <li>
            <emu-grammar>CharacterEscapeSequence :: NonEscapeCharacter</emu-grammar> の TRV は |NonEscapeCharacter| の SV。
          </li>
          <li>
            <emu-grammar>SingleEscapeCharacter :: one of `'` `"` `\` `b` `f` `n` `r` `t` `v`</emu-grammar> の TRV はそのコードポイントの UTF16EncodeCodePoint 結果。
          </li>
          <li>
            <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> の TRV は 0x0078 と 2 つの |HexDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar> の TRV は 0x0075 と |Hex4Digits| の TRV の連結。
          </li>
          <li>
            <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> の TRV は 0x0075, 0x007B, |CodePoint| の TRV, 0x007D の連結。
          </li>
          <li>
            <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> の TRV は 4 つの |HexDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> の TRV は |HexDigits| の TRV と |HexDigit| の TRV の連結。
          </li>
          <li>
            <emu-grammar>HexDigit :: one of `0` `9` `a` `f` `A` `F`</emu-grammar> の TRV は UTF16EncodeCodePoint の結果。
          </li>
          <li>
            <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> の TRV は 0x005C と |LineTerminatorSequence| の TRV の連結。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;LF&gt;</emu-grammar> の TRV は 0x000A。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;CR&gt;</emu-grammar> の TRV は 0x000A。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;LS&gt;</emu-grammar> の TRV は 0x2028。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;PS&gt;</emu-grammar> の TRV は 0x2029。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;CR&gt; &lt;LF&gt;</emu-grammar> の TRV は 0x000A。
          </li>
        </ul>
        <emu-note>
          <p>TV は |LineContinuation| のコードユニットを除外するが TRV は含む。&lt;CR>&lt;LF> と &lt;CR> の |LineTerminatorSequence| は TV と TRV の両方で &lt;LF> に正規化される。&lt;CR> または &lt;CR>&lt;LF> を含めるには明示的な |TemplateEscapeSequence| が必要。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-automatic-semicolon-insertion">
    <h1>自動セミコロン挿入 (Automatic Semicolon Insertion)</h1>
    <p>ほとんどの ECMAScript 文および宣言はセミコロンで終端されなければならない。これらのセミコロンは常に明示的に記述できる。利便性のため、特定の状況ではそれらを省略できる。これらの状況ではソースコードトークン列へ自動的にセミコロンが挿入されると記述される。</p>

    <emu-clause id="sec-rules-of-automatic-semicolon-insertion" namespace="asi-rules">
      <h1>自動セミコロン挿入の規則 (Rules of Automatic Semicolon Insertion)</h1>
      <p>以下の規則において “token” は <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref> に述べる現在の字句目標記号を用いて決定される実際に認識された字句トークンを意味する。</p>
      <p>セミコロン挿入には 3 つの基本規則がある:</p>
      <ol>
        <li>
          <p>ソーステキストを左から右へパースする際、いかなる文法生成規則でも許可されないトークン（<em>違反トークン</em>）に遭遇したとき、以下のいずれかが真ならその違反トークンの前にセミコロンが自動挿入される:</p>
          <ul>
            <li>
              違反トークンが直前のトークンと 1 つ以上の |LineTerminator| で分離されている。
            </li>
            <li>
              違反トークンが `}` である。
            </li>
            <li>
              直前のトークンが `)` であり、挿入されたセミコロンが do-while 文 (<emu-xref href="#sec-do-while-statement"></emu-xref>) の終端セミコロンとしてパースされる。
            </li>
          </ul>
        </li>
        <li>
          ソーステキストを左から右へパースする際、トークン入力列の終端に到達し、構文解析器が入力トークン列を目標非終端の単一インスタンスとしてパースできないなら、入力列末尾にセミコロンが自動挿入される。
        </li>
        <li>
          ソーステキストを左から右へパースする際、文法生成規則により許可されるトークンだがその生成規則が<em>制限付き生成規則</em>であり、トークンが制限付き生成規則内の “[no |LineTerminator| here]” 注釈直後に位置する終端または非終端の先頭トークン（= 制限トークン）であり、その制限トークンが直前トークンと 1 つ以上の |LineTerminator| で分離されているなら、制限トークンの前にセミコロンが自動挿入される。
        </li>
      </ol>
      <p>ただし上記規則には更に支配的な条件がある: セミコロンが自動挿入された結果それが空文としてパースされる場合、またはそのセミコロンが `for` 文ヘッダ内の 2 つのセミコロンの一つになる場合（<emu-xref href="#sec-for-statement"></emu-xref> 参照）、セミコロンは決して自動挿入されない。</p>
      <emu-note>
        <p>以下は文法中の唯一の制限付き生成規則である:</p>
        <emu-grammar>
          UpdateExpression[Yield, Await] :
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`

          ContinueStatement[Yield, Await] :
            `continue` `;`
            `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          BreakStatement[Yield, Await] :
            `break` `;`
            `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          ReturnStatement[Yield, Await] :
            `return` `;`
            `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ThrowStatement[Yield, Await] :
            `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          YieldExpression[In, Await] :
            `yield`
            `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
            `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]

          ArrowFunction[In, Yield, Await] :
            ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

          AsyncFunctionDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
            [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncFunctionExpression :
            `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncMethod[Yield, Await] :
            `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncGeneratorDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
            [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorExpression :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorMethod[Yield, Await] :
            `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncArrowFunction[In, Yield, Await] :
            `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
            CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

          AsyncArrowHead :
            `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
        </emu-grammar>
        <p>これら制限付き生成規則の実際的効果は次の通り:</p>
        <ul>
          <li>
            後置 `++` または `--` が出現し、直前トークンとの間に 1 つ以上の |LineTerminator| がある場合、その前にセミコロンが自動挿入される。
          </li>
          <li>
            `continue`, `break`, `return`, `throw`, `yield` トークンに続いて |LineTerminator| が現れた場合、それらトークンの直後にセミコロンが自動挿入される。
          </li>
          <li>
            アロー関数パラメータの終わりと `=>` の間に |LineTerminator| がある場合、セミコロンが挿入され `=>` は構文エラーとなる。
          </li>
          <li>
            `async` の後に |LineTerminator| があり、その後に `function` や |IdentifierName| や `(` が続く前に改行がある場合、セミコロンが挿入され `async` は後続と同じ式／クラス要素と扱われない。
          </li>
          <li>
            `async` の後に |LineTerminator| があり、その後に `*` が来る場合、セミコロンが挿入され `*` は構文エラーとなる。
          </li>
        </ul>
        <p>実務上の指針:</p>
        <ul>
          <li>
            後置 `++` / `--` はオペランドと同じ行に置く。
          </li>
          <li>
            `return` / `throw` / `yield` の後に続く式は同じ行で開始する。
          </li>
          <li>
            `break` / `continue` の |LabelIdentifier| は同じ行に置く。
          </li>
          <li>
            アロー関数のパラメータ終端と `=>` は同じ行に置く。
          </li>
          <li>
            非同期関数やメソッドの直前の `async` は直後のトークンと同じ行に置く。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-examples-of-automatic-semicolon-insertion">
      <h1>自動セミコロン挿入の例 (Examples of Automatic Semicolon Insertion)</h1>
      <em>この節は規範的でない (non-normative)。</em>
      <p>次のソース</p>
      <pre><code class="javascript">{ 1 2 } 3</code></pre>
      <p>は自動セミコロン挿入規則を考慮しても ECMAScript 文法の妥当な文ではない。対照的に次のソース</p>
      <pre><code class="javascript">
        { 1
        2 } 3
      </code></pre>
      <p>も妥当ではないが、自動セミコロン挿入により以下に変換される:</p>
      <pre><code class="javascript">
        { 1
        ;2 ;} 3;
      </code></pre>
      <p>これは妥当な ECMAScript 文である。</p>
      <p>次のソース</p>
      <pre><code class="javascript">
        for (a; b
        )
      </code></pre>
      <p>は妥当ではなく、自動セミコロン挿入で変更されない。これは `for` 文ヘッダのセミコロンが必要であり、自動挿入は `for` ヘッダ内 2 つのセミコロンのいずれも挿入しないためである。</p>
      <p>次のソース</p>
      <pre><code class="javascript">
        return
        a + b
      </code></pre>
      <p>は次に変換される:</p>
      <pre><code class="javascript">
        return;
        a + b;
      </code></pre>
      <emu-note>
        <p>`a + b` は `return` 文で返される値として扱われない。|LineTerminator| が `return` トークンとそれに続く式を分離するためである。</p>
      </emu-note>
      <p>次のソース</p>
      <pre><code class="javascript">
        a = b
        ++c
      </code></pre>
      <p>は以下に変換される:</p>
      <pre><code class="javascript">
        a = b;
        ++c;
      </code></pre>
      <emu-note>
        <p>`++` トークンは変数 `b` への後置演算子として扱われない。`b` と `++` の間に |LineTerminator| があるため。</p>
      </emu-note>
      <p>次のソース</p>
      <pre><code class="javascript">
        if (a &gt; b)
        else c = d
      </code></pre>
      <p>は妥当ではなく、`else` トークンの前には自動セミコロン挿入による変化は起こらない。文法生成規則が適用できない地点ではあるが、挿入された場合空文になるため。</p>
      <p>次のソース</p>
      <pre><code class="javascript">
        a = b + c
        (d + e).print()
      </code></pre>
      <p>は自動セミコロン挿入で<em>変換されない</em>。2 行目冒頭の括弧付き式は関数呼び出しの引数リストと解釈できるためである:</p>
      <pre><code class="javascript">a = b + c(d + e).print()</code></pre>
      <p>代入文が左括弧で始まらなければならない状況では、自動セミコロン挿入に頼らず前の文末に明示的なセミコロンを置くべきである。</p>
    </emu-clause>

    <emu-clause id="sec-interesting-cases-of-automatic-semicolon-insertion">
      <h1>自動セミコロン挿入の興味深いケース (Interesting Cases of Automatic Semicolon Insertion)</h1>
      <em>この節は規範的でない。</em>
      <p>ECMAScript プログラムは自動セミコロン挿入に依存することで非常に少ないセミコロンで書くことができる。上述のようにセミコロンはすべての改行で挿入されるわけではなく、挿入は複数トークンにまたがる。</p>

      <p>ECMAScript に新しい構文機能が追加されると、追加の構文生成規則が導入され、自動セミコロン挿入に依存する行がパース時に使用する生成規則を変化させる可能性がある。</p>

      <p>本節では、前に現れるソーステキストによってセミコロンが挿入されるか否かが変わりうる箇所を興味深いケースとみなす。本バージョンでの自動セミコロン挿入のいくつかの興味深いケースを以下で説明する。</p>

      <emu-clause id="sec-asi-interesting-cases-in-statement-lists">
        <h1>文リストにおける自動セミコロン挿入の興味深いケース</h1>
        <p>|StatementList| では多くの |StatementListItem| がセミコロンで終わり、自動セミコロン挿入により省略できる。上記規則の結果、式で終わる行の末尾で、次の行が以下のいずれかで始まる場合セミコロンが必要になる:</p>
        <ul>
          <li><strong>開き丸括弧 (<code>(</code>)</strong>。セミコロンがなければ 2 行は |CallExpression| とみなされる。</li>
          <li><strong>開き角括弧 (<code>[</code>)</strong>。セミコロンがなければ 2 行は |ArrayLiteral| / |ArrayAssignmentPattern| ではなくプロパティアクセスと解釈される。</li>
          <li><strong>テンプレートリテラル (<code>`</code>)</strong>。セミコロンがなければ 2 行は前の式を |MemberExpression| とするタグ付きテンプレート (<emu-xref href="#sec-tagged-templates"></emu-xref>) と解釈される。</li>
          <li><strong>単項 <code>+</code> または <code>-</code></strong>。セミコロンがなければ 2 行は対応する二項演算子の使用と解釈され得る。</li>
          <li><strong>RegExp リテラル</strong>。セミコロンがなければ 2 行は `/` |MultiplicativeOperator| として（正規表現にフラグがある場合など）パースされ得る。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-asi-cases-with-no-lineterminator-here">
        <h1>“[no |LineTerminator| here]” を伴う自動セミコロン挿入のケース</h1>
        <em>この節は規範的でない。</em>
        <p>ECMAScript には “[no |LineTerminator| here]” を含む生成規則があり、これらはしばしば文法における省略可能オペランドを実現する手段である。これら位置に |LineTerminator| を導入すると省略可能オペランドを持たない別生成規則の使用へ切り替わる。</p>

        <p>以下では本バージョンの “[no |LineTerminator| here]” を使用するいくつかの生成規則を列挙する。</p>

        <emu-clause id="sec-no-lineterminator-here-automatic-semicolon-insertion-list">
          <h1>省略可能オペランドと “[no |LineTerminator| here]” を持つ生成規則一覧</h1>
          <ul>
            <li>|UpdateExpression|.</li>
            <li>|ContinueStatement|.</li>
            <li>|BreakStatement|.</li>
            <li>|ReturnStatement|.</li>
            <li>|YieldExpression|.</li>
            <li>Async Function 定義（<emu-xref href="#sec-async-function-definitions"></emu-xref>）と Function 定義（<emu-xref href="#sec-function-definitions"></emu-xref>）の関係。</li>
          </ul>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript 言語: 表現式 (Expressions)</h1>

  <emu-clause id="sec-identifiers">
    <h1>識別子 (Identifiers)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      IdentifierReference[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      BindingIdentifier[Yield, Await] :
        Identifier
        `yield`
        `await`

      LabelIdentifier[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      Identifier :
        IdentifierName but not ReservedWord
    </emu-grammar>

    <emu-note>
      <p>`yield` と `await` は文法上は |BindingIdentifier| として許可されるが、以下の静的セマンティクスにより禁止され、次のようなケースで自動セミコロン挿入を許さないためである:</p>
      <pre><code class="javascript">
        let
        await 0;
      </code></pre>
    </emu-note>

    <emu-clause id="sec-identifiers-static-semantics-early-errors">
      <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <ul>
        <li>
          IsStrict(this production) が *true* であり、|Identifier| の StringValue が *"arguments"* か *"eval"* のいずれかであるなら構文エラー。
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <ul>
        <li>
          IsStrict(this production) が *true* なら構文エラー。
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <ul>
        <li>
          構文文法のゴール記号が |Module| であるなら構文エラー。
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `yield`
      </emu-grammar>
      <ul>
        <li>
          この生成規則が <sub>[Yield]</sub> パラメータを持つなら構文エラー。
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `await`
      </emu-grammar>
      <ul>
        <li>
          この生成規則が <sub>[Await]</sub> パラメータを持つなら構文エラー。
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference[Yield, Await] : Identifier

        BindingIdentifier[Yield, Await] : Identifier

        LabelIdentifier[Yield, Await] : Identifier
      </emu-grammar>
      <ul>
        <li>
          この生成規則が <sub>[Yield]</sub> パラメータを持ち、|Identifier| の StringValue が *"yield"* なら構文エラー。
        </li>
        <li>
          この生成規則が <sub>[Await]</sub> パラメータを持ち、|Identifier| の StringValue が *"await"* なら構文エラー。
        </li>
      </ul>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <ul>
        <li>
          IsStrict(this phrase) が *true* で、|IdentifierName| の StringValue が *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, *"static"*, *"yield"* のいずれかなら構文エラー。
        </li>
        <li>
          構文文法のゴール記号が |Module| で、|IdentifierName| の StringValue が *"await"* なら構文エラー。
        </li>
        <li>
          |IdentifierName| の StringValue が `yield` および `await` を除くいずれかの |ReservedWord| の StringValue と同じなら構文エラー。
        </li>
      </ul>
      <emu-note>
        <p>|IdentifierName| の StringValue は |IdentifierName| 内の Unicode エスケープシーケンスを正規化するため、エスケープによって |ReservedWord| と同じコードポイント列の |Identifier| を作ることはできない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-stringvalue" oldids="sec-identifiers-static-semantics-stringvalue,sec-identifier-names-static-semantics-stringvalue" type="sdo">
      <h1>静的セマンティクス: StringValue ( ): String</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        IdentifierName ::
          IdentifierStart
          IdentifierName IdentifierPart
      </emu-grammar>
      <emu-alg>
        1. _idTextUnescaped_ を |IdentifierName| の IdentifierCodePoints とする。
        1. CodePointsToString(_idTextUnescaped_) を返す。
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <emu-alg>
        1. *"yield"* を返す。
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <emu-alg>
        1. *"await"* を返す。
      </emu-alg>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <emu-alg>
        1. |IdentifierName| の StringValue を返す。
      </emu-alg>
      <emu-grammar>
        PrivateIdentifier ::
          `#` IdentifierName
      </emu-grammar>
      <emu-alg>
        1. 0x0023 (NUMBER SIGN) と |IdentifierName| の StringValue の文字列連結を返す。
      </emu-alg>
      <emu-grammar>
        ModuleExportName : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. |StringLiteral| の SV を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-identifiers-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(StringValue of |Identifier|) を返す。
      </emu-alg>
      <emu-grammar>IdentifierReference : `yield`</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(*"yield"*) を返す。
      </emu-alg>
      <emu-grammar>IdentifierReference : `await`</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(*"await"*) を返す。
      </emu-alg>
      <emu-note>
        <p>|IdentifierReference| の評価結果は常に Reference 型の値である。</p>
      </emu-note>
      <emu-note>
        <p>非 strict コードではキーワード `yield` を識別子として使用できる。|IdentifierReference| の評価は `yield` の束縛を |Identifier| であるかのように解決する。Early Error によりこの評価は非 strict コードでのみ発生し得ることが保証される。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-primary-expression">
    <h1>一次式 (Primary Expression)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      PrimaryExpression[Yield, Await] :
        `this`
        IdentifierReference[?Yield, ?Await]
        Literal
        ArrayLiteral[?Yield, ?Await]
        ObjectLiteral[?Yield, ?Await]
        FunctionExpression
        ClassExpression[?Yield, ?Await]
        GeneratorExpression
        AsyncFunctionExpression
        AsyncGeneratorExpression
        RegularExpressionLiteral
        TemplateLiteral[?Yield, ?Await, ~Tagged]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `)`
        `(` `)`
        `(` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` `...` BindingPattern[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`
    </emu-grammar>
    <h2>補助構文 (Supplemental Syntax)</h2>
    <p>
      次の生成規則インスタンスを処理する際<br>
      <emu-grammar>PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      |CoverParenthesizedExpressionAndArrowParameterList| の解釈は次の文法で精緻化される:
    </p>
    <emu-grammar type="definition">
      ParenthesizedExpression[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-this-keyword">
      <h1>`this` キーワード</h1>

      <emu-clause id="sec-this-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>PrimaryExpression : `this`</emu-grammar>
        <emu-alg>
          1. ? ResolveThisBinding() を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-identifier-reference">
      <h1>識別子参照 (Identifier Reference)</h1>
      <p>|IdentifierReference| については <emu-xref href="#sec-identifiers"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-literals">
      <h1>リテラル (Literals)</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        Literal :
          NullLiteral
          BooleanLiteral
          NumericLiteral
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-literals-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>Literal : NullLiteral</emu-grammar>
        <emu-alg>
          1. *null* を返す。
        </emu-alg>
        <emu-grammar>Literal : BooleanLiteral</emu-grammar>
        <emu-alg>
          1. |BooleanLiteral| がトークン `false` なら *false* を返す。
          1. |BooleanLiteral| がトークン `true` なら *true* を返す。
        </emu-alg>
        <emu-grammar>Literal : NumericLiteral</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-literals-numeric-literals"></emu-xref> で定義される |NumericLiteral| の NumericValue を返す。
        </emu-alg>
        <emu-grammar>Literal : StringLiteral</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-static-semantics-sv"></emu-xref> で定義される |StringLiteral| の SV を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-initializer">
      <h1>配列初期化子 (Array Initializer)</h1>
      <emu-note>
        <p>|ArrayLiteral| は 0 個以上の式（各々が要素を表す）のリストを角括弧で囲んで配列の初期化を記述する式である。要素はリテラルである必要はなく、配列初期化子の評価ごとに評価される。</p>
      </emu-note>
      <p>配列要素は先頭・中間・末尾で省略（elide）できる。要素リスト中のカンマが直前に |AssignmentExpression| を伴わないとき（先頭、または別のカンマの後）、欠落した要素は配列の length に寄与し、後続要素のインデックスを増やす。省略された配列要素は定義されない。末尾で要素が省略された場合、その要素は length に寄与しない。</p>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        ArrayLiteral[Yield, Await] :
          `[` Elision? `]`
          `[` ElementList[?Yield, ?Await] `]`
          `[` ElementList[?Yield, ?Await] `,` Elision? `]`

        ElementList[Yield, Await] :
          Elision? AssignmentExpression[+In, ?Yield, ?Await]
          Elision? SpreadElement[?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]

        Elision :
          `,`
          Elision `,`

        SpreadElement[Yield, Await] :
          `...` AssignmentExpression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-arrayaccumulation" oldids="sec-static-semantics-elisionwidth" type="sdo">
        <h1>
          実行時セマンティクス: ArrayAccumulation (
          _array_: Array,
          _nextIndex_: integer,
          ): 正常完了で整数を含むか、または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. _len_ を _nextIndex_ + 1 とする。
          1. ? Set(_array_, *"length"*, 𝔽(_len_), *true*) を実行する。
          1. 注: 上の手順は _len_ が 2<sup>32</sup>-1 を超えると投げる。
          1. _len_ を返す。
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. 引数 _array_, (_nextIndex_ + 1) で |Elision| の ArrayAccumulation を実行した結果を返す。
        </emu-alg>
        <emu-grammar>ElementList : Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. |Elision| が存在するなら
            1. _nextIndex_ を 引数 _array_, _nextIndex_ で |Elision| の ArrayAccumulation を実行した結果に設定。
          1. _initResult_ を |AssignmentExpression| の Evaluation。
          1. _initValue_ を ? GetValue(_initResult_)。
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_) を実行。
          1. _nextIndex_ + 1 を返す。
        </emu-alg>
        <emu-grammar>ElementList : Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. |Elision| が存在するなら
            1. _nextIndex_ を 引数 _array_, _nextIndex_ で |Elision| の ArrayAccumulation を実行した結果に設定。
          1. 引数 _array_, _nextIndex_ で |SpreadElement| の ArrayAccumulation を実行した結果を返す。
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _nextIndex_ を 引数 _array_, _nextIndex_ で |ElementList| の ArrayAccumulation を実行した結果に設定。
          1. |Elision| が存在するなら
            1. _nextIndex_ を 引数 _array_, _nextIndex_ で |Elision| の ArrayAccumulation を実行した結果に設定。
          1. _initResult_ を |AssignmentExpression| の Evaluation。
          1. _initValue_ を ? GetValue(_initResult_)。
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_) を実行。
          1. _nextIndex_ + 1 を返す。
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. _nextIndex_ を 引数 _array_, _nextIndex_ で |ElementList| の ArrayAccumulation を実行した結果に設定。
          1. |Elision| が存在するなら
            1. _nextIndex_ を 引数 _array_, _nextIndex_ で |Elision| の ArrayAccumulation を実行した結果に設定。
          1. 引数 _array_, _nextIndex_ で |SpreadElement| の ArrayAccumulation を実行した結果を返す。
        </emu-alg>
        <emu-grammar>SpreadElement : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _spreadRef_ を |AssignmentExpression| の Evaluation。
          1. _spreadObj_ を ? GetValue(_spreadRef_)。
          1. _iteratorRecord_ を ? GetIterator(_spreadObj_, ~sync~)。
          1. 反復:
            1. _next_ を ? IteratorStepValue(_iteratorRecord_)。
            1. _next_ が ~done~ なら _nextIndex_ を返す。
            1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_) を実行。
            1. _nextIndex_ を _nextIndex_ + 1 に設定。
        </emu-alg>
        <emu-note>
          <p>標準組込み Array prototype が [[Set]] による新たな自身プロパティ生成を妨げるよう改変されていても、自身プロパティ確立を保証するため CreateDataPropertyOrThrow が使用される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ArrayLiteral : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. _array_ を ! ArrayCreate(0) とする。
          1. |Elision| が存在するなら
            1. 引数 _array_, 0 で |Elision| の ArrayAccumulation を実行。
          1. _array_ を返す。
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `]`</emu-grammar>
        <emu-alg>
          1. _array_ を ! ArrayCreate(0)。
          1. 引数 _array_, 0 で |ElementList| の ArrayAccumulation を実行。
          1. _array_ を返す。
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. _array_ を ! ArrayCreate(0)。
          1. _nextIndex_ を 引数 _array_, 0 で |ElementList| の ArrayAccumulation を実行した結果とする。
          1. |Elision| が存在するなら
            1. 引数 _array_, _nextIndex_ で |Elision| の ArrayAccumulation を実行。
          1. _array_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-initializer">
      <h1>オブジェクト初期化子 (Object Initializer)</h1>
      <emu-note>
        <p>オブジェクト初期化子はオブジェクトの初期化をリテラル風の書式で表す式であり、波括弧で囲まれた 0 個以上のプロパティキーと対応値の組のリストである。値はリテラルである必要はなく、オブジェクト初期化子の評価ごとに評価される。</p>
      </emu-note>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        ObjectLiteral[Yield, Await] :
          `{` `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`

        PropertyDefinitionList[Yield, Await] :
          PropertyDefinition[?Yield, ?Await]
          PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]

        PropertyDefinition[Yield, Await] :
          IdentifierReference[?Yield, ?Await]
          CoverInitializedName[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
          MethodDefinition[?Yield, ?Await]
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        PropertyName[Yield, Await] :
          LiteralPropertyName
          ComputedPropertyName[?Yield, ?Await]

        LiteralPropertyName :
          IdentifierName
          StringLiteral
          NumericLiteral

        ComputedPropertyName[Yield, Await] :
          `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

        CoverInitializedName[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

        Initializer[In, Yield, Await] :
          `=` AssignmentExpression[?In, ?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>|MethodDefinition| は <emu-xref href="#sec-method-definitions"></emu-xref> で定義される。</p>
      </emu-note>
      <emu-note>
        <p>特定の文脈では |ObjectLiteral| はより制限された二次文法を覆うカバー文法として使われる。|CoverInitializedName| 生成規則はこれら二次文法を完全に覆うために必要である。しかし通常の実際の |ObjectLiteral| が期待される場面でこの生成規則が使用されると Early Syntax Error になる。</p>
      </emu-note>

      <emu-clause id="sec-object-initializer-static-semantics-early-errors" oldids="sec-__proto__-property-names-in-object-initializers">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <ul>
          <li>
            HasDirectSuper(|MethodDefinition|) が *true* なら構文エラー。
          </li>
          <li>
            |MethodDefinition| の PrivateBoundIdentifiers が空でなければ構文エラー。
          </li>
        </ul>
        <p>|ObjectLiteral| 生成規則は実際のオブジェクト初期化子を記述するだけでなく |ObjectAssignmentPattern| を覆うカバー文法として、また |CoverParenthesizedExpressionAndArrowParameterList| の一部として認識され得る。|ObjectAssignmentPattern| が要求される文脈で |ObjectLiteral| が現れるとき、以下の Early Error 規則は適用<b>されない</b>。さらに、|CoverParenthesizedExpressionAndArrowParameterList| や |CoverCallExpressionAndAsyncArrowHead| の初期パース時にも適用されない。</p>
        <emu-grammar>PropertyDefinition : CoverInitializedName</emu-grammar>
        <ul>
          <li>
            この生成規則にマッチするソーステキストが存在するなら構文エラー。
          </li>
        </ul>
        <emu-note>
          <p>この生成規則は |ObjectLiteral| を |ObjectAssignmentPattern| のカバー文法として機能させるために存在し、実際のオブジェクト初期化子には現れない。</p>
        </emu-note>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <ul>
          <li>
            |PropertyDefinitionList| の PropertyNameList が *"__proto__"* の重複エントリを含み、そのうち少なくとも 2 つが <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar> 形式から得られているなら構文エラー。この規則は、この |ObjectLiteral| が ParseJSON のためにパースされている |Script| 内に含まれている場合（ParseJSON の step <emu-xref href="#step-json-parse-parse"></emu-xref> 参照）には適用されない。
          </li>
        </ul>
        <emu-note>
          <p>PropertyNameList が返すリストには |ComputedPropertyName| を用いて定義された名前は含まれない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-iscomputedpropertykey" type="sdo">
        <h1>静的セマンティクス: IsComputedPropertyKey ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyName : LiteralPropertyName</emu-grammar>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
        <emu-alg>
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-propertynamelist" type="sdo">
        <h1>静的セマンティクス: PropertyNameList ( ): String の List</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinition</emu-grammar>
        <emu-alg>
          1. _propName_ を |PropertyDefinition| の PropName とする。
          1. _propName_ が ~empty~ なら新しい空 List を返す。
          1. « _propName_ » を返す。
        </emu-alg>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. _list_ を |PropertyDefinitionList| の PropertyNameList。
          1. _propName_ を |PropertyDefinition| の PropName。
          1. _propName_ が ~empty~ なら _list_ を返す。
          1. _list_ と « _propName_ » のリスト結合を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ObjectLiteral : `{` `}`</emu-grammar>
        <emu-alg>
          1. OrdinaryObjectCreate(%Object.prototype%) を返す。
        </emu-alg>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. _obj_ を OrdinaryObjectCreate(%Object.prototype%)。
          1. 引数 _obj_ で |PropertyDefinitionList| の PropertyDefinitionEvaluation を実行。
          1. _obj_ を返す。
        </emu-alg>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. |IdentifierName| の StringValue を返す。
        </emu-alg>
        <emu-grammar>LiteralPropertyName : StringLiteral</emu-grammar>
        <emu-alg>
          1. |StringLiteral| の SV を返す。
        </emu-alg>
        <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
        <emu-alg>
          1. _nbr_ を |NumericLiteral| の NumericValue。
          1. ! ToString(_nbr_) を返す。
        </emu-alg>
        <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
        <emu-alg>
          1. _exprValue_ を |AssignmentExpression| の Evaluation。
          1. _propName_ を ? GetValue(_exprValue_)。
          1. ? ToPropertyKey(_propName_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydefinitionevaluation" oldids="sec-object-initializer-runtime-semantics-propertydefinitionevaluation" type="sdo">
        <h1>
          実行時セマンティクス: PropertyDefinitionEvaluation (
          _object_: Object,
          ): 正常完了で ~unused~ を含むか、または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. 引数 _object_ で |PropertyDefinitionList| の PropertyDefinitionEvaluation を実行。
          1. 引数 _object_ で |PropertyDefinition| の PropertyDefinitionEvaluation を実行。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _exprValue_ を |AssignmentExpression| の Evaluation。
          1. _fromValue_ を ? GetValue(_exprValue_)。
          1. _excludedNames_ を新しい空 List。
          1. ? CopyDataProperties(_object_, _fromValue_, _excludedNames_) を実行。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. _propName_ を |IdentifierReference| の StringValue。
          1. _exprValue_ を |IdentifierReference| の Evaluation。
          1. _propValue_ を ? GetValue(_exprValue_)。
          1. 事前条件: _object_ は通常 (ordinary) で拡張可能で非 configurable プロパティを持たない。
          1. ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_) を実行。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _propKey_ を |PropertyName| の Evaluation。
          1. この |PropertyDefinition| が ParseJSON のため評価中の |Script| 内に含まれるなら（ParseJSON の step <emu-xref href="#step-json-parse-eval"></emu-xref> 参照）
            1. _isProtoSetter_ を *false*。
          1. それ以外で _propKey_ が *"__proto__"* かつ |PropertyName| の IsComputedPropertyKey が *false* なら
            1. _isProtoSetter_ を *true*。
          1. それ以外
            1. _isProtoSetter_ を *false*。
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) が *true* かつ _isProtoSetter_ が *false* なら
            1. _propValue_ を 引数 _propKey_ で |AssignmentExpression| の NamedEvaluation。
          1. それ以外
            1. _exprValueRef_ を |AssignmentExpression| の Evaluation。
            1. _propValue_ を ? GetValue(_exprValueRef_)。
          1. _isProtoSetter_ が *true* なら
            1. _propValue_ が Object か *null* なら
              1. ! <emu-meta effects="user-code">_object_.[[SetPrototypeOf]]</emu-meta>(_propValue_) を実行。
            1. ~unused~ を返す。
          1. 事前条件: _object_ は通常で拡張可能、非 configurable プロパティなし。
          1. ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_) を実行。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <emu-alg>
          1. 引数 _object_, *true* で |MethodDefinition| の MethodDefinitionEvaluation を実行。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-defining-expressions">
      <h1>関数定義式 (Function Defining Expressions)</h1>
      <p><emu-xref href="#sec-function-definitions"></emu-xref> の <emu-grammar>PrimaryExpression : FunctionExpression</emu-grammar> を参照。</p>
      <p><emu-xref href="#sec-generator-function-definitions"></emu-xref> の <emu-grammar>PrimaryExpression : GeneratorExpression</emu-grammar> を参照。</p>
      <p><emu-xref href="#sec-class-definitions"></emu-xref> の <emu-grammar>PrimaryExpression : ClassExpression</emu-grammar> を参照。</p>
      <p><emu-xref href="#sec-async-function-definitions"></emu-xref> の <emu-grammar>PrimaryExpression : AsyncFunctionExpression</emu-grammar> を参照。</p>
      <p><emu-xref href="#sec-async-generator-function-definitions"></emu-xref> の <emu-grammar>PrimaryExpression : AsyncGeneratorExpression</emu-grammar> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-regular-expression-literals">
      <h1>正規表現リテラル (Regular Expression Literals)</h1>
      <h2>構文 (Syntax)</h2>
      <p><emu-xref href="#sec-literals-regular-expression-literals"></emu-xref> を参照。</p>

      <emu-clause id="sec-primary-expression-regular-expression-literals-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <ul>
          <li>
            IsValidRegularExpressionLiteral(|RegularExpressionLiteral|) が *false* なら構文エラー。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-isvalidregularexpressionliteral" type="abstract operation">
        <h1>
          静的セマンティクス: IsValidRegularExpressionLiteral (
          _literal_: |RegularExpressionLiteral| Parse Node,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>説明</dt>
          <dd>引数が有効な正規表現リテラルか判定する。</dd>
        </dl>
        <emu-alg>
          1. _flags_ を _literal_ の FlagText とする。
          1. _flags_ に `d`, `g`, `i`, `m`, `s`, `u`, `v`, `y` 以外のコードポイントが含まれるか、同一コードポイントが複数回含まれるなら *false* を返す。
          1. _flags_ が `u` を含むなら _u_ = *true*、そうでなければ *false*。
          1. _flags_ が `v` を含むなら _v_ = *true*、そうでなければ *false*。
          1. _patternText_ を _literal_ の BodyText とする。
          1. _u_ が *false* かつ _v_ が *false* なら
            1. _stringValue_ を CodePointsToString(_patternText_)。
            1. _patternText_ を _stringValue_ の 16-bit 要素を Unicode BMP コードポイントとして逐次解釈した結果のコードポイント列に設定（UTF-16 デコードは行わない）。
          1. _parseResult_ を ParsePattern(_patternText_, _u_, _v_)。
          1. _parseResult_ が Parse Node なら *true*、そうでなければ *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regular-expression-literals-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <emu-alg>
          1. _pattern_ を CodePointsToString(BodyText of |RegularExpressionLiteral|)。
          1. _flags_ を CodePointsToString(FlagText of |RegularExpressionLiteral|)。
          1. ! RegExpCreate(_pattern_, _flags_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literals">
      <h1>テンプレートリテラル (Template Literals)</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        TemplateLiteral[Yield, Await, Tagged] :
          NoSubstitutionTemplate
          SubstitutionTemplate[?Yield, ?Await, ?Tagged]

        SubstitutionTemplate[Yield, Await, Tagged] :
          TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

        TemplateSpans[Yield, Await, Tagged] :
          TemplateTail
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

        TemplateMiddleList[Yield, Await, Tagged] :
          TemplateMiddle Expression[+In, ?Yield, ?Await]
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-static-semantics-template-early-errors" oldids="sec-primary-expression-template-literals-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> パラメータが設定されておらず、|NoSubstitutionTemplate| が |NotEscapeSequence| を含むなら構文エラー。
          </li>
        </ul>

        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            引数 *false* での |TemplateLiteral| の TemplateStrings の要素数が 2<sup>32</sup> 以上なら構文エラー。
          </li>
        </ul>

        <emu-grammar>
          SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> パラメータが設定されておらず、|TemplateHead| が |NotEscapeSequence| を含むなら構文エラー。
          </li>
        </ul>

        <emu-grammar>
          TemplateSpans[Yield, Await, Tagged] : TemplateTail
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> パラメータが設定されておらず、|TemplateTail| が |NotEscapeSequence| を含むなら構文エラー。
          </li>
        </ul>

        <emu-grammar>
          TemplateMiddleList[Yield, Await, Tagged] :
            TemplateMiddle Expression[+In, ?Yield, ?Await]
            TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> パラメータが設定されておらず、|TemplateMiddle| が |NotEscapeSequence| を含むなら構文エラー。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-templatestrings" type="sdo">
        <h1>
          静的セマンティクス: TemplateStrings (
          _raw_: Boolean,
          ): String または *undefined* を含む List
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. « TemplateString(|NoSubstitutionTemplate|, _raw_) » を返す。
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _head_ を « TemplateString(|TemplateHead|, _raw_) »。
          1. _tail_ を 引数 _raw_ で |TemplateSpans| の TemplateStrings。
          1. _head_ と _tail_ のリスト結合を返す。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. « TemplateString(|TemplateTail|, _raw_) » を返す。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. _middle_ を 引数 _raw_ で |TemplateMiddleList| の TemplateStrings。
          1. _tail_ を « TemplateString(|TemplateTail|, _raw_) »。
          1. _middle_ と _tail_ のリスト結合を返す。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. « TemplateString(|TemplateMiddle|, _raw_) » を返す。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _front_ を 引数 _raw_ で |TemplateMiddleList| の TemplateStrings。
          1. _last_ を « TemplateString(|TemplateMiddle|, _raw_) »。
          1. _front_ と _last_ のリスト結合を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-templatestring" type="abstract operation">
        <h1>
          静的セマンティクス: TemplateString (
          _templateToken_: |NoSubstitutionTemplate| / |TemplateHead| / |TemplateMiddle| / |TemplateTail| Parse Node,
          _raw_: Boolean,
          ): String または *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _raw_ が *true* なら
            1. _string_ を _templateToken_ の TRV。
          1. それ以外
            1. _string_ を _templateToken_ の TV。
          1. _string_ を返す。
        </emu-alg>
        <emu-note>
          <p>_raw_ が *false* かつ _templateToken_ が |NotEscapeSequence| を含む場合、この操作は *undefined* を返す。それ以外は String を返す。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-gettemplateobject" type="abstract operation">
        <h1>
          GetTemplateObject (
            _templateLiteral_: Parse Node,
          ): Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _realm_ を現在の Realm Record。
          1. _templateRegistry_ を _realm_.[[TemplateMap]]。
          1. _templateRegistry_ の各要素 _e_ について
            1. _e_.[[Site]] が _templateLiteral_ と同じ Parse Node なら
              1. _e_.[[Array]] を返す。
          1. _rawStrings_ を 引数 *true* で _templateLiteral_ の TemplateStrings。
          1. 事前条件: _rawStrings_ は String の List。
          1. _cookedStrings_ を 引数 *false* で _templateLiteral_ の TemplateStrings。
          1. _count_ を _cookedStrings_ の要素数。
          1. 事前条件: _count_ ≤ 2<sup>32</sup>-1。
          1. _template_ を ! ArrayCreate(_count_)。
          1. _rawObj_ を ! ArrayCreate(_count_)。
          1. _index_ を 0。
          1. _index_ &lt; _count_ の間繰り返す:
            1. _prop_ を ! ToString(𝔽(_index_))。
            1. _cookedValue_ を _cookedStrings_[_index_]。
            1. ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* })。
            1. _rawValue_ を String 値 _rawStrings_[_index_]。
            1. ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* })。
            1. _index_ を _index_ + 1。
          1. ! SetIntegrityLevel(_rawObj_, ~frozen~)。
          1. ! DefinePropertyOrThrow(_template_, *"raw"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. ! SetIntegrityLevel(_template_, ~frozen~)。
          1. Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } を _realm_.[[TemplateMap]] に追加。
          1. _template_ を返す。
        </emu-alg>
        <emu-note>
          <p>テンプレートオブジェクトの生成は突然の完了を引き起こさない。</p>
        </emu-note>
        <emu-note>
          <p>ある realm のプログラムコード内の各 |TemplateLiteral| はタグ付きテンプレート評価 (<emu-xref href="#sec-template-literals-runtime-semantics-evaluation"></emu-xref>) に用いられる一意のテンプレートオブジェクトと関連付けられる。テンプレートオブジェクトは凍結され、同一タグ付きテンプレート評価では同じオブジェクトが再利用される。テンプレートオブジェクトが最初の評価時に遅延生成されるか、事前に eager に生成されるかは ECMAScript コードからは観測不能で実装依存。</p>
        </emu-note>
        <emu-note>
          <p>将来の版ではテンプレートオブジェクトに追加の列挙不可プロパティを定義する可能性がある。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-substitutionevaluation" type="sdo">
        <h1>実行時セマンティクス: SubstitutionEvaluation ( )</h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. 新しい空 List を返す。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. |TemplateMiddleList| の SubstitutionEvaluation を返す。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _subRef_ を |Expression| の Evaluation。
          1. _sub_ を ? GetValue(_subRef_)。
          1. « _sub_ » を返す。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _preceding_ を |TemplateMiddleList| の SubstitutionEvaluation。
          1. _nextRef_ を |Expression| の Evaluation。
          1. _next_ を ? GetValue(_nextRef_)。
          1. _preceding_ と « _next_ » のリスト結合を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-template-literals-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> で定義される |NoSubstitutionTemplate| の TV を返す。
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _head_ を <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> で定義される |TemplateHead| の TV。
          1. _subRef_ を |Expression| の Evaluation。
          1. _sub_ を ? GetValue(_subRef_)。
          1. _middle_ を ? ToString(_sub_)。
          1. _tail_ を |TemplateSpans| の Evaluation。
          1. _head_, _middle_, _tail_ の文字列連結を返す。
        </emu-alg>
        <emu-note>
          <p>|Expression| 値への文字列変換は `+` 演算子ではなく `String.prototype.concat` と同様のセマンティクス。</p>
        </emu-note>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> で定義される |TemplateTail| の TV を返す。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. _head_ を |TemplateMiddleList| の Evaluation。
          1. _tail_ を <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> で定義される |TemplateTail| の TV。
          1. _head_ と _tail_ の文字列連結を返す。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _head_ を <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> で定義される |TemplateMiddle| の TV。
          1. _subRef_ を |Expression| の Evaluation。
          1. _sub_ を ? GetValue(_subRef_)。
            1. _middle_ を ? ToString(_sub_)。
          1. _head_ と _middle_ の文字列連結を返す。
        </emu-alg>
        <emu-note>
          <p>|Expression| 値への文字列変換は `+` 演算子ではなく `String.prototype.concat` と同様。</p>
        </emu-note>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _rest_ を |TemplateMiddleList| の Evaluation。
          1. _middle_ を <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> で定義される |TemplateMiddle| の TV。
          1. _subRef_ を |Expression| の Evaluation。
          1. _sub_ を ? GetValue(_subRef_)。
          1. _last_ を ? ToString(_sub_)。
          1. _rest_, _middle_, _last_ の文字列連結を返す。
        </emu-alg>
        <emu-note>
          <p>|Expression| 値への文字列変換は `String.prototype.concat` と同様で `+` 演算子とは異なる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-grouping-operator">
      <h1>グルーピング演算子 (The Grouping Operator)</h1>

      <emu-clause id="sec-grouping-operator-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <ul>
          <li>
            |CoverParenthesizedExpressionAndArrowParameterList| は |ParenthesizedExpression| を覆わなければならない。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. _expr_ を |CoverParenthesizedExpressionAndArrowParameterList| により覆われる |ParenthesizedExpression| とする。
          1. _expr_ の Evaluation を返す (必要なら ? を付す)。
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. |Expression| の Evaluation を返す（Reference 型であり得る）。
        </emu-alg>
        <emu-note>
          <p>このアルゴリズムは |Expression| の Evaluation に GetValue を適用しない。主な動機は `delete` や `typeof` などの演算子をかっこ付き式に適用可能とするためである。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>左辺式 (Left-Hand-Side Expressions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget
        ImportMeta

      NewTarget :
        `new` `.` `target`

      ImportMeta :
        `import` `.` `meta`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]

      OptionalExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

      OptionalChain[Yield, Await] :
        `?.` Arguments[?Yield, ?Await]
        `?.` `[` Expression[+In, ?Yield, ?Await] `]`
        `?.` IdentifierName
        `?.` TemplateLiteral[?Yield, ?Await, +Tagged]
        `?.` PrivateIdentifier
        OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
        OptionalChain[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        OptionalChain[?Yield, ?Await] `.` IdentifierName
        OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        OptionalChain[?Yield, ?Await] `.` PrivateIdentifier

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await]
    </emu-grammar>
    <h2>補助構文 (Supplemental Syntax)</h2>
    <p>
      次の生成規則インスタンスを処理する際<br>
      <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar><br>
      |CoverCallExpressionAndAsyncArrowHead| の解釈は以下の文法で精緻化される:
    </p>
    <emu-grammar type="definition">
      CallMemberExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics">
      <h1>静的セマンティクス (Static Semantics)</h1>

      <emu-clause id="sec-left-hand-side-expressions-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー (Early Errors)</h1>
        <emu-grammar>
          OptionalChain :
            `?.` TemplateLiteral
            OptionalChain TemplateLiteral
        </emu-grammar>
        <ul>
          <li>
            この生成規則にソーステキストがマッチした場合は構文エラー。
          </li>
        </ul>
        <emu-note>
          <p>この生成規則は次のコードに自動セミコロン挿入規則（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）が適用されて 2 つの有効な文として解釈されることを防ぐために存在する:</p>
          <pre><code class="javascript">
            a?.b
            `c`
          </code></pre>
          <p>これはオプショナルチェイニングを用いない類似コードとの一貫性を保つ目的である:</p>
          <pre><code class="javascript">
            a.b
            `c`
          </code></pre>
          <p>後者は自動セミコロン挿入が適用されず有効な文である。</p>
        </emu-note>

        <emu-grammar>
          ImportMeta :
            `import` `.` `meta`
        </emu-grammar>
        <ul>
          <li>
            構文ゴール記号が |Module| でない場合は構文エラー。
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-accessors">
      <h1>プロパティアクセッサ (Property Accessors)</h1>
      <emu-note>
        <p>プロパティは名前でアクセスされ、ドット記法:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|<br>
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>またはブラケット記法を用いる:</p>
        <div class="rhs">
          |MemberExpression| `[` |Expression| `]`<br>
          |CallExpression| `[` |Expression| `]`
        </div>
        <p>ドット記法は次の構文変換で説明される:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
        </div>
        <p>これは動作上次と同一である:</p>
        <div class="rhs">
          |MemberExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>同様に</p>
        <div class="rhs">
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>は次と同一である:</p>
        <div class="rhs">
          |CallExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>ここで &lt;<i>identifier-name-string</i>> は |IdentifierName| の StringValue である。</p>
      </emu-note>

      <emu-clause id="sec-property-accessors-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |MemberExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _strict_ を IsStrict(this |MemberExpression|) とする。
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |MemberExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _strict_ を IsStrict(this |MemberExpression|)。
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |MemberExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _fieldNameString_ を |PrivateIdentifier| の StringValue とする。
          1. MakePrivateReference(_baseValue_, _fieldNameString_) を返す。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |CallExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _strict_ を IsStrict(this |CallExpression|)。
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |CallExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _strict_ を IsStrict(this |CallExpression|)。
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |CallExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _fieldNameString_ を |PrivateIdentifier| の StringValue。
          1. MakePrivateReference(_baseValue_, _fieldNameString_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-expression-key" type="abstract operation" oldids="sec-evaluate-expression-key-property-access">
      <h1>
        EvaluatePropertyAccessWithExpressionKey (
          _baseValue_: ECMAScript 言語値,
          _expression_: |Expression| Parse Node,
          _strict_: Boolean,
        ): 正常完了で Reference Record を含むか、または突然の完了
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _propertyNameReference_ を ? _expression_ の Evaluation。
        1. _propertyNameValue_ を ? GetValue(_propertyNameReference_)。
        1. 注: 多くの場合この直後に ToPropertyKey が _propertyNameValue_ に対して行われるが、`a[b] = c` の場合は `c` の評価後まで行われない。
        1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameValue_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-identifier-key" type="abstract operation" oldids="sec-evaluate-identifier-key-property-access">
      <h1>
        EvaluatePropertyAccessWithIdentifierKey (
          _baseValue_: ECMAScript 言語値,
          _identifierName_: |IdentifierName| Parse Node,
          _strict_: Boolean,
        ): Reference Record
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _propertyNameString_ を _identifierName_ の StringValue。
        1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-new-operator">
      <h1>`new` 演算子 (The `new` Operator)</h1>

      <emu-clause id="sec-new-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>NewExpression : `new` NewExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateNew(|NewExpression|, ~empty~) を返す。
        </emu-alg>
        <emu-grammar>MemberExpression : `new` MemberExpression Arguments</emu-grammar>
        <emu-alg>
          1. ? EvaluateNew(|MemberExpression|, |Arguments|) を返す。
        </emu-alg>

        <emu-clause id="sec-evaluatenew" type="abstract operation">
          <h1>
            EvaluateNew (
              _constructExpr_: |NewExpression| Parse Node または |MemberExpression| Parse Node,
              _arguments_: ~empty~ 又は |Arguments| Parse Node,
            ): 正常完了で ECMAScript 言語値を含むか、または突然の完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _ref_ を ? _constructExpr_ の Evaluation。
            1. _constructor_ を ? GetValue(_ref_)。
            1. _arguments_ が ~empty~ なら
              1. _argList_ を新しい空 List。
            1. それ以外
              1. _argList_ を ? ArgumentListEvaluation(_arguments_)。
            1. IsConstructor(_constructor_) が *false* なら *TypeError* 例外を投げる。
            1. ? Construct(_constructor_, _argList_) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-calls">
      <h1>関数呼び出し (Function Calls)</h1>

      <emu-clause id="sec-function-calls-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>
        <emu-alg>
          1. _expr_ を |CoverCallExpressionAndAsyncArrowHead| により覆われる |CallMemberExpression| とする。
          1. _memberExpr_ を _expr_ の |MemberExpression|。
          1. _arguments_ を _expr_ の |Arguments|。
          1. _ref_ を ? _memberExpr_ の Evaluation。
          1. _func_ を ? GetValue(_ref_)。
          1. もし _ref_ が Reference Record で IsPropertyReference(_ref_) が *false* かつ _ref_.[[ReferencedName]] が *"eval"* なら
            1. SameValue(_func_, %eval%) が *true* なら
              1. _argList_ を ? ArgumentListEvaluation(_arguments_)。
              1. _argList_ が要素を持たないなら *undefined* を返す。
              1. _evalArg_ を _argList_ の最初の要素。
              1. IsStrict(this |CallExpression|) が *true* なら _strictCaller_ = *true*、そうでなければ *false*。
              1. [id="step-callexpression-evaluation-direct-eval"] ? PerformEval(_evalArg_, _strictCaller_, *true*) を返す。
          1. _thisCall_ を this |CallExpression|。
          1. _tailCall_ を IsInTailPosition(_thisCall_)。
          1. ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_) を返す。
        </emu-alg>
        <p>ステップ <emu-xref href="#step-callexpression-evaluation-direct-eval"></emu-xref> を実行する |CallExpression| の評価は <dfn variants="direct evals">direct eval</dfn> である。</p>
        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>
        <emu-alg>
          1. _ref_ を ? |CallExpression| の Evaluation。
          1. _func_ を ? GetValue(_ref_)。
          1. _thisCall_ を this |CallExpression|。
          1. _tailCall_ を IsInTailPosition(_thisCall_)。
          1. ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluatecall" type="abstract operation" oldids="sec-evaluatedirectcall">
        <h1>
          EvaluateCall (
            _func_: ECMAScript 言語値,
            _ref_: ECMAScript 言語値または Reference Record,
            _arguments_: Parse Node,
            _tailPosition_: Boolean,
          ): 正常完了で ECMAScript 言語値を含むか、または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. もし _ref_ が Reference Record なら
            1. IsPropertyReference(_ref_) が *true* なら
              1. _thisValue_ を GetThisValue(_ref_)。
            1. それ以外
              1. _refEnv_ を _ref_.[[Base]]。
              1. 事前条件: _refEnv_ は Environment Record。
              1. _thisValue_ を _refEnv_.WithBaseObject()。
          1. それ以外
            1. _thisValue_ を *undefined*。
          1. _argList_ を ? ArgumentListEvaluation(_arguments_)。
          1. _func_ が Object でなければ *TypeError* 例外。
          1. IsCallable(_func_) が *false* なら *TypeError* 例外。
          1. _tailPosition_ が *true* なら PrepareForTailCall() を実行。
          1. ? Call(_func_, _thisValue_, _argList_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-super-keyword">
      <h1>`super` キーワード (The `super` Keyword)</h1>

      <emu-clause id="sec-super-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>SuperProperty : `super` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _env_ を GetThisEnvironment()。
          1. _actualThis_ を ? _env_.GetThisBinding()。
          1. _propertyNameReference_ を ? |Expression| の Evaluation。
          1. _propertyNameValue_ を ? GetValue(_propertyNameReference_)。
          1. _strict_ を IsStrict(this |SuperProperty|)。
          1. 注: 多くの場合ここですぐ ToPropertyKey が行われるが、`super[b] = c` のケースでは `c` 評価後。
          1. MakeSuperPropertyReference(_actualThis_, _propertyNameValue_, _strict_) を返す。
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _env_ を GetThisEnvironment()。
          1. _actualThis_ を ? _env_.GetThisBinding()。
          1. _propertyKey_ を |IdentifierName| の StringValue。
          1. _strict_ を IsStrict(this |SuperProperty|)。
          1. MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_) を返す。
        </emu-alg>
        <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
        <emu-alg>
          1. _newTarget_ を GetNewTarget()。
          1. 事前条件: _newTarget_ は constructor。
          1. _func_ を GetSuperConstructor()。
          1. _argList_ を ? ArgumentListEvaluation(|Arguments|)。
          1. IsConstructor(_func_) が *false* なら *TypeError* 例外。
          1. _result_ を ? Construct(_func_, _argList_, _newTarget_)。
          1. _thisER_ を GetThisEnvironment()。
          1. 事前条件: _thisER_ は Function Environment Record。
          1. ? BindThisValue(_thisER_, _result_)。
          1. _F_ を _thisER_.[[FunctionObject]]。
          1. 事前条件: _F_ は ECMAScript function object。
          1. ? InitializeInstanceElements(_result_, _F_)。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getsuperconstructor" type="abstract operation">
        <h1>GetSuperConstructor ( ): ECMAScript 言語値</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _envRec_ を GetThisEnvironment()。
          1. 事前条件: _envRec_ は Function Environment Record。
          1. _activeFunction_ を _envRec_.[[FunctionObject]]。
          1. 事前条件: _activeFunction_ は ECMAScript function object。
          1. _superConstructor_ を ! _activeFunction_.[[GetPrototypeOf]]()。
          1. _superConstructor_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makesuperpropertyreference" type="abstract operation">
        <h1>
          MakeSuperPropertyReference (
            _actualThis_: ECMAScript 言語値,
            _propertyKey_: ECMAScript 言語値,
            _strict_: Boolean,
          ): Super Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _env_ を GetThisEnvironment()。
          1. 事前条件: _env_.HasSuperBinding() は *true*。
          1. 事前条件: _env_ は Function Environment Record。
          1. _baseValue_ を GetSuperBase(_env_)。
          1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ } を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-argument-lists">
      <h1>引数リスト (Argument Lists)</h1>
      <emu-note>
        <p>引数リストの評価は値の List を生成する。</p>
      </emu-note>

      <emu-clause id="sec-runtime-semantics-argumentlistevaluation" oldids="sec-template-literals-runtime-semantics-argumentlistevaluation,sec-argument-lists-runtime-semantics-argumentlistevaluation" type="sdo">
        <h1>実行時セマンティクス: ArgumentListEvaluation ( ) — 正常完了で ECMAScript 言語値の List または突然の完了</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Arguments : `(` `)`</emu-grammar>
        <emu-alg>
          1. 新しい空 List を返す。
        </emu-alg>
        <emu-grammar>ArgumentList : AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _ref_ を ? |AssignmentExpression| の Evaluation。
          1. _arg_ を ? GetValue(_ref_)。
          1. « _arg_ » を返す。
        </emu-alg>
        <emu-grammar>ArgumentList : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _list_ を新しい空 List。
          1. _spreadRef_ を ? |AssignmentExpression| の Evaluation。
          1. _spreadObj_ を ? GetValue(_spreadRef_)。
          1. _iteratorRecord_ を ? GetIterator(_spreadObj_, ~sync~)。
          1. 反復:
            1. _next_ を ? IteratorStepValue(_iteratorRecord_)。
            1. _next_ が ~done~ なら _list_ を返す。
            1. _next_ を _list_ に追加。
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _precedingArgs_ を ? ArgumentListEvaluation(|ArgumentList|)。
          1. _ref_ を ? |AssignmentExpression| の Evaluation。
          1. _arg_ を ? GetValue(_ref_)。
          1. _precedingArgs_ と « _arg_ » のリスト結合を返す。
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _precedingArgs_ を ? ArgumentListEvaluation(|ArgumentList|)。
          1. _spreadRef_ を ? |AssignmentExpression| の Evaluation。
          1. _iteratorRecord_ を ? GetIterator(? GetValue(_spreadRef_), ~sync~)。
          1. 反復:
            1. _next_ を ? IteratorStepValue(_iteratorRecord_)。
            1. _next_ が ~done~ なら _precedingArgs_ を返す。
            1. _next_ を _precedingArgs_ に追加。
        </emu-alg>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. _templateLiteral_ を this |TemplateLiteral|。
          1. _siteObj_ を GetTemplateObject(_templateLiteral_)。
          1. « _siteObj_ » を返す。
        </emu-alg>
        <emu-grammar>TemplateLiteral : SubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. _templateLiteral_ を this |TemplateLiteral|。
          1. _siteObj_ を GetTemplateObject(_templateLiteral_)。
          1. _remaining_ を ? ArgumentListEvaluation(|SubstitutionTemplate|)。
          1. « _siteObj_ » と _remaining_ のリスト結合を返す。
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _firstSubRef_ を ? |Expression| の Evaluation。
          1. _firstSub_ を ? GetValue(_firstSubRef_)。
          1. _restSub_ を ? SubstitutionEvaluation(|TemplateSpans|)。
          1. 事前条件: _restSub_ は（空かもしれない）List。
          1. « _firstSub_ » と _restSub_ のリスト結合を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-optional-chains">
      <h1>オプショナルチェイン (Optional Chains)</h1>
      <emu-note>オプショナルチェインは 1 つ以上のプロパティアクセスおよび関数呼び出しの連鎖で、最初のものが `?.` トークンで始まる。</emu-note>

      <emu-clause id="sec-optional-chaining-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>
          OptionalExpression :
            MemberExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |MemberExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _baseValue_ が *undefined* または *null* なら
            1. *undefined* を返す。
          1. ? ChainEvaluation(|OptionalChain|, 引数 _baseValue_, _baseReference_) を返す。
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            CallExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |CallExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _baseValue_ が *undefined* または *null* なら
            1. *undefined* を返す。
          1. ? ChainEvaluation(|OptionalChain|, 引数 _baseValue_, _baseReference_) を返す。
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            OptionalExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ を ? |OptionalExpression| の Evaluation。
          1. _baseValue_ を ? GetValue(_baseReference_)。
          1. _baseValue_ が *undefined* または *null* なら
            1. *undefined* を返す。
          1. ? ChainEvaluation(|OptionalChain|, 引数 _baseValue_, _baseReference_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-optional-chaining-chain-evaluation" type="sdo">
        <h1>
          実行時セマンティクス: ChainEvaluation (
          _baseValue_: ECMAScript 言語値,
          _baseReference_: ECMAScript 言語値または Reference Record,
          ): 正常完了で ECMAScript 言語値または Reference Record を含むか、または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>OptionalChain : `?.` Arguments</emu-grammar>
        <emu-alg>
          1. _thisChain_ を this |OptionalChain|。
          1. _tailCall_ を IsInTailPosition(_thisChain_)。
          1. ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_) を返す。
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _strict_ を IsStrict(this |OptionalChain|)。
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _strict_ を IsStrict(this |OptionalChain|)。
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _fieldNameString_ を |PrivateIdentifier| の StringValue。
          1. MakePrivateReference(_baseValue_, _fieldNameString_) を返す。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain Arguments</emu-grammar>
        <emu-alg>
          1. _optionalChain_ を |OptionalChain|。
          1. _newReference_ を ? ChainEvaluation(_optionalChain_, 引数 _baseValue_, _baseReference_)。
          1. _newValue_ を ? GetValue(_newReference_)。
          1. _thisChain_ を this |OptionalChain|。
          1. _tailCall_ を IsInTailPosition(_thisChain_)。
          1. ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_) を返す。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _optionalChain_ を |OptionalChain|。
          1. _newReference_ を ? ChainEvaluation(_optionalChain_, 引数 _baseValue_, _baseReference_)。
          1. _newValue_ を ? GetValue(_newReference_)。
          1. _strict_ を IsStrict(this |OptionalChain|)。
          1. ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _optionalChain_ を |OptionalChain|。
          1. _newReference_ を ? ChainEvaluation(_optionalChain_, 引数 _baseValue_, _baseReference_)。
          1. _newValue_ を ? GetValue(_newReference_)。
          1. _strict_ を IsStrict(this |OptionalChain|)。
          1. EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_) を返す。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _optionalChain_ を |OptionalChain|。
          1. _newReference_ を ? ChainEvaluation(_optionalChain_, 引数 _baseValue_, _baseReference_)。
          1. _newValue_ を ? GetValue(_newReference_)。
          1. _fieldNameString_ を |PrivateIdentifier| の StringValue。
          1. MakePrivateReference(_newValue_, _fieldNameString_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>Import 呼び出し (Import Calls)</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. ? EvaluateImportCall(|AssignmentExpression|) を返す。
        </emu-alg>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. ? EvaluateImportCall(the first |AssignmentExpression|, the second |AssignmentExpression|) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          EvaluateImportCall (
            _specifierExpression_: Parse Node,
            optional _optionsExpression_: Parse Node,
          ): 正常完了で Promise を含むか、または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _referrer_ を GetActiveScriptOrModule() とする。
          1. もし _referrer_ が *null* であれば、_referrer_ を現在の Realm Record に設定する。
          1. _specifierRef_ を ? _specifierExpression_ の評価結果とする。
          1. _specifier_ を ? GetValue(_specifierRef_) とする。
          1. もし _optionsExpression_ が存在するなら、
            1. _optionsRef_ を ? _optionsExpression_ の評価結果とする。
            1. _options_ を ? GetValue(_optionsRef_) とする。
          1. そうでなければ、
            1. _options_ を *undefined* とする。
          1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
          1. _specifierString_ を Completion(ToString(_specifier_)) とする。
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_)。
          1. _attributes_ を新しい空の List とする。
          1. もし _options_ が *undefined* でないなら、
            1. もし _options_ が Object でないなら、
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新たに生成された *TypeError* オブジェクト ») を実行する。
              1. _promiseCapability_.[[Promise]] を返す。
            1. _attributesObj_ を Completion(Get(_options_, *"with"* )) とする。
            1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_)。
            1. もし _attributesObj_ が *undefined* でないなら、
              1. もし _attributesObj_ が Object でないなら、
                1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新たに生成された *TypeError* オブジェクト ») を実行する。
                1. _promiseCapability_.[[Promise]] を返す。
              1. _entries_ を Completion(EnumerableOwnProperties(_attributesObj_, ~key+value~)) とする。
              1. IfAbruptRejectPromise(_entries_, _promiseCapability_)。
              1. _entries_ の各要素 _entry_ について、次を行う
                1. _key_ を ! Get(_entry_, *"0"*) とする。
                1. _value_ を ! Get(_entry_, *"1"*) とする。
                1. もし _key_ が String なら、
                  1. もし _value_ が String でないなら、
                    1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新たに生成された *TypeError* オブジェクト ») を実行する。
                    1. _promiseCapability_.[[Promise]] を返す。
                  1. ImportAttribute Record { [[Key]]: _key_, [[Value]]: _value_ } を _attributes_ に追加する。
            1. もし AllImportAttributesSupported(_attributes_) が *false* なら、
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新たに生成された *TypeError* オブジェクト ») を実行する。
              1. _promiseCapability_.[[Promise]] を返す。
            1. _attributes_ をその各要素の [[Key]] フィールドの文字順 (各値を UTF-16 のコード単位列として扱う) に従ってソートする。注: このソートは、ホストが属性の列挙順序に基づいて挙動を変更することを禁じられているという点でのみ観測可能である。
          1. _moduleRequest_ を新しい ModuleRequest Record { [[Specifier]]: _specifierString_, [[Attributes]]: _attributes_ } とする。
          1. HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_) を実行する。
          1. _promiseCapability_.[[Promise]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            _promiseCapability_: PromiseCapability Record,
            _moduleCompletion_: Module Record を含む正常完了または throw 完了,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>説明</dt>
          <dd>`import()` 呼び出しにより開始された動的 import の処理を完了し、適切に Promise を解決または拒否する。</dd>
        </dl>
        <emu-alg>
          1. _moduleCompletion_ が abrupt completion なら
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »)。
            1. ~unused~ を返す。
          1. _module_ を _moduleCompletion_.[[Value]]。
          1. _loadPromise_ を _module_.LoadRequestedModules()。
          1. _rejectedClosure_ を (_reason_) をパラメータとし _promiseCapability_ を捕捉する Abstract Closure とし、呼ばれたら:
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »)。
            1. Return NormalCompletion(*undefined*)。
          1. _onRejected_ を CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »)。
          1. _linkAndEvaluateClosure_ をパラメータなしで _module_, _promiseCapability_, _onRejected_ を捕捉する Abstract Closure とし、呼ばれたら:
            1. _link_ を Completion(_module_.Link())。
            1. _link_ が abrupt なら
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »)。
              1. Return NormalCompletion(*undefined*)。
            1. _evaluatePromise_ を _module_.Evaluate()。
            1. _fulfilledClosure_ をパラメータなしで _module_, _promiseCapability_ を捕捉する Abstract Closure とし、呼ばれたら:
              1. _namespace_ を GetModuleNamespace(_module_)。
              1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »)。
              1. Return NormalCompletion(*undefined*)。
            1. _onFulfilled_ を CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »)。
            1. PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_) を実行。
            1. ~unused~ を返す。
          1. _linkAndEvaluate_ を CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *""*, « »)。
          1. PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_) を実行。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tagged-templates">
      <h1>タグ付きテンプレート (Tagged Templates)</h1>
      <emu-note>
        <p>タグ付きテンプレートは |TemplateLiteral| (<emu-xref href="#sec-template-literals"></emu-xref>) から導出される引数を持つ関数呼び出しである。実際の引数はテンプレートオブジェクト (<emu-xref href="#sec-gettemplateobject"></emu-xref>) と |TemplateLiteral| 内に埋め込まれた式の評価結果を含む。</p>
      </emu-note>

      <emu-clause id="sec-tagged-templates-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. _tagRef_ を ? |MemberExpression| の Evaluation。
          1. _tagFunc_ を ? GetValue(_tagRef_)。
          1. _thisCall_ を this |MemberExpression|。
          1. _tailCall_ を IsInTailPosition(_thisCall_)。
          1. ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_) を返す。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. _tagRef_ を ? |CallExpression| の Evaluation。
          1. _tagFunc_ を ? GetValue(_tagRef_)。
          1. _thisCall_ を this |CallExpression|。
          1. _tailCall_ を IsInTailPosition(_thisCall_)。
          1. ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-meta-properties">
      <h1>メタプロパティ (Meta Properties)</h1>

      <emu-clause id="sec-meta-properties-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>NewTarget : `new` `.` `target`</emu-grammar>
        <emu-alg>
          1. GetNewTarget() を返す。
        </emu-alg>

        <emu-grammar>ImportMeta : `import` `.` `meta`</emu-grammar>
        <emu-alg>
          1. _module_ を GetActiveScriptOrModule()。
          1. 事前条件: _module_ は Source Text Module Record。
          1. _importMeta_ を _module_.[[ImportMeta]]。
          1. _importMeta_ が ~empty~ なら
            1. _importMeta_ を OrdinaryObjectCreate(*null*)。
            1. _importMetaValues_ を HostGetImportMetaProperties(_module_)。
            1. 各 Record { [[Key]], [[Value]] } _p_ について
              1. ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]])。
            1. HostFinalizeImportMeta(_importMeta_, _module_) を実行。
            1. _module_.[[ImportMeta]] に _importMeta_ を設定。
            1. _importMeta_ を返す。
          1. それ以外
            1. 事前条件: _importMeta_ は Object。
            1. _importMeta_ を返す。
        </emu-alg>

        <emu-clause id="sec-hostgetimportmetaproperties" type="host-defined abstract operation">
          <h1>
            HostGetImportMetaProperties (
              _moduleRecord_: Module Record,
            ): 各 [[Key]] (property key), [[Value]] (ECMAScript 言語値) を持つ Record の List
          </h1>
          <dl class="header">
            <dt>説明</dt>
            <dd>`import.meta` で返されるオブジェクトに対し、ホストがプロパティキーと値を提供する。</dd>
          </dl>

          <p>デフォルト実装は新しい空 List を返す。</p>
        </emu-clause>

        <emu-clause id="sec-hostfinalizeimportmeta" type="host-defined abstract operation">
          <h1>
            HostFinalizeImportMeta (
              _importMeta_: Object,
              _moduleRecord_: Module Record,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>説明</dt>
            <dd>`import.meta` で返されるオブジェクトを ECMAScript コードへ公開する前に追加操作を行うことをホストに許可する。</dd>
          </dl>

          <p>多くのホストは HostGetImportMetaProperties を定義するだけで済み、HostFinalizeImportMeta のデフォルト動作をそのまま利用できる。HostFinalizeImportMeta は公開前に直接オブジェクトを操作する必要があるホスト向けの「エスケープハッチ」を提供する。</p>

          <p>デフォルト実装は ~unused~ を返す。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-update-expressions">
    <h1>更新式 (Update Expressions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      UpdateExpression[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`
        `++` UnaryExpression[?Yield, ?Await]
        `--` UnaryExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-update-expressions-static-semantics-early-errors">
      <h1>静的セマンティクス: 早期エラー (Static Semantics: Early Errors)</h1>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
      </emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| の AssignmentTargetType が ~invalid~ なら早期 Syntax Error とする。
        </li>
      </ul>

      <emu-grammar>
        UpdateExpression :
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <ul>
        <li>
          |UnaryExpression| の AssignmentTargetType が ~invalid~ なら早期 Syntax Error とする。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-postfix-increment-operator">
      <h1>後置インクリメント演算子 (Postfix Increment Operator)</h1>

      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. _lhs_ を ? |LeftHandSideExpression| の Evaluation とする。
          1. |LeftHandSideExpression| の AssignmentTargetType が ~web-compat~ なら *ReferenceError* 例外を投げる。
          1. _oldValue_ を ? ToNumeric(? GetValue(_lhs_)) とする。
          1. _oldValue_ が Number なら
            1. _newValue_ を Number::add(_oldValue_, *1*<sub>𝔽</sub>) とする。
          1. そうでなければ
            1. Assert: _oldValue_ は BigInt である。
            1. _newValue_ を BigInt::add(_oldValue_, *1*<sub>ℤ</sub>) とする。
          1. ? PutValue(_lhs_, _newValue_) を実行する。
          1. _oldValue_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-postfix-decrement-operator">
      <h1>後置デクリメント演算子 (Postfix Decrement Operator)</h1>

      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. _lhs_ を ? |LeftHandSideExpression| の Evaluation とする。
          1. |LeftHandSideExpression| の AssignmentTargetType が ~web-compat~ なら *ReferenceError* 例外を投げる。
          1. _oldValue_ を ? ToNumeric(? GetValue(_lhs_)) とする。
          1. _oldValue_ が Number なら
            1. _newValue_ を Number::subtract(_oldValue_, *1*<sub>𝔽</sub>) とする。
          1. そうでなければ
            1. Assert: _oldValue_ は BigInt。
            1. _newValue_ を BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>) とする。
          1. ? PutValue(_lhs_, _newValue_) を実行。
          1. _oldValue_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-increment-operator">
      <h1>前置インクリメント演算子 (Prefix Increment Operator)</h1>

      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ を ? |UnaryExpression| の Evaluation とする。
          1. |UnaryExpression| の AssignmentTargetType が ~web-compat~ なら *ReferenceError* 例外を投げる。
          1. _oldValue_ を ? ToNumeric(? GetValue(_expr_)) とする。
          1. _oldValue_ が Number なら
            1. _newValue_ を Number::add(_oldValue_, *1*<sub>𝔽</sub>) とする。
          1. そうでなければ
            1. Assert: _oldValue_ は BigInt。
            1. _newValue_ を BigInt::add(_oldValue_, *1*<sub>ℤ</sub>) とする。
          1. ? PutValue(_expr_, _newValue_) を実行。
          1. _newValue_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-decrement-operator">
      <h1>前置デクリメント演算子 (Prefix Decrement Operator)</h1>

      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ を ? |UnaryExpression| の Evaluation とする。
          1. |UnaryExpression| の AssignmentTargetType が ~web-compat~ なら *ReferenceError* 例外を投げる。
          1. _oldValue_ を ? ToNumeric(? GetValue(_expr_)) とする。
          1. _oldValue_ が Number なら
            1. _newValue_ を Number::subtract(_oldValue_, *1*<sub>𝔽</sub>) とする。
          1. そうでなければ
            1. Assert: _oldValue_ は BigInt。
            1. _newValue_ を BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>) とする。
          1. ? PutValue(_expr_, _newValue_) を実行。
          1. _newValue_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-unary-operators">
    <h1>単項演算子 (Unary Operators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        `delete` UnaryExpression[?Yield, ?Await]
        `void` UnaryExpression[?Yield, ?Await]
        `typeof` UnaryExpression[?Yield, ?Await]
        `+` UnaryExpression[?Yield, ?Await]
        `-` UnaryExpression[?Yield, ?Await]
        `~` UnaryExpression[?Yield, ?Await]
        `!` UnaryExpression[?Yield, ?Await]
        [+Await] AwaitExpression[?Yield]
    </emu-grammar>

    <emu-clause id="sec-delete-operator">
      <h1>`delete` 演算子 (The `delete` Operator)</h1>

      <emu-clause id="sec-delete-operator-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー (Static Semantics: Early Errors)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <ul>
          <li>
            IsStrict(the |UnaryExpression|) が *true* で導出された |UnaryExpression| が <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>, <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>, または <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar> のいずれかである場合は Syntax Error。
          </li>
          <li>
            <p>
              導出された |UnaryExpression| が<br>
              <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar><br>
              であり、|CoverParenthesizedExpressionAndArrowParameterList| が最終的に（|UnaryExpression| の代わりに用いた場合）これらの規則により Syntax Error となる句を導出するなら Syntax Error。これは再帰的に適用される。
            </p>
          </li>
        </ul>
        <emu-note>
          <p>最後の規則により `delete (((foo)))` のような式は最初の規則が再帰適用されるため早期エラーになる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-delete-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _ref_ を ? |UnaryExpression| の Evaluation とする。
          1. _ref_ が Reference Record でなければ *true* を返す。
          1. IsUnresolvableReference(_ref_) が *true* なら
            1. Assert: _ref_.[[Strict]] は *false*。
            1. *true* を返す。
          1. IsPropertyReference(_ref_) が *true* なら
            1. Assert: IsPrivateReference(_ref_) は *false*。
            1. IsSuperReference(_ref_) が *true* なら *ReferenceError* 例外を投げる。
            1. [id="step-delete-operator-toobject"] _baseObj_ を ? ToObject(_ref_.[[Base]]) とする。
            1. _ref_.[[ReferencedName]] が property key でなければ
              1. _ref_.[[ReferencedName]] を ? ToPropertyKey(_ref_.[[ReferencedName]]) に設定。
            1. _deleteStatus_ を ? <emu-meta effects="user-code">_baseObj_.[[Delete]]</emu-meta>(_ref_.[[ReferencedName]]) とする。
            1. _deleteStatus_ が *false* かつ _ref_.[[Strict]] が *true* なら *TypeError* 例外。
            1. _deleteStatus_ を返す。
          1. そうでなければ
            1. _base_ を _ref_.[[Base]] とする。
            1. Assert: _base_ は Environment Record。
            1. ? <emu-meta effects="user-code">_base_.DeleteBinding</emu-meta>(_ref_.[[ReferencedName]]) を返す。
        </emu-alg>
        <emu-note>
          <p>strict mode コード内で `delete` 演算子が出現し、その |UnaryExpression| が変数・引数・関数名への直接参照であると *SyntaxError* 例外となる。さらに strict mode で `delete` の対象プロパティが { [[Configurable]]: *false* }（または削除不能）である場合 *TypeError* 例外となる。</p>
        </emu-note>
        <emu-note>
          <p>手順 <emu-xref href="#step-delete-operator-toobject"></emu-xref> で生成されうるオブジェクトは上記抽象操作および通常オブジェクトの [[Delete]] 内部メソッドの外からはアクセスできない。実装はそのオブジェクトの実際の生成を省略してもよい。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-void-operator">
      <h1>`void` 演算子 (The `void` Operator)</h1>

      <emu-clause id="sec-void-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `void` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ を ? |UnaryExpression| の Evaluation とする。
          1. ? GetValue(_expr_) を実行。
          1. *undefined* を返す。
        </emu-alg>
        <emu-note>
          <p>値を使用しない場合でも副作用が観測され得るため GetValue を呼び出す必要がある。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typeof-operator">
      <h1>`typeof` 演算子 (The `typeof` Operator)</h1>

      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation" oldids="table-typeof-operator-results,sec-IsHTMLDDA-internal-slot-typeof" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _val_ を ? |UnaryExpression| の Evaluation とする。
          1. _val_ が Reference Record なら
            1. IsUnresolvableReference(_val_) が *true* なら *"undefined"* を返す。
          1. _val_ を ? GetValue(_val_) に設定。
          1. _val_ が *undefined* なら *"undefined"* を返す。
          1. _val_ が *null* なら *"object"* を返す。
          1. _val_ が String なら *"string"* を返す。
          1. _val_ が Symbol なら *"symbol"* を返す。
          1. _val_ が Boolean なら *"boolean"* を返す。
          1. _val_ が Number なら *"number"* を返す。
          1. _val_ が BigInt なら *"bigint"* を返す。
          1. Assert: _val_ は Object。
          1. [id="step-typeof-web-compat-insertion-point", normative-optional] ホストがウェブブラウザ又は <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref> をサポートするなら
            1. _val_ が [[IsHTMLDDA]] 内部スロットを持つ場合 *"undefined"* を返す。
          1. _val_ が [[Call]] 内部メソッドを持つなら *"function"* を返す。
          1. *"object"* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-plus-operator">
      <h1>単項 `+` 演算子 (Unary `+` Operator)</h1>
      <emu-note>
        <p>単項 + 演算子は被演算子を Number 型に変換する。</p>
      </emu-note>

      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ を ? |UnaryExpression| の Evaluation とする。
          1. ? ToNumber(? GetValue(_expr_)) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-minus-operator">
      <h1>単項 `-` 演算子 (Unary `-` Operator)</h1>
      <emu-note>
        <p>単項 `-` は被演算子を数値へ変換し符号を反転する。*+0*<sub>𝔽</sub> の反転は *-0*<sub>𝔽</sub>、*-0*<sub>𝔽</sub> の反転は *+0*<sub>𝔽</sub> を生成する。</p>
      </emu-note>

      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ を ? |UnaryExpression| の Evaluation とする。
          1. _oldValue_ を ? ToNumeric(? GetValue(_expr_)) とする。
          1. _oldValue_ が Number なら
            1. Number::unaryMinus(_oldValue_) を返す。
          1. そうでなければ
            1. Assert: _oldValue_ は BigInt。
            1. BigInt::unaryMinus(_oldValue_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-bitwise-not-operator">
      <h1>ビット単位 NOT 演算子 ( `~` ) (Bitwise NOT Operator)</h1>

      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ を ? |UnaryExpression| の Evaluation とする。
          1. _oldValue_ を ? ToNumeric(? GetValue(_expr_)) とする。
          1. _oldValue_ が Number なら
            1. Number::bitwiseNOT(_oldValue_) を返す。
          1. そうでなければ
            1. Assert: _oldValue_ は BigInt。
            1. BigInt::bitwiseNOT(_oldValue_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-logical-not-operator">
      <h1>論理 NOT 演算子 ( `!` ) (Logical NOT Operator)</h1>

      <emu-clause id="sec-logical-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `!` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ を ? |UnaryExpression| の Evaluation とする。
          1. _oldValue_ を ToBoolean(? GetValue(_expr_)) とする。
          1. _oldValue_ が *true* なら *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>累乗演算子 (Exponentiation Operator)</h1>
    <h2>構文 (Syntax)</h2>

    <emu-grammar type="definition">
      ExponentiationExpression[Yield, Await] :
        UnaryExpression[?Yield, ?Await]
        UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-multiplicative-operators">
    <h1>乗算系演算子 (Multiplicative Operators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      MultiplicativeExpression[Yield, Await] :
        ExponentiationExpression[?Yield, ?Await]
        MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

      MultiplicativeOperator : one of
        `*` `/` `%`
    </emu-grammar>
    <emu-note>
      <ul>
        <li>`*` は乗算で被演算子の積を生成する。</li>
        <li>`/` は除算で被演算子の商を生成する。</li>
        <li>`%` は暗黙の除算に基づく剰余を生成する。</li>
      </ul>
    </emu-note>

    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. _opText_ を |MultiplicativeOperator| にマッチしたソーステキストとする。
        1. ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-additive-operators">
    <h1>加算系演算子 (Additive Operators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      AdditiveExpression[Yield, Await] :
        MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-addition-operator-plus">
      <h1>加算演算子 ( `+` ) (The Addition Operator)</h1>
      <emu-note>
        <p>加算演算子は文字列連結または数値加算を行う。</p>
      </emu-note>

      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-subtraction-operator-minus">
      <h1>減算演算子 ( `-` ) (The Subtraction Operator)</h1>
      <emu-note>
        <p>`-` 演算子は減算を行い被演算子の差を生成する。</p>
      </emu-note>

      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bitwise-shift-operators">
    <h1>ビットシフト演算子 (Bitwise Shift Operators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ShiftExpression[Yield, Await] :
        AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&lt;&lt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;&gt;` AdditiveExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-left-shift-operator">
      <h1>左シフト演算子 ( `&lt;&lt;` ) (The Left Shift Operator)</h1>
      <emu-note>
        <p>左オペランドを右オペランドで指定された回数だけビット左シフトする。</p>
      </emu-note>

      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `&lt;&lt;`, |AdditiveExpression|) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-signed-right-shift-operator">
      <h1>算術（符号付き）右シフト演算子 ( `>>` ) (The Signed Right Shift Operator)</h1>
      <emu-note>
        <p>左オペランドを右オペランドで指定された回数だけ符号拡張しつつビット右シフトする。</p>
      </emu-note>

      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>論理（ゼロ埋め）右シフト演算子 ( `>>>` ) (The Unsigned Right Shift Operator)</h1>
      <emu-note>
        <p>左オペランドを右オペランドで指定回数だけゼロ埋めしつつビット右シフトする。</p>
      </emu-note>

      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relational-operators">
    <h1>関係演算子 (Relational Operators)</h1>
    <emu-note>
      <p>関係演算子の評価結果は常に Boolean 型で、被演算子間にその関係が成り立つかを示す。</p>
    </emu-note>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      RelationalExpression[In, Yield, Await] :
        ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
        [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
        [+In] PrivateIdentifier `in` ShiftExpression[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p><sub>[In]</sub> 文法パラメータは関係式内の `in` 演算子と `for` 文の `in` を混同しないために必要。</p>
    </emu-note>

    <emu-clause id="sec-relational-operators-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |RelationalExpression| の Evaluation。
        1. _lVal_ を ? GetValue(_lRef_)。
        1. _rRef_ を ? |ShiftExpression| の Evaluation。
        1. _rVal_ を ? GetValue(_rRef_)。
        1. _r_ を ? IsLessThan(_lVal_, _rVal_, *true*) とする。
        1. _r_ が *undefined* なら *false*、そうでなければ _r_ を返す。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ を上と同様に求める（ただし比較順を反転）。
        1. _r_ を ? IsLessThan(_rVal_, _lVal_, *false*) とする。
        1. _r_ が *undefined* なら *false*、そうでなければ _r_。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _r_ を ? IsLessThan(_rVal_, _lVal_, *false*)。
        1. _r_ が *true* または *undefined* なら *false*、そうでなければ *true*。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _r_ を ? IsLessThan(_lVal_, _rVal_, *true*)。
        1. _r_ が *true* または *undefined* なら *false*、そうでなければ *true*。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `instanceof` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _lVal_, _rVal_ を得る。
        1. ? InstanceofOperator(_lVal_, _rVal_) を返す。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _lVal_, _rVal_ を得る。
        1. _rVal_ が Object でなければ *TypeError*。
        1. ? HasProperty(_rVal_, ? ToPropertyKey(_lVal_)) を返す。
      </emu-alg>
      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _privateIdentifier_ を |PrivateIdentifier| の StringValue とする。
        1. _rRef_, _rVal_ を評価して得る。
        1. _rVal_ が Object でなければ *TypeError*。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. Assert: _privateEnv_ は *null* でない。
        1. _privateName_ を ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_)。
        1. PrivateElementFind(_rVal_, _privateName_) が ~empty~ でなければ *true*。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-instanceofoperator" type="abstract operation">
      <h1>
        InstanceofOperator (
          _V_: ECMAScript 言語値,
          _target_: ECMAScript 言語値,
        ): 正常完了で Boolean を含むか throw 完了
      </h1>
      <dl class="header">
        <dt>説明 (description)</dt>
        <dd>_target_ の %Symbol.hasInstance% メソッドを用いるか、存在しない場合は _target_ の *"prototype"* が _V_ のプロトタイプ連鎖に存在するかを判定する汎用アルゴリズム。</dd>
      </dl>
      <emu-alg>
        1. _target_ が Object でなければ *TypeError* 例外。
        1. _instOfHandler_ を ? GetMethod(_target_, %Symbol.hasInstance%) とする。
        1. _instOfHandler_ が *undefined* でなければ
          1. ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)) を返す。
        1. [id="step-instanceof-check-function"] IsCallable(_target_) が *false* なら *TypeError*。
        1. [id="step-instanceof-fallback"] ? OrdinaryHasInstance(_target_, _V_) を返す。
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-instanceof-check-function"></emu-xref> と <emu-xref href="#step-instanceof-fallback"></emu-xref> は %Symbol.hasInstance% が存在しなかった以前の版との互換性を提供する。オブジェクトが %Symbol.hasInstance% を定義・継承しない場合は従来の `instanceof` 既定セマンティクスを用いる。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-equality-operators">
    <h1>等価演算子 (Equality Operators)</h1>
    <emu-note>
      <p>等価演算子の評価結果は常に Boolean 型で、演算子が命名する関係が両被演算子間で成り立つかを表す。</p>
    </emu-note>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      EqualityExpression[In, Yield, Await] :
        RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-equality-operators-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>EqualityExpression : EqualityExpression `==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _lVal_, _rVal_ を得る。
        1. ? IsLooselyEqual(_rVal_, _lVal_) を返す。
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!=` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _lVal_, _rVal_ を得る。
        1. _r_ を ? IsLooselyEqual(_rVal_, _lVal_)。
        1. _r_ が *true* なら *false*、それ以外 *true*。
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `===` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _lVal_, _rVal_ を得る。
        1. IsStrictlyEqual(_rVal_, _lVal_) を返す。
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 左右を評価し _lVal_, _rVal_ を得る。
        1. _r_ を IsStrictlyEqual(_rVal_, _lVal_)。
        1. _r_ が *true* なら *false*、それ以外 *true*。
      </emu-alg>
      <emu-note>
        <p>上記定義に関して:</p>
        <ul>
          <li>
            文字列比較は: <code>\`${a}\` == \`${b}\`</code> により強制できる。
          </li>
          <li>
            数値比較は: <code>+a == +b</code> により強制できる。
          </li>
          <li>
            Boolean 比較は: <code>!a == !b</code> により強制できる。
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>等価演算子は次の不変条件を保持する:</p>
        <ul>
          <li>
            <code>A != B</code> は <code>!(A == B)</code> と同値。
          </li>
          <li>
            <code>A == B</code> は評価順序を除き <code>B == A</code> と同値。
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>等価演算子は常に推移的とは限らない。例えば同じ String 値を表す異なる 2 つの String オブジェクトは、それぞれがリテラル文字列とは <code>==</code> で等しいが、互いには等しくない:</p>
        <ul>
          <li>
            <code>new String("a") == "a"</code> および <code>"a" == new String("a")</code> は *true*。
          </li>
          <li>
            <code>new String("a") == new String("a")</code> は *false*。
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>文字列比較はコードユニット列の単純な同値判定であり、Unicode 仕様の正規等価や照合順序は考慮されない。Unicode の正規等価な String が不等と判定され得る。両 String は既に正規化されているものとみなす。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-bitwise-operators">
    <h1>ビット単位二項演算子 (Binary Bitwise Operators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      BitwiseANDExpression[In, Yield, Await] :
        EqualityExpression[?In, ?Yield, ?Await]
        BitwiseANDExpression[?In, ?Yield, ?Await] `&amp;` EqualityExpression[?In, ?Yield, ?Await]

      BitwiseXORExpression[In, Yield, Await] :
        BitwiseANDExpression[?In, ?Yield, ?Await]
        BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]

      BitwiseORExpression[In, Yield, Await] :
        BitwiseXORExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&amp;`, |EqualityExpression|) を返す。
      </emu-alg>
      <emu-grammar>BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|) を返す。
      </emu-alg>
      <emu-grammar>BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-logical-operators">
    <h1>論理二項演算子 (Binary Logical Operators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      LogicalANDExpression[In, Yield, Await] :
        BitwiseORExpression[?In, ?Yield, ?Await]
        LogicalANDExpression[?In, ?Yield, ?Await] `&amp;&amp;` BitwiseORExpression[?In, ?Yield, ?Await]

      LogicalORExpression[In, Yield, Await] :
        LogicalANDExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]

      CoalesceExpression[In, Yield, Await] :
        CoalesceExpressionHead[?In, ?Yield, ?Await] `??` BitwiseORExpression[?In, ?Yield, ?Await]

      CoalesceExpressionHead[In, Yield, Await] :
        CoalesceExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await]

      ShortCircuitExpression[In, Yield, Await] :
        LogicalORExpression[?In, ?Yield, ?Await]
        CoalesceExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`&amp;&amp;` および `||` 演算子の結果値は必ずしも Boolean 型ではなく、常に 2 つの被演算子のいずれかの値そのものである。</p>
    </emu-note>

    <emu-clause id="sec-binary-logical-operators-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |LogicalANDExpression| の Evaluation。
        1. _lVal_ を ? GetValue(_lRef_)。
        1. ToBoolean(_lVal_) が *false* なら _lVal_ を返す。
        1. _rRef_ を ? |BitwiseORExpression| の Evaluation。
        1. ? GetValue(_rRef_) を返す。
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |LogicalORExpression| の Evaluation。
        1. _lVal_ を ? GetValue(_lRef_)。
        1. ToBoolean(_lVal_) が *true* なら _lVal_ を返す。
        1. _rRef_ を ? |LogicalANDExpression| の Evaluation。
        1. ? GetValue(_rRef_) を返す。
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |CoalesceExpressionHead| の Evaluation。
        1. _lVal_ を ? GetValue(_lRef_)。
        1. _lVal_ が *undefined* または *null* なら
          1. _rRef_ を ? |BitwiseORExpression| の Evaluation。
          1. ? GetValue(_rRef_) を返す。
        1. そうでなければ
          1. _lVal_ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-conditional-operator">
    <h1>条件演算子 ( `? :` ) (Conditional Operator)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ConditionalExpression[In, Yield, Await] :
        ShortCircuitExpression[?In, ?Yield, ?Await]
        ShortCircuitExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>ECMAScript の |ConditionalExpression| の文法は C や Java とわずかに異なる。C / Java では第 2 部分式を |Expression| とできる一方で第 3 部分式を |ConditionalExpression| に制限する。ECMAScript が異なるのは、条件のどちらの腕でも代入式を許可し、かつ中央の式として（紛らわしくほとんど有用でない）カンマ式となるケースを排除するためである。</p>
    </emu-note>

    <emu-clause id="sec-conditional-operator-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |ShortCircuitExpression| の Evaluation とする。
        1. _lVal_ を ToBoolean(? GetValue(_lRef_)) とする。
        1. _lVal_ が *true* なら
          1. _trueRef_ を 1 番目の |AssignmentExpression| の Evaluation。
          1. ? GetValue(_trueRef_) を返す。
        1. そうでなければ
          1. _falseRef_ を 2 番目の |AssignmentExpression| の Evaluation。
          1. ? GetValue(_falseRef_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-assignment-operators">
    <h1>代入演算子 (Assignment Operators)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      AssignmentExpression[In, Yield, Await] :
        ConditionalExpression[?In, ?Yield, ?Await]
        [+Yield] YieldExpression[?In, ?Await]
        ArrowFunction[?In, ?Yield, ?Await]
        AsyncArrowFunction[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await] #assignment
        LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `&amp;&amp;=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `||=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `??=` AssignmentExpression[?In, ?Yield, ?Await]

      // emu-format ignore
      AssignmentOperator : one of
        `*=` `/=` `%=` `+=` `-=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `^=` `|=` `**=`
    </emu-grammar>

    <emu-clause id="sec-assignment-operators-static-semantics-early-errors">
      <h1>静的セマンティクス: 早期エラー (Static Semantics: Early Errors)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <ul>
        <li>|LeftHandSideExpression| が |ObjectLiteral| か |ArrayLiteral| のいずれかであるなら、|LeftHandSideExpression| は |AssignmentPattern| を覆わねばならない。</li>
        <li>|LeftHandSideExpression| が |ObjectLiteral| でも |ArrayLiteral| でもないなら、|LeftHandSideExpression| の AssignmentTargetType が ~invalid~ なら Syntax Error。</li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression AssignmentOperator AssignmentExpression
      </emu-grammar>
      <ul>
        <li>|LeftHandSideExpression| の AssignmentTargetType が ~invalid~ なら Syntax Error。</li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression
      </emu-grammar>
      <ul>
        <li>|LeftHandSideExpression| の AssignmentTargetType が ~simple~ でなければ Syntax Error。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-assignment-operators-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. |LeftHandSideExpression| が |ObjectLiteral| でも |ArrayLiteral| でもないなら
          1. _lRef_ を ? |LeftHandSideExpression| の Evaluation。
          1. |LeftHandSideExpression| の AssignmentTargetType が ~web-compat~ なら *ReferenceError* 例外。
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) が *true* かつ IsIdentifierRef(|LeftHandSideExpression|) が *true* なら
            1. _lhs_ を |LeftHandSideExpression| の StringValue。
            1. _rVal_ を 引数 _lhs_ で |AssignmentExpression| の NamedEvaluation。
          1. そうでなければ
            1. _rRef_ を ? |AssignmentExpression| の Evaluation。
            1. _rVal_ を ? GetValue(_rRef_)。
          1. [id="step-assignmentexpression-evaluation-simple-putvalue"] ? PutValue(_lRef_, _rVal_) を実行。
          1. _rVal_ を返す。
        1. _assignmentPattern_ を |LeftHandSideExpression| が覆う |AssignmentPattern| とする。
        1. _rRef_ を ? |AssignmentExpression| の Evaluation。
        1. _rVal_ を ? GetValue(_rRef_)。
        1. _assignmentPattern_ の DestructuringAssignmentEvaluation を引数 _rVal_ で実行。
        1. _rVal_ を返す。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |LeftHandSideExpression| の Evaluation。
        1. |LeftHandSideExpression| の AssignmentTargetType が ~web-compat~ なら *ReferenceError*。
        1. [id="step-assignmentexpression-evaluation-compound-getvalue"] _lVal_ を ? GetValue(_lRef_)。
        1. _rRef_ を ? |AssignmentExpression| の Evaluation。
        1. _rVal_ を ? GetValue(_rRef_)。
        1. _assignmentOpText_ を |AssignmentOperator| にマッチしたソーステキスト。
        1. _opText_ を次の表で _assignmentOpText_ に対応する Unicode コードポイント列。
          <figure>
            <!-- emu-format ignore -->
            <table class="lightweight-table">
              <thead>
                <tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>
              </thead>
              <tr><td> `**=`              </td><td> `**`           </td></tr>
              <tr><td> `*=`               </td><td> `*`            </td></tr>
              <tr><td> `/=`               </td><td> `/`            </td></tr>
              <tr><td> `%=`               </td><td> `%`            </td></tr>
              <tr><td> `+=`               </td><td> `+`            </td></tr>
              <tr><td> `-=`               </td><td> `-`            </td></tr>
              <tr><td> `&lt;&lt;=`        </td><td> `&lt;&lt;`     </td></tr>
              <tr><td> `&gt;&gt;=`        </td><td> `&gt;&gt;`     </td></tr>
              <tr><td> `&gt;&gt;&gt;=`    </td><td> `&gt;&gt;&gt;` </td></tr>
              <tr><td> `&amp;=`           </td><td> `&amp;`        </td></tr>
              <tr><td> `^=`               </td><td> `^`            </td></tr>
              <tr><td> `|=`               </td><td> `|`            </td></tr>
            </table>
          </figure>
        1. _r_ を ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_) とする。
        1. [id="step-assignmentexpression-evaluation-compound-putvalue"] ? PutValue(_lRef_, _r_) を実行。
        1. _r_ を返す。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `&amp;&amp;=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |LeftHandSideExpression| の Evaluation。
        1. [id="step-assignmentexpression-evaluation-lgcl-and-getvalue"] _lVal_ を ? GetValue(_lRef_)。
        1. ToBoolean(_lVal_) が *false* なら _lVal_ を返す。
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) が *true* かつ IsIdentifierRef(|LeftHandSideExpression|) が *true* なら
          1. _lhs_ を |LeftHandSideExpression| の StringValue。
          1. _rVal_ を 引数 _lhs_ で |AssignmentExpression| の NamedEvaluation。
        1. そうでなければ
          1. _rRef_ を ? |AssignmentExpression| の Evaluation。
          1. _rVal_ を ? GetValue(_rRef_)。
        1. [id="step-assignmentexpression-evaluation-lgcl-and-putvalue"] ? PutValue(_lRef_, _rVal_) を実行。
        1. _rVal_ を返す。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `||=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |LeftHandSideExpression| の Evaluation。
        1. [id="step-assignmentexpression-evaluation-lgcl-or-getvalue"] _lVal_ を ? GetValue(_lRef_)。
        1. ToBoolean(_lVal_) が *true* なら _lVal_ を返す。
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) が *true* かつ IsIdentifierRef(|LeftHandSideExpression|) が *true* なら
          1. _lhs_ を |LeftHandSideExpression| の StringValue。
          1. _rVal_ を 引数 _lhs_ で |AssignmentExpression| の NamedEvaluation。
        1. そうでなければ
          1. _rRef_ を ? |AssignmentExpression| の Evaluation。
          1. _rVal_ を ? GetValue(_rRef_)。
        1. [id="step-assignmentexpression-evaluation-lgcl-or-putvalue"] ? PutValue(_lRef_, _rVal_) を実行。
        1. _rVal_ を返す。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `??=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |LeftHandSideExpression| の Evaluation。
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-getvalue"] _lVal_ を ? GetValue(_lRef_)。
        1. _lVal_ が *undefined* でも *null* でもないなら _lVal_ を返す。
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) が *true* かつ IsIdentifierRef(|LeftHandSideExpression|) が *true* なら
          1. _lhs_ を |LeftHandSideExpression| の StringValue。
          1. _rVal_ を 引数 _lhs_ で |AssignmentExpression| の NamedEvaluation。
        1. そうでなければ
          1. _rRef_ を ? |AssignmentExpression| の Evaluation。
          1. _rVal_ を ? GetValue(_rRef_)。
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-putvalue"] ? PutValue(_lRef_, _rVal_) を実行。
        1. _rVal_ を返す。
      </emu-alg>
      <emu-note>
        <p>strict mode コード内でこの式が現れる場合、手順 <emu-xref href="#step-assignmentexpression-evaluation-simple-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-compound-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-getvalue"></emu-xref> の _lRef_ が解決不能参照なら実行時エラー（*ReferenceError* 例外）。さらに手順 <emu-xref href="#step-assignmentexpression-evaluation-compound-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-putvalue"></emu-xref> の _lRef_ が [[Writable]]:*false* のデータプロパティ、[[Set]]:*undefined* のアクセサプロパティ、あるいは IsExtensible が *false* を返すオブジェクト上の存在しないプロパティを参照しているなら *TypeError* 例外を投げる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-applystringornumericbinaryoperator" type="abstract operation">
      <h1>
        ApplyStringOrNumericBinaryOperator (
          _lVal_: ECMAScript 言語値,
          _opText_: `**`, `*`, `/`, `%`, `+`, `-`, `&lt;&lt;`, `&gt;&gt;`, `&gt;&gt;&gt;`, `&amp;`, `^`, `|`,
          _rVal_: ECMAScript 言語値,
        ): 正常完了で String / BigInt / Number のいずれか、または throw 完了
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _opText_ が `+` なら
          1. [id="step-binary-op-toprimitive-lval"] _lPrim_ を ? ToPrimitive(_lVal_)。
          1. [id="step-binary-op-toprimitive-rval"] _rPrim_ を ? ToPrimitive(_rVal_)。
          1. [id="step-binary-op-string-check"] _lPrim_ が String であるか _rPrim_ が String なら
            1. _lStr_ を ? ToString(_lPrim_)。
            1. _rStr_ を ? ToString(_rPrim_)。
            1. _lStr_ と _rStr_ の文字列連結を返す。
          1. _lVal_ を _lPrim_ に設定。
          1. _rVal_ を _rPrim_ に設定。
        1. 注: ここからは数値演算である。
        1. _lNum_ を ? ToNumeric(_lVal_)。
        1. _rNum_ を ? ToNumeric(_rVal_)。
        1. SameType(_lNum_, _rNum_) が *false* なら *TypeError* 例外。
        1. _lNum_ が BigInt なら
          1. _opText_ が `**` なら ? BigInt::exponentiate(_lNum_, _rNum_) を返す。
          1. _opText_ が `/` なら ? BigInt::divide(_lNum_, _rNum_)。
          1. _opText_ が `%` なら ? BigInt::remainder(_lNum_, _rNum_)。
          1. _opText_ が `>>>` なら ? BigInt::unsignedRightShift(_lNum_, _rNum_)。
          1. _operation_ を次の表で _opText_ に対応する抽象操作とする:
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_   </th><th> _operation_              </th></tr>
                </thead>
                <tbody>
                  <tr><td> `*`        </td><td> BigInt::multiply         </td></tr>
                  <tr><td> `+`        </td><td> BigInt::add              </td></tr>
                  <tr><td> `-`        </td><td> BigInt::subtract         </td></tr>
                  <tr><td> `&lt;&lt;` </td><td> BigInt::leftShift        </td></tr>
                  <tr><td> `&gt;&gt;` </td><td> BigInt::signedRightShift </td></tr>
                  <tr><td> `&amp;`    </td><td> BigInt::bitwiseAND       </td></tr>
                  <tr><td> `^`        </td><td> BigInt::bitwiseXOR       </td></tr>
                  <tr><td> `|`        </td><td> BigInt::bitwiseOR        </td></tr>
                </tbody>
              </table>
            </figure>
        1. そうでなければ
          1. Assert: _lNum_ は Number。
          1. _operation_ を次の表で _opText_ に対応する抽象操作とする:
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_       </th><th> _operation_                </th></tr>
                </thead>
                <tbody>
                  <tr><td> `**`           </td><td> Number::exponentiate       </td></tr>
                  <tr><td> `*`            </td><td> Number::multiply           </td></tr>
                  <tr><td> `/`            </td><td> Number::divide             </td></tr>
                  <tr><td> `%`            </td><td> Number::remainder          </td></tr>
                  <tr><td> `+`            </td><td> Number::add                </td></tr>
                  <tr><td> `-`            </td><td> Number::subtract           </td></tr>
                  <tr><td> `&lt;&lt;`     </td><td> Number::leftShift          </td></tr>
                  <tr><td> `&gt;&gt;`     </td><td> Number::signedRightShift   </td></tr>
                  <tr><td> `&gt;&gt;&gt;` </td><td> Number::unsignedRightShift </td></tr>
                  <tr><td> `&amp;`        </td><td> Number::bitwiseAND         </td></tr>
                  <tr><td> `^`            </td><td> Number::bitwiseXOR         </td></tr>
                  <tr><td> `|`            </td><td> Number::bitwiseOR          </td></tr>
                </tbody>
              </table>
            </figure>
        1. _operation_(_lNum_, _rNum_) を返す。
      </emu-alg>
      <emu-note>
        <p>手順 <emu-xref href="#step-binary-op-toprimitive-lval"></emu-xref>, <emu-xref href="#step-binary-op-toprimitive-rval"></emu-xref> の ToPrimitive 呼出しでは hint を与えない。標準オブジェクト（Date を除く）は hint 省略時 ~number~ と同等に扱い、Date は ~string~ と同等に扱う。エキゾチックオブジェクトは別の扱いをするかもしれない。</p>
      </emu-note>
      <emu-note>
        <p>手順 <emu-xref href="#step-binary-op-string-check"></emu-xref> は IsLessThan アルゴリズムの手順 <emu-xref href="#step-arc-string-check"></emu-xref> と異なり、論理積ではなく論理和を用いる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-evaluatestringornumericbinaryexpression" type="abstract operation">
      <h1>
        EvaluateStringOrNumericBinaryExpression (
          _leftOperand_: Parse Node,
          _opText_: Unicode コードポイント列,
          _rightOperand_: Parse Node,
        ): 正常完了で String / BigInt / Number のいずれか、または突然の完了
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _lRef_ を ? _leftOperand_ の Evaluation。
        1. _lVal_ を ? GetValue(_lRef_)。
        1. _rRef_ を ? _rightOperand_ の Evaluation。
        1. _rVal_ を ? GetValue(_rRef_)。
        1. ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-destructuring-assignment">
      <h1>分割代入 (Destructuring Assignment)</h1>
      <h2>補助構文 (Supplemental Syntax)</h2>
      <p>
        次の生成規則インスタンスを処理する特定状況で<br>
        <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar><br>
        |LeftHandSideExpression| の解釈は以下の文法で精緻化される:
      </p>
      <emu-grammar type="definition">
        AssignmentPattern[Yield, Await] :
          ObjectAssignmentPattern[?Yield, ?Await]
          ArrayAssignmentPattern[?Yield, ?Await]

        ObjectAssignmentPattern[Yield, Await] :
          `{` `}`
          `{` AssignmentRestProperty[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

        ArrayAssignmentPattern[Yield, Await] :
          `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
          `[` AssignmentElementList[?Yield, ?Await] `]`
          `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

        AssignmentRestProperty[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        AssignmentPropertyList[Yield, Await] :
          AssignmentProperty[?Yield, ?Await]
          AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

        AssignmentElementList[Yield, Await] :
          AssignmentElisionElement[?Yield, ?Await]
          AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

        AssignmentElisionElement[Yield, Await] :
          Elision? AssignmentElement[?Yield, ?Await]

        AssignmentProperty[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

        AssignmentElement[Yield, Await] :
          DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        AssignmentRestElement[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        DestructuringAssignmentTarget[Yield, Await] :
          LeftHandSideExpression[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-assignment-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー (Static Semantics: Early Errors)</h1>
        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <ul>
          <li>|IdentifierReference| の AssignmentTargetType が ~simple~ でなければ Syntax Error。</li>
        </ul>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <ul>
          <li>|DestructuringAssignmentTarget| が |ArrayLiteral| または |ObjectLiteral| なら Syntax Error。</li>
        </ul>
        <emu-grammar>DestructuringAssignmentTarget : LeftHandSideExpression</emu-grammar>
        <ul>
          <li>|LeftHandSideExpression| が |ObjectLiteral| または |ArrayLiteral| なら |AssignmentPattern| を覆わねばならない。</li>
          <li>|LeftHandSideExpression| がそうでないなら AssignmentTargetType が ~simple~ でなければ Syntax Error。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-destructuringassignmentevaluation" type="sdo">
        <h1>
          実行時セマンティクス: DestructuringAssignmentEvaluation (
          _value_: ECMAScript 言語値,
          ): 正常完了で ~unused~ または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ObjectAssignmentPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_)。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>
          ObjectAssignmentPattern :
            `{` AssignmentPropertyList `}`
            `{` AssignmentPropertyList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_)。
          1. |AssignmentPropertyList| の PropertyDestructuringAssignmentEvaluation を引数 _value_ で実行。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_)。
          1. _excludedNames_ を空 List。
          1. |AssignmentRestProperty| の RestDestructuringAssignmentEvaluation を引数 _value_, _excludedNames_ で返す。
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentPropertyList `,` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_)。
          1. _excludedNames_ を |AssignmentPropertyList| の PropertyDestructuringAssignmentEvaluation(引数 _value_)。
          1. |AssignmentRestProperty| の RestDestructuringAssignmentEvaluation(_value_, _excludedNames_) を返す。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ を ? GetIterator(_value_, ~sync~)。
          1. ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~)) を返す。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ を ? GetIterator(_value_, ~sync~)。
          1. _result_ を Completion(|Elision| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_))。
          1. _iteratorRecord_.[[Done]] が *false* なら ? IteratorClose(_iteratorRecord_, _result_) を返す。
          1. _result_ を返す。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision? AssignmentRestElement `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ を ? GetIterator(_value_, ~sync~)。
          1. |Elision| が存在するなら
            1. _status_ を Completion(|Elision| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_))。
            1. _status_ が abrupt なら
              1. Assert: _iteratorRecord_.[[Done]] は *true*。
              1. ? _status_ を返す。
          1. _result_ を Completion(|AssignmentRestElement| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_))。
          1. _iteratorRecord_.[[Done]] が *false* なら ? IteratorClose(_iteratorRecord_, _result_)。
          1. _result_ を返す。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ を ? GetIterator(_value_, ~sync~)。
          1. _result_ を Completion(|AssignmentElementList| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_))。
          1. _iteratorRecord_.[[Done]] が *false* なら ? IteratorClose(_iteratorRecord_, _result_)。
          1. _result_ を返す。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `,` Elision? AssignmentRestElement? `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ を ? GetIterator(_value_, ~sync~)。
          1. _status_ を Completion(|AssignmentElementList| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_))。
          1. _status_ が abrupt なら
            1. _iteratorRecord_.[[Done]] が *false* なら ? IteratorClose(_iteratorRecord_, _status_) を返す。
            1. ? _status_ を返す。
          1. |Elision| が存在するなら
            1. _status_ を Completion(|Elision| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)) に設定。
            1. _status_ が abrupt なら
              1. Assert: _iteratorRecord_.[[Done]] は *true*。
              1. ? _status_ を返す。
          1. |AssignmentRestElement| が存在するなら
            1. _status_ を Completion(|AssignmentRestElement| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)) に設定。
          1. _iteratorRecord_.[[Done]] が *false* なら ? IteratorClose(_iteratorRecord_, _status_)。
          1. ? _status_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydestructuringassignmentevaluation" type="sdo">
        <h1>
          実行時セマンティクス: PropertyDestructuringAssignmentEvaluation (
          _value_: ECMAScript 言語値,
          ): 正常完了でプロパティキーの List または突然の完了
        </h1>
        <dl class="header">
          <dt>説明 (description)</dt>
          <dd>分割代入された全プロパティキーのリストを収集する。</dd>
        </dl>
        <emu-grammar>AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty</emu-grammar>
        <emu-alg>
          1. _propertyNames_ を ? PropertyDestructuringAssignmentEvaluation(|AssignmentPropertyList|, _value_)。
          1. _nextNames_ を ? PropertyDestructuringAssignmentEvaluation(|AssignmentProperty|, _value_)。
          1. _propertyNames_ と _nextNames_ のリスト結合を返す。
        </emu-alg>

        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <emu-alg>
          1. _P_ を |IdentifierReference| の StringValue。
          1. _lRef_ を ? ResolveBinding(_P_)。
          1. _v_ を ? GetV(_value_, _P_)。
          1. |Initializer| が存在し _v_ が *undefined* なら
            1. IsAnonymousFunctionDefinition(|Initializer|) が *true* なら
              1. _v_ を 引数 _P_ で |Initializer| の NamedEvaluation。
            1. そうでなければ
              1. _defaultValue_ を ? |Initializer| の Evaluation。
              1. _v_ を ? GetValue(_defaultValue_)。
          1. ? PutValue(_lRef_, _v_) を実行。
          1. « _P_ » を返す。
        </emu-alg>

        <emu-grammar>AssignmentProperty : PropertyName `:` AssignmentElement</emu-grammar>
        <emu-alg>
          1. _name_ を ? |PropertyName| の Evaluation。
          1. |AssignmentElement| の KeyedDestructuringAssignmentEvaluation(_value_, _name_) を実行。
          1. « _name_ » を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-restdestructuringassignmentevaluation" type="sdo">
        <h1>
          実行時セマンティクス: RestDestructuringAssignmentEvaluation (
          _value_: ECMAScript 言語値,
          _excludedNames_: プロパティキーの List,
          ): 正常完了で ~unused~ または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. _lRef_ を ? |DestructuringAssignmentTarget| の Evaluation。
          1. _restObj_ を OrdinaryObjectCreate(%Object.prototype%)。
          1. ? CopyDataProperties(_restObj_, _value_, _excludedNames_)。
          1. ? PutValue(_lRef_, _restObj_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-iteratordestructuringassignmentevaluation" type="sdo">
        <h1>
          実行時セマンティクス: IteratorDestructuringAssignmentEvaluation (
          _iteratorRecord_: Iterator Record,
          ): 正常完了で ~unused~ または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElementList : AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. |AssignmentElisionElement| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_) を返す。
        </emu-alg>
        <emu-grammar>AssignmentElementList : AssignmentElementList `,` AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. |AssignmentElementList| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_) を実行。
          1. |AssignmentElisionElement| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_) を返す。
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : AssignmentElement</emu-grammar>
        <emu-alg>
          1. |AssignmentElement| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_) を返す。
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : Elision AssignmentElement</emu-grammar>
        <emu-alg>
          1. |Elision| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_) を実行。
          1. |AssignmentElement| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_) を返す。
        </emu-alg>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_.[[Done]] が *false* なら
            1. ? IteratorStep(_iteratorRecord_)。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. |Elision| の IteratorDestructuringAssignmentEvaluation(_iteratorRecord_) を実行。
          1. _iteratorRecord_.[[Done]] が *false* なら
            1. ? IteratorStep(_iteratorRecord_)。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| が |ObjectLiteral| / |ArrayLiteral| のいずれでもないなら
            1. _lRef_ を ? |DestructuringAssignmentTarget| の Evaluation。
          1. _value_ を *undefined*。
          1. _iteratorRecord_.[[Done]] が *false* なら
            1. _next_ を ? IteratorStepValue(_iteratorRecord_)。
            1. _next_ が ~done~ でなければ _value_ を _next_ に設定。
          1. |Initializer| が存在し _value_ が *undefined* なら
            1. IsAnonymousFunctionDefinition(|Initializer|) かつ IsIdentifierRef(|DestructuringAssignmentTarget|) が *true* なら
              1. _target_ を |DestructuringAssignmentTarget| の StringValue。
              1. _v_ を 引数 _target_ で |Initializer| の NamedEvaluation。
            1. そうでなければ
              1. _defaultValue_ を ? |Initializer| の Evaluation。
              1. _v_ を ? GetValue(_defaultValue_)。
          1. そうでなければ
            1. _v_ を _value_。
          1. |DestructuringAssignmentTarget| が |ObjectLiteral| または |ArrayLiteral| なら
            1. _nestedAssignmentPattern_ を |DestructuringAssignmentTarget| が覆う |AssignmentPattern|。
            1. ? DestructuringAssignmentEvaluation(_nestedAssignmentPattern_, 引数 _v_) を返す。
          1. ? PutValue(_lRef_, _v_) を返す。
        </emu-alg>
        <emu-note>
          <p>|DestructuringAssignmentTarget| がパターンでない場合にそれを先に評価してからイテレータアクセスや |Initializer| の評価を行うことで、左から右への評価順序を維持する。</p>
        </emu-note>
        <emu-grammar>AssignmentRestElement : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| が |ObjectLiteral| / |ArrayLiteral| でないなら
            1. _lRef_ を ? |DestructuringAssignmentTarget| の Evaluation。
          1. _A_ を ! ArrayCreate(0)。
          1. _n_ を 0。
          1. _iteratorRecord_.[[Done]] が *false* の間繰り返す
            1. _next_ を ? IteratorStepValue(_iteratorRecord_)。
            1. _next_ が ~done~ でなければ
              1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)。
              1. _n_ を _n_ + 1 に。
          1. |DestructuringAssignmentTarget| が |ObjectLiteral| / |ArrayLiteral| でないなら
            1. ? PutValue(_lRef_, _A_) を返す。
          1. _nestedAssignmentPattern_ を |DestructuringAssignmentTarget| が覆う |AssignmentPattern|。
          1. ? DestructuringAssignmentEvaluation(_nestedAssignmentPattern_, 引数 _A_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyeddestructuringassignmentevaluation" type="sdo">
        <h1>
          実行時セマンティクス: KeyedDestructuringAssignmentEvaluation (
          _value_: ECMAScript 言語値,
          _propertyName_: プロパティキー,
          ): 正常完了で ~unused~ または突然の完了
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| が |ObjectLiteral| / |ArrayLiteral| でないなら
            1. _lRef_ を ? |DestructuringAssignmentTarget| の Evaluation。
          1. _v_ を ? GetV(_value_, _propertyName_)。
          1. |Initializer| が存在し _v_ が *undefined* なら
            1. IsAnonymousFunctionDefinition(|Initializer|) かつ IsIdentifierRef(|DestructuringAssignmentTarget|) が *true* なら
              1. _target_ を |DestructuringAssignmentTarget| の StringValue。
              1. _rhsValue_ を 引数 _target_ で |Initializer| の NamedEvaluation。
            1. そうでなければ
              1. _defaultValue_ を ? |Initializer| の Evaluation。
              1. _rhsValue_ を ? GetValue(_defaultValue_)。
          1. そうでなければ
            1. _rhsValue_ を _v_。
          1. |DestructuringAssignmentTarget| が |ObjectLiteral| または |ArrayLiteral| なら
            1. _assignmentPattern_ を |DestructuringAssignmentTarget| が覆う |AssignmentPattern|。
            1. ? DestructuringAssignmentEvaluation(_assignmentPattern_, 引数 _rhsValue_) を返す。
          1. ? PutValue(_lRef_, _rhsValue_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-comma-operator">
    <h1>カンマ演算子 ( `,` ) (Comma Operator)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      Expression[In, Yield, Await] :
        AssignmentExpression[?In, ?Yield, ?Await]
        Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-comma-operator-runtime-semantics-evaluation" type="sdo">
      <h1>実行時セマンティクス: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ を ? |Expression| の Evaluation とする。
        1. ? GetValue(_lRef_) を実行する。
        1. _rRef_ を ? |AssignmentExpression| の Evaluation とする。
        1. ? GetValue(_rRef_) を返す。
      </emu-alg>
      <emu-note>
        <p>値は使用されないが、副作用が観測可能であるため GetValue を呼び出す必要がある。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript 言語: 文 (Statement) と 宣言 (Declaration)</h1>
  <h2>構文 (Syntax)</h2>
  <emu-grammar type="definition">
    Statement[Yield, Await, Return] :
      BlockStatement[?Yield, ?Await, ?Return]
      VariableStatement[?Yield, ?Await]
      EmptyStatement
      ExpressionStatement[?Yield, ?Await]
      IfStatement[?Yield, ?Await, ?Return]
      BreakableStatement[?Yield, ?Await, ?Return]
      ContinueStatement[?Yield, ?Await]
      BreakStatement[?Yield, ?Await]
      [+Return] ReturnStatement[?Yield, ?Await]
      WithStatement[?Yield, ?Await, ?Return]
      LabelledStatement[?Yield, ?Await, ?Return]
      ThrowStatement[?Yield, ?Await]
      TryStatement[?Yield, ?Await, ?Return]
      DebuggerStatement

    Declaration[Yield, Await] :
      HoistableDeclaration[?Yield, ?Await, ~Default]
      ClassDeclaration[?Yield, ?Await, ~Default]
      LexicalDeclaration[+In, ?Yield, ?Await]

    HoistableDeclaration[Yield, Await, Default] :
      FunctionDeclaration[?Yield, ?Await, ?Default]
      GeneratorDeclaration[?Yield, ?Await, ?Default]
      AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
      AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

    BreakableStatement[Yield, Await, Return] :
      IterationStatement[?Yield, ?Await, ?Return]
      SwitchStatement[?Yield, ?Await, ?Return]
  </emu-grammar>

  <emu-clause id="sec-statement-semantics">
    <h1>Statement の意味論 (Semantics)</h1>

    <emu-clause id="sec-statement-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        HoistableDeclaration :
          GeneratorDeclaration
          AsyncFunctionDeclaration
          AsyncGeneratorDeclaration
      </emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>
        HoistableDeclaration : FunctionDeclaration
      </emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| の Evaluation の結果を ? 付きで返す。
      </emu-alg>
      <emu-grammar>
        BreakableStatement :
          IterationStatement
          SwitchStatement
      </emu-grammar>
      <emu-alg>
        1. _newLabelSet_ を新しい空の List とする。
        1. この |BreakableStatement| の LabelledEvaluation (引数 _newLabelSet_) の結果を ? 付きで返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-block">
    <h1>Block</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      BlockStatement[Yield, Await, Return] :
        Block[?Yield, ?Await, ?Return]

      Block[Yield, Await, Return] :
        `{` StatementList[?Yield, ?Await, ?Return]? `}`

      StatementList[Yield, Await, Return] :
        StatementListItem[?Yield, ?Await, ?Return]
        StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

      StatementListItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        Declaration[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-block-static-semantics-early-errors" oldids="sec-block-duplicates-allowed-static-semantics">
      <h1>静的意味論: 早期エラー (Static Semantics: Early Errors)</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <ul>
        <li>
          <p>|StatementList| の LexicallyDeclaredNames に重複する要素が含まれるなら構文エラーである<span normative-optional>。ただしホストが Web ブラウザであるか又は <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> をサポートし、以下の両条件を満たす場合は除く:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) が *false* である。</li>
            <li>重複している要素はいずれも FunctionDeclarations によってのみ束縛される。</li>
          </ul>
        </li>
        <li>
          |StatementList| の LexicallyDeclaredNames の任意の要素が |StatementList| の VarDeclaredNames にも含まれているなら構文エラーである。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-block-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. _oldEnv_ を現在実行中コンテキストの LexicalEnvironment とする。
        1. _blockEnv_ を NewDeclarativeEnvironment(_oldEnv_) とする。
        1. BlockDeclarationInstantiation(|StatementList|, _blockEnv_) を実行する。
        1. 実行中コンテキストの LexicalEnvironment を _blockEnv_ に設定する。
        1. _blockValue_ を |StatementList| の Evaluation の Completion とする。
        1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
        1. ? _blockValue_ を返す。
      </emu-alg>
      <emu-note>
        <p>どのように |Block| を抜けても LexicalEnvironment は常に元に復元される。</p>
      </emu-note>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _sl_ を |StatementList| の Evaluation を ? 付きで行った結果とする。
        1. _s_ を |StatementListItem| の Evaluation の Completion とする。
        1. UpdateEmpty(_s_, _sl_) を ? 付きで返す。
      </emu-alg>
      <emu-note>
        <p>|StatementList| の値はその中で最後に値を生成する項目の値である。例えば以下の `eval` 呼び出しはいずれも 1 を返す:</p>
        <pre><code class="javascript">
          eval("1;;;;;")
          eval("1;{}")
          eval("1;var a;")
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-blockdeclarationinstantiation">
      <h1>
        BlockDeclarationInstantiation (
          _code_: a Parse Node,
          _env_: a Declarative Environment Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ はブロック本体に対応する Parse Node。_env_ は束縛を生成する Environment Record。</dd>
      </dl>
      <emu-note>
        <p>|Block| または |CaseBlock| が評価される際、新しい Declarative Environment Record が生成され、そのブロック内で宣言された block スコープの変数・定数・関数・クラスの束縛がそこにインスタンス化される。</p>
      </emu-note>
      <p>呼び出されたとき以下の手順を行う:</p>
      <emu-alg>
        1. _declarations_ を _code_ の LexicallyScopedDeclarations とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _declarations_ の各要素 _d_ について:
          1. _d_ の BoundNames の各要素 _dn_ について:
            1. IsConstantDeclaration of _d_ が *true* なら:
              1. ! _env_.CreateImmutableBinding(_dn_, *true*) を実行。
            1. それ以外:
              1. [id="step-blockdeclarationinstantiation-createmutablebinding", normative-optional] ホストが Web ブラウザまたは <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> をサポートするなら:
                1. ! _env_.HasBinding(_dn_) が *false* なら:
                  1. ! _env_.CreateMutableBinding(_dn_, *false*) を実行。
              1. それ以外:
                1. ! _env_.CreateMutableBinding(_dn_, *false*) を実行。
          1. _d_ が |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| のいずれかであれば:
            1. _fn_ を _d_ の BoundNames の唯一の要素とする。
            1. _fo_ を 引数 _env_, _privateEnv_ で _d_ の InstantiateFunctionObject とする。
            1. [id="step-blockdeclarationinstantiation-initializebinding", normative-optional] ホストが Web ブラウザまたは <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> をサポートするなら:
              1. _env_ 内の _fn_ の束縛が未初期化なら:
                1. ! _env_.InitializeBinding(_fn_, _fo_) を実行。
              1. それ以外:
                1. Assert: _d_ は |FunctionDeclaration| である。
                1. ! _env_.SetMutableBinding(_fn_, _fo_, *false*) を実行。
            1. それ以外:
              1. ! _env_.InitializeBinding(_fn_, _fo_) を実行。
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>Declarations と Variable 文</h1>

    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let および Const 宣言</h1>
      <emu-note>
        <p>`let` と `const` 宣言は、現在実行中コンテキストの LexicalEnvironment にスコープを持つ変数を定義する。変数はその包含 Environment Record がインスタンス化された時に生成されるが、その |LexicalBinding| が評価されるまでいかなる方法でもアクセスできない。|Initializer| を伴う |LexicalBinding| により定義された変数は、その |Initializer| の |AssignmentExpression| が評価されたときに値が割り当てられ、生成時ではない。`let` 宣言内で |Initializer| を持たない |LexicalBinding| によって定義された変数は、その |LexicalBinding| が評価されたとき *undefined* が割り当てられる。</p>
      </emu-note>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await] `;`

        LetOrConst :
          `let`
          `const`

        BindingList[In, Yield, Await] :
          LexicalBinding[?In, ?Yield, ?Await]
          BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]

        LexicalBinding[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <ul>
          <li>
            |BindingList| の BoundNames に *"let"* が含まれるなら構文エラー。
          </li>
          <li>
            |BindingList| の BoundNames に重複があるなら構文エラー。
          </li>
        </ul>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
        <ul>
          <li>
            |Initializer| が存在せず、これを含む |LexicalDeclaration| の IsConstantDeclaration が *true* なら構文エラー。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation" type="sdo">
        <h1>実行時意味論: 評価</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. |BindingList| の Evaluation を ? 付きで実行する。
          1. ~empty~ を返す。
        </emu-alg>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. |BindingList| の Evaluation を ? 付きで実行。
          1. |LexicalBinding| の Evaluation を ? 付きで返す。
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. _lhs_ を ! ResolveBinding(StringValue of |BindingIdentifier|) とする。
          1. ! InitializeReferencedBinding(_lhs_, *undefined*) を実行。
          1. ~empty~ を返す。
        </emu-alg>
        <emu-note>
          <p>静的意味論により、この形の |LexicalBinding| が `const` 宣言で現れないことが保証されている。</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. _bindingId_ を |BindingIdentifier| の StringValue とする。
          1. _lhs_ を ! ResolveBinding(_bindingId_) とする。
          1. IsAnonymousFunctionDefinition(|Initializer|) が *true* なら:
            1. _value_ を |Initializer| の NamedEvaluation (引数 _bindingId_) を ? 付きで行った結果とする。
          1. それ以外:
            1. _rhs_ を |Initializer| の Evaluation を ? 付きで行った結果とする。
            1. _value_ を ? GetValue(_rhs_) とする。
          1. ! InitializeReferencedBinding(_lhs_, _value_) を実行。
          1. ~empty~ を返す。
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. _rhs_ を |Initializer| の Evaluation を ? 付きで行った結果とする。
          1. _value_ を ? GetValue(_rhs_) とする。
          1. _env_ を実行中コンテキストの LexicalEnvironment とする。
          1. |BindingPattern| の BindingInitialization (引数 _value_, _env_) を ? 付きで返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-variable-statement">
      <h1>Variable 文 (var 文)</h1>
      <emu-note>
        <p>`var` 文は現在実行中コンテキストの VariableEnvironment にスコープを持つ変数を宣言する。Var 変数は包含 Environment Record のインスタンス化時に生成され、生成時に *undefined* へ初期化される。同一 VariableEnvironment のスコープ内で同じ |BindingIdentifier| が複数の |VariableDeclaration| に現れても、それらは単一の変数のみを定義する。|Initializer| を持つ |VariableDeclaration| により定義された変数は、生成時ではなくその |VariableDeclaration| が実行される際に |Initializer| の |AssignmentExpression| の値が割り当てられる。</p>
      </emu-note>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        VariableStatement[Yield, Await] :
          `var` VariableDeclarationList[+In, ?Yield, ?Await] `;`

        VariableDeclarationList[In, Yield, Await] :
          VariableDeclaration[?In, ?Yield, ?Await]
          VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]

        VariableDeclaration[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-variable-statement-runtime-semantics-evaluation" type="sdo">
        <h1>実行時意味論: 評価</h1>
        <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| の Evaluation を ? 付きで実行。
          1. ~empty~ を返す。
        </emu-alg>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| の Evaluation を ? 付きで実行。
          1. |VariableDeclaration| の Evaluation を ? 付きで返す。
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. ~empty~ を返す。
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. _bindingId_ を |BindingIdentifier| の StringValue とする。
          1. _lhs_ を ? ResolveBinding(_bindingId_) とする。
          1. IsAnonymousFunctionDefinition(|Initializer|) が *true* なら:
            1. _value_ を |Initializer| の NamedEvaluation (引数 _bindingId_) を ? 付きで行った結果とする。
          1. それ以外:
            1. _rhs_ を |Initializer| の Evaluation を ? 付きで行った結果とする。
            1. _value_ を ? GetValue(_rhs_) とする。
          1. [id="step-vardecllist-evaluation-putvalue"] ? PutValue(_lhs_, _value_) を実行。
          1. ~empty~ を返す。
        </emu-alg>
        <emu-note>
          <p>|VariableDeclaration| が with 文内にネストしており、その |BindingIdentifier| がその with 文の Object Environment Record のバインディングオブジェクトのプロパティ名と同一である場合、<emu-xref href="#step-vardecllist-evaluation-putvalue"></emu-xref> のステップは |Identifier| の VariableEnvironment の束縛ではなくそのプロパティに _value_ を代入する。</p>
        </emu-note>
        <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. _rhs_ を |Initializer| の Evaluation を ? 付きで行った結果とする。
          1. _rVal_ を ? GetValue(_rhs_) とする。
          1. |BindingPattern| の BindingInitialization (引数 _rVal_, *undefined*) を ? 付きで返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>分割代入用束縛パターン (Destructuring Binding Patterns)</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        BindingPattern[Yield, Await] :
          ObjectBindingPattern[?Yield, ?Await]
          ArrayBindingPattern[?Yield, ?Await]

        ObjectBindingPattern[Yield, Await] :
          `{` `}`
          `{` BindingRestProperty[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

        ArrayBindingPattern[Yield, Await] :
          `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
          `[` BindingElementList[?Yield, ?Await] `]`
          `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

        BindingRestProperty[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]

        BindingPropertyList[Yield, Await] :
          BindingProperty[?Yield, ?Await]
          BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

        BindingElementList[Yield, Await] :
          BindingElisionElement[?Yield, ?Await]
          BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

        BindingElisionElement[Yield, Await] :
          Elision? BindingElement[?Yield, ?Await]

        BindingProperty[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

        BindingElement[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        SingleNameBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        BindingRestElement[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]
          `...` BindingPattern[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization" type="sdo">
        <h1>
          実行時意味論: PropertyBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          ): プロパティキーの List を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>束縛される全プロパティ名のリストを収集する。</dd>
        </dl>
        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. _boundNames_ を |BindingPropertyList| の PropertyBindingInitialization(_value_, _environment_) を ? 付きで行った結果とする。
          1. _nextNames_ を |BindingProperty| の PropertyBindingInitialization(_value_, _environment_) を ? 付きで行った結果とする。
          1. _boundNames_ と _nextNames_ のリスト連結を返す。
        </emu-alg>

        <emu-grammar>BindingProperty : SingleNameBinding</emu-grammar>
        <emu-alg>
          1. _name_ を |SingleNameBinding| の BoundNames の唯一の要素とする。
          1. |SingleNameBinding| の KeyedBindingInitialization(_value_, _environment_, _name_) を ? 付きで実行。
          1. « _name_ » を返す。
        </emu-alg>

        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. _P_ を |PropertyName| の Evaluation を ? 付きで行った結果とする。
          1. |BindingElement| の KeyedBindingInitialization(_value_, _environment_, _P_) を ? 付きで実行。
          1. « _P_ » を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization" type="sdo">
        <h1>
          実行時意味論: RestBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          _excludedNames_: a List of property keys,
          ): ~unused~ を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. _lhs_ を ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_) とする。
          1. _restObj_ を OrdinaryObjectCreate(%Object.prototype%) とする。
          1. ? CopyDataProperties(_restObj_, _value_, _excludedNames_) を実行。
          1. _environment_ が *undefined* なら ? PutValue(_lhs_, _restObj_) を返す。
          1. ? InitializeReferencedBinding(_lhs_, _restObj_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo">
        <h1>
          実行時意味論: KeyedBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          _propertyName_: a property key,
          ): ~unused~ を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>_environment_ に *undefined* を渡すのは PutValue を用いて初期化値を代入すべきであることを示す。その例は非 strict 関数の仮引数リストなど。そこでは複数同名パラメータの可能性に対応するため事前初期化が行われる。</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. _v_ を ? GetV(_value_, _propertyName_) とする。
          1. |Initializer| が存在し _v_ が *undefined* なら:
            1. _defaultValue_ を |Initializer| の Evaluation を ? 付きで行った結果とする。
            1. _v_ を ? GetValue(_defaultValue_) に設定。
          1. |BindingPattern| の BindingInitialization(_v_, _environment_) を ? 付きで返す。
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. _bindingId_ を |BindingIdentifier| の StringValue とする。
          1. _lhs_ を ? ResolveBinding(_bindingId_, _environment_) とする。
          1. _v_ を ? GetV(_value_, _propertyName_) とする。
          1. |Initializer| が存在し _v_ が *undefined* なら:
            1. IsAnonymousFunctionDefinition(|Initializer|) が *true* なら:
              1. _v_ を |Initializer| の NamedEvaluation (引数 _bindingId_) を ? 付きで行った結果とする。
            1. それ以外:
              1. _defaultValue_ を |Initializer| の Evaluation を ? 付きで行った結果とする。
              1. _v_ を ? GetValue(_defaultValue_) に設定。
          1. _environment_ が *undefined* なら ? PutValue(_lhs_, _v_) を返す。
          1. ? InitializeReferencedBinding(_lhs_, _v_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-empty-statement">
    <h1>Empty 文 (Empty Statement)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      EmptyStatement :
        `;`
    </emu-grammar>

    <emu-clause id="sec-empty-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>EmptyStatement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-expression-statement">
    <h1>Expression 文 (Expression Statement)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ExpressionStatement[Yield, Await] :
        [lookahead &notin; { `{`, `function`, `async` [no LineTerminator here] `function`, `class`, `let` `[` }] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>|ExpressionStatement| は U+007B LEFT CURLY BRACKET で始まれない。これは |Block| との曖昧さを避けるためである。`function` または `class` で始めることもできない。これは |FunctionDeclaration|, |GeneratorDeclaration|, |ClassDeclaration| との曖昧さを避けるためである。`async function` で始めることは |AsyncFunctionDeclaration| または |AsyncGeneratorDeclaration| との曖昧さを避けるため禁止される。`let [` の 2 トークン列で始めることは、最初の |LexicalBinding| が |ArrayBindingPattern| である `let` |LexicalDeclaration| との曖昧さを避けるため禁止される。</p>
    </emu-note>

    <emu-clause id="sec-expression-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>ExpressionStatement : Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
        1. ? GetValue(_exprRef_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-if-statement">
    <h1>`if` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      IfStatement[Yield, Await, Return] :
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] [lookahead != `else`]
    </emu-grammar>
    <emu-note>[lookahead ≠ `else`] 制約は古典的な「dangling else」問題を通常の方法で解決する。すなわち曖昧な場合、`else` は最も内側の `if` に関連付けられる。</emu-note>

    <emu-clause id="sec-if-statement-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <ul>
        <li>
          最初の |Statement| について IsLabelledFunction が *true* なら構文エラー。
        </li>
        <li>
          二番目の |Statement| について IsLabelledFunction が *true* なら構文エラー。
        </li>
      </ul>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          |Statement| について IsLabelledFunction が *true* なら構文エラー。
        </li>
      </ul>
      <emu-note>
        <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> で規定される拡張が実装されている場合にのみこの規則を適用する必要がある。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-if-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
        1. _exprValue_ を ToBoolean(? GetValue(_exprRef_)) とする。
        1. _exprValue_ が *true* なら:
          1. _stmtCompletion_ を 最初の |Statement| の Evaluation の Completion とする。
        1. それ以外:
          1. _stmtCompletion_ を 二番目の |Statement| の Evaluation の Completion とする。
        1. ? UpdateEmpty(_stmtCompletion_, *undefined*) を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
        1. _exprValue_ を ToBoolean(? GetValue(_exprRef_)) とする。
        1. _exprValue_ が *false* なら:
          1. *undefined* を返す。
        1. それ以外:
          1. _stmtCompletion_ を |Statement| の Evaluation の Completion とする。
          1. ? UpdateEmpty(_stmtCompletion_, *undefined*) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>反復文 (Iteration Statements)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      IterationStatement[Yield, Await, Return] :
        DoWhileStatement[?Yield, ?Await, ?Return]
        WhileStatement[?Yield, ?Await, ?Return]
        ForStatement[?Yield, ?Await, ?Return]
        ForInOfStatement[?Yield, ?Await, ?Return]
    </emu-grammar>

    <emu-clause id="sec-iteration-statements-semantics">
      <h1>意味論 (Semantics)</h1>

      <emu-clause id="sec-loopcontinues" type="abstract operation">
        <h1>
          LoopContinues (
            _completion_: a Completion Record,
            _labelSet_: a List of Strings,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _completion_ が normal completion なら *true* を返す。
          1. _completion_ が continue completion でないなら *false* を返す。
          1. _completion_.[[Target]] が ~empty~ なら *true* を返す。
          1. _labelSet_ が _completion_.[[Target]] を含むなら *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>|IterationStatement| の |Statement| 部内では |ContinueStatement| により新しい反復を開始できる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-loopevaluation" type="sdo">
        <h1>
          実行時意味論: LoopEvaluation (
          _labelSet_: a List of Strings,
          ): ECMAScript 言語値を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>IterationStatement : DoWhileStatement</emu-grammar>
        <emu-alg>
          1. |DoWhileStatement| の DoWhileLoopEvaluation(_labelSet_) を ? 付きで返す。
        </emu-alg>
        <emu-grammar>IterationStatement : WhileStatement</emu-grammar>
        <emu-alg>
          1. |WhileStatement| の WhileLoopEvaluation(_labelSet_) を ? 付きで返す。
        </emu-alg>
        <emu-grammar>IterationStatement : ForStatement</emu-grammar>
        <emu-alg>
          1. |ForStatement| の ForLoopEvaluation(_labelSet_) を ? 付きで返す。
        </emu-alg>
        <emu-grammar>IterationStatement : ForInOfStatement</emu-grammar>
        <emu-alg>
          1. |ForInOfStatement| の ForIn/OfLoopEvaluation(_labelSet_) を ? 付きで返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-do-while-statement">
      <h1>`do`-`while` 文</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        DoWhileStatement[Yield, Await, Return] :
          `do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`
      </emu-grammar>

      <emu-clause id="sec-do-while-statement-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <ul>
          <li>
            |Statement| について IsLabelledFunction が *true* なら構文エラー。
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> で規定される拡張が実装されている場合にのみこの規則を適用する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-dowhileloopevaluation" oldids="sec-do-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          実行時意味論: DoWhileLoopEvaluation (
          _labelSet_: a List of Strings,
          ): ECMAScript 言語値を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. _V_ を *undefined* とする。
          1. 繰り返し:
            1. _stmtResult_ を |Statement| の Evaluation の Completion とする。
            1. LoopContinues(_stmtResult_, _labelSet_) が *false* なら ? UpdateEmpty(_stmtResult_, _V_) を返す。
            1. _stmtResult_.[[Value]] が ~empty~ でなければ _V_ を _stmtResult_.[[Value]] に設定。
            1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
            1. _exprValue_ を ? GetValue(_exprRef_) とする。
            1. ToBoolean(_exprValue_) が *false* なら _V_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-while-statement">
      <h1>`while` 文</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        WhileStatement[Yield, Await, Return] :
          `while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-while-statement-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <ul>
          <li>
            |Statement| について IsLabelledFunction が *true* なら構文エラー。
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> の拡張が実装されている場合のみ適用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-whileloopevaluation" oldids="sec-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          実行時意味論: WhileLoopEvaluation (
          _labelSet_: a List of Strings,
          ): ECMAScript 言語値を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _V_ を *undefined* とする。
          1. 繰り返し:
            1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
            1. _exprValue_ を ? GetValue(_exprRef_) とする。
            1. ToBoolean(_exprValue_) が *false* なら _V_ を返す。
            1. _stmtResult_ を |Statement| の Evaluation の Completion とする。
            1. LoopContinues(_stmtResult_, _labelSet_) が *false* なら ? UpdateEmpty(_stmtResult_, _V_) を返す。
            1. _stmtResult_.[[Value]] が ~empty~ でなければ _V_ を _stmtResult_.[[Value]] に設定。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-statement">
      <h1>`for` 文</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        ForStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-for-statement-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>
          ForStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |Statement| について IsLabelledFunction が *true* なら構文エラー。
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> の拡張が実装されている場合のみ適用。</p>
        </emu-note>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <ul>
          <li>
            |LexicalDeclaration| の BoundNames の任意要素が |Statement| の VarDeclaredNames にも現れるなら構文エラー。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forloopevaluation" oldids="sec-for-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          実行時意味論: ForLoopEvaluation (
          _labelSet_: a List of Strings,
          ): ECMAScript 言語値を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. 最初の |Expression| が存在するなら:
            1. _exprRef_ をその Evaluation を ? 付きで行った結果とする。
            1. ? GetValue(_exprRef_) を実行。
          1. 二番目の |Expression| が存在するなら _test_ をそれに、存在しなければ ~empty~ とする。
          1. 三番目の |Expression| が存在するなら _increment_ をそれに、存在しなければ ~empty~ とする。
          1. ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_) を ? 付きで返す。
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| の Evaluation を ? 付きで実行。
          1. 最初の |Expression| が存在するなら _test_ をそれに、存在しなければ ~empty~。
          1. 二番目の |Expression| が存在するなら _increment_ をそれに、存在しなければ ~empty~。
          1. ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_) を ? 付きで返す。
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. _oldEnv_ を現在実行中コンテキストの LexicalEnvironment とする。
          1. _loopEnv_ を NewDeclarativeEnvironment(_oldEnv_) とする。
          1. _isConst_ を |LexicalDeclaration| の IsConstantDeclaration とする。
          1. _boundNames_ を |LexicalDeclaration| の BoundNames とする。
          1. _boundNames_ の各 _dn_ について:
            1. _isConst_ が *true* なら:
              1. ! _loopEnv_.CreateImmutableBinding(_dn_, *true*) を実行。
            1. それ以外:
              1. ! _loopEnv_.CreateMutableBinding(_dn_, *false*) を実行。
          1. 実行中コンテキストの LexicalEnvironment を _loopEnv_ に設定。
          1. _forDcl_ を |LexicalDeclaration| の Evaluation の Completion とする。
          1. _forDcl_ が abrupt completion なら:
            1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
            1. ? _forDcl_ を返す。
          1. _isConst_ が *false* なら _perIterationLets_ を _boundNames_、そうでなければ新しい空 List とする。
          1. 最初の |Expression| が存在するなら _test_ をそれに、存在しなければ ~empty~。
          1. 二番目の |Expression| が存在するなら _increment_ をそれに、存在しなければ ~empty~。
          1. _bodyResult_ を ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_) の Completion とする。
          1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
          1. ? _bodyResult_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-forbodyevaluation" type="abstract operation">
        <h1>
          ForBodyEvaluation (
            _test_: an |Expression| Parse Node or ~empty~,
            _increment_: an |Expression| Parse Node or ~empty~,
            _stmt_: a |Statement| Parse Node,
            _perIterationBindings_: a List of Strings,
            _labelSet_: a List of Strings,
          ): ECMAScript 言語値を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_ を *undefined* とする。
          1. ? CreatePerIterationEnvironment(_perIterationBindings_) を実行。
          1. 繰り返し:
            1. _test_ が ~empty~ でないなら:
              1. _testRef_ を _test_ の Evaluation を ? 付きで行った結果とする。
              1. _testValue_ を ? GetValue(_testRef_) とする。
              1. ToBoolean(_testValue_) が *false* なら _V_ を返す。
            1. _result_ を _stmt_ の Evaluation の Completion とする。
            1. LoopContinues(_result_, _labelSet_) が *false* なら ? UpdateEmpty(_result_, _V_) を返す。
            1. _result_.[[Value]] が ~empty~ でなければ _V_ を _result_.[[Value]] に設定。
            1. ? CreatePerIterationEnvironment(_perIterationBindings_) を実行。
            1. _increment_ が ~empty~ でないなら:
              1. _incRef_ を _increment_ の Evaluation を ? 付きで行った結果とする。
              1. ? GetValue(_incRef_) を実行。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createperiterationenvironment" type="abstract operation">
        <h1>
          CreatePerIterationEnvironment (
            _perIterationBindings_: a List of Strings,
          ): ~unused~ を含む normal completion または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _perIterationBindings_ が要素を持つなら:
            1. _lastIterationEnv_ を現在実行中コンテキストの LexicalEnvironment とする。
            1. _outer_ を _lastIterationEnv_.[[OuterEnv]] とする。
            1. Assert: _outer_ は *null* ではない。
            1. _thisIterationEnv_ を NewDeclarativeEnvironment(_outer_) とする。
            1. _perIterationBindings_ の各 _bn_ について:
              1. ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*) を実行。
              1. _lastValue_ を ? _lastIterationEnv_.GetBindingValue(_bn_, *true*) とする。
              1. ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_) を実行。
            1. 実行中コンテキストの LexicalEnvironment を _thisIterationEnv_ に設定。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>`for`-`in`, `for`-`of`, `for`-`await`-`of` 文</h1>
      <h2>構文 (Syntax)</h2>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` [lookahead &notin; { `let`, `async` `of` }] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` [lookahead != `let`] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

        ForDeclaration[Yield, Await] :
          LetOrConst ForBinding[?Yield, ?Await]

        ForBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await]
          BindingPattern[?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>この節は 付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
      </emu-note>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |Statement| について IsLabelledFunction が *true* なら構文エラー。
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> の拡張が実装されている場合のみ適用。</p>
        </emu-note>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |LeftHandSideExpression| が |ObjectLiteral| または |ArrayLiteral| の場合、|LeftHandSideExpression| は |AssignmentPattern| を覆っていなければならない。
          </li>
          <li>
            |LeftHandSideExpression| が |ObjectLiteral| でも |ArrayLiteral| でもない場合、|LeftHandSideExpression| の AssignmentTargetType が ~invalid~ なら構文エラー。
          </li>
        </ul>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |ForDeclaration| の BoundNames に *"let"* が含まれるなら構文エラー。
          </li>
          <li>
            |ForDeclaration| の BoundNames の任意要素が |Statement| の VarDeclaredNames にも現れるなら構文エラー。
          </li>
          <li>
            |ForDeclaration| の BoundNames に重複があるなら構文エラー。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-isdestructuring" oldids="sec-static-semantics-static-semantics-isdestructuring,sec-for-in-and-for-of-statements-static-semantics-isdestructuring" type="sdo">
        <h1>静的意味論: IsDestructuring ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>
        <emu-alg>
          1. |PrimaryExpression| が |ObjectLiteral| または |ArrayLiteral| なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            MemberExpression `.` PrivateIdentifier

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
            OptionalExpression
        </emu-grammar>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| の IsDestructuring を返す。
        </emu-alg>
        <emu-grammar>ForBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>ForBinding : BindingPattern</emu-grammar>
        <emu-alg>
          1. *true* を返す。
        </emu-alg>
        <emu-note>
          <p>この節は 付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginitialization" oldids="sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization" type="sdo">
        <h1>
          実行時意味論: ForDeclarationBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          ): ~unused~ を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>_environment_ に *undefined* を渡すのは PutValue による代入を用いるべきことを示す。これは `var` 文や一部非 strict 関数（<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref> 参照）の仮引数リストの場合で、これらでは初期化子評価前にレキシカル束縛がホイストされ事前初期化される。</p>
        </emu-note>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| の BindingInitialization(_value_, _environment_) を ? 付きで返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginstantiation" oldids="sec-runtime-semantics-bindinginstantiation" type="sdo">
        <h1>
          実行時意味論: ForDeclarationBindingInstantiation (
          _environment_: a Declarative Environment Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| の BoundNames の各 _name_ について:
            1. |LetOrConst| の IsConstantDeclaration が *true* なら:
              1. ! _environment_.CreateImmutableBinding(_name_, *true*) を実行。
            1. それ以外:
              1. ! _environment_.CreateMutableBinding(_name_, *false*) を実行。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofloopevaluation" oldids="sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          実行時意味論: ForInOfLoopEvaluation (
          _labelSet_: a List of Strings,
          ): ECMAScript 言語値を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~) とする。
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_) を返す。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~) とする。
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_) を返す。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~) とする。
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_) を返す。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~) とする。
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_) を返す。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~) とする。
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_) を返す。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~) とする。
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_) を返す。
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~) とする。
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~) を返す。
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~) とする。
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~) を返す。
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ を ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~) とする。
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~) を返す。
        </emu-alg>
        <emu-note>
          <p>この節は 付録 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> により拡張される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofheadevaluation" type="abstract operation" oldids="sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind">
        <h1>
          ForIn/OfHeadEvaluation (
            _uninitializedBoundNames_: a List of Strings,
            _expr_: an |Expression| Parse Node or an |AssignmentExpression| Parse Node,
            _iterationKind_: ~enumerate~, ~iterate~, or ~async-iterate~,
          ): Iterator Record を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _oldEnv_ を現在実行中コンテキストの LexicalEnvironment とする。
          1. _uninitializedBoundNames_ が空でないなら:
            1. Assert: 重複はない。
            1. _newEnv_ を NewDeclarativeEnvironment(_oldEnv_) とする。
            1. _uninitializedBoundNames_ の各 String _name_ について:
              1. ! _newEnv_.CreateMutableBinding(_name_, *false*) を実行。
            1. 実行中コンテキストの LexicalEnvironment を _newEnv_ に設定。
          1. _exprRef_ を _expr_ の Evaluation の Completion とする。
          1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
          1. _exprValue_ を ? GetValue(? _exprRef_) とする。
          1. _iterationKind_ が ~enumerate~ なら:
            1. _exprValue_ が *undefined* または *null* なら:
              1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ } を返す。
            1. _obj_ を ! ToObject(_exprValue_) とする。
            1. _iterator_ を EnumerateObjectProperties(_obj_) とする。
            1. _nextMethod_ を ! GetV(_iterator_, *"next"*) とする。
            1. Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* } を返す。
          1. それ以外:
            1. Assert: _iterationKind_ は ~iterate~ 又は ~async-iterate~。
            1. _iterationKind_ が ~async-iterate~ なら _iteratorKind_ を ~async~ とする。そうでなければ ~sync~。
            1. ? GetIterator(_exprValue_, _iteratorKind_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" type="abstract operation">
        <h1>
          ForIn/OfBodyEvaluation (
            _lhs_: a Parse Node,
            _stmt_: a |Statement| Parse Node,
            _iteratorRecord_: an Iterator Record,
            _iterationKind_: ~enumerate~ or ~iterate~,
            _lhsKind_: ~assignment~, ~var-binding~, or ~lexical-binding~,
            _labelSet_: a List of Strings,
            optional _iteratorKind_: ~sync~ or ~async~,
          ): ECMAScript 言語値を含む normal completion または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _iteratorKind_ が与えられていなければ ~sync~ とする。
          1. _oldEnv_ を現在実行中コンテキストの LexicalEnvironment とする。
          1. _V_ を *undefined* とする。
          1. _destructuring_ を IsDestructuring of _lhs_ とする。
          1. _destructuring_ が *true* かつ _lhsKind_ が ~assignment~ なら:
            1. Assert: _lhs_ は |LeftHandSideExpression|。
            1. _assignmentPattern_ を _lhs_ が覆う |AssignmentPattern| とする。
          1. 繰り返し:
            1. _nextResult_ を ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]) とする。
            1. _iteratorKind_ が ~async~ なら _nextResult_ を ? Await(_nextResult_) とする。
            1. _nextResult_ が Object でなければ *TypeError* を throw。
            1. _done_ を ? IteratorComplete(_nextResult_) とする。
            1. _done_ が *true* なら _V_ を返す。
            1. _nextValue_ を ? IteratorValue(_nextResult_) とする。
            1. _lhsKind_ が ~assignment~ または ~var-binding~ の場合:
              1. _destructuring_ が *true* なら:
                1. _lhsKind_ が ~assignment~ なら:
                  1. _status_ を DestructuringAssignmentEvaluation of _assignmentPattern_ (_nextValue_ 引数) の Completion。
                1. それ以外:
                  1. Assert: _lhsKind_ は ~var-binding~。
                  1. Assert: _lhs_ は |ForBinding|。
                  1. _status_ を |ForBinding| の BindingInitialization(_nextValue_, *undefined*) の Completion。
              1. それ以外:
                1. _lhsRef_ を _lhs_ の Evaluation の Completion（繰り返し行われ得る）とする。
                1. _lhsKind_ が ~assignment~ かつ _lhs_ の AssignmentTargetType が ~web-compat~ なら *ReferenceError* を throw。
                1. _lhsRef_ が abrupt completion なら:
                  1. _status_ を _lhsRef_ とする。
                1. それ以外:
                  1. _status_ を Completion(PutValue(_lhsRef_.[[Value]], _nextValue_)) とする。
            1. それ以外:
              1. Assert: _lhsKind_ は ~lexical-binding~。
              1. Assert: _lhs_ は |ForDeclaration|。
              1. _iterationEnv_ を NewDeclarativeEnvironment(_oldEnv_) とする。
              1. ForDeclarationBindingInstantiation of _lhs_ (_iterationEnv_) を実行。
              1. 実行中コンテキストの LexicalEnvironment を _iterationEnv_ に設定。
              1. _destructuring_ が *true* なら:
                1. _status_ を ForDeclarationBindingInitialization of _lhs_ (_nextValue_, _iterationEnv_) の Completion。
              1. それ以外:
                1. Assert: _lhs_ は単一名を束縛する。
                1. _lhsName_ を _lhs_ の BoundNames の唯一の要素とする。
                1. _lhsRef_ を ! ResolveBinding(_lhsName_) とする。
                1. _status_ を Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_)) とする。
            1. _status_ が abrupt completion なら:
              1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
              1. _iteratorKind_ が ~async~ なら ? AsyncIteratorClose(_iteratorRecord_, _status_) を返す。
              1. _iterationKind_ が ~enumerate~ なら:
                1. ? _status_ を返す。
              1. それ以外:
                1. Assert: _iterationKind_ は ~iterate~。
                1. ? IteratorClose(_iteratorRecord_, _status_) を返す。
            1. _result_ を |Statement| の Evaluation の Completion とする。
            1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
            1. LoopContinues(_result_, _labelSet_) が *false* なら:
              1. _iterationKind_ が ~enumerate~ なら:
                1. ? UpdateEmpty(_result_, _V_) を返す。
              1. それ以外:
                1. Assert: _iterationKind_ は ~iterate~。
                1. _status_ を Completion(UpdateEmpty(_result_, _V_)) とする。
                1. _iteratorKind_ が ~async~ なら ? AsyncIteratorClose(_iteratorRecord_, _status_) を返す。
                1. ? IteratorClose(_iteratorRecord_, _status_) を返す。
            1. _result_.[[Value]] が ~empty~ でなければ _V_ を _result_.[[Value]] に設定。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-evaluation" type="sdo">
        <h1>実行時意味論: 評価</h1>
        <emu-grammar>
          BindingIdentifier :
            Identifier
            `yield`
            `await`
        </emu-grammar>
        <emu-alg>
          1. _bindingId_ を |BindingIdentifier| の StringValue とする。
          1. ? ResolveBinding(_bindingId_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-enumerate-object-properties" type="abstract operation">
        <h1>
          EnumerateObjectProperties (
            _O_: an Object,
          ): 反復子 (iterator object)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_ の列挙可能なプロパティの String キーを反復する `next` メソッドを持つ反復子オブジェクトを返す。この反復子は ECMAScript コードから直接アクセスできない。列挙の機構と順序は下記規則に従う限り規定されない。
        </emu-alg>
        <p>反復子の `throw` および `return` メソッドは *null* で呼ばれない。`next` メソッドはプロパティキーを返すべきか判定する。返されるキーは Symbol を含まない。列挙中にターゲットオブジェクトのプロパティが削除されることがある。削除されたプロパティは無視される。列挙中に新規プロパティが追加されても処理される保証はない。いかなる列挙でも同じプロパティ名は高々一度だけ返される。</p>
        <p>ターゲットオブジェクトの列挙はそのプロトタイプ、さらにそのプロトタイプ…と再帰的に行う。ただし既に `next` により処理済みの名前と同名のプロトタイプ上のプロパティは処理しない。処理済み判定に [[Enumerable]] 属性値は考慮しない。プロトタイプオブジェクトの列挙可能プロパティ名取得には EnumerateObjectProperties をそのプロトタイプに対し呼び出す。ターゲットオブジェクトの own プロパティキーは [[OwnPropertyKeys]] 内部メソッド呼出しで取得し、属性は [[GetOwnProperty]] 内部メソッド呼出しで取得する。</p>
        <p>加えて _O_ およびそのプロトタイプ連鎖上のいずれも Proxy, TypedArray, module namespace, 実装提供の exotic object でないなら、以下のいずれかが起こるまで反復子は CreateForInIterator(_O_) によるものと同様に振る舞わねばならない:</p>
        <ul>
          <li>_O_ またはプロトタイプ連鎖上のオブジェクトの [[Prototype]] 値が変化</li>
          <li>_O_ または連鎖上オブジェクトからプロパティが削除</li>
          <li>_O_ のプロトタイプ連鎖上のオブジェクトにプロパティが追加</li>
          <li>_O_ または連鎖上オブジェクトのプロパティの [[Enumerable]] が変化</li>
        </ul>

        <emu-note>
          <p>実装は <emu-xref href="#sec-%foriniteratorprototype%.next"></emu-xref> のアルゴリズムを直接実装する必要はない。上記制約が破られない限り挙動が一致する任意実装を選べる。</p>
          <p>以下はこれら規則に従う ECMAScript generator function の参考定義である:</p>
          <pre><code class="javascript">
            function* EnumerateObjectProperties(obj) {
              const visited = new Set();
              for (const key of Reflect.ownKeys(obj)) {
                if (typeof key === "symbol") continue;
                const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                if (desc) {
                  visited.add(key);
                  if (desc.enumerable) yield key;
                }
              }
              const proto = Reflect.getPrototypeOf(obj);
              if (proto === null) return;
              for (const protoKey of EnumerateObjectProperties(proto)) {
                if (!visited.has(protoKey)) yield protoKey;
              }
            }
          </code></pre>
        </emu-note>
        <emu-note>
          CreateForInIterator との一致が不要な exotic object のリストは、歴史的に挙動差異があり他については一致していたため選択された。
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-iterator-objects">
        <h1>For-In 反復子オブジェクト</h1>
        <p><dfn variants="For-In Iterator object,For-In Iterator objects">For-In Iterator</dfn> は特定オブジェクト上の特定の列挙を表すオブジェクトである。ECMAScript コードから直接アクセスされず、EnumerateObjectProperties の挙動説明のためのみ存在する。</p>

        <emu-clause id="sec-createforiniterator" type="abstract operation">
          <h1>
            CreateForInIterator (
              _object_: an Object,
            ): For-In Iterator
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_object_ の own および継承された列挙可能な文字列プロパティを特定順序で反復する For-In Iterator オブジェクトを生成する。</dd>
          </dl>
          <emu-alg>
            1. _iterator_ を OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] ») とする。
            1. _iterator_.[[Object]] を _object_ に設定。
            1. _iterator_.[[ObjectWasVisited]] を *false* に設定。
            1. _iterator_.[[VisitedKeys]] を空 List に設定。
            1. _iterator_.[[RemainingKeys]] を空 List に設定。
            1. _iterator_ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%foriniteratorprototype%-object">
          <h1>%ForInIteratorPrototype% オブジェクト</h1>
          <p><dfn>%ForInIteratorPrototype%</dfn> オブジェクト:</p>
          <ul>
            <li>全 For-In Iterator オブジェクトが継承するプロパティを持つ。</li>
            <li>通常のオブジェクトである。</li>
            <li>[[Prototype]] 内部スロットの値は %Iterator.prototype%。</li>
            <li>ECMAScript コードから直接アクセスされない。</li>
            <li>以下のプロパティを持つ。</li>
          </ul>

          <emu-clause id="sec-%foriniteratorprototype%.next">
            <h1>%ForInIteratorPrototype%.next ( )</h1>
            <emu-alg>
              1. _O_ を *this* 値とする。
              1. Assert: _O_ は Object。
              1. Assert: _O_ は For-In Iterator インスタンスの内部スロットを全て持つ (<emu-xref href="#sec-properties-of-for-in-iterator-instances"></emu-xref>)。
              1. _object_ を _O_.[[Object]] とする。
              1. 繰り返し:
                1. _O_.[[ObjectWasVisited]] が *false* なら:
                  1. _keys_ を ? <emu-meta effects="user-code">_object_.[[OwnPropertyKeys]]()</emu-meta> とする。
                  1. _keys_ の各 _key_ について:
                    1. _key_ が String なら:
                      1. _O_.[[RemainingKeys]] に _key_ を追加。
                  1. _O_.[[ObjectWasVisited]] を *true* に設定。
                1. _O_.[[RemainingKeys]] が空でない間の繰り返し:
                  1. _r_ を _O_.[[RemainingKeys]] の先頭要素とする。
                  1. 先頭要素を削除。
                  1. _O_.[[VisitedKeys]] が _r_ を含まないなら:
                    1. _desc_ を ? <emu-meta effects="user-code">_object_.[[GetOwnProperty]]</emu-meta>(_r_) とする。
                    1. _desc_ が *undefined* でなければ:
                      1. _O_.[[VisitedKeys]] に _r_ を追加。
                      1. _desc_.[[Enumerable]] が *true* なら CreateIteratorResultObject(_r_, *false*) を返す。
                1. _object_ を ? <emu-meta effects="user-code">_object_.[[GetPrototypeOf]]()</emu-meta> とする。
                1. _O_.[[Object]] を _object_ に設定。
                1. _O_.[[ObjectWasVisited]] を *false* に設定。
                1. _object_ が *null* なら CreateIteratorResultObject(*undefined*, *true*) を返す。
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-properties-of-for-in-iterator-instances">
          <h1>For-In Iterator インスタンスのプロパティ</h1>
          <p>For-In Iterator インスタンスは %ForInIteratorPrototype% からプロパティを継承する通常オブジェクトであり、<emu-xref href="#table-for-in-iterator-instance-slots"></emu-xref> に列挙する内部スロットで初期化される。</p>
          <emu-table id="table-for-in-iterator-instance-slots" caption="For-In Iterator インスタンスの内部スロット">
            <table>
              <thead>
                <tr>
                  <th>
                    Internal Slot
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    説明 (Description)
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  [[Object]]
                </td>
                <td>
                  an Object
                </td>
                <td>
                  プロパティを列挙中のオブジェクト値。
                </td>
              </tr>
              <tr>
                <td>
                  [[ObjectWasVisited]]
                </td>
                <td>
                  a Boolean
                </td>
                <td>
                  既に [[OwnPropertyKeys]] を呼び出したなら *true*、そうでなければ *false*。
                </td>
              </tr>
              <tr>
                <td>
                  [[VisitedKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  これまでにこの反復子が出力した値。
                </td>
              </tr>
              <tr>
                <td>
                  [[RemainingKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  現在のオブジェクトで未出力の値（プロトタイプ列挙前。プロトタイプが *null* でなければ）。
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-continue-statement">
    <h1>`continue` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ContinueStatement[Yield, Await] :
        `continue` `;`
        `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-continue-statement-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>
        ContinueStatement :
          `continue` `;`
          `continue` LabelIdentifier `;`
      </emu-grammar>
      <ul>
        <li>
          この |ContinueStatement| が（関数や `static` 初期化ブロック境界を越えずに）直接または間接的に |IterationStatement| 内にネストしていないなら構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-continue-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ } を返す。
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _label_ を |LabelIdentifier| の StringValue とする。
        1. Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ } を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-break-statement">
    <h1>`break` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      BreakStatement[Yield, Await] :
        `break` `;`
        `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-break-statement-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <ul>
        <li>
          この |BreakStatement| が（関数や `static` 初期化ブロック境界を越えずに）直接または間接的に |IterationStatement| か |SwitchStatement| 内にネストしていないなら構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-break-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ } を返す。
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _label_ を |LabelIdentifier| の StringValue とする。
        1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ } を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-return-statement">
    <h1>`return` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ReturnStatement[Yield, Await] :
        `return` `;`
        `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>`return` 文は関数の実行を停止し、通常は呼出し元に値を返す。|Expression| が省略された場合戻り値は *undefined*。存在する場合その値を返す。`try` ブロック内など文脈によっては必ずしも呼出し元に値を返さない（`finally` で上書きされる等）。</p>
    </emu-note>

    <emu-clause id="sec-return-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>ReturnStatement : `return` `;`</emu-grammar>
      <emu-alg>
        1. ReturnCompletion(*undefined*) を返す。
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
        1. _exprValue_ を ? GetValue(_exprRef_) とする。
        1. GetGeneratorKind() が ~async~ なら _exprValue_ を ? Await(_exprValue_) に設定。
        1. ReturnCompletion(_exprValue_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-with-statement" legacy>
    <h1>`with` 文</h1>
    <emu-note>
      <p>レガシー `with` 文の使用は新しい ECMAScript コードでは推奨されない。<emu-xref href="#sec-destructuring-assignment">分割代入</emu-xref> など strict / 非 strict 両方で許容される代替を検討せよ。</p>
    </emu-note>

    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      WithStatement[Yield, Await, Return] :
        `with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    </emu-grammar>
    <emu-note>
      <p>`with` 文は計算されたオブジェクトの Object Environment Record を実行中コンテキストのレキシカル環境に追加し、この拡張環境で Statement を実行し、その後元の環境を復元する。</p>
    </emu-note>

    <emu-clause id="sec-with-statement-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          IsStrict(this production) が *true* なら構文エラー。
        </li>
        <li>
          |Statement| について IsLabelledFunction が *true* なら構文エラー。
        </li>
      </ul>
      <emu-note>
        <p>2 番目の規則は <emu-xref href="#sec-labelled-function-declarations"></emu-xref> の拡張が実装される場合のみ適用。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-with-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _val_ を |Expression| の Evaluation を ? 付きで行った結果とする。
        1. _obj_ を ? ToObject(? GetValue(_val_)) とする。
        1. _oldEnv_ を実行中コンテキストの LexicalEnvironment とする。
        1. _newEnv_ を NewObjectEnvironment(_obj_, *true*, _oldEnv_) とする。
        1. 実行中コンテキストの LexicalEnvironment を _newEnv_ に設定。
        1. _C_ を |Statement| の Evaluation の Completion とする。
        1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
        1. ? UpdateEmpty(_C_, *undefined*) を返す。
      </emu-alg>
      <emu-note>
        <p>埋め込まれた |Statement| をどのように抜けても（通常終了・abrupt completion・例外）LexicalEnvironment は常に元に戻る。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>`switch` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      SwitchStatement[Yield, Await, Return] :
        `switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]

      CaseBlock[Yield, Await, Return] :
        `{` CaseClauses[?Yield, ?Await, ?Return]? `}`
        `{` CaseClauses[?Yield, ?Await, ?Return]? DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]? `}`

      CaseClauses[Yield, Await, Return] :
        CaseClause[?Yield, ?Await, ?Return]
        CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]

      CaseClause[Yield, Await, Return] :
        `case` Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await, ?Return]?

      DefaultClause[Yield, Await, Return] :
        `default` `:` StatementList[?Yield, ?Await, ?Return]?
    </emu-grammar>

    <emu-clause id="sec-switch-statement-static-semantics-early-errors" oldids="sec-switch-duplicates-allowed-static-semantics">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <ul>
        <li>
          <p>|CaseBlock| の LexicallyDeclaredNames に重複があるなら構文エラー<span normative-optional>。ただしホストが Web ブラウザ又は <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> をサポートし、以下を全て満たす場合は除く:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) が *false*。</li>
            <li>重複は FunctionDeclarations のみで束縛される。</li>
          </ul>
        </li>
        <li>
          |CaseBlock| の LexicallyDeclaredNames の任意要素が |CaseBlock| の VarDeclaredNames にも現れるなら構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseblockevaluation" type="sdo">
      <h1>
        実行時意味論: CaseBlockEvaluation (
        _input_: an ECMAScript language value,
        ): ECMAScript 言語値を含む normal completion または abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *undefined* を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses `}`</emu-grammar>
      <emu-alg>
        1. _V_ を *undefined* とする。
        1. _A_ を |CaseClauses| 内の |CaseClause| 項目（ソース順）の List とする。
        1. _found_ を *false* とする。
        1. 各 |CaseClause| _C_ について:
          1. _found_ が *false* なら:
            1. _found_ を ? CaseClauseIsSelected(_C_, _input_) に設定。
          1. _found_ が *true* なら:
            1. _R_ を _C_ の Evaluation の Completion とする。
            1. _R_.[[Value]] が ~empty~ でなければ _V_ を _R_.[[Value]] に設定。
            1. _R_ が abrupt completion なら ? UpdateEmpty(_R_, _V_) を返す。
        1. _V_ を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. _V_ を *undefined* とする。
        1. 最初の |CaseClauses| が存在するなら:
          1. _A_ をその |CaseClause| 項目（ソース順）List とする。
        1. それ以外:
          1. _A_ を空 List とする。
        1. _found_ を *false* とする。
        1. _A_ の各 |CaseClause| _C_ について:
          1. _found_ が *false* なら:
            1. _found_ を ? CaseClauseIsSelected(_C_, _input_) に設定。
          1. _found_ が *true* なら:
            1. _R_ を _C_ の Evaluation の Completion とする。
            1. _R_.[[Value]] が ~empty~ でなければ _V_ を _R_.[[Value]] に設定。
            1. _R_ が abrupt completion なら ? UpdateEmpty(_R_, _V_) を返す。
        1. _foundInB_ を *false* とする。
        1. 二番目の |CaseClauses| が存在するなら:
          1. _B_ をその |CaseClause| 項目（ソース順）List とする。
        1. それ以外:
          1. _B_ を空 List とする。
        1. _found_ が *false* なら:
          1. _B_ の各 |CaseClause| _C_ について:
            1. _foundInB_ が *false* なら:
              1. _foundInB_ を ? CaseClauseIsSelected(_C_, _input_) に設定。
            1. _foundInB_ が *true* なら:
              1. _R_ を |CaseClause| _C_ の Evaluation の Completion とする。
              1. _R_.[[Value]] が ~empty~ でなければ _V_ を _R_.[[Value]] に設定。
              1. _R_ が abrupt completion なら ? UpdateEmpty(_R_, _V_) を返す。
        1. _foundInB_ が *true* なら _V_ を返す。
        1. _defaultR_ を |DefaultClause| の Evaluation の Completion とする。
        1. _defaultR_.[[Value]] が ~empty~ でなければ _V_ を _defaultR_.[[Value]] に設定。
        1. _defaultR_ が abrupt completion なら ? UpdateEmpty(_defaultR_, _V_) を返す。
        1. 注: ここから二番目の |CaseClauses| を再度全走査する。
        1. _B_ の各 |CaseClause| _C_ について:
          1. _R_ を |CaseClause| _C_ の Evaluation の Completion とする。
          1. _R_.[[Value]] が ~empty~ でなければ _V_ を _R_.[[Value]] に設定。
          1. _R_ が abrupt completion なら ? UpdateEmpty(_R_, _V_) を返す。
        1. _V_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseclauseisselected" type="abstract operation" oldids="sec-runtime-semantics-caseselectorevaluation">
      <h1>
        CaseClauseIsSelected (
          _C_: a |CaseClause| Parse Node,
          _input_: an ECMAScript language value,
        ): Boolean を含む normal completion または abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_C_ が _input_ にマッチするか判定する。</dd>
      </dl>
      <emu-alg>
        1. Assert: _C_ は <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar> のインスタンス。
        1. _exprRef_ を _C_ の |Expression| の Evaluation を ? 付きで行った結果とする。
        1. _clauseSelector_ を ? GetValue(_exprRef_) とする。
        1. IsStrictlyEqual(_input_, _clauseSelector_) を返す。
      </emu-alg>
      <emu-note>
        <p>この操作は _C_ の |StatementList| を実行しない。|CaseBlock| アルゴリズムは戻り値によりどの |StatementList| から実行開始するかを決定する。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
        1. _switchValue_ を ? GetValue(_exprRef_) とする。
        1. _oldEnv_ を現在実行中コンテキストの LexicalEnvironment とする。
        1. _blockEnv_ を NewDeclarativeEnvironment(_oldEnv_) とする。
        1. BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_) を実行。
        1. 実行中コンテキストの LexicalEnvironment を _blockEnv_ に設定。
        1. _R_ を CaseBlockEvaluation of |CaseBlock| (引数 _switchValue_) の Completion とする。
        1. 実行中コンテキストの LexicalEnvironment を _oldEnv_ に戻す。
        1. _R_ を返す。
      </emu-alg>
      <emu-note>
        <p>|SwitchStatement| をどのように抜けても LexicalEnvironment は常に元に戻る。</p>
      </emu-note>
      <emu-grammar>CaseClause : `case` Expression `:`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の Evaluation を ? 付きで返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| の Evaluation を ? 付きで返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-labelled-statements">
    <h1>ラベル付き文 (Labelled Statements)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      LabelledStatement[Yield, Await, Return] :
        LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]

      LabelledItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        FunctionDeclaration[?Yield, ?Await, ~Default]
    </emu-grammar>
    <emu-note>
      <p>|Statement| はラベルで前置できる。ラベル付き文はラベル付き `break` / `continue` と組み合わせてのみ利用され、ECMAScript には `goto` はない。|Statement| は |LabelledStatement| の一部となり再帰的にネスト可能。その導入されたラベル集合を「current label set」と呼ぶ。</p>
    </emu-note>

    <emu-clause id="sec-labelled-statements-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <ul>
        <li>
          この生成規則にマッチするソーステキストが存在する場合<span normative-optional>、そのソーステキストが非 strict コードでありホストが <emu-xref href="#sec-labelled-function-declarations" title></emu-xref> をサポートする場合を除き</span>構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-islabelledfunction" type="abstract operation">
      <h1>
        静的意味論: IsLabelledFunction (
        _stmt_: a |Statement| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _stmt_ が |LabelledStatement| でなければ *false* を返す。
        1. _item_ を _stmt_ の |LabelledItem| とする。
        1. _item_ が <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar> なら *true* を返す。
        1. _subStmt_ を _item_ の |Statement| とする。
        1. IsLabelledFunction(_subStmt_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. この |LabelledStatement| の LabelledEvaluation (引数 « ») を ? 付きで返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-labelledevaluation" oldids="sec-statement-semantics-runtime-semantics-labelledevaluation,sec-labelled-statements-runtime-semantics-labelledevaluation" type="sdo">
      <h1>
        実行時意味論: LabelledEvaluation (
        _labelSet_: a List of Strings,
        ): ECMAScript 言語値または ~empty~ を含む normal completion あるいは abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ を LoopEvaluation of |IterationStatement| (_labelSet_) の Completion とする。
        1. _stmtResult_ が break completion なら:
          1. _stmtResult_.[[Target]] が ~empty~ なら:
            1. _stmtResult_.[[Value]] が ~empty~ なら _stmtResult_ を NormalCompletion(*undefined*) に設定。
            1. それ以外は NormalCompletion(_stmtResult_.[[Value]]) に設定。
        1. ? _stmtResult_ を返す。
      </emu-alg>
      <emu-grammar>BreakableStatement : SwitchStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ を |SwitchStatement| の Evaluation の Completion とする。
        1. _stmtResult_ が break completion なら:
          1. _stmtResult_.[[Target]] が ~empty~ なら:
            1. _stmtResult_.[[Value]] が ~empty~ なら _stmtResult_ を NormalCompletion(*undefined*) に、そうでなければ NormalCompletion(_stmtResult_.[[Value]]) に設定。
        1. ? _stmtResult_ を返す。
      </emu-alg>
      <emu-note>
        <p>|BreakableStatement| は無ラベル |BreakStatement| により脱出可能な文である。</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_ を |LabelIdentifier| の StringValue とする。
        1. _newLabelSet_ を _labelSet_ と « _label_ » のリスト連結とする。
        1. _stmtResult_ を |LabelledItem| の LabelledEvaluation(_newLabelSet_) の Completion とする。
        1. _stmtResult_ が break completion かつ _stmtResult_.[[Target]] が _label_ なら:
          1. _stmtResult_ を NormalCompletion(_stmtResult_.[[Value]]) に設定。
        1. ? _stmtResult_ を返す。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| の Evaluation を ? 付きで返す。
      </emu-alg>
      <emu-grammar>
        Statement :
          BlockStatement
          VariableStatement
          EmptyStatement
          ExpressionStatement
          IfStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          WithStatement
          ThrowStatement
          TryStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. |Statement| の Evaluation を ? 付きで返す。
      </emu-alg>
      <emu-note>
        <p>|Statement| のうち LabelledEvaluation に特別な意味論を持つのは |BreakableStatement| と |LabelledStatement| のみ。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-throw-statement">
    <h1>`throw` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ThrowStatement[Yield, Await] :
        `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-throw-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>ThrowStatement : `throw` Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |Expression| の Evaluation を ? 付きで行った結果とする。
        1. _exprValue_ を ? GetValue(_exprRef_) とする。
        1. ThrowCompletion(_exprValue_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-try-statement">
    <h1>`try` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      TryStatement[Yield, Await, Return] :
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]

      Catch[Yield, Await, Return] :
        `catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]
        `catch` Block[?Yield, ?Await, ?Return]

      Finally[Yield, Await, Return] :
        `finally` Block[?Yield, ?Await, ?Return]

      CatchParameter[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        BindingPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`try` 文は例外（実行時エラーや `throw`）が発生し得るコードブロックを囲む。`catch` 節は例外処理コードを提供し、捕捉時その |CatchParameter| に例外が束縛される。</p>
    </emu-note>

    <emu-clause id="sec-try-statement-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>
          |CatchParameter| の BoundNames に重複があれば構文エラー。
        </li>
        <li>
          |CatchParameter| の BoundNames の任意要素が |Block| の LexicallyDeclaredNames にも現れるなら構文エラー。
        </li>
        <li>
          |CatchParameter| の BoundNames の任意要素が |Block| の VarDeclaredNames にも現れるなら構文エラー<span normative-optional>。ただし |CatchParameter| が <emu-grammar>CatchParameter : BindingIdentifier</emu-grammar> であり、ホストが <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> をサポートする場合は除く。</span>
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-catchclauseevaluation" type="sdo">
      <h1>
        実行時意味論: CatchClauseEvaluation (
        _thrownValue_: an ECMAScript language value,
        ): ECMAScript 言語値または ~empty~ を含む normal completion あるいは abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. _oldEnv_ を実行中コンテキストの LexicalEnvironment とする。
        1. _catchEnv_ を NewDeclarativeEnvironment(_oldEnv_) とする。
        1. |CatchParameter| の BoundNames の各 _argName_ について:
          1. ! _catchEnv_.CreateMutableBinding(_argName_, *false*) を実行。
        1. 実行中コンテキストの LexicalEnvironment を _catchEnv_ に設定。
        1. _status_ を |CatchParameter| の BindingInitialization(_thrownValue_, _catchEnv_) の Completion とする。
        1. _status_ が abrupt completion なら:
          1. LexicalEnvironment を _oldEnv_ に戻す。
          1. ? _status_ を返す。
        1. _B_ を |Block| の Evaluation の Completion とする。
        1. LexicalEnvironment を _oldEnv_ に戻す。
        1. ? _B_ を返す。
      </emu-alg>
      <emu-grammar>Catch : `catch` Block</emu-grammar>
      <emu-alg>
        1. |Block| の Evaluation を ? 付きで返す。
      </emu-alg>
      <emu-note>
        <p>|Block| をどのように抜けても LexicalEnvironment は常に元に復元される。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-try-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _B_ を |Block| の Evaluation の Completion とする。
        1. _B_ が throw completion なら _C_ を CatchClauseEvaluation of |Catch| (_B_.[[Value]] 引数) の Completion、そうでなければ _C_ を _B_ とする。
        1. ? UpdateEmpty(_C_, *undefined*) を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _B_ を |Block| の Evaluation の Completion とする。
        1. _F_ を |Finally| の Evaluation の Completion とする。
        1. _F_ が normal completion なら _F_ を _B_ に設定。
        1. ? UpdateEmpty(_F_, *undefined*) を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _B_ を |Block| の Evaluation の Completion とする。
        1. _B_ が throw completion なら _C_ を CatchClauseEvaluation of |Catch| (_B_.[[Value]] 引数) の Completion、そうでなければ _C_ を _B_ とする。
        1. _F_ を |Finally| の Evaluation の Completion とする。
        1. _F_ が normal completion なら _F_ を _C_ に設定。
        1. ? UpdateEmpty(_F_, *undefined*) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-debugger-statement">
    <h1>`debugger` 文</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      DebuggerStatement :
        `debugger` `;`
    </emu-grammar>

    <emu-clause id="sec-debugger-statement-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-note>
        <p>|DebuggerStatement| の評価は、デバッガ下で実行時にブレークポイントを発生させることを実装に許す。デバッガ非存在または非活性なら可視効果はない。</p>
      </emu-note>
      <emu-grammar>DebuggerStatement : `debugger` `;`</emu-grammar>
      <emu-alg>
        1. 実装定義のデバッグ機能が利用可能かつ有効なら:
          1. 実装定義のデバッグ動作を実行。
          1. 新しい実装定義 Completion Record を返す。
        1. それ以外:
          1. ~empty~ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript 言語: 関数とクラス</h1>
  <emu-note>
    <p>様々な ECMAScript 言語要素は ECMAScript 関数オブジェクト (<emu-xref href="#sec-ecmascript-function-objects"></emu-xref>) を生成する。これらの関数の評価は、その [[Call]] 内部メソッド (<emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>) の実行から開始される。</p>
  </emu-note>

  <emu-clause id="sec-parameter-lists">
    <h1>仮引数リスト (Parameter Lists)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      UniqueFormalParameters[Yield, Await] :
        FormalParameters[?Yield, ?Await]

      FormalParameters[Yield, Await] :
        [empty]
        FunctionRestParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,`
        FormalParameterList[?Yield, ?Await] `,` FunctionRestParameter[?Yield, ?Await]

      FormalParameterList[Yield, Await] :
        FormalParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]

      FunctionRestParameter[Yield, Await] :
        BindingRestElement[?Yield, ?Await]

      FormalParameter[Yield, Await] :
        BindingElement[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-parameter-lists-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>
      <ul>
        <li>
          |FormalParameters| の BoundNames に重複要素が含まれる場合は構文エラーである。
        </li>
      </ul>
      <emu-grammar>FormalParameters : FormalParameterList</emu-grammar>
      <ul>
        <li>
          |FormalParameterList| の IsSimpleParameterList が *false* であり、かつ |FormalParameterList| の BoundNames に重複要素が含まれる場合は構文エラーである。
        </li>
      </ul>
      <emu-note>
        <p>同一の |BindingIdentifier| が |FormalParameterList| 内に複数回出現することが許されるのは、パラメータリストが「単純 (simple)」であり、かつ strict mode コード内で定義されていない関数の場合に限られる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsexpression" oldids="sec-destructuring-binding-patterns-static-semantics-containsexpression,sec-function-definitions-static-semantics-containsexpression,sec-arrow-function-definitions-static-semantics-containsexpression,sec-async-arrow-function-definitions-static-semantics-ContainsExpression" type="sdo">
      <h1>静的意味論: ContainsExpression ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ObjectBindingPattern :
          `{` `}`
          `{` BindingRestProperty `}`
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. |BindingPropertyList| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingRestElement| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. _has_ を |BindingElementList| の ContainsExpression とする。
        1. _has_ が *true* なら *true* を返す。
        1. |BindingRestElement| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. _has_ を |BindingPropertyList| の ContainsExpression とする。
        1. _has_ が *true* なら *true* を返す。
        1. |BindingProperty| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. _has_ を |BindingElementList| の ContainsExpression とする。
        1. _has_ が *true* なら *true* を返す。
        1. |BindingElisionElement| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. _has_ を |PropertyName| の IsComputedPropertyKey とする。
        1. _has_ が *true* なら *true* を返す。
        1. |BindingElement| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. |BindingPattern| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| の ContainsExpression が *true* なら *true* を返す。
        1. |FunctionRestParameter| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| の ContainsExpression が *true* なら *true* を返す。
        1. |FormalParameter| の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ を |CoverParenthesizedExpressionAndArrowParameterList| が覆う |ArrowFormalParameters| とする。
        1. _formals_ の ContainsExpression を返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-issimpleparameterlist" oldids="sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist,sec-function-definitions-static-semantics-issimpleparameterlist,sec-arrow-function-definitions-static-semantics-issimpleparameterlist,sec-async-arrow-function-definitions-static-semantics-IsSimpleParameterList" type="sdo">
      <h1>静的意味論: IsSimpleParameterList ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| の IsSimpleParameterList が *false* なら *false* を返す。
        1. |FormalParameter| の IsSimpleParameterList を返す。
      </emu-alg>
      <emu-grammar>FormalParameter : BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement| の IsSimpleParameterList を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ を |CoverParenthesizedExpressionAndArrowParameterList| が覆う |ArrowFormalParameters| とする。
        1. _formals_ の IsSimpleParameterList を返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. _head_ を |CoverCallExpressionAndAsyncArrowHead| が覆う |AsyncArrowHead| とする。
        1. _head_ の IsSimpleParameterList を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasinitializer" oldids="sec-destructuring-binding-patterns-static-semantics-hasinitializer,sec-function-definitions-static-semantics-hasinitializer" type="sdo">
      <h1>静的意味論: HasInitializer ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| の HasInitializer が *true* なら *true* を返す。
        1. |FormalParameter| の HasInitializer を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-expectedargumentcount" oldids="sec-function-definitions-static-semantics-expectedargumentcount,sec-arrow-function-definitions-static-semantics-expectedargumentcount,sec-method-definitions-static-semantics-expectedargumentcount,sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount" type="sdo">
      <h1>静的意味論: ExpectedArgumentCount ( ): 非負整数 (non-negative integer)</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FormalParameters :
          [empty]
          FunctionRestParameter
      </emu-grammar>
      <emu-alg>
        1. 0 を返す。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| の ExpectedArgumentCount を返す。
      </emu-alg>
      <emu-note>
        <p>|FormalParameterList| の ExpectedArgumentCount は、rest parameter または初期化子を持つ最初の |FormalParameter| の左側にある |FormalParameters| の個数である。初期化子を持つ最初のパラメータの後に初期化子を持たないパラメータを置くことは許されるが、そのようなパラメータはデフォルト値 *undefined* の任意 (optional) パラメータと見なされる。</p>
      </emu-note>
      <emu-grammar>FormalParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameter| の HasInitializer が *true* なら 0 を返す。
        1. 1 を返す。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. _count_ を |FormalParameterList| の ExpectedArgumentCount とする。
        1. |FormalParameterList| の HasInitializer が *true* または |FormalParameter| の HasInitializer が *true* なら _count_ を返す。
        1. _count_ + 1 を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 1 を返す。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ を |CoverParenthesizedExpressionAndArrowParameterList| が覆う |ArrowFormalParameters| とする。
        1. _formals_ の ExpectedArgumentCount を返す。
      </emu-alg>
      <emu-grammar>PropertySetParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameter| の HasInitializer が *true* なら 0 を返す。
        1. 1 を返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 1 を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-definitions">
    <h1>関数定義 (Function Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      FunctionDeclaration[Yield, Await, Default] :
        `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        [+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionExpression :
        `function` BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionBody[Yield, Await] :
        FunctionStatementList[?Yield, ?Await]

      FunctionStatementList[Yield, Await] :
        StatementList[?Yield, ?Await, +Return]?
    </emu-grammar>

    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          IsStrict(|FormalParameters|) が *true* のとき、<emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> の早期エラー規則を適用する。
        </li>
        <li>
          |BindingIdentifier| が存在し、かつ IsStrict(|BindingIdentifier|) が *true* のとき、その StringValue が *"eval"* または *"arguments"* なら構文エラー。
        </li>
        <li>
          FunctionBodyContainsUseStrict of |FunctionBody| が *true* かつ IsSimpleParameterList of |FormalParameters| が *false* なら構文エラー。
        </li>
        <li>
          |FormalParameters| の BoundNames の任意の要素が |FunctionBody| の LexicallyDeclaredNames にも現れるなら構文エラー。
        </li>
        <li>
          |FormalParameters| Contains |SuperProperty| が *true* なら構文エラー。
        </li>
        <li>
          |FunctionBody| Contains |SuperProperty| が *true* なら構文エラー。
        </li>
        <li>
          |FormalParameters| Contains |SuperCall| が *true* なら構文エラー。
        </li>
        <li>
          |FunctionBody| Contains |SuperCall| が *true* なら構文エラー。
        </li>
      </ul>
      <emu-note>
        <p>|FunctionBody| の LexicallyDeclaredNames には var 宣言や function 宣言で束縛された識別子は含まれない。</p>
      </emu-note>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <ul>
        <li>
          |FunctionStatementList| の LexicallyDeclaredNames に重複があれば構文エラー。
        </li>
        <li>
          |FunctionStatementList| の LexicallyDeclaredNames の任意の要素が VarDeclaredNames にも現れるなら構文エラー。
        </li>
        <li>
          ContainsDuplicateLabels of |FunctionStatementList| (引数 « ») が *true* なら構文エラー。
        </li>
        <li>
          ContainsUndefinedBreakTarget of |FunctionStatementList| (引数 « ») が *true* なら構文エラー。
        </li>
        <li>
          ContainsUndefinedContinueTarget of |FunctionStatementList| (引数 « » および « ») が *true* なら構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-functionbodycontainsusestrict" oldids="sec-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>静的意味論: FunctionBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. |FunctionBody| の Directive Prologue が Use Strict Directive を含むなら *true*、そうでなければ *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluatefunctionbody" oldids="sec-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        実行時意味論: EvaluateFunctionBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): return completion または throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) を実行する。
        1. ? |FunctionStatementList| の Evaluation を実行する。
        1. 注: 前の手順が normal completion なら評価は |FunctionStatementList| 終端まで進み終了している。
        1. ReturnCompletion(*undefined*) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionobject" oldids="sec-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        実行時意味論: InstantiateOrdinaryFunctionObject (
        _env_: an Environment Record,
        _privateEnv_: a PrivateEnvironment Record or *null*,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ を |BindingIdentifier| の StringValue とする。
        1. _sourceText_ を |FunctionDeclaration| にマッチしたソーステキストとする。
        1. _F_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, _name_) を実行。
        1. MakeConstructor(_F_) を実行。
        1. _F_ を返す。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _sourceText_ を |FunctionDeclaration| にマッチしたソーステキストとする。
        1. _F_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, *"default"*) を実行。
        1. MakeConstructor(_F_) を実行。
        1. _F_ を返す。
      </emu-alg>
      <emu-note>
        <p>匿名の |FunctionDeclaration| は `export default` 宣言の一部としてのみ出現でき、その関数コードは常に strict mode である。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionexpression" type="sdo">
      <h1>
        実行時意味論: InstantiateOrdinaryFunctionExpression (
        optional _name_: a property key or a Private Name,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ が存在しなければ *""* を代入。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |FunctionExpression| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. MakeConstructor(_closure_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ は存在しない。
        1. _name_ を |BindingIdentifier| の StringValue に設定。
        1. _outerEnv_ を実行中コンテキストの LexicalEnvironment とする。
        1. _funcEnv_ を NewDeclarativeEnvironment(_outerEnv_) とする。
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) を実行。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |FunctionExpression| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. MakeConstructor(_closure_) を実行。
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-note>
        <p>|FunctionExpression| 内の |BindingIdentifier| はその |FunctionBody| 内から参照でき、再帰呼び出しを可能にする。しかし |FunctionDeclaration| と異なり、|FunctionExpression| の |BindingIdentifier| は外側のスコープから参照できず、外側スコープに影響を与えない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Evaluation)</h1>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-note>
        <p>代替の意味論は FunctionDeclarationInstantiation のステップ <emu-xref href="#step-functiondeclarationinstantiation-alt-funcdecl-eval"></emu-xref>、GlobalDeclarationInstantiation のステップ <emu-xref href="#step-globaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref>、EvalDeclarationInstantiation のステップ <emu-xref href="#step-evaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref> にて <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> が提供する。</p>
      </emu-note>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>
        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. InstantiateOrdinaryFunctionExpression of |FunctionExpression| を返す。
      </emu-alg>
      <emu-note>
        <p>|FunctionDeclaration| または |FunctionExpression| により定義された全ての関数には自動的に *"prototype"* プロパティが作成され、その関数がコンストラクタとして利用される可能性を持たせる。</p>
      </emu-note>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined* を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-arrow-function-definitions">
    <h1>アロー関数定義 (Arrow Function Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ArrowFunction[In, Yield, Await] :
        ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

      ArrowParameters[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      ConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, ~Await]
        `{` FunctionBody[~Yield, ~Await] `}`

      ExpressionBody[In, Await] :
        AssignmentExpression[?In, ~Yield, ?Await]
    </emu-grammar>
    <h2>補助構文 (Supplemental Syntax)</h2>
    <p>
      生成規則<br>
      <emu-grammar>ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      のインスタンスを処理するとき、|CoverParenthesizedExpressionAndArrowParameterList| の解釈は以下の文法で精密化される:
    </p>
    <emu-grammar type="definition">
      ArrowFormalParameters[Yield, Await] :
        `(` UniqueFormalParameters[?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <ul>
        <li>
          |ArrowParameters| Contains |YieldExpression| が *true* なら構文エラー。
        </li>
        <li>
          |ArrowParameters| Contains |AwaitExpression| が *true* なら構文エラー。
        </li>
        <li>
          ConciseBodyContainsUseStrict of |ConciseBody| が *true* かつ IsSimpleParameterList of |ArrowParameters| が *false* なら構文エラー。
        </li>
        <li>
          |ArrowParameters| の BoundNames の任意要素が |ConciseBody| の LexicallyDeclaredNames にも現れるなら構文エラー。
        </li>
      </ul>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <ul>
        <li>
          |CoverParenthesizedExpressionAndArrowParameterList| は |ArrowFormalParameters| を覆っていなければならない。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-concisebodycontainsusestrict" oldids="sec-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>静的意味論: ConciseBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ConciseBody : `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. FunctionBodyContainsUseStrict of |FunctionBody| を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateconcisebody" oldids="sec-arrow-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        実行時意味論: EvaluateConciseBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): return completion または throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) を実行。
        1. |ExpressionBody| の Evaluation を ? 付きで返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiatearrowfunctionexpression" type="sdo">
      <h1>
        実行時意味論: InstantiateArrowFunctionExpression (
        optional _name_: a property key or a Private Name,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _name_ が存在しなければ *""* を代入。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |ArrowFunction| にマッチしたソーステキストとする。
        1. [id="step-arrowfunction-evaluation-functioncreate"] _closure_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-note>
        <p>|ArrowFunction| は `arguments`, `super`, `this`, `new.target` の局所束縛を定義しない。これらへの参照はレキシカルに囲む環境の束縛へ解決される。典型的には直近の（非アロー）関数の Function Environment となる。|ArrowFunction| が `super` を参照し得ても、ステップ <emu-xref href="#step-arrowfunction-evaluation-functioncreate"></emu-xref> で生成される関数オブジェクトは MakeMethod によりメソッド化されない。`super` を参照する |ArrowFunction| は常に非 |ArrowFunction| 内に含まれ、`super` 実装に必要な状態はその |ArrowFunction| の関数オブジェクトが捕捉する _env_ から得られる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Evaluation)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. InstantiateArrowFunctionExpression of |ArrowFunction| を返す。
      </emu-alg>
      <emu-grammar>ExpressionBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |AssignmentExpression| の Evaluation を ? 付きで行った結果とする。
        1. _exprValue_ を ? GetValue(_exprRef_) とする。
        1. ReturnCompletion(_exprValue_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-method-definitions">
    <h1>メソッド定義 (Method Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      MethodDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        GeneratorMethod[?Yield, ?Await]
        AsyncMethod[?Yield, ?Await]
        AsyncGeneratorMethod[?Yield, ?Await]
        `get` ClassElementName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`
        `set` ClassElementName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`

      PropertySetParameterList :
        FormalParameter[~Yield, ~Await]
    </emu-grammar>

    <emu-clause id="sec-method-definitions-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          FunctionBodyContainsUseStrict of |FunctionBody| が *true* かつ IsSimpleParameterList of |UniqueFormalParameters| が *false* なら構文エラー。
        </li>
        <li>
          |UniqueFormalParameters| の BoundNames の任意要素が |FunctionBody| の LexicallyDeclaredNames にも現れるなら構文エラー。
        </li>
      </ul>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          |PropertySetParameterList| の BoundNames に重複があれば構文エラー。
        </li>
        <li>
          FunctionBodyContainsUseStrict of |FunctionBody| が *true* かつ IsSimpleParameterList of |PropertySetParameterList| が *false* なら構文エラー。
        </li>
        <li>
          |PropertySetParameterList| の BoundNames の任意要素が |FunctionBody| の LexicallyDeclaredNames にも現れるなら構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasdirectsuper" oldids="sec-method-definitions-static-semantics-hasdirectsuper,sec-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-function-definitions-static-semantics-HasDirectSuper" type="sdo">
      <h1>静的意味論: HasDirectSuper ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| が *true* なら *true* を返す。
        1. |FunctionBody| Contains |SuperCall| を返す。
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |FunctionBody| Contains |SuperCall| を返す。
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |PropertySetParameterList| Contains |SuperCall| が *true* なら *true* を返す。
        1. |FunctionBody| Contains |SuperCall| を返す。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| が *true* なら *true* を返す。
        1. |GeneratorBody| Contains |SuperCall| を返す。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| が *true* なら *true* を返す。
        1. |AsyncGeneratorBody| Contains |SuperCall| を返す。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| が *true* なら *true* を返す。
        1. |AsyncFunctionBody| Contains |SuperCall| を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-specialmethod" type="sdo">
      <h1>静的意味論: SpecialMethod ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          GeneratorMethod
          AsyncMethod
          AsyncGeneratorMethod
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-definemethod" type="sdo">
      <h1>
        実行時意味論: DefineMethod (
        _object_: an Object,
        optional _functionPrototype_: an Object,
        ): 正常完了なら Record ( [[Key]]: property key, [[Closure]]: ECMAScript function object ) を含むか、または abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ を |ClassElementName| の Evaluation を ? 付きで行った結果とする。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _functionPrototype_ が存在するなら:
          1. _prototype_ を _functionPrototype_ とする。
        1. そうでなければ:
          1. _prototype_ を %Function.prototype% とする。
        1. _sourceText_ を |MethodDefinition| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. MakeMethod(_closure_, _object_) を実行。
        1. Record { [[Key]]: _propKey_, [[Closure]]: _closure_ } を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-methoddefinitionevaluation" oldids="sec-method-definitions-runtime-semantics-propertydefinitionevaluation,sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation,sec-asyncgenerator-definitions-propertydefinitionevaluation,sec-async-function-definitions-PropertyDefinitionEvaluation" type="sdo">
      <h1>
        実行時意味論: MethodDefinitionEvaluation (
        _object_: an Object,
        _enumerable_: a Boolean,
        ): 正常完了なら PrivateElement か ~unused~ のいずれか、または abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _methodDef_ を ? DefineMethod of |MethodDefinition| (引数 _object_) とする。
        1. SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]) を実行。
        1. ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_) を返す。
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ を ? Evaluation of |ClassElementName| とする。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |MethodDefinition| にマッチしたソーステキストとする。
        1. _formalParameterList_ を <emu-grammar>FormalParameters : [empty]</emu-grammar> の生成規則インスタンスとする。
        1. _closure_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. MakeMethod(_closure_, _object_) を実行。
        1. SetFunctionName(_closure_, _propKey_, *"get"*) を実行。
        1. _propKey_ が Private Name なら:
          1. PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* } を返す。
        1. そうでなければ:
          1. _desc_ を PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* } とする。
          1. ? DefinePropertyOrThrow(_object_, _propKey_, _desc_) を実行。
          1. ~unused~ を返す。
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ を ? Evaluation of |ClassElementName| とする。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |MethodDefinition| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. MakeMethod(_closure_, _object_) を実行。
        1. SetFunctionName(_closure_, _propKey_, *"set"*) を実行。
        1. _propKey_ が Private Name なら:
          1. PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ } を返す。
        1. そうでなければ:
          1. _desc_ を PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* } とする。
          1. ? DefinePropertyOrThrow(_object_, _propKey_, _desc_) を実行。
          1. ~unused~ を返す。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ を ? Evaluation of |ClassElementName| とする。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |GeneratorMethod| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. MakeMethod(_closure_, _object_) を実行。
        1. SetFunctionName(_closure_, _propKey_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%GeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) を返す。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _propKey_ を ? Evaluation of |ClassElementName| とする。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncGeneratorMethod| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. MakeMethod(_closure_, _object_) を実行。
        1. SetFunctionName(_closure_, _propKey_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%AsyncGeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) を返す。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _propKey_ を ? Evaluation of |ClassElementName| とする。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncMethod| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. MakeMethod(_closure_, _object_) を実行。
        1. SetFunctionName(_closure_, _propKey_) を実行。
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>ジェネレーター関数定義 (Generator Function Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      GeneratorDeclaration[Yield, Await, Default] :
        `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
        [+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorExpression :
        `function` `*` BindingIdentifier[+Yield, ~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorMethod[Yield, Await] :
        `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorBody :
        FunctionBody[+Yield, ~Await]

      YieldExpression[In, Await] :
        `yield`
        `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`yield` 直後の構文文脈では字句目標 |InputElementRegExpOrTemplateTail| を用いる必要がある。</p>
    </emu-note>
    <emu-note>
      <p>|YieldExpression| はジェネレーター関数の |FormalParameters| 内では使用できない。これは |FormalParameters| に含まれる式が、生成される Generator が再開可能状態になる前に評価されるためである。</p>
    </emu-note>
    <emu-note>
      <p>Generator に関する抽象操作は <emu-xref href="#sec-generator-abstract-operations"></emu-xref> で定義される。</p>
    </emu-note>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <ul>
        <li>
          |GeneratorMethod| の HasDirectSuper が *true* の場合は構文エラー。
        </li>
        <li>
          |UniqueFormalParameters| Contains |YieldExpression| が *true* の場合は構文エラー。
        </li>
        <li>
          FunctionBodyContainsUseStrict of |GeneratorBody| が *true* かつ IsSimpleParameterList of |UniqueFormalParameters| が *false* の場合は構文エラー。
        </li>
        <li>
          |UniqueFormalParameters| の BoundNames の任意要素が |GeneratorBody| の LexicallyDeclaredNames にも現れる場合は構文エラー。
        </li>
      </ul>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>
          IsStrict(|FormalParameters|) が *true* のとき <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> の早期エラー規則を適用する。
        </li>
        <li>
          |BindingIdentifier| が存在し IsStrict(|BindingIdentifier|) が *true* のとき、その StringValue が *"eval"* または *"arguments"* なら構文エラー。
        </li>
        <li>
          FunctionBodyContainsUseStrict of |GeneratorBody| が *true* かつ IsSimpleParameterList of |FormalParameters| が *false* の場合は構文エラー。
        </li>
        <li>
          |FormalParameters| の BoundNames の任意要素が |GeneratorBody| の LexicallyDeclaredNames にも現れる場合は構文エラー。
        </li>
        <li>
          |FormalParameters| Contains |YieldExpression| が *true* の場合は構文エラー。
        </li>
        <li>
          |FormalParameters| Contains |SuperProperty| が *true* の場合は構文エラー。
        </li>
        <li>
          |GeneratorBody| Contains |SuperProperty| が *true* の場合は構文エラー。
        </li>
        <li>
          |FormalParameters| Contains |SuperCall| が *true* の場合は構文エラー。
        </li>
        <li>
          |GeneratorBody| Contains |SuperCall| が *true* の場合は構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluategeneratorbody" oldids="sec-generator-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        実行時意味論: EvaluateGeneratorBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): throw completion または return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) を実行する。
        1. _G_ を ? OrdinaryCreateFromConstructor(_functionObject_, *"%GeneratorPrototype%"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ») とする。
        1. _G_.[[GeneratorBrand]] に ~empty~ を設定。
        1. _G_.[[GeneratorState]] に ~suspended-start~ を設定。
        1. GeneratorStart(_G_, |FunctionBody|) を実行。
        1. ReturnCompletion(_G_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionobject" oldids="sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        実行時意味論: InstantiateGeneratorFunctionObject (
        _env_: an Environment Record,
        _privateEnv_: a PrivateEnvironment Record or *null*,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ を |BindingIdentifier| の StringValue とする。
        1. _sourceText_ を |GeneratorDeclaration| にマッチしたソーステキストとする。
        1. _F_ を OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, _name_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%GeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. _F_ を返す。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _sourceText_ を |GeneratorDeclaration| にマッチしたソーステキストとする。
        1. _F_ を OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, *"default"*) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%GeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. _F_ を返す。
      </emu-alg>
      <emu-note>
        <p>匿名の |GeneratorDeclaration| は `export default` 宣言の一部でのみ出現し、その関数コードは常に strict mode である。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionexpression" type="sdo">
      <h1>
        実行時意味論: InstantiateGeneratorFunctionExpression (
        optional _name_: a property key or a Private Name,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ が存在しなければ _name_ に *""* を設定。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |GeneratorExpression| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%GeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ は存在しない。
        1. _name_ を |BindingIdentifier| の StringValue に設定。
        1. _outerEnv_ を実行中コンテキストの LexicalEnvironment とする。
        1. _funcEnv_ を NewDeclarativeEnvironment(_outerEnv_) とする。
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) を実行。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |GeneratorExpression| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%GeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-note>
        <p>|GeneratorExpression| の |BindingIdentifier| はその |FunctionBody| 内から参照でき再帰呼び出しを可能にするが、|GeneratorDeclaration| と異なり外側のスコープには現れず影響しない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Evaluation)</h1>
      <emu-grammar>
        GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. InstantiateGeneratorFunctionExpression of |GeneratorExpression| を返す。
      </emu-alg>
      <emu-grammar>YieldExpression : `yield`</emu-grammar>
      <emu-alg>
        1. ? Yield(*undefined*) を返す。
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _exprRef_ を |AssignmentExpression| の Evaluation を ? 付きで行った結果とする。
        1. _value_ を ? GetValue(_exprRef_) とする。
        1. ? Yield(_value_) を返す。
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` `*` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _generatorKind_ を GetGeneratorKind() とする。
        1. Assert: _generatorKind_ は ~sync~ か ~async~ のいずれか。
        1. _exprRef_ を |AssignmentExpression| の Evaluation を ? 付きで行った結果とする。
        1. _value_ を ? GetValue(_exprRef_) とする。
        1. _iteratorRecord_ を ? GetIterator(_value_, _generatorKind_) とする。
        1. _iterator_ を _iteratorRecord_.[[Iterator]] とする。
        1. _received_ を NormalCompletion(*undefined*) とする。
        1. 繰り返し:
          1. _received_ が normal completion なら
            1. _innerResult_ を ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] ») とする。
            1. _generatorKind_ が ~async~ なら _innerResult_ を ? Await(_innerResult_) に設定。
            1. _innerResult_ が Object でなければ *TypeError* を throw。
            1. _done_ を ? IteratorComplete(_innerResult_) とする。
            1. _done_ が *true* なら
              1. ? IteratorValue(_innerResult_) を返す。
            1. _generatorKind_ が ~async~ なら _received_ を Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))) に設定。
            1. それ以外は _received_ を Completion(GeneratorYield(_innerResult_)) に設定。
          1. それ以外で _received_ が throw completion なら
            1. _throw_ を ? GetMethod(_iterator_, *"throw"*) とする。
            1. _throw_ が *undefined* でなければ
              1. _innerResult_ を ? Call(_throw_, _iterator_, « _received_.[[Value]] ») とする。
              1. _generatorKind_ が ~async~ なら _innerResult_ を ? Await(_innerResult_) に設定。
              1. 注: 内部イテレータ `throw` メソッドの例外は伝播し、正常完了は内部 `next` と同様に処理される。
              1. _innerResult_ が Object でなければ *TypeError* を throw。
              1. _done_ を ? IteratorComplete(_innerResult_) とする。
              1. _done_ が *true* なら
                1. ? IteratorValue(_innerResult_) を返す。
              1. _generatorKind_ が ~async~ なら _received_ を Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))) に設定。
              1. それ以外は _received_ を Completion(GeneratorYield(_innerResult_)) に設定。
            1. それ以外:
              1. 注: _iterator_ に `throw` メソッドがない場合、この throw は `yield*` ループを終了させる。まずクリーンアップを与える。
              1. _closeCompletion_ を NormalCompletion(~empty~) とする。
              1. _generatorKind_ が ~async~ なら ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_) を実行。
              1. それ以外は ? IteratorClose(_iteratorRecord_, _closeCompletion_) を実行。
              1. 注: 次のステップで `throw` メソッド欠如による `yield*` プロトコル違反として *TypeError* を投げる。
              1. *TypeError* を throw。
          1. それ以外:
            1. Assert: _received_ は return completion。
            1. _return_ を ? GetMethod(_iterator_, *"return"*) とする。
            1. _return_ が *undefined* なら
              1. _value_ を _received_.[[Value]] に設定。
              1. _generatorKind_ が ~async~ なら
                1. _value_ を ? Await(_value_) に設定。
              1. ReturnCompletion(_value_) を返す。
            1. _innerReturnResult_ を ? Call(_return_, _iterator_, « _received_.[[Value]] ») とする。
            1. _generatorKind_ が ~async~ なら _innerReturnResult_ を ? Await(_innerReturnResult_) に設定。
            1. _innerReturnResult_ が Object でなければ *TypeError* を throw。
            1. _done_ を ? IteratorComplete(_innerReturnResult_) とする。
            1. _done_ が *true* なら
              1. _value_ を ? IteratorValue(_innerReturnResult_) に設定。
              1. ReturnCompletion(_value_) を返す。
            1. _generatorKind_ が ~async~ なら _received_ を Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_))) に設定。
            1. それ以外は _received_ を Completion(GeneratorYield(_innerReturnResult_)) に設定。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>非同期ジェネレーター関数定義 (Async Generator Function Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncGeneratorDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
        [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorExpression :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorMethod[Yield, Await] :
        `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorBody :
        FunctionBody[+Yield, +Await]
    </emu-grammar>
    <emu-note>
      <p>非同期ジェネレーター関数の |FormalParameters| 内では |YieldExpression| と |AwaitExpression| は使用できない。|FormalParameters| 内の式は結果の AsyncGenerator が再開可能となる前に評価されるためである。</p>
    </emu-note>
    <emu-note>
      <p>AsyncGenerator に関する抽象操作は <emu-xref href="#sec-asyncgenerator-abstract-operations"></emu-xref> で定義される。</p>
    </emu-note>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <ul>
        <li>HasDirectSuper of |AsyncGeneratorMethod| が *true* なら構文エラー。</li>
        <li>|UniqueFormalParameters| Contains |YieldExpression| が *true* なら構文エラー。</li>
        <li>|UniqueFormalParameters| Contains |AwaitExpression| が *true* なら構文エラー。</li>
        <li>FunctionBodyContainsUseStrict of |AsyncGeneratorBody| が *true* かつ IsSimpleParameterList of |UniqueFormalParameters| が *false* なら構文エラー。</li>
        <li>|UniqueFormalParameters| の BoundNames の任意要素が |AsyncGeneratorBody| の LexicallyDeclaredNames にも現れるなら構文エラー。</li>
      </ul>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>IsStrict(|FormalParameters|) が *true* のとき <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> の早期エラー規則を適用する。</li>
        <li>|BindingIdentifier| が存在し IsStrict(|BindingIdentifier|) が *true* でその StringValue が *"eval"* または *"arguments"* なら構文エラー。</li>
        <li>FunctionBodyContainsUseStrict of |AsyncGeneratorBody| が *true* かつ IsSimpleParameterList of |FormalParameters| が *false* なら構文エラー。</li>
        <li>|FormalParameters| の BoundNames の任意要素が |AsyncGeneratorBody| の LexicallyDeclaredNames にも現れるなら構文エラー。</li>
        <li>|FormalParameters| Contains |YieldExpression| が *true* なら構文エラー。</li>
        <li>|FormalParameters| Contains |AwaitExpression| が *true* なら構文エラー。</li>
        <li>|FormalParameters| Contains |SuperProperty| が *true* なら構文エラー。</li>
        <li>|AsyncGeneratorBody| Contains |SuperProperty| が *true* なら構文エラー。</li>
        <li>|FormalParameters| Contains |SuperCall| が *true* なら構文エラー。</li>
        <li>|AsyncGeneratorBody| Contains |SuperCall| が *true* なら構文エラー。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncgeneratorbody" oldids="sec-asyncgenerator-definitions-evaluatebody" type="sdo">
      <h1>
        実行時意味論: EvaluateAsyncGeneratorBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): throw completion または return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) を実行。
        1. _generator_ を ? OrdinaryCreateFromConstructor(_functionObject_, *"%AsyncGeneratorPrototype%"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ») とする。
        1. _generator_.[[GeneratorBrand]] に ~empty~ を設定。
        1. _generator_.[[AsyncGeneratorState]] に ~suspended-start~ を設定।
        1. AsyncGeneratorStart(_generator_, |FunctionBody|) を実行。
        1. ReturnCompletion(_generator_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionobject" oldids="sec-asyncgenerator-definitions-instantiatefunctionobject" type="sdo">
      <h1>
        実行時意味論: InstantiateAsyncGeneratorFunctionObject (
        _env_: an Environment Record,
        _privateEnv_: a PrivateEnvironment Record or *null*,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ を |BindingIdentifier| の StringValue とする。
        1. _sourceText_ を |AsyncGeneratorDeclaration| にマッチしたソーステキストとする。
        1. _F_ を OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, _name_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%AsyncGeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. _F_ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _sourceText_ を |AsyncGeneratorDeclaration| にマッチしたソーステキストとする。
        1. _F_ を OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, *"default"*) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%AsyncGeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. _F_ を返す。
      </emu-alg>
      <emu-note>
        <p>匿名の |AsyncGeneratorDeclaration| は `export default` 宣言の一部でのみ出現する。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression" type="sdo">
      <h1>
        実行時意味論: InstantiateAsyncGeneratorFunctionExpression (
        optional _name_: a property key or a Private Name,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ が存在しなければ _name_ に *""* を設定。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncGeneratorExpression| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%AsyncGeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ は存在しない。
        1. _name_ を |BindingIdentifier| の StringValue に設定。
        1. _outerEnv_ を実行中コンテキストの LexicalEnvironment とする。
        1. _funcEnv_ を NewDeclarativeEnvironment(_outerEnv_) とする。
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) を実行。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncGeneratorExpression| にマッチしたソーステキストとする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _prototype_ を OrdinaryObjectCreate(%AsyncGeneratorPrototype%) とする。
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行。
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-note>
        <p>|AsyncGeneratorExpression| の |BindingIdentifier| はその |AsyncGeneratorBody| 内から参照でき再帰呼び出しを可能にするが、|AsyncGeneratorDeclaration| と異なり外側スコープには現れず影響しない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Evaluation)</h1>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression| を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>クラス定義 (Class Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      ClassDeclaration[Yield, Await, Default] :
        `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] `class` ClassTail[?Yield, ?Await]

      ClassExpression[Yield, Await] :
        `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

      ClassTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` ClassBody[?Yield, ?Await]? `}`

      ClassHeritage[Yield, Await] :
        `extends` LeftHandSideExpression[?Yield, ?Await]

      ClassBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]

      ClassElementList[Yield, Await] :
        ClassElement[?Yield, ?Await]
        ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        FieldDefinition[?Yield, ?Await] `;`
        `static` FieldDefinition[?Yield, ?Await] `;`
        ClassStaticBlock
        `;`

      FieldDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

      ClassElementName[Yield, Await] :
        PropertyName[?Yield, ?Await]
        PrivateIdentifier

      ClassStaticBlock :
        `static` `{` ClassStaticBlockBody `}`

      ClassStaticBlockBody :
        ClassStaticBlockStatementList

      ClassStaticBlockStatementList :
        StatementList[~Yield, +Await, ~Return]?
    </emu-grammar>
    <emu-note>
      <p>クラス定義は常に strict mode コードである。</p>
    </emu-note>

    <emu-clause id="sec-class-definitions-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <ul>
        <li>
          <p>|ClassHeritage| が存在しない場合、次のアルゴリズムが *true* を返すなら構文エラー:</p>
          <emu-alg>
            1. _constructor_ を |ClassBody| の ConstructorMethod とする。
            1. _constructor_ が ~empty~ なら *false* を返す。
            1. HasDirectSuper of _constructor_ を返す。
          </emu-alg>
        </li>
      </ul>
      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <ul>
        <li>
          |ClassElementList| の PrototypePropertyNameList に *"constructor"* が 2 回以上含まれる場合は構文エラー。
        </li>
        <li>
          |ClassElementList| の PrivateBoundIdentifiers に重複があり、その名前がゲッターとセッターの 1 回ずつ（他で未使用）かつ両方 static か両方非 static である場合を除いて構文エラー。
        </li>
      </ul>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <ul>
        <li>
          |MethodDefinition| の PropName が *"constructor"* でなく、HasDirectSuper of |MethodDefinition| が *true* なら構文エラー。
        </li>
        <li>
          |MethodDefinition| の PropName が *"constructor"* で SpecialMethod of |MethodDefinition| が *true* なら構文エラー。
        </li>
      </ul>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <ul>
        <li>
          HasDirectSuper of |MethodDefinition| が *true* なら構文エラー。
        </li>
        <li>
          |MethodDefinition| の PropName が *"prototype"* なら構文エラー。
        </li>
      </ul>

      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <ul>
        <li>|FieldDefinition| の PropName が *"constructor"* なら構文エラー。</li>
      </ul>

      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <ul>
        <li>
          |FieldDefinition| の PropName が *"prototype"* または *"constructor"* なら構文エラー。
        </li>
      </ul>

      <emu-grammar>
        FieldDefinition :
          ClassElementName Initializer?
      </emu-grammar>
      <ul>
        <li>|Initializer| が存在し ContainsArguments(|Initializer|) が *true* なら構文エラー。</li>
        <li>|Initializer| が存在し かつ |Initializer| Contains |SuperCall| が *true* なら構文エラー。</li>
      </ul>

      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <ul>
        <li>|PrivateIdentifier| の StringValue が *"#constructor"* なら構文エラー。</li>
      </ul>

      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <ul>
        <li>
          |ClassStaticBlockStatementList| の LexicallyDeclaredNames に重複があれば構文エラー。
        </li>
        <li>
          LexicallyDeclaredNames の要素が VarDeclaredNames にも現れる場合は構文エラー。
        </li>
        <li>
          ContainsDuplicateLabels(|ClassStaticBlockStatementList|, « ») が *true* なら構文エラー。
        </li>
        <li>
          ContainsUndefinedBreakTarget(|ClassStaticBlockStatementList|, « ») が *true* なら構文エラー。
        </li>
        <li>
          ContainsUndefinedContinueTarget(|ClassStaticBlockStatementList|, « », « ») が *true* なら構文エラー。
        </li>
        <li>
          ContainsArguments(|ClassStaticBlockStatementList|) が *true* なら構文エラー。
        </li>
        <li>
          |ClassStaticBlockStatementList| Contains |SuperCall| が *true* なら構文エラー。
        </li>
        <li>
          |ClassStaticBlockStatementList| Contains `await` が *true* なら構文エラー。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementkind" type="sdo">
      <h1>静的意味論: ClassElementKind ( ): ~constructor-method~, ~non-constructor-method~, または ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. |MethodDefinition| の PropName が *"constructor"* であれば ~constructor-method~ を返す。
        1. ~non-constructor-method~ を返す。
      </emu-alg>
      <emu-grammar>
        ClassElement :
          `static` MethodDefinition
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. ~non-constructor-method~ を返す。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. ~non-constructor-method~ を返す。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-constructormethod" type="sdo">
      <h1>静的意味論: ConstructorMethod ( ): |ClassElement| Parse Node または ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. |ClassElement| の ClassElementKind が ~constructor-method~ なら |ClassElement| を返す。
        1. ~empty~ を返す。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _head_ を |ClassElementList| の ConstructorMethod とする。
        1. _head_ が ~empty~ でなければ _head_ を返す。
        1. |ClassElement| の ClassElementKind が ~constructor-method~ なら |ClassElement| を返す。
        1. ~empty~ を返す。
      </emu-alg>
      <emu-note>
        <p>早期エラー規則により *"constructor"* という名前のメソッドは 1 つであり、 accessor や generator ではないことが保証される。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isstatic" type="sdo">
      <h1>静的意味論: IsStatic ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. *true* を返す。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-nonconstructorelements" oldids="sec-static-semantics-nonconstructormethoddefinitions" type="sdo">
      <h1>静的意味論: NonConstructorElements ( ): |ClassElement| Parse Nodes の List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. |ClassElement| の ClassElementKind が ~non-constructor-method~ なら
          1. « |ClassElement| » を返す。
        1. 新しい空 List を返す。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _list_ を |ClassElementList| の NonConstructorElements とする。
        1. |ClassElement| の ClassElementKind が ~non-constructor-method~ なら
          1. _list_ の末尾に |ClassElement| を追加。
        1. _list_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-prototypepropertynamelist" type="sdo">
      <h1>静的意味論: PrototypePropertyNameList ( ): プロパティキーの List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. _propName_ を |ClassElement| の PropName とする。
        1. _propName_ が ~empty~ なら空の新しい List を返す。
        1. IsStatic(|ClassElement|) が *true* なら空の新しい List を返す。
        1. « _propName_ » を返す。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _list_ を |ClassElementList| の PrototypePropertyNameList とする。
        1. _propName_ を |ClassElement| の PropName とする。
        1. _propName_ が ~empty~ なら _list_ を返す。
        1. IsStatic(|ClassElement|) が *true* なら _list_ を返す。
        1. _list_ と « _propName_ » のリスト連結を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-allprivateidentifiersvalid" type="sdo">
      <h1>
        静的意味論: AllPrivateIdentifiersValid (
        _names_: a List of Strings,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>以下に列挙されない仕様中のすべての生成規則選択肢は、暗黙に次の既定定義を持つ:</p>
      <emu-alg>
        1. この Parse Node の各子ノード _child_ について:
          1. _child_ が非終端記号インスタンスなら
            1. AllPrivateIdentifiersValid(_child_, _names_) が *false* なら *false* を返す。
        1. *true* を返す。
      </emu-alg>

      <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ が |PrivateIdentifier| の StringValue を含むなら
          1. AllPrivateIdentifiersValid(|MemberExpression|, _names_) を返す。
        1. *false* を返す。
      </emu-alg>

      <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ が |PrivateIdentifier| の StringValue を含むなら
          1. AllPrivateIdentifiersValid(|CallExpression|, _names_) を返す。
        1. *false* を返す。
      </emu-alg>

      <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ が |PrivateIdentifier| の StringValue を含むなら *true* を返す。
        1. *false* を返す。
      </emu-alg>

      <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ が |PrivateIdentifier| の StringValue を含むなら
          1. AllPrivateIdentifiersValid(|OptionalChain|, _names_) を返す。
        1. *false* を返す。
      </emu-alg>

      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <emu-alg>
        1. _newNames_ を _names_ と |ClassBody| の PrivateBoundIdentifiers のリスト連結とする。
        1. AllPrivateIdentifiersValid(|ClassElementList|, _newNames_) を返す。
      </emu-alg>

      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _names_ が |PrivateIdentifier| の StringValue を含むなら
          1. AllPrivateIdentifiersValid(|ShiftExpression|, _names_) を返す。
        1. *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-privateboundidentifiers" type="sdo">
      <h1>静的意味論: PrivateBoundIdentifiers ( ): 文字列 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName| の PrivateBoundIdentifiers を返す。
      </emu-alg>

      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. |PrivateIdentifier| の StringValue 1 要素のみを含む List を返す。
      </emu-alg>

      <emu-grammar>
        ClassElementName :
          PropertyName

        ClassElement :
          ClassStaticBlock
          `;`
      </emu-grammar>
      <emu-alg>
        1. 新しい空 List を返す。
      </emu-alg>

      <emu-grammar>
        ClassElementList : ClassElementList ClassElement
      </emu-grammar>
      <emu-alg>
        1. _names1_ を |ClassElementList| の PrivateBoundIdentifiers とする。
        1. _names2_ を |ClassElement| の PrivateBoundIdentifiers とする。
        1. _names1_ と _names2_ のリスト連結を返す。
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName| の PrivateBoundIdentifiers を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsarguments" type="sdo">
      <h1>静的意味論: ContainsArguments ( ): Boolean</h1>
      <dl class="header">
      </dl>

      <p>以下に列挙されないすべての生成規則選択肢は暗黙に次の既定定義を持つ:</p>
      <emu-alg>
        1. この Parse Node の各子 _child_ について:
          1. _child_ が非終端であれば
            1. ContainsArguments(_child_) が *true* なら *true* を返す。
        1. *false* を返す。
      </emu-alg>

      <emu-grammar>
        IdentifierReference : Identifier
      </emu-grammar>
      <emu-alg>
        1. |Identifier| の StringValue が *"arguments"* なら *true* を返す。
        1. *false* を返す。
      </emu-alg>

      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. ContainsArguments(|ClassElementName|) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classfielddefinitionevaluation" type="sdo">
      <h1>
        実行時意味論: ClassFieldDefinitionEvaluation (
        _homeObject_: an Object,
        ): ClassFieldDefinition Record を含む normal completion または abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. _name_ を ? Evaluation of |ClassElementName| とする。
        1. |Initializer| が存在するなら:
          1. _formalParameterList_ を <emu-grammar>FormalParameters : [empty]</emu-grammar> のインスタンスとする。
          1. _env_ を実行中コンテキストの LexicalEnvironment とする。
          1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
          1. _sourceText_ を空の Unicode コードポイント列とする。
          1. _initializer_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_) とする。
          1. MakeMethod(_initializer_, _homeObject_) を実行。
          1. _initializer_.[[ClassFieldInitializerName]] に _name_ を設定。
        1. それ以外:
          1. _initializer_ を ~empty~ とする。
        1. ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ } を返す。
      </emu-alg>
      <emu-note>
        _initializer_ のために生成された関数は ECMAScript コードから直接参照できない。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classstaticblockdefinitionevaluation" type="sdo">
      <h1>
        実行時意味論: ClassStaticBlockDefinitionEvaluation (
        _homeObject_: an Object,
        ): ClassStaticBlockDefinition Record
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. _lex_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を空の Unicode コードポイント列とする。
        1. _formalParameters_ を <emu-grammar>FormalParameters : [empty]</emu-grammar> のインスタンスとする。
        1. [id="step-synthetic-class-static-block-fn"] _bodyFunction_ を OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_) とする。
        1. MakeMethod(_bodyFunction_, _homeObject_) を実行。
        1. ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ } を返す。
      </emu-alg>
      <emu-note>_bodyFunction_ は ECMAScript コードから直接アクセスできない。</emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateclassstaticblockbody" type="sdo">
      <h1>
        実行時意味論: EvaluateClassStaticBlockBody (
        _functionObject_: an ECMAScript function object,
        ): return completion または throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <emu-alg>
        1. Assert: _functionObject_ は ClassStaticBlockDefinitionEvaluation ステップ <emu-xref href="#step-synthetic-class-static-block-fn"></emu-xref> により生成された合成関数である。
        1. ! FunctionDeclarationInstantiation(_functionObject_, « ») を実行。
        1. ? |ClassStaticBlockStatementList| の Evaluation を実行。
        1. ReturnCompletion(*undefined*) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementevaluation" type="sdo">
      <h1>
        実行時意味論: ClassElementEvaluation (
        _object_: an Object,
        ): ClassFieldDefinition Record / ClassStaticBlockDefinition Record / PrivateElement / ~unused~ のいずれかを含む normal completion または abrupt completion
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ClassElement :
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. ? ClassFieldDefinitionEvaluation of |FieldDefinition| (引数 _object_) を返す。
      </emu-alg>

      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. ? MethodDefinitionEvaluation of |MethodDefinition| (引数 _object_, *false*) を返す。
      </emu-alg>

      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. ClassStaticBlockDefinitionEvaluation of |ClassStaticBlock| (引数 _object_) を返す。
      </emu-alg>

      <emu-grammar>
        ClassElement : `;`
      </emu-grammar>
      <emu-alg>
        1. ~unused~ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        実行時意味論: ClassDefinitionEvaluation (
        _classBinding_: 文字列または *undefined*,
        _className_: プロパティキーまたは Private Name,
        _sourceText_: ECMAScript source text,
        ): 関数オブジェクトを含む normal completion または abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>仕様を簡潔にするため、private method と accessor はクラスインスタンスの [[PrivateElements]] スロットで private field と並列に扱われる。ただし任意のオブジェクトは、そのクラスで定義された private method / accessor を全部持つか全く持たないかのどちらかである。この設計により実装は各メソッドやアクセサを個別に追跡しない戦略を選択できる。</p>
        <p>例として、実装はインスタンスの private method を対応する Private Name と直接関連付け、各オブジェクトに対しどのクラスコンストラクタが `this` として走ったかを追跡できる。オブジェクト上の private method 参照は、そのメソッドを定義するクラスコンストラクタで初期化されたかを確認し、Private Name に結び付くメソッドを返す手順になる。</p>
        <p>これは private field と異なる。field 初期化子はクラスインスタンス化中に例外を投げ得るため、個々のオブジェクトがクラスの private field の真部分集合だけを持つ状況があり、private field は一般に個別追跡する必要がある。</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. _env_ を実行中の実行コンテキストの LexicalEnvironment とする。
        1. _classEnv_ を NewDeclarativeEnvironment(_env_) とする。
        1. _classBinding_ が *undefined* でない場合、
          1. ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*) を実行する。
        1. _outerPrivateEnvironment_ を実行中の実行コンテキストの PrivateEnvironment とする。
        1. _classPrivateEnvironment_ を NewPrivateEnvironment(_outerPrivateEnvironment_) とする。
        1. |ClassBody| が存在する場合、
          1. |ClassBody| の PrivateBoundIdentifiers の各文字列 _dn_ について、次を行う:
            1. _classPrivateEnvironment_.[[Names]] に、[[Description]] が _dn_ である Private Name _pn_ が含まれているなら、
              1. Assert: これは getter/setter ペアの場合にのみ起こり得る。
            1. そうでなければ、
              1. _dn_ を [[Description]] とする新しい Private Name _name_ を生成する。
              1. _name_ を _classPrivateEnvironment_.[[Names]] に追加する。
        1. |ClassHeritage| が存在しない場合、
          1. _protoParent_ を %Object.prototype% とする。
          1. _constructorParent_ を %Function.prototype% とする。
        1. そうでなければ、
          1. 実行中の実行コンテキストの LexicalEnvironment を _classEnv_ に設定する。
          1. 注: |ClassHeritage| の評価中、実行中の実行コンテキストの PrivateEnvironment は _outerPrivateEnvironment_ である。
          1. _superclassRef_ を Completion(Evaluation of |ClassHeritage|) とする。
          1. 実行中の実行コンテキストの LexicalEnvironment を _env_ に戻す。
          1. _superclass_ を ? GetValue(? _superclassRef_) とする。
          1. もし _superclass_ が *null* であるなら、
            1. _protoParent_ を *null* とする。
            1. _constructorParent_ を %Function.prototype% とする。
          1. そうでなく、かつ IsConstructor(_superclass_) が *false* であるなら、
            1. *TypeError* 例外を投げる。
          1. そうでなければ、
            1. _protoParent_ を ? Get(_superclass_, *"prototype"*) とする。
            1. もし _protoParent_ がオブジェクトでも *null* でもないなら、*TypeError* 例外を投げる。
            1. _constructorParent_ を _superclass_ とする。
        1. _proto_ を OrdinaryObjectCreate(_protoParent_) とする。
        1. |ClassBody| が存在しない場合、_constructor_ を ~empty~ とする。
        1. そうでなければ、_constructor_ を |ClassBody| の ConstructorMethod とする。
        1. 実行中の実行コンテキストの LexicalEnvironment を _classEnv_ に設定する。
        1. 実行中の実行コンテキストの PrivateEnvironment を _classPrivateEnvironment_ に設定する。
        1. もし _constructor_ が ~empty~ であるなら、
          1. 引数を持たず、何もキャプチャしない新しい Abstract Closure _defaultConstructor_ を生成し、呼び出された時に次を実行する:
            1. _args_ を、この関数に [[Call]] または [[Construct]] で渡された引数のリストとする。
            1. もし NewTarget が *undefined* であるなら、*TypeError* 例外を投げる。
            1. _F_ をアクティブな関数オブジェクトとする。
            1. もし _F_.[[ConstructorKind]] が ~derived~ であるなら、
              1. 注: この分岐は `constructor(...args) { super(...args); }` に類似しているが、前述の ECMAScript ソーステキストが観測可能に %Array.prototype% の %Symbol.iterator% メソッドを呼び出す一方で、この関数はそれを呼び出さない。
              1. _func_ を ! _F_.[[GetPrototypeOf]]() とする。
              1. もし IsConstructor(_func_) が *false* であるなら、*TypeError* 例外を投げる。
              1. _result_ を ? Construct(_func_, _args_, NewTarget) とする。
            1. そうでなければ、
              1. 注: この分岐は `constructor() {}` に類似している。
              1. _result_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*) とする。
            1. ? InitializeInstanceElements(_result_, _F_) を実行する。
            1. NormalCompletion(_result_) を返す。
          1. _F_ を CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_) とする。
        1. そうでなければ、
          1. _constructorInfo_ を ! DefineMethod of _constructor_ (引数 _proto_ と _constructorParent_) とする。
          1. _F_ を _constructorInfo_.[[Closure]] とする。
          1. MakeClassConstructor(_F_) を実行する。
          1. SetFunctionName(_F_, _className_) を実行する。
        1. _F_.[[SourceText]] を _sourceText_ に設定する。
        1. MakeConstructor(_F_, *false*, _proto_) を実行する。
        1. もし |ClassHeritage| が存在するなら、_F_.[[ConstructorKind]] を ~derived~ に設定する。
        1. ! DefineMethodProperty(_proto_, *"constructor"*, _F_, *false*) を実行する。
        1. もし |ClassBody| が存在しないなら、_elements_ を新しい空の List とする。
        1. そうでなければ、_elements_ を |ClassBody| の NonConstructorElements とする。
        1. _instancePrivateMethods_ を新しい空の List とする。
        1. _staticPrivateMethods_ を新しい空の List とする。
        1. _instanceFields_ を新しい空の List とする。
        1. _staticElements_ を新しい空の List とする。
        1. _elements_ の各 |ClassElement| _e_ について、次を行う:
          1. もし IsStatic(_e_) が *false* なら、
            1. _element_ を Completion(ClassElementEvaluation of _e_ with argument _proto_) とする。
          1. そうでなければ、
            1. _element_ を Completion(ClassElementEvaluation of _e_ with argument _F_) とする。
          1. もし _element_ が abrupt completion なら、
            1. 実行中の実行コンテキストの LexicalEnvironment を _env_ に戻す。
            1. 実行中の実行コンテキストの PrivateEnvironment を _outerPrivateEnvironment_ に戻す。
            1. ? _element_ を返す。
          1. _element_ を ! _element_ に設定する。
          1. もし _element_ が PrivateElement であるなら、
            1. Assert: _element_.[[Kind]] は ~method~ または ~accessor~ のいずれかである。
            1. もし IsStatic(_e_) が *false* なら、_container_ を _instancePrivateMethods_ とし、そうでなければ _staticPrivateMethods_ とする。
            1. もし _container_ に、_element_.[[Key]] と同じ [[Key]] を持つ PrivateElement _pe_ が含まれているなら、
              1. Assert: _element_.[[Kind]] と _pe_.[[Kind]] は共に ~accessor~ である。
              1. もし _element_.[[Get]] が *undefined* であるなら、
                1. _combined_ を PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] } とする。
              1. そうでなければ、
                1. _combined_ を PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] } とする。
              1. _container_ 内の _pe_ を _combined_ で置き換える。
            1. そうでなければ、
              1. _element_ を _container_ に追加する。
          1. そうでなく、もし _element_ が ClassFieldDefinition Record であるなら、
            1. もし IsStatic(_e_) が *false* なら、_element_ を _instanceFields_ に追加し、そうでなければ _staticElements_ に追加する。
          1. そうでなく、もし _element_ が ClassStaticBlockDefinition Record であるなら、
            1. _element_ を _staticElements_ に追加する。
        1. 実行中の実行コンテキストの LexicalEnvironment を _env_ に戻す。
        1. もし _classBinding_ が *undefined* でないなら、
          1. ! _classEnv_.InitializeBinding(_classBinding_, _F_) を実行する。
        1. _F_.[[PrivateMethods]] を _instancePrivateMethods_ に設定する。
        1. _F_.[[Fields]] を _instanceFields_ に設定する。
        1. _staticPrivateMethods_ の各 PrivateElement _method_ について、次を行う:
          1. ! PrivateMethodOrAccessorAdd(_F_, _method_) を実行する。
        1. _staticElements_ の各要素 _elementRecord_ について、次を行う:
          1. もし _elementRecord_ が ClassFieldDefinition Record であるなら、
            1. _result_ を Completion(DefineField(_F_, _elementRecord_)) とする。
          1. そうでなければ、
            1. Assert: _elementRecord_ は ClassStaticBlockDefinition Record である。
            1. _result_ を Completion(Call(_elementRecord_.[[BodyFunction]], _F_)) とする。
          1. もし _result_ が abrupt completion であるなら、
            1. 実行中の実行コンテキストの PrivateEnvironment を _outerPrivateEnvironment_ に戻す。
            1. ? _result_ を返す。
        1. 実行中の実行コンテキストの PrivateEnvironment を _outerPrivateEnvironment_ に戻す。
        1. _F_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation" type="sdo">
      <h1>実行時意味論: BindingClassDeclarationEvaluation ( ): 関数オブジェクトを含む normal completion または abrupt completion</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. _className_ を |BindingIdentifier| の StringValue とする。
        1. _sourceText_ を |ClassDeclaration| にマッチしたソースとする。
        1. _value_ を ? ClassDefinitionEvaluation(|ClassTail|, _className_, _className_, _sourceText_) とする。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. ? InitializeBoundName(_className_, _value_, _env_) を実行。
        1. _value_ を返す。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. _sourceText_ を |ClassDeclaration| にマッチしたソースとする。
        1. ? ClassDefinitionEvaluation(|ClassTail|, *undefined*, *"default"*, _sourceText_) を返す。
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> は |ExportDeclaration| の一部としてのみ出現し、その束縛確立は該当生成規則の評価で処理される。<emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref> 参照。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Evaluation)</h1>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. この |ClassDeclaration| の BindingClassDeclarationEvaluation を ? 付きで実行。
        1. ~empty~ を返す。
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> は |ExportDeclaration| の一部でのみ出現し直接評価されない。</p>
      </emu-note>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. _sourceText_ を |ClassExpression| にマッチしたソースとする。
        1. ? ClassDefinitionEvaluation(|ClassTail|, *undefined*, *""*, _sourceText_) を返す。
      </emu-alg>
      <emu-grammar>ClassExpression : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. _className_ を |BindingIdentifier| の StringValue とする。
        1. _sourceText_ を |ClassExpression| にマッチしたソースとする。
        1. ? ClassDefinitionEvaluation(|ClassTail|, _className_, _className_, _sourceText_) を返す。
      </emu-alg>
      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _privateIdentifier_ を |PrivateIdentifier| の StringValue とする。
        1. _privateEnvRec_ を実行中コンテキストの PrivateEnvironment とする。
        1. _names_ を _privateEnvRec_.[[Names]] とする。
        1. Assert: _names_ に [[Description]] = _privateIdentifier_ の Private Name が正確に 1 つ存在。
        1. _privateName_ をその Private Name とする。
        1. _privateName_ を返す。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined* を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>非同期関数定義 (Async Function Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncFunctionDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
        [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionExpression :
        `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncMethod[Yield, Await] :
        `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionBody :
        FunctionBody[~Yield, +Await]

      AwaitExpression[Yield] :
        `await` UnaryExpression[?Yield, +Await]
    </emu-grammar>

    <emu-note>
      <p>`await` は <sub>[Await]</sub> パラメータが存在する場合に |AwaitExpression| のキーワードとして構文解析される。<sub>[Await]</sub> パラメータは次の文脈のトップレベルで存在し得る（|FunctionBody| など非終端により欠如し得る）:</p>
      <ul>
        <li>|AsyncFunctionBody| 内。</li>
        <li>|AsyncFunctionDeclaration| / |AsyncFunctionExpression| / |AsyncGeneratorDeclaration| / |AsyncGeneratorExpression| の |FormalParameters| 内（この位置の |AwaitExpression| は静的意味論で Syntax Error）。</li>
        <li>|Module| 内。</li>
      </ul>
      <p>構文目標記号が |Script| の場合、<sub>[Await]</sub> パラメータが無い文脈では `await` は識別子として解析され得る。例:</p>
      <ul>
        <li>|AsyncFunctionBody| または上記の |FormalParameters| 外の任意の場所。</li>
        <li>|FunctionExpression| / |GeneratorExpression| / |AsyncGeneratorExpression| の |BindingIdentifier| 内。</li>
      </ul>
    </emu-note>

    <emu-note>
      <p>|YieldExpression| と異なり、|AwaitExpression| のオペランド省略は Syntax Error である。必ず何かを await しなければならない。</p>
    </emu-note>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>FunctionBodyContainsUseStrict of |AsyncFunctionBody| が *true* かつ IsSimpleParameterList of |UniqueFormalParameters| が *false* なら構文エラー。</li>
        <li>HasDirectSuper of |AsyncMethod| が *true* なら構文エラー。</li>
        <li>|UniqueFormalParameters| Contains |AwaitExpression| が *true* なら構文エラー。</li>
        <li>|UniqueFormalParameters| の BoundNames の要素が |AsyncFunctionBody| の LexicallyDeclaredNames にも現れるなら構文エラー。</li>
      </ul>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>FunctionBodyContainsUseStrict of |AsyncFunctionBody| が *true* かつ IsSimpleParameterList of |FormalParameters| が *false* なら構文エラー。</li>
        <li>|FormalParameters| Contains |AwaitExpression| が *true* なら構文エラー。</li>
        <li>IsStrict(|FormalParameters|) が *true* なら <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> の早期エラー規則を適用。</li>
        <li>|BindingIdentifier| が存在し IsStrict(|BindingIdentifier|) が *true* でその StringValue が *"eval"* または *"arguments"* なら構文エラー。</li>
        <li>|FormalParameters| の BoundNames の要素が |AsyncFunctionBody| の LexicallyDeclaredNames にも現れるなら構文エラー。</li>
        <li>|FormalParameters| Contains |SuperProperty| が *true* なら構文エラー。</li>
        <li>|AsyncFunctionBody| Contains |SuperProperty| が *true* なら構文エラー。</li>
        <li>|FormalParameters| Contains |SuperCall| が *true* なら構文エラー。</li>
        <li>|AsyncFunctionBody| Contains |SuperCall| が *true* なら構文エラー。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionobject" oldids="sec-async-function-definitions-InstantiateFunctionObject" type="sdo">
      <h1>
        実行時意味論: InstantiateAsyncFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record または *null*,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ を |BindingIdentifier| の StringValue とする。
        1. _sourceText_ を |AsyncFunctionDeclaration| にマッチしたソースとする。
        1. _F_ を OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, _name_) を実行。
        1. _F_ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _sourceText_ を |AsyncFunctionDeclaration| にマッチしたソースとする。
        1. _F_ を OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_F_, *"default"*) を実行。
        1. _F_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionexpression" type="sdo">
      <h1>
        実行時意味論: InstantiateAsyncFunctionExpression (
        optional _name_: プロパティキーまたは Private Name,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ が存在しなければ *""* を設定。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncFunctionExpression| にマッチしたソースとする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ は存在しない。
        1. _name_ を |BindingIdentifier| の StringValue に設定。
        1. _outerEnv_ を実行中コンテキストの LexicalEnvironment とする。
        1. _funcEnv_ を NewDeclarativeEnvironment(_outerEnv_) とする。
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) を実行。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncFunctionExpression| にマッチしたソースとする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-note>
        <p>|AsyncFunctionExpression| の |BindingIdentifier| はその |AsyncFunctionBody| 内から参照でき再帰呼び出しを可能にするが、|FunctionDeclaration| と異なり外側スコープには影響しない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncfunctionbody" oldids="sec-async-function-definitions-EvaluateBody" type="sdo">
      <h1>
        実行時意味論: EvaluateAsyncFunctionBody (
        _functionObject_: ECMAScript 関数オブジェクト,
        _argumentsList_: ECMAScript 言語値の List,
        ): return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
        1. _completion_ を Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)) とする。
        1. _completion_ が abrupt なら
          1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] ») を実行。
        1. それ以外
          1. AsyncFunctionStart(_promiseCapability_, |FunctionBody|) を実行。
        1. ReturnCompletion(_promiseCapability_.[[Promise]]) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Evaluation)</h1>
      <emu-grammar>
        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. InstantiateAsyncFunctionExpression of |AsyncFunctionExpression| を返す。
      </emu-alg>
      <emu-grammar>
        AwaitExpression : `await` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. _exprRef_ を ? Evaluation of |UnaryExpression| とする。
        1. _value_ を ? GetValue(_exprRef_) とする。
        1. ? Await(_value_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-arrow-function-definitions">
    <h1>非同期アロー関数定義 (Async Arrow Function Definitions)</h1>
    <h2>構文 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncArrowFunction[In, Yield, Await] :
        `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

      AsyncConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, +Await]
        `{` AsyncFunctionBody `}`

      AsyncArrowBindingIdentifier[Yield] :
        BindingIdentifier[?Yield, +Await]

      CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>
    <h2>補助構文 (Supplemental Syntax)</h2>
    <p>
      生成規則<br>
      <emu-grammar>AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody</emu-grammar><br>
      のインスタンス処理時、|CoverCallExpressionAndAsyncArrowHead| の解釈は以下の文法で精密化される:
    </p>

    <emu-grammar type="definition">
      AsyncArrowHead :
        `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-early-errors" type="sdo">
      <h1>静的意味論: 早期エラー (Early Errors)</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|AsyncArrowBindingIdentifier| の BoundNames の任意要素が |AsyncConciseBody| の LexicallyDeclaredNames にも現れるなら構文エラー。</li>
      </ul>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|CoverCallExpressionAndAsyncArrowHead| は |AsyncArrowHead| を覆っていなければならない。</li>
        <li>|CoverCallExpressionAndAsyncArrowHead| Contains |YieldExpression| が *true* なら構文エラー。</li>
        <li>|CoverCallExpressionAndAsyncArrowHead| Contains |AwaitExpression| が *true* なら構文エラー。</li>
        <li>|CoverCallExpressionAndAsyncArrowHead| の BoundNames の任意要素が |AsyncConciseBody| の LexicallyDeclaredNames にも現れるなら構文エラー。</li>
        <li>AsyncConciseBodyContainsUseStrict of |AsyncConciseBody| が *true* かつ IsSimpleParameterList of |CoverCallExpressionAndAsyncArrowHead| が *false* なら構文エラー。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-asyncconcisebodycontainsusestrict" oldids="sec-async-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>静的意味論: AsyncConciseBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>AsyncConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>AsyncConciseBody : `{` AsyncFunctionBody `}`</emu-grammar>
      <emu-alg>
        1. FunctionBodyContainsUseStrict of |AsyncFunctionBody| を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncconcisebody" oldids="sec-async-arrow-function-definitions-EvaluateBody" type="sdo">
      <h1>
        実行時意味論: EvaluateAsyncConciseBody (
        _functionObject_: ECMAScript 関数オブジェクト,
        _argumentsList_: ECMAScript 言語値の List,
        ): return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
        1. _completion_ を Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)) とする。
        1. _completion_ が abrupt なら
          1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] ») を実行。
        1. それ以外
          1. AsyncFunctionStart(_promiseCapability_, |ExpressionBody|) を実行。
        1. ReturnCompletion(_promiseCapability_.[[Promise]]) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncarrowfunctionexpression" type="sdo">
      <h1>
        実行時意味論: InstantiateAsyncArrowFunctionExpression (
        optional _name_: プロパティキーまたは Private Name,
        ): ECMAScript 関数オブジェクト
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_ が存在しなければ *""* を設定。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncArrowFunction| にマッチしたソースとする。
        1. _parameters_ を |AsyncArrowBindingIdentifier| とする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _closure_ を返す。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_ が存在しなければ *""* を設定。
        1. _env_ を実行中コンテキストの LexicalEnvironment とする。
        1. _privateEnv_ を実行中コンテキストの PrivateEnvironment とする。
        1. _sourceText_ を |AsyncArrowFunction| にマッチしたソースとする。
        1. _head_ を |CoverCallExpressionAndAsyncArrowHead| が覆う |AsyncArrowHead| とする。
        1. _parameters_ を _head_ の |ArrowFormalParameters| とする。
        1. _closure_ を OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_) とする。
        1. SetFunctionName(_closure_, _name_) を実行。
        1. _closure_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価 (Evaluation)</h1>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>末尾位置呼び出し (Tail Position Calls)</h1>

    <emu-clause id="sec-isintailposition" type="abstract operation">
      <h1>
        静的意味論: IsInTailPosition (
        _call_: |CallExpression| / |MemberExpression| / |OptionalChain| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. IsStrict(_call_) が *false* なら *false* を返す。
        1. _call_ が |FunctionBody|, |ConciseBody|, |AsyncConciseBody| の内部に含まれていなければ *false* を返す。
        1. _body_ を _call_ を最も近く包含する |FunctionBody| / |ConciseBody| / |AsyncConciseBody| とする。
        1. _body_ が |GeneratorBody| の |FunctionBody| なら *false* を返す。
        1. _body_ が |AsyncFunctionBody| の |FunctionBody| なら *false* を返す。
        1. _body_ が |AsyncGeneratorBody| の |FunctionBody| なら *false* を返す。
        1. _body_ が |AsyncConciseBody| なら *false* を返す。
        1. HasCallInTailPosition(_body_, _call_) の結果を返す。
      </emu-alg>
      <emu-note>
        <p>末尾位置呼び出しは strict mode コードでのみ定義される。これは caller chain を観測可能にする一般的な非標準拡張（<emu-xref href="#sec-addrestrictedfunctionproperties"></emu-xref> 参照）との整合のためである。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hascallintailposition" type="sdo" oldids="sec-statement-rules,sec-expression-rules">
      <h1>
        静的意味論: HasCallInTailPosition (
        _call_: |CallExpression| / |MemberExpression| / |OptionalChain| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_call_ は特定のソース範囲を表す Parse Node である。以下のアルゴリズムで他の Parse Node と比較する場合、それらが同一ソース範囲を表すかを判定する。</p>
      </emu-note>
      <emu-note>
        <p>潜在的な末尾位置呼び出しの直後が return でその呼び出し結果の GetValue を返している場合も末尾位置呼び出しと見なされる。関数呼び出しは Reference Record を返さないため、その GetValue は呼び出し結果と同じ値を返す。</p>
      </emu-note>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _has_ を HasCallInTailPosition(|StatementList|, _call_) とする。
        1. _has_ が *true* なら *true* を返す。
        1. HasCallInTailPosition(|StatementListItem|, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        FunctionStatementList :
          [empty]

        StatementListItem :
          Declaration

        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        ReturnStatement :
          `return` `;`

        LabelledItem :
          FunctionDeclaration

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

        CaseBlock :
          `{` `}`
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _has_ を最初の |Statement| の HasCallInTailPosition(…, _call_) とする。
        1. _has_ が *true* なら *true* を返す。
        1. 2 番目の |Statement| の HasCallInTailPosition(…, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        IfStatement :
          `if` `(` Expression `)` Statement

        DoWhileStatement :
          `do` Statement `while` `(` Expression `)` `;`

        WhileStatement :
          `while` `(` Expression `)` Statement

        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement

        WithStatement :
          `with` `(` Expression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|Statement|, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        LabelledStatement :
          LabelIdentifier `:` LabelledItem
      </emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|LabelledItem|, _call_) を返す。
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|Expression|, _call_) を返す。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|CaseBlock|, _call_) を返す。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. _has_ を *false* とする。
        1. 最初の |CaseClauses| があれば _has_ = HasCallInTailPosition(その |CaseClauses|, _call_)。
        1. _has_ が *true* なら *true* を返す。
        1. _has_ = HasCallInTailPosition(|DefaultClause|, _call_)。
        1. _has_ が *true* なら *true* を返す。
        1. 2 番目の |CaseClauses| があれば _has_ = HasCallInTailPosition(その |CaseClauses|, _call_)。
        1. _has_ を返す。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _has_ を HasCallInTailPosition(|CaseClauses|, _call_) とする。
        1. _has_ が *true* なら *true* を返す。
        1. HasCallInTailPosition(|CaseClause|, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        CaseClause : `case` Expression `:` StatementList?

        DefaultClause : `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. |StatementList| があれば HasCallInTailPosition(|StatementList|, _call_) を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|Catch|, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        TryStatement :
          `try` Block Finally
          `try` Block Catch Finally
      </emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|Finally|, _call_) を返す。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|Block|, _call_) を返す。
      </emu-alg>

      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        CallExpression :
          SuperCall
          ImportCall
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        Expression :
          AssignmentExpression
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|AssignmentExpression|, _call_) を返す。
      </emu-alg>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _has_ を最初の |AssignmentExpression| の HasCallInTailPosition(…, _call_) とする。
        1. _has_ が *true* なら *true* を返す。
        1. 2 番目の |AssignmentExpression| の HasCallInTailPosition(…, _call_) を返す。
      </emu-alg>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|BitwiseORExpression|, _call_) を返す。
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|LogicalANDExpression|, _call_) を返す。
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|BitwiseORExpression|, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
          CallExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. この |CallExpression| が _call_ なら *true* を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        OptionalExpression :
          MemberExpression OptionalChain
          CallExpression OptionalChain
          OptionalExpression OptionalChain
      </emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|OptionalChain|, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` `[` Expression `]`
          `?.` IdentifierName
          `?.` PrivateIdentifier
          OptionalChain `[` Expression `]`
          OptionalChain `.` IdentifierName
          OptionalChain `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` Arguments
          OptionalChain Arguments
      </emu-grammar>
      <emu-alg>
        1. この |OptionalChain| が _call_ なら *true* を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>
        MemberExpression :
          MemberExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. この |MemberExpression| が _call_ なら *true* を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_ を |CoverParenthesizedExpressionAndArrowParameterList| が覆う |ParenthesizedExpression| とする。
        1. HasCallInTailPosition(_expr_, _call_) を返す。
      </emu-alg>
      <emu-grammar>
        ParenthesizedExpression :
          `(` Expression `)`
      </emu-grammar>
      <emu-alg>
        1. HasCallInTailPosition(|Expression|, _call_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-preparefortailcall" type="abstract operation">
      <h1>PrepareForTailCall ( ): ~unused~</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: 現在の実行コンテキストは以後 ECMAScript コードや組込み関数の評価に再利用されない。続いて呼び出される Call はその評価前に新しい実行コンテキストを生成し push する。
        1. 現在の実行コンテキストに関連する全リソースを破棄する。
        1. ~unused~ を返す。
      </emu-alg>
      <p>末尾位置呼び出しは、現在実行中の関数実行コンテキストに結び付く一時的内部リソースをターゲット関数の呼び出し前に解放するか、その関数のために再利用しなければならない。</p>
      <emu-note>
        <p>例えば末尾位置呼び出しは、ターゲット関数のアクティベーションレコードが呼出元より大きい差分のみスタックを増加させるべきである。ターゲットの方が小さいなら総スタックサイズは減少すべきである。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript 言語: スクリプトとモジュール</h1>

  <emu-clause id="sec-scripts">
    <h1>スクリプト</h1>
    <h2>構文</h2>
    <emu-grammar type="definition">
      Script :
        ScriptBody?

      ScriptBody :
        StatementList[~Yield, ~Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>静的意味論: 早期エラー</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          |ScriptBody| の LexicallyDeclaredNames に重複するエントリが含まれている場合、構文エラーである。
        </li>
        <li>
          |ScriptBody| の LexicallyDeclaredNames の任意の要素が |ScriptBody| の VarDeclaredNames にも出現する場合、構文エラーである。
        </li>
      </ul>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <ul>
        <li>
          `super` を含むソーステキストが直接 eval によって処理される eval コードでない限り、|StatementList| が `super` を含む場合は構文エラーである。直接 eval 内での `super` に関する追加の早期エラー規則は <emu-xref href="#sec-performeval"></emu-xref> で定義されている。
        </li>
        <li>
          |NewTarget| を含むソーステキストが直接 eval によって処理される eval コードでない限り、|StatementList| が |NewTarget| を含む場合は構文エラーである。直接 eval での |NewTarget| に関する追加の早期エラー規則は <emu-xref href="#sec-performeval"></emu-xref> で定義されている。
        </li>
        <li>
          引数 « » での |StatementList| の ContainsDuplicateLabels が *true* の場合、構文エラーである。
        </li>
        <li>
          引数 « » での |StatementList| の ContainsUndefinedBreakTarget が *true* の場合、構文エラーである。
        </li>
        <li>
          引数 « » と « » での |StatementList| の ContainsUndefinedContinueTarget が *true* の場合、構文エラーである。
        </li>
        <li>
          |ScriptBody| を含むソーステキストが直接 eval によって処理される eval コードでない限り、引数 « » での |StatementList| の AllPrivateIdentifiersValid が *false* の場合は構文エラーである。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-scriptisstrict" oldids="sec-static-semantics-isstrict" type="sdo">
      <h1>静的意味論: ScriptIsStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Script : ScriptBody?</emu-grammar>
      <emu-alg>
        1. |ScriptBody| が存在し、|ScriptBody| の Directive Prologue に Use Strict Directive が含まれている場合は *true* を返し、そうでなければ *false* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>実行時意味論: 評価</h1>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-records">
      <h1>Script Record</h1>

      <p><dfn id="script-record" variants="Script Records">Script Record</dfn> は、評価されるスクリプトに関する情報をカプセル化する。各 Script Record は <emu-xref href="#table-script-records"></emu-xref> にリストされたフィールドを含む。</p>

      <emu-table id="table-script-records" caption="Script Record フィールド">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値の型
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              Realm Record
            </td>
            <td>
              このスクリプトが作成されたレルム。
            </td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              |Script| Parse Node
            </td>
            <td>
              このスクリプトのソーステキストを解析した結果。
            </td>
          </tr>
          <tr>
            <td>
              [[LoadedModules]]
            </td>
            <td>
              LoadedModuleRequest Record のリスト
            </td>
            <td>
              このスクリプトによってインポートされた指定子文字列から解決された Module Record へのマップ。リストには ModuleRequestsEqual(_r1_, _r2_) が *true* となる異なる Record _r1_ と _r2_ は含まれない。
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              任意（デフォルト値は ~empty~）
            </td>
            <td>
              スクリプトに追加情報を関連付ける必要があるホスト環境による使用のために予約されたフィールド。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript ソーステキスト,
          _realm_: Realm Record,
          _hostDefined_: 任意,
        ): Script Record または *SyntaxError* オブジェクトの空でないリスト
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_sourceText_ を |Script| として解析した結果に基づいて Script Record を作成する。</dd>
      </dl>

      <emu-alg>
        1. _script_ を ParseText(_sourceText_, |Script|) とする。
        1. _script_ がエラーのリストである場合、_script_ を返す。
        1. Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ } を返す。
      </emu-alg>
      <emu-note>
        <p>実装は、そのスクリプトソーステキストに対する ParseScript の評価より前に、スクリプトソーステキストを解析し早期エラー条件を分析してもよい。ただし、エラーの報告は、この仕様が実際にそのソーステキストに対して ParseScript を実行する時点まで延期されなければならない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-scriptevaluation" type="abstract operation">
      <h1>
        ScriptEvaluation (
          _scriptRecord_: Script Record,
        ): ECMAScript 言語値を含む通常完了か異常完了
      </h1>
      <dl class="header">
      </dl>

      <emu-alg>
        1. _globalEnv_ を _scriptRecord_.[[Realm]].[[GlobalEnv]] とする。
        1. _scriptContext_ を新しい ECMAScript コード実行コンテキストとする。
        1. _scriptContext_ の Function を *null* に設定する。
        1. _scriptContext_ の Realm を _scriptRecord_.[[Realm]] に設定する。
        1. _scriptContext_ の ScriptOrModule を _scriptRecord_ に設定する。
        1. _scriptContext_ の VariableEnvironment を _globalEnv_ に設定する。
        1. _scriptContext_ の LexicalEnvironment を _globalEnv_ に設定する。
        1. _scriptContext_ の PrivateEnvironment を *null* に設定する。
        1. 実行中の実行コンテキストを中断する。
        1. _scriptContext_ を実行コンテキストスタックにプッシュする；_scriptContext_ が実行中の実行コンテキストとなる。
        1. _script_ を _scriptRecord_.[[ECMAScriptCode]] とする。
        1. _result_ を Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_)) とする。
        1. _result_ が通常完了の場合、
          1. _result_ を Completion(Evaluation of _script_) に設定する。
          1. _result_ が通常完了で _result_.[[Value]] が ~empty~ の場合、
            1. _result_ を NormalCompletion(*undefined*) に設定する。
        1. _scriptContext_ を中断し、実行コンテキストスタックから除去する。
        1. Assert: 実行コンテキストスタックは空でない。
        1. 実行コンテキストスタックの最上位にあるコンテキストを実行中の実行コンテキストとして再開する。
        1. ? _result_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-globaldeclarationinstantiation">
      <h1>
        GlobalDeclarationInstantiation (
          _script_: |Script| Parse Node,
          _env_: Global Environment Record,
        ): ~unused~ を含む通常完了か投げ完了
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_script_ は実行コンテキストが確立される |Script| である。_env_ は束縛が作成されるグローバル環境である。</dd>
      </dl>
      <emu-note>
        <p>スクリプトを評価するために実行コンテキストが確立されるとき、宣言は現在のグローバル環境でインスタンス化される。コードで宣言された各グローバル束縛がインスタンス化される。</p>
      </emu-note>
      <p>呼び出されたとき、次の手順を実行する：</p>
      <emu-alg>
        1. _lexNames_ を _script_ の LexicallyDeclaredNames とする。
        1. _varNames_ を _script_ の VarDeclaredNames とする。
        1. _lexNames_ の各要素 _name_ について、
          1. HasLexicalDeclaration(_env_, _name_) が *true* の場合、*SyntaxError* 例外を投げる。
          1. _hasRestrictedGlobal_ を ? HasRestrictedGlobalProperty(_env_, _name_) とする。
          1. 注: グローバル `var` および `function` 束縛（非 strict 直接 eval によって導入されるものを除く）は非設定可能であり、したがって制限されたグローバルプロパティである。
          1. _hasRestrictedGlobal_ が *true* の場合、*SyntaxError* 例外を投げる。
        1. _varNames_ の各要素 _name_ について、
          1. HasLexicalDeclaration(_env_, _name_) が *true* の場合、*SyntaxError* 例外を投げる。
        1. _varDeclarations_ を _script_ の VarScopedDeclarations とする。
        1. _functionsToInitialize_ を新しい空のリストとする。
        1. _declaredFunctionNames_ を新しい空のリストとする。
        1. _varDeclarations_ の各要素 _d_ について、逆順で、
          1. _d_ が |VariableDeclaration|、|ForBinding|、または |BindingIdentifier| のいずれでもない場合、
            1. Assert: _d_ は |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、または |AsyncGeneratorDeclaration| のいずれかである。
            1. 注: 同じ名前に対して複数の関数宣言がある場合、最後の宣言が使用される。
            1. _fn_ を _d_ の BoundNames の唯一の要素とする。
            1. _declaredFunctionNames_ が _fn_ を含まない場合、
              1. _fnDefinable_ を ? CanDeclareGlobalFunction(_env_, _fn_) とする。
              1. _fnDefinable_ が *false* の場合、*TypeError* 例外を投げる。
              1. _fn_ を _declaredFunctionNames_ に追加する。
              1. _d_ を _functionsToInitialize_ の最初の要素として挿入する。
        1. _declaredVarNames_ を新しい空のリストとする。
        1. _varDeclarations_ の各要素 _d_ について、
          1. _d_ が |VariableDeclaration|、|ForBinding|、または |BindingIdentifier| のいずれかの場合、
            1. _d_ の BoundNames の各文字列 _vn_ について、
              1. _declaredFunctionNames_ が _vn_ を含まない場合、
                1. _vnDefinable_ を ? CanDeclareGlobalVar(_env_, _vn_) とする。
                1. _vnDefinable_ が *false* の場合、*TypeError* 例外を投げる。
                1. _declaredVarNames_ が _vn_ を含まない場合、
                  1. _vn_ を _declaredVarNames_ に追加する。
        1. 注: グローバルオブジェクトが通常のオブジェクトの場合、このアルゴリズムステップ以降に異常終了は発生しない。ただし、グローバルオブジェクトが Proxy exotic オブジェクトの場合、以下のステップの一部で異常終了を引き起こす動作を示すことがある。
        1. [id="step-globaldeclarationinstantiation-web-compat-insertion-point", normative-optional] ホストが Web ブラウザであるか、または <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> をサポートする場合、
          1. _strict_ を _script_ の ScriptIsStrict とする。
          1. _strict_ が *false* の場合、
            1. _declaredFunctionOrVarNames_ を _declaredFunctionNames_ と _declaredVarNames_ のリスト連結とする。
            1. _script_ Contains _x_ が *true* となる任意の |Block|、|CaseClause|、または |DefaultClause| _x_ の |StatementList| に直接含まれる各 |FunctionDeclaration| _f_ について、
              1. _F_ を _f_ の |BindingIdentifier| の StringValue とする。
              1. |FunctionDeclaration| _f_ を _F_ を |BindingIdentifier| として持つ |VariableStatement| で置き換えても _script_ に早期エラーが発生しない場合、
                1. HasLexicalDeclaration(_env_, _F_) が *false* の場合、
                  1. _fnDefinable_ を ? CanDeclareGlobalVar(_env_, _F_) とする。
                  1. _fnDefinable_ が *true* の場合、
                    1. 注: _F_ の var 束縛は、VarDeclaredName でも他の |FunctionDeclaration| の名前でもない場合にのみここでインスタンス化される。
                    1. _declaredFunctionOrVarNames_ が _F_ を含まない場合、
                      1. ? CreateGlobalVarBinding(_env_, _F_, *false*) を実行する。
                      1. _F_ を _declaredFunctionOrVarNames_ に追加する。
                    1. [id="step-globaldeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_ が評価されるとき、<emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> で提供される |FunctionDeclaration| 評価アルゴリズムの代わりに次の手順を実行する：
                      1. _gEnv_ を実行中の実行コンテキストの VariableEnvironment とする。
                      1. _bEnv_ を実行中の実行コンテキストの LexicalEnvironment とする。
                      1. _fObj_ を ! _bEnv_.GetBindingValue(_F_, *false*) とする。
                      1. ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*) を実行する。
                      1. ~unused~ を返す。
        1. _lexDeclarations_ を _script_ の LexicallyScopedDeclarations とする。
        1. _privateEnv_ を *null* とする。
        1. _lexDeclarations_ の各要素 _d_ について、
          1. 注: 字句的に宣言された名前はここでインスタンス化されるが初期化されない。
          1. _d_ の BoundNames の各要素 _dn_ について、
            1. _d_ の IsConstantDeclaration が *true* の場合、
              1. ? <emu-meta effects="user-code">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*) を実行する。
            1. そうでなければ、
              1. ? <emu-meta effects="user-code">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*) を実行する。
        1. _functionsToInitialize_ の各 Parse Node _f_ について、
          1. _fn_ を _f_ の BoundNames の唯一の要素とする。
          1. _fo_ を引数 _env_ と _privateEnv_ での _f_ の InstantiateFunctionObject とする。
          1. ? <emu-meta effects="user-code">CreateGlobalFunctionBinding</emu-meta>(_env_, _fn_, _fo_, *false*) を実行する。
        1. _declaredVarNames_ の各文字列 _vn_ について、
          1. ? <emu-meta effects="user-code">CreateGlobalVarBinding</emu-meta>(_env_, _vn_, *false*) を実行する。
        1. ~unused~ を返す。
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref> で指定された早期エラーは、単一の |Script| に含まれる宣言について、function/var 宣言と let/const/class 宣言の間の名前の競合、および let/const/class 束縛の再宣言を防ぐ。ただし、複数の |Script| にまたがるそのような競合と再宣言は、GlobalDeclarationInstantiation 中に実行時エラーとして検出される。そのようなエラーが検出された場合、スクリプトの束縛はインスタンス化されない。ただし、グローバルオブジェクトが Proxy exotic オブジェクトを使用して定義されている場合、競合する宣言の実行時テストが信頼できない場合があり、異常完了となり一部のグローバル宣言がインスタンス化されない可能性がある。これが発生した場合、|Script| のコードは評価されない。</p>
        <p>明示的な var または function 宣言とは異なり、グローバルオブジェクトに直接作成されるプロパティは、let/const/class 宣言によってシャドウされる可能性があるグローバル束縛をもたらす。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>モジュール</h1>
    <h2>構文</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, +Await, ~Return]

      ModuleExportName :
        IdentifierName
        StringLiteral
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>モジュール意味論</h1>

      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            |ModuleItemList| の LexicallyDeclaredNames に重複するエントリが含まれている場合、構文エラーである。
          </li>
          <li>
            |ModuleItemList| の LexicallyDeclaredNames の任意の要素が |ModuleItemList| の VarDeclaredNames にも出現する場合、構文エラーである。
          </li>
          <li>
            |ModuleItemList| の ExportedNames に重複するエントリが含まれている場合、構文エラーである。
          </li>
          <li>
            |ModuleItemList| の ExportedBindings の任意の要素が |ModuleItemList| の VarDeclaredNames または LexicallyDeclaredNames のいずれにも出現しない場合、構文エラーである。
          </li>
          <li>
            |ModuleItemList| が `super` を含む場合、構文エラーである。
          </li>
          <li>
            |ModuleItemList| が |NewTarget| を含む場合、構文エラーである。
          </li>
          <li>
            引数 « » での |ModuleItemList| の ContainsDuplicateLabels が *true* の場合、構文エラーである。
          </li>
          <li>
            引数 « » での |ModuleItemList| の ContainsUndefinedBreakTarget が *true* の場合、構文エラーである。
          </li>
          <li>
            引数 « » と « » での |ModuleItemList| の ContainsUndefinedContinueTarget が *true* の場合、構文エラーである。
          </li>
          <li>
            引数 « » での |ModuleItemList| の AllPrivateIdentifiersValid が *false* の場合、構文エラーである。
          </li>
        </ul>
        <emu-note>
          <p>重複する ExportedNames ルールは、|ModuleBody| 内で複数の `export default` |ExportDeclaration| 項目が構文エラーであることを意味する。競合または重複する宣言に関する追加のエラー条件は、|Module| の評価に先立つモジュールリンキング中にチェックされる。そのようなエラーが検出された場合、|Module| は評価されない。</p>
        </emu-note>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <ul>
          <li>IsStringWellFormedUnicode(SV of |StringLiteral|) が *false* の場合、構文エラーである。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-importedlocalnames" type="abstract operation">
        <h1>
          静的意味論: ImportedLocalNames (
          _importEntries_: ImportEntry Record のリスト,
          ): 文字列のリスト
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_importEntries_ によって定義されるすべてのローカル名束縛のリストを作成する。</dd>
        </dl>
        <emu-alg>
          1. _localNames_ を新しい空のリストとする。
          1. _importEntries_ の各 ImportEntry Record _i_ について、
            1. _i_.[[LocalName]] を _localNames_ に追加する。
          1. _localNames_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulerequest-record">
        <h1>ModuleRequest Record</h1>

        <p><dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest Record</dfn> は、指定されたインポート属性でモジュールをインポートするリクエストを表す。次のフィールドで構成される：</p>
        <emu-table id="table-modulerequest-fields" caption="ModuleRequest Record フィールド">
          <table>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値の型
              </th>
              <th>
                意味
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                文字列
              </td>
              <td>
                モジュール指定子
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Record のリスト
              </td>
              <td>
                インポート属性
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="loadedmodulerequest-record" variants="LoadedModuleRequest Records">LoadedModuleRequest Record</dfn> は、モジュールをインポートするリクエストと結果として得られる Module Record を一緒に表す。表 <emu-xref href="#table-modulerequest-fields"></emu-xref> で定義された同じフィールドに加えて、[[Module]] が追加される：</p>
        <emu-table id="table-loadedmodulerequest-fields" caption="LoadedModuleRequest Record フィールド">
          <table>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値の型
              </th>
              <th>
                意味
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                文字列
              </td>
              <td>
                モジュール指定子
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Record のリスト
              </td>
              <td>
                インポート属性
              </td>
            </tr>
            <tr>
              <td>
                [[Module]]
              </td>
              <td>
                Module Record
              </td>
              <td>
                このモジュールリクエストに対応するロードされたモジュール
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="importattribute-record" variants="ImportAttribute Records">ImportAttribute Record</dfn> は次のフィールドで構成される：</p>
        <emu-table id="table-importattribute-fields" caption="ImportAttribute Record フィールド">
          <table>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値の型
              </th>
              <th>
                意味
              </th>
            </tr>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                文字列
              </td>
              <td>
                属性キー
              </td>
            </tr>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                文字列
              </td>
              <td>
                属性値
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ModuleRequestsEqual" type="abstract operation">
          <h1>
            ModuleRequestsEqual (
              _left_: ModuleRequest Record または LoadedModuleRequest Record,
              _right_: ModuleRequest Record または LoadedModuleRequest Record,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. _left_.[[Specifier]] が _right_.[[Specifier]] でない場合、*false* を返す。
            1. _leftAttrs_ を _left_.[[Attributes]] とする。
            1. _rightAttrs_ を _right_.[[Attributes]] とする。
            1. _leftAttrsCount_ を _leftAttrs_ の要素数とする。
            1. _rightAttrsCount_ を _rightAttrs_ の要素数とする。
            1. _leftAttrsCount_ ≠ _rightAttrsCount_ の場合、*false* を返す。
            1. _leftAttrs_ の各 ImportAttribute Record _l_ について、
              1. _rightAttrs_ に _l_.[[Key]] が _r_.[[Key]] で _l_.[[Value]] が _r_.[[Value]] である ImportAttribute Record _r_ が含まれていない場合、*false* を返す。
            1. *true* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" oldids="sec-module-semantics-static-semantics-modulerequests,sec-imports-static-semantics-modulerequests,sec-exports-static-semantics-modulerequests" type="sdo">
        <h1>静的意味論: ModuleRequests ( ): ModuleRequest Record のリスト</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 新しい空のリストを返す。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. |ModuleItem| の ModuleRequests を返す。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _requests_ を |ModuleItemList| の ModuleRequests とする。
          1. _additionalRequests_ を |ModuleItem| の ModuleRequests とする。
          1. _additionalRequests_ の各 ModuleRequest Record _mr_ について、
            1. _requests_ に ModuleRequestsEqual(_mr_, _mr2_) が *true* である ModuleRequest Record _mr2_ が含まれていない場合、
              1. _mr_ を _requests_ に追加する。
          1. _requests_ を返す。
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. 新しい空のリストを返す。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_ を |FromClause| の SV とする。
          1. 唯一の要素が ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » } であるリストを返す。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_ を |FromClause| の SV とする。
          1. _attributes_ を |WithClause| の WithClauseToAttributes とする。
          1. 唯一の要素が ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ } であるリストを返す。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
        <emu-alg>
          1. _specifier_ を |ModuleSpecifier| の SV とする。
          1. 唯一の要素が ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » } であるリストを返す。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_ を |ModuleSpecifier| の SV とする。
          1. _attributes_ を |WithClause| の WithClauseToAttributes とする。
          1. 唯一の要素が ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ } であるリストを返す。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. _specifier_ を |FromClause| の SV とする。
          1. 唯一の要素が ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » } であるリストを返す。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause WithClause `;`
        </emu-grammar>
        <emu-alg>
          1. _specifier_ を |FromClause| の SV とする。
          1. _attributes_ を |WithClause| の WithClauseToAttributes とする。
          1. 唯一の要素が ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ } であるリストを返す。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 新しい空のリストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>抽象モジュールレコード</h1>
        <p><dfn variants="Module Records">Module Record</dfn> は、単一のモジュールのインポートとエクスポートの構造情報をカプセル化する。この情報は、接続されたモジュール群のインポートとエクスポートをリンクするために使用される。Module Record には、モジュールを評価するときにのみ使用される4つのフィールドが含まれている。</p>
        <p>仕様の目的上、Module Record 値は Record 仕様型の値であり、Module Record が抽象クラスであり、抽象および具象サブクラスの両方を持つ単純なオブジェクト指向階層に存在するものと考えることができる。この仕様では、Cyclic Module Record という名前の抽象サブクラスと、その具象サブクラスである Source Text Module Record を定義している。他の仕様や実装では、それらが定義する代替モジュール定義機能に対応する追加の Module Record サブクラスを定義してもよい。</p>
        <p>Module Record は <emu-xref href="#table-module-record-fields"></emu-xref> にリストされたフィールドを定義する。すべての Module Definition サブクラスには、少なくともこれらのフィールドが含まれる。Module Record はまた、<emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> の抽象メソッドリストも定義する。すべての Module definition サブクラスは、これらの抽象メソッドの具象実装を提供しなければならない。</p>
        <emu-table id="table-module-record-fields" caption="Module Record フィールド" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値の型
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                Realm Record
              </td>
              <td>
                このモジュールが作成されたレルム。
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                Module Environment Record または ~empty~
              </td>
              <td>
                このモジュールのトップレベル束縛を含む Environment Record。このフィールドはモジュールがリンクされるときに設定される。
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                Object または ~empty~
              </td>
              <td>
                このモジュールに対して作成されている場合の Module Namespace Object（<emu-xref href="#sec-module-namespace-objects"></emu-xref>）。
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                任意（デフォルト値は *undefined*）
              </td>
              <td>
                モジュールに追加情報を関連付ける必要があるホスト環境による使用のために予約されたフィールド。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-abstract-methods-of-module-records" caption="Module Record の抽象メソッド" oldids="table-37">
          <table>
            <thead>
              <tr>
                <th>
                  メソッド
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                LoadRequestedModules([_hostDefined_])
              </td>
              <td>
                <p>すべての依存関係を再帰的にロードしてモジュールをリンキング用に準備し、プロミスを返す。</p>
              </td>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                <p>このモジュールから直接または間接的にエクスポートされるすべての名前のリストを返す。</p>
                <p>このメソッドを呼び出す前に LoadRequestedModules が正常に完了している必要がある。</p>
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>このモジュールによってエクスポートされる名前の束縛を返す。束縛は { [[Module]]: Module Record, [[BindingName]]: String | ~namespace~ } の形式の <dfn id="resolvedbinding-record" variants="ResolvedBinding Records">ResolvedBinding Record</dfn> で表される。エクスポートが任意のモジュールに直接束縛を持たない Module Namespace Object の場合、[[BindingName]] は ~namespace~ に設定される。名前を解決できない場合は *null* を返し、複数の束縛が見つかった場合は ~ambiguous~ を返す。</p>
                <p>この操作が特定の _exportName_, _resolveSet_ ペアを引数として呼び出されるたびに、同じ結果を返さなければならない。</p>
                <p>このメソッドを呼び出す前に LoadRequestedModules が正常に完了している必要がある。</p>
              </td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td>
                <p>すべてのモジュール依存関係を遷移的に解決し、Module Environment Record を作成してモジュールを評価用に準備する。</p>
                <p>このメソッドを呼び出す前に LoadRequestedModules が正常に完了している必要がある。</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>このモジュールとその依存関係の評価のプロミスを返す。評価が成功した場合または既に正常に評価されている場合は解決し、評価エラーまたは既に評価に失敗している場合は拒否する。プロミスが拒否された場合、ホストはプロミス拒否を処理し、評価エラーを再スローすることが期待される。</p>
                <p>このメソッドを呼び出す前に Link が正常に完了している必要がある。</p>
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-EvaluateModuleSync" type="abstract operation">
          <h1>
            EvaluateModuleSync (
              _module_: Module Record,
            ): ~unused~ を含む通常完了か投げ完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>呼び出し元が _module_ の評価が既に決定されたプロミスを返すことを保証する場合に、_module_ を同期的に評価する。</dd>
          </dl>

          <emu-alg>
            1. Assert: _module_ は Cyclic Module Record ではない。
            1. _promise_ を _module_.Evaluate() とする。
            1. Assert: _promise_.[[PromiseState]] は ~fulfilled~ または ~rejected~ のいずれかである。
            1. _promise_.[[PromiseState]] が ~rejected~ の場合、
              1. _promise_.[[PromiseIsHandled]] が *false* の場合、HostPromiseRejectionTracker(_promise_, *"handle"*) を実行する。
              1. _promise_.[[PromiseIsHandled]] を *true* に設定する。
              1. ThrowCompletion(_promise_.[[PromiseResult]]) を返す。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>循環モジュールレコード (Cyclic Module Records)</h1>
        <p><dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> は、Cyclic Module Record 型のサブクラスである他のモジュールと依存サイクルを形成し得るモジュールに関する情報を表現するために用いられる。Cyclic Module Record 型のサブクラスではない Module Record は、Source Text Module Record との依存サイクルに参加してはならない。</p>
        <p><emu-xref href="#table-module-record-fields"></emu-xref> で定義されたフィールドに加えて、Cyclic Module Record は <emu-xref href="#table-cyclic-module-fields"></emu-xref> に列挙される追加フィールドを持つ。</p>
        <emu-table id="table-cyclic-module-fields" caption="Cyclic Module Record の追加フィールド">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値の型
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, または ~evaluated~
              </td>
              <td>
                初期値は ~new~。モジュールのライフサイクル進行に伴って ~unlinked~, ~linking~, ~linked~, ~evaluating~, （必要に応じて）~evaluating-async~, ~evaluated~ と順に遷移する。~evaluating-async~ は、このモジュールが非同期依存の完了後に実行キューへ入ったか、[[HasTLA]] フィールドが *true* で実行済みでトップレベル完了待ちであることを示す。
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                throw completion または ~empty~
              </td>
              <td>
                評価中に発生した例外を表す throw completion。例外が発生していない、または [[Status]] が ~evaluated~ でない場合は *undefined*。
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                整数または ~empty~
              </td>
              <td>
                Link と Evaluate 中のみ使用される補助フィールド。[[Status]] が ~linking~ または ~evaluating~ のとき、モジュール自身の深さ優先走査インデックス、または同じ強連結成分内の「より早い」モジュールのそれ。
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                ModuleRequest Record のリスト
              </td>
              <td>
                そのモジュール内の import に対応する ModuleRequest Record のリスト。ソーステキスト出現順で並ぶ。
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                LoadedModuleRequest Record のリスト
              </td>
              <td>
                このレコードが表すモジュールが使用した指定子文字列と解決済み Module Record との（相対的インポート属性を含む）対応。ModuleRequestsEqual(_r1_, _r2_) が *true* となる異なる Record _r1_ と _r2_ を同時に含まない。
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                Cyclic Module Record または ~empty~
              </td>
              <td>
                サイクル内で最初に訪れたモジュール（強連結成分の DFS ルート）。サイクル外ならモジュール自身。Evaluate 完了後、モジュールの [[DFSAncestorIndex]] はその [[CycleRoot]] の深さ優先インデックスとなる。
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                このモジュール自体が個別に非同期かどうか（例: top-level await を含む Source Text Module Record）。非同期依存があるだけでは *true* にはならない。パース後に変更されてはならない。
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluationOrder]]
              </td>
              <td>
                ~unset~, 整数, または ~done~
              </td>
              <td>
                初期値 ~unset~。完全同期モジュールでは ~unset~ のまま。自身が非同期または非同期依存を持つ場合、<emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref> により保留モジュール実行をキューする順序を決める整数を設定。保留モジュールが実行されたら ~done~。
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                PromiseCapability Record または ~empty~
              </td>
              <td>
                あるサイクルの [[CycleRoot]] で、かつそのサイクル内のモジュールに Evaluate() が呼ばれた場合、その全評価の PromiseCapability Record を保持。Evaluate() 抽象メソッドが返す Promise を解決・拒否するために用いる。サイクル内依存でもトップレベル Evaluate() が開始されていなければ ~empty~。
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                Cyclic Module Record のリスト
              </td>
              <td>
                このモジュールまたは依存に [[HasTLA]] *true* があり実行進行中の場合、トップレベル実行ジョブにおける親インポーターを追跡。親モジュールはこのモジュールが成功完了するまで実行を開始しない。
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                整数または ~empty~
              </td>
              <td>
                非同期依存がある場合、残り非同期依存モジュールの数。これが 0 になり実行エラーがなければモジュールは実行される。
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> で定義されたメソッドに加えて、Cyclic Module Record は <emu-xref href="#table-cyclic-module-methods"></emu-xref> に列挙される追加抽象メソッドを持つ。</p>
        <emu-table id="table-cyclic-module-methods" caption="Cyclic Module Record の追加抽象メソッド">
          <table>
            <thead>
              <tr>
                <th>
                  メソッド
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td>
                すべてのインポート束縛解決を含めモジュールの Environment Record を初期化し、実行コンテキストを作成する。
              </td>
            </tr>
            <tr>
              <td>
                ExecuteModule([_promiseCapability_])
              </td>
              <td>
                モジュールのコードをその実行コンテキスト内で評価。[[HasTLA]] が *true* の場合は PromiseCapability Record が引数で渡され、その capability を resolve / reject する責務を持つ。この場合メソッドは例外を throw せず、必要なら PromiseCapability Record を reject しなければならない。
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record</dfn> はモジュールグラフの読み込み過程に関する情報を保持し、HostLoadImportedModule 呼び出し後の読み込み継続に用いる。各 GraphLoadingState Record は <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref> で定義されるフィールドを持つ:</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="GraphLoadingState Record フィールド">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値の型
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                PromiseCapability Record
              </td>
              <td>
                読み込み処理完了時に解決する Promise。
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                成功またはエラーでまだ終了していなければ *true*。
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                非負整数
              </td>
              <td>
                保留中の HostLoadImportedModule 呼び出し数を追跡。
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                Cyclic Module Record のリスト
              </td>
              <td>
                現在の読み込み過程ですでにロードされた Cyclic Module Record のリスト。循環依存による無限ループ防止。
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                任意（初期値 ~empty~）
              </td>
              <td>
                LoadRequestedModules 呼び出し元から HostLoadImportedModule へ渡すホスト定義データ。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-cyclic-module-record-module-record-methods">
          <h1>Module Record 抽象メソッドの実装</h1>

          <p>以下は <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> で定義された Module Record 抽象メソッドを実装する Cyclic Module Record の具象メソッドである。</p>

          <emu-clause id="sec-LoadRequestedModules" type="concrete method">
            <h1>
              LoadRequestedModules (
                optional _hostDefined_: anything,
              ): Promise
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>_module_ の依存グラフ内すべての Module Record の [[LoadedModules]] を埋める（実作業の大半は補助関数 InnerModuleLoading が行う）。オプションの _hostDefined_ は HostLoadImportedModule フックに渡される。</dd>
            </dl>

            <emu-alg>
              1. _hostDefined_ が与えられないなら _hostDefined_ を ~empty~ とする。
              1. _pc_ を ! NewPromiseCapability(%Promise%) とする。
              1. _state_ を GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ } とする。
              1. InnerModuleLoading(_state_, _module_) を実行する。
              1. _pc_.[[Promise]] を返す。
            </emu-alg>

            <emu-note>
              _hostDefined_ パラメータはインポートモジュール取得に必要な追加情報を渡すために利用できる。例えば HTML では <code>&lt;link rel="preload" as="..."&gt;</code> の適切な fetch destination 設定に使う。<code>import()</code> 式は _hostDefined_ を設定しない。
            </emu-note>

            <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
              <h1>
                InnerModuleLoading (
                  _state_: GraphLoadingState Record,
                  _module_: Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>LoadRequestedModules により再帰的に _module_ 依存グラフの実際の読み込みを行うために使用される。</dd>
              </dl>

              <emu-alg>
                1. Assert: _state_.[[IsLoading]] は *true*。
                1. もし _module_ が Cyclic Module Record で、_module_.[[Status]] が ~new~、かつ _state_.[[Visited]] に _module_ を含まないなら
                  1. _module_ を _state_.[[Visited]] に追加する。
                  1. _requestedModulesCount_ を _module_.[[RequestedModules]] の要素数とする。
                  1. _state_.[[PendingModulesCount]] を _state_.[[PendingModulesCount]] + _requestedModulesCount_ に設定。
                  1. _module_.[[RequestedModules]] の各 ModuleRequest Record _request_ について
                    1. AllImportAttributesSupported(_request_.[[Attributes]]) が *false* なら
                      1. _error_ を ThrowCompletion(新たに生成した *SyntaxError* オブジェクト) とする。
                      1. ContinueModuleLoading(_state_, _error_) を実行。
                    1. そうでなく _module_.[[LoadedModules]] に ModuleRequestsEqual(_record_, _request_) が *true* となる LoadedModuleRequest Record _record_ が含まれるなら
                      1. InnerModuleLoading(_state_, _record_.[[Module]]) を実行。
                    1. それ以外
                      1. HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_) を実行。
                      1. 注: HostLoadImportedModule は FinishLoadingImportedModule を呼び、ContinueModuleLoading を通じてグラフ読み込みに再突入する。
                    1. _state_.[[IsLoading]] が *false* なら ~unused~ を返す。
                1. Assert: _state_.[[PendingModulesCount]] ≥ 1。
                1. _state_.[[PendingModulesCount]] を 1 減らす。
                1. もし _state_.[[PendingModulesCount]] = 0 なら
                  1. _state_.[[IsLoading]] を *false* に設定。
                  1. _state_.[[Visited]] の各 Cyclic Module Record _loaded_ について
                    1. もし _loaded_.[[Status]] が ~new~ なら ~unlinked~ に設定。
                  1. ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* ») を実行。
                1. ~unused~ を返す。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
              <h1>
                ContinueModuleLoading (
                  _state_: GraphLoadingState Record,
                  _moduleCompletion_: モジュール Record を含む通常完了または throw completion,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>HostLoadImportedModule 呼び出し後に読み込み処理へ再突入するために用いる。</dd>
              </dl>

              <emu-alg>
                1. _state_.[[IsLoading]] が *false* なら ~unused~ を返す。
                1. _moduleCompletion_ が通常完了なら
                  1. InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]) を実行。
                1. そうでなければ
                  1. _state_.[[IsLoading]] を *false* に設定。
                  1. ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] ») を実行。
                1. ~unused~ を返す。
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
            <h1>Link ( ): ~unused~ を含む通常完了または throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>成功時、Link はこのモジュールの [[Status]] を ~unlinked~ から ~linked~ に遷移させる。失敗時は例外を投げ、[[Status]] は ~unlinked~ のまま。（実作業の大半は補助関数 InnerModuleLinking が行う。）</dd>
            </dl>

            <emu-alg>
              1. Assert: _module_.[[Status]] は ~unlinked~, ~linked~, ~evaluating-async~, ~evaluated~ のいずれか。
              1. _stack_ を新しい空リストとする。
              1. _result_ を Completion(InnerModuleLinking(_module_, _stack_, 0)) とする。
              1. もし _result_ が abrupt completion なら
                1. _stack_ の各 Cyclic Module Record _m_ について
                  1. Assert: _m_.[[Status]] は ~linking~。
                  1. _m_.[[Status]] を ~unlinked~ に設定。
                1. Assert: _module_.[[Status]] は ~unlinked~。
                1. ? _result_ を返す。
              1. Assert: _module_.[[Status]] は ~linked~, ~evaluating-async~, ~evaluated~ のいずれか。
              1. Assert: _stack_ は空。
              1. ~unused~ を返す。
            </emu-alg>

            <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
              <h1>
                InnerModuleLinking (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record のリスト,
                  _index_: 非負整数,
                ): 非負整数を含む通常完了または throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Link により _module_ および依存グラフの他モジュールを再帰的にリンクする。_stack_ と _index_、および各モジュールの [[DFSAncestorIndex]] は DFS 走査管理に用いられる。特に [[DFSAncestorIndex]] は強連結成分 (SCC) を発見し、その全モジュールを一括で ~linked~ に遷移させるために使われる。</dd>
              </dl>

              <emu-alg>
                1. _module_ が Cyclic Module Record でないなら
                  1. ? _module_.Link() を実行。
                  1. _index_ を返す。
                1. もし _module_.[[Status]] が ~linking~, ~linked~, ~evaluating-async~, ~evaluated~ のいずれかなら
                  1. _index_ を返す。
                1. Assert: _module_.[[Status]] は ~unlinked~。
                1. _module_.[[Status]] を ~linking~ に設定。
                1. _moduleIndex_ を _index_ とする。
                1. _module_.[[DFSAncestorIndex]] を _index_ に設定。
                1. _index_ を _index_ + 1 に更新。
                1. _module_ を _stack_ に追加。
                1. _module_.[[RequestedModules]] の各 ModuleRequest Record _request_ について
                  1. _requiredModule_ を GetImportedModule(_module_, _request_) とする。
                  1. _index_ を ? InnerModuleLinking(_requiredModule_, _stack_, _index_) に設定。
                  1. もし _requiredModule_ が Cyclic Module Record なら
                    1. Assert: _requiredModule_.[[Status]] は ~linking~, ~linked~, ~evaluating-async~, ~evaluated~ のいずれか。
                    1. Assert: _requiredModule_.[[Status]] が ~linking~ であることと _stack_ に _requiredModule_ を含むことは同値。
                    1. もし _requiredModule_.[[Status]] が ~linking~ なら
                      1. _module_.[[DFSAncestorIndex]] を min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]) に設定。
                1. ? _module_.InitializeEnvironment() を実行。
                1. Assert: _module_ は _stack_ にちょうど 1 回出現。
                1. Assert: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_。
                1. もし _module_.[[DFSAncestorIndex]] = _moduleIndex_ なら
                  1. _done_ を *false* とする。
                  1. _done_ が *false* の間繰り返す
                    1. _requiredModule_ を _stack_ の最後の要素とする。
                    1. 最後の要素を _stack_ から除去。
                    1. Assert: _requiredModule_ は Cyclic Module Record。
                    1. _requiredModule_.[[Status]] を ~linked~ に設定。
                    1. もし _requiredModule_ と _module_ が同一なら _done_ を *true* に。
                1. _index_ を返す。
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduleevaluation" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>Evaluate は [[Status]] を ~linked~ から ~evaluating-async~ または ~evaluated~ に遷移させる。与えられた強連結成分で最初に呼ばれたモジュールについては Promise を作成し、評価完了時に解決する。その Promise は成分の [[CycleRoot]] の [[TopLevelCapability]] に保持され、成分内の他モジュールでの後続呼び出しも同じ Promise を返す。（実作業の大半は補助関数 InnerModuleEvaluation が行う。）</dd>
            </dl>

            <emu-alg>
              1. Assert: この Evaluate 呼び出しと同時並行で同エージェント内の別の Evaluate 呼び出しは起こっていない。
              1. Assert: _module_.[[Status]] は ~linked~, ~evaluating-async~, ~evaluated~ のいずれか。
              1. もし _module_.[[Status]] が ~evaluating-async~ または ~evaluated~ なら _module_ を _module_.[[CycleRoot]] に置き換える。
              1. もし _module_.[[TopLevelCapability]] が ~empty~ でないなら
                1. _module_.[[TopLevelCapability]].[[Promise]] を返す。
              1. _stack_ を新しい空リストとする。
              1. _capability_ を ! NewPromiseCapability(%Promise%) とする。
              1. _module_.[[TopLevelCapability]] を _capability_ に設定。
              1. _result_ を Completion(InnerModuleEvaluation(_module_, _stack_, 0)) とする。
              1. もし _result_ が abrupt completion なら
                1. _stack_ の各 Cyclic Module Record _m_ について
                  1. Assert: _m_.[[Status]] は ~evaluating~。
                  1. Assert: _m_.[[AsyncEvaluationOrder]] は ~unset~。
                  1. _m_.[[Status]] を ~evaluated~ に設定。
                  1. _m_.[[EvaluationError]] を _result_ に設定。
                1. Assert: _module_.[[Status]] は ~evaluated~。
                1. Assert: _module_.[[EvaluationError]] と _result_ は同じ Completion Record。
                1. ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] ») を実行。
              1. それ以外
                1. Assert: _module_.[[Status]] は ~evaluating-async~ または ~evaluated~。
                1. Assert: _module_.[[EvaluationError]] は ~empty~。
                1. もし _module_.[[Status]] が ~evaluated~ なら
                  1. 注: 評価が同期的に完了したことを意味する。
                  1. Assert: _module_.[[AsyncEvaluationOrder]] は ~unset~。
                  1. ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* ») を実行。
                1. Assert: _stack_ は空。
              1. _capability_.[[Promise]] を返す。
            </emu-alg>

            <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
              <h1>
                InnerModuleEvaluation (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record のリスト,
                  _index_: 非負整数,
                ): 非負整数を含む通常完了または throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Evaluate が実際の評価処理を _module_ および依存グラフ上の他モジュールへ再帰的に行う。_stack_, _index_ および _module_.[[DFSAncestorIndex]] の用途は InnerModuleLinking と同様。</dd>
              </dl>

              <emu-alg>
                1. _module_ が Cyclic Module Record でないなら
                  1. ? EvaluateModuleSync(_module_) を実行。
                  1. _index_ を返す。
                1. もし _module_.[[Status]] が ~evaluating-async~ または ~evaluated~ なら
                  1. もし _module_.[[EvaluationError]] が ~empty~ なら _index_ を返す。
                  1. それ以外なら ? _module_.[[EvaluationError]] を返す。
                1. もし _module_.[[Status]] が ~evaluating~ なら _index_ を返す。
                1. Assert: _module_.[[Status]] は ~linked~。
                1. _module_.[[Status]] を ~evaluating~ に設定。
                1. _moduleIndex_ を _index_ とする。
                1. _module_.[[DFSAncestorIndex]] を _index_ に設定。
                1. _module_.[[PendingAsyncDependencies]] を 0 に設定。
                1. _index_ を _index_ + 1 に。
                1. _module_ を _stack_ に追加。
                1. _module_.[[RequestedModules]] の各 ModuleRequest Record _request_ について
                  1. _requiredModule_ を GetImportedModule(_module_, _request_) とする。
                  1. _index_ を ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_) に設定。
                  1. もし _requiredModule_ が Cyclic Module Record なら
                    1. Assert: _requiredModule_.[[Status]] は ~evaluating~, ~evaluating-async~, ~evaluated~ のいずれか。
                    1. Assert: _requiredModule_.[[Status]] が ~evaluating~ であることと _stack_ に含まれることは同値。
                    1. もし _requiredModule_.[[Status]] が ~evaluating~ なら
                      1. _module_.[[DFSAncestorIndex]] を min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]) に設定。
                    1. それ以外
                      1. _requiredModule_ を _requiredModule_.[[CycleRoot]] に設定。
                      1. Assert: _requiredModule_.[[Status]] は ~evaluating-async~ または ~evaluated~。
                      1. もし _requiredModule_.[[EvaluationError]] が ~empty~ でないなら ? _requiredModule_.[[EvaluationError]] を返す。
                    1. もし _requiredModule_.[[AsyncEvaluationOrder]] が整数なら
                      1. _module_.[[PendingAsyncDependencies]] を 1 増やす。
                      1. _requiredModule_.[[AsyncParentModules]] に _module_ を追加。
                1. もし _module_.[[PendingAsyncDependencies]] > 0 または _module_.[[HasTLA]] が *true* なら
                  1. Assert: _module_.[[AsyncEvaluationOrder]] は ~unset~。
                  1. _module_.[[AsyncEvaluationOrder]] を IncrementModuleAsyncEvaluationCount() に設定。
                  1. もし _module_.[[PendingAsyncDependencies]] = 0 なら ExecuteAsyncModule(_module_) を実行。
                1. それ以外
                  1. ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta> を実行。
                1. Assert: _module_ は _stack_ にちょうど 1 回。
                1. Assert: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_。
                1. もし _module_.[[DFSAncestorIndex]] = _moduleIndex_ なら
                  1. _done_ を *false* とする。
                  1. _done_ が *false* の間
                    1. _requiredModule_ を _stack_ の最後の要素とする。
                    1. 最後の要素を _stack_ から除去。
                    1. Assert: _requiredModule_ は Cyclic Module Record。
                    1. Assert: _requiredModule_.[[AsyncEvaluationOrder]] は 整数 または ~unset~。
                    1. もし _requiredModule_.[[AsyncEvaluationOrder]] が ~unset~ なら _requiredModule_.[[Status]] を ~evaluated~ に。
                    1. それ以外は ~evaluating-async~ に。
                    1. もし _requiredModule_ と _module_ が同一なら _done_ を *true* に。
                    1. _requiredModule_.[[CycleRoot]] を _module_ に設定。
                1. _index_ を返す。
              </emu-alg>
              <emu-note>
                <p>モジュールは InnerModuleEvaluation に走査されている間 ~evaluating~。[[HasTLA]] が *true* か非同期依存がある場合、実行中は ~evaluating-async~、完了後 ~evaluated~。</p>
              </emu-note>
              <emu-note>
                <p>非同期サイクルに属するモジュールに依存するモジュールは、サイクルが ~evaluating~ でない間、そのサイクルのルート ([[CycleRoot]]) の実行に依存する。これによりサイクル全体をルート状態を介した単一の強連結成分として扱える。</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-execute-async-module" type="abstract operation">
              <h1>
                ExecuteAsyncModule (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>

              <emu-alg>
                1. Assert: _module_.[[Status]] は ~evaluating~ または ~evaluating-async~。
                1. Assert: _module_.[[HasTLA]] は *true*。
                1. _capability_ を ! NewPromiseCapability(%Promise%) とする。
                1. _fulfilledClosure_ を、引数なしで _module_ を捕捉し呼び出し時に以下を行う新しい Abstract Closure とする:
                  1. AsyncModuleExecutionFulfilled(_module_) を実行。
                  1. NormalCompletion(*undefined*) を返す。
                1. _onFulfilled_ を CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « ») とする。
                1. _rejectedClosure_ を、引数 (_error_) を取り _module_ を捕捉し以下を行う Abstract Closure とする:
                  1. AsyncModuleExecutionRejected(_module_, _error_) を実行。
                  1. NormalCompletion(*undefined*) を返す。
                1. _onRejected_ を CreateBuiltinFunction(_rejectedClosure_, 0, *""*, « ») とする。
                1. PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_) を実行。
                1. ! <emu-meta effects="user-code">_module_.ExecuteModule</emu-meta>(_capability_) を実行。
                1. ~unused~ を返す。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-gather-available-ancestors" type="abstract operation">
              <h1>
                GatherAvailableAncestors (
                  _module_: Cyclic Module Record,
                  _execList_: Cyclic Module Record のリスト,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. _module_.[[AsyncParentModules]] の各 Cyclic Module Record _m_ について
                  1. もし _execList_ に _m_ を含まず、かつ _m_.[[CycleRoot]].[[EvaluationError]] が ~empty~ なら
                    1. Assert: _m_.[[Status]] は ~evaluating-async~。
                    1. Assert: _m_.[[EvaluationError]] は ~empty~。
                    1. Assert: _m_.[[AsyncEvaluationOrder]] は整数。
                    1. Assert: _m_.[[PendingAsyncDependencies]] > 0。
                    1. _m_.[[PendingAsyncDependencies]] を 1 減らす。
                    1. もし 0 なら
                      1. _execList_ に _m_ を追加。
                      1. もし _m_.[[HasTLA]] が *false* なら GatherAvailableAncestors(_m_, _execList_) を実行。
                1. ~unused~ を返す。
              </emu-alg>
              <emu-note>
                <p>非同期実行が root _module_ で充足された際、この関数は同期的に一括実行可能なモジュール集合を決定し _execList_ を構築する。</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-fulfilled" type="abstract operation">
              <h1>
                AsyncModuleExecutionFulfilled (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. もし _module_.[[Status]] が ~evaluated~ なら
                  1. Assert: _module_.[[EvaluationError]] は ~empty~ ではない。
                  1. ~unused~ を返す。
                1. Assert: _module_.[[Status]] は ~evaluating-async~。
                1. Assert: _module_.[[AsyncEvaluationOrder]] は整数。
                1. Assert: _module_.[[EvaluationError]] は ~empty~。
                1. _module_.[[AsyncEvaluationOrder]] を ~done~ に設定。
                1. _module_.[[Status]] を ~evaluated~ に設定。
                1. もし _module_.[[TopLevelCapability]] が ~empty~ でないなら
                  1. Assert: _module_.[[CycleRoot]] と _module_ は同一 Module Record。
                  1. ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* ») を実行。
                1. _execList_ を空リストとする。
                1. GatherAvailableAncestors(_module_, _execList_) を実行。
                1. Assert: _execList_ の全要素は [[AsyncEvaluationOrder]] が整数、[[PendingAsyncDependencies]] が 0、[[EvaluationError]] が ~empty~。
                1. _sortedExecList_ を _execList_ を [[AsyncEvaluationOrder]] 昇順で並べたリストとする。
                1. _sortedExecList_ の各 Cyclic Module Record _m_ について
                  1. もし _m_.[[Status]] が ~evaluated~ なら
                    1. Assert: _m_.[[EvaluationError]] は ~empty~ ではない。
                  1. Else if _m_.[[HasTLA]] が *true* なら
                    1. ExecuteAsyncModule(_m_) を実行。
                  1. Else
                    1. _result_ を <emu-meta effects="user-code">_m_.ExecuteModule()</emu-meta> とする。
                    1. もし _result_ が abrupt completion なら
                      1. AsyncModuleExecutionRejected(_m_, _result_.[[Value]]) を実行。
                    1. それ以外
                      1. _m_.[[AsyncEvaluationOrder]] を ~done~ に。
                      1. _m_.[[Status]] を ~evaluated~ に。
                      1. もし _m_.[[TopLevelCapability]] が ~empty~ でないなら
                        1. Assert: _m_.[[CycleRoot]] と _m_ は同一。
                        1. ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* ») を実行。
                1. ~unused~ を返す。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-rejected" type="abstract operation">
              <h1>
                AsyncModuleExecutionRejected (
                  _module_: Cyclic Module Record,
                  _error_: ECMAScript 言語値,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. もし _module_.[[Status]] が ~evaluated~ なら
                  1. Assert: _module_.[[EvaluationError]] は ~empty~ ではない。
                  1. ~unused~ を返す。
                1. Assert: _module_.[[Status]] は ~evaluating-async~。
                1. Assert: _module_.[[AsyncEvaluationOrder]] は整数。
                1. Assert: _module_.[[EvaluationError]] は ~empty~。
                1. _module_.[[EvaluationError]] を ThrowCompletion(_error_) に設定。
                1. _module_.[[Status]] を ~evaluated~ に設定。
                1. _module_.[[AsyncEvaluationOrder]] を ~done~ に設定。
                1. 注: 対称性のため ~done~。InnerModuleEvaluation では [[EvaluationError]] が ~empty~ でない場合 [[AsyncEvaluationOrder]] は利用されない。
                1. _module_.[[AsyncParentModules]] の各 Cyclic Module Record _m_ について
                  1. AsyncModuleExecutionRejected(_m_, _error_) を実行。
                1. もし _module_.[[TopLevelCapability]] が ~empty~ でないなら
                  1. Assert: _module_.[[CycleRoot]] と _module_ は同一。
                  1. ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ ») を実行。
                1. ~unused~ を返す。
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-example-cyclic-module-record-graphs">
          <h1>循環モジュールレコードグラフの例</h1>

          <p>この非規範節では、よくあるモジュールグラフのリンクおよび評価例と、エラー発生の様態に焦点を当てた事例を示す。</p>

          <p>まず次の単純なモジュールグラフを考える:</p>

          <emu-figure id="figure-module-graph-simple" caption="単純なモジュールグラフ">
            <img alt="モジュール A が B に依存し、B が C に依存するモジュールグラフ" width="60" height="198" src="https://tc39.es/ecma262/img/module-graph-simple.svg">
          </emu-figure>

          <p>先にエラー条件が無いと仮定する。ホストが最初に _A_.LoadRequestedModules() を呼ぶと、仮定により成功裏に完了し、再帰的に _B_ と _C_ の依存（それぞれ _C_ となし）をロードし、その後 _A_.[[Status]] = _B_.[[Status]] = _C_.[[Status]] = ~unlinked~ に設定する。続いてホストが _A_.Link() を呼ぶと、再度成功し、_A_.[[Status]] = _B_.[[Status]] = _C_.[[Status]] = ~linked~ となる。これら準備ステップは任意の時点で行える。その後、モジュール副作用を許容するタイミングで _A_.Evaluate() を呼ぶと、仮定により成功し *undefined* に解決される Promise を返し、内部的には _C_、次に _B_ を評価する。各モジュールの [[Status]] は ~evaluated~。</p>

          <p>次にリンクエラーを含むケースを考える（_A_.LoadRequestedModules() が成功後）。もし _C_ の InnerModuleLinking が成功した後 _B_ で失敗（例: _B_ が _C_ に存在しないものを import）すれば、当初の _A_.Link() は失敗し、_A_ と _B_ の [[Status]] は ~unlinked~ のまま。_C_ の [[Status]] は ~linked~ に達している。</p>

          <p>最後に、Link() 成功後の評価エラーを含むケース。_C_ の InnerModuleEvaluation が成功後、_B_ で失敗（例: _B_ のコードが例外を投げる）すると、_A_.Evaluate() は拒否された Promise を返す。例外は _A_ と _B_ 双方の [[EvaluationError]] に記録され、それらの [[Status]] は ~evaluated~。一方 _C_ も ~evaluated~ になるが、例外はなく [[EvaluationError]] は空。例外を保存することで後続の Evaluate() 呼び出しでも同一例外に遭遇する。（ホストは Cyclic Module Record を再利用する義務も、例外オブジェクトを外部に露出する義務もないが、仕様として可能にしている。）</p>

          <p>次に別種のエラー条件を考える:</p>

          <emu-figure id="figure-module-graph-missing" caption="解決不能モジュールを含むモジュールグラフ">
            <img alt="モジュール A が ??? という未解決モジュールに依存するモジュールグラフ" width="60" height="121" src="https://tc39.es/ecma262/img/module-graph-missing.svg">
          </emu-figure>

          <p>このシナリオではモジュール _A_ が他モジュールへの依存を宣言するが、その Module Record が存在しない（HostLoadImportedModule が FinishLoadingImportedModule へ例外で返す）。リソース不存在や ParseModule がエラーを返した場合などが要因。ホストは FinishLoadingImportedModule へ渡す completion を通じて失敗原因を公開できる。いずれにせよ例外は読み込み失敗を引き起こし、_A_ の [[Status]] は ~new~ のまま。</p>

          <p>読み込み・リンク・評価エラーの差異は以下の特徴による:</p>
          <ul>
            <li>評価は副作用をもたらすため一度だけ行うべきで、成功/失敗を記録しておく必要がある（失敗時も同じ例外を保持しないと後続 Evaluate() が新規例外を合成する必要が出る）。</li>
            <li>リンクは副作用がなく、失敗しても後から再試行できる。</li>
            <li>読み込みはホストとの緊密な相互作用があり、一時的ネットワーク不調などで失敗したロードをユーザが再試行できることが望まれる場合がある。</li>
          </ul>

          <p>次にサイクルを持つモジュールグラフ:</p>

          <emu-figure id="figure-module-graph-cycle" caption="循環モジュールグラフ">
            <img alt="モジュール A が B と C に依存し、B が A に依存するグラフ" width="181" height="121" src="https://tc39.es/ecma262/img/module-graph-cycle.svg">
          </emu-figure>

          <p>エントリポイントを _A_ と仮定し、ホストは _A_.LoadRequestedModules() を呼ぶ。これは _A_ 上で InnerModuleLoading を行い、さらに _B_, _C_ 上でも呼ぶ。サイクルにより再び _A_ に対する InnerModuleLoading がトリガーされるが、その依存読み込みは既に開始済みなので無操作。グラフ中すべてが正常にロードされると、全ての [[Status]] が同時に ~new~ から ~unlinked~ に。</p>

          <p>続いて _A_.Link() により _A_ の InnerModuleLinking を行い、_B_ に再帰。サイクルで再度 _A_ に来るが既に ~linking~ なので無操作。_B_ が ~linking~ のまま制御が _A_ に戻り _C_ の InnerModuleLinking。_C_ が ~linked~ になると _A_ と _B_ は同時に ~linking~ から ~linked~ へ（強連結成分単位で同時遷移できるよう DFS）。</p>

          <p>成功ケースでは評価段階も同様の物語。</p>

          <p>次に _A_ がリンクエラー（例: _C_ に存在しない束縛 import）を持つケース。上述のステップは（二度目の InnerModuleLinking(_A_) 早期リターン含め）進むが、最初の InnerModuleLinking(_A_) に戻って InitializeEnvironment（_C_.ResolveExport() 後）で失敗。*SyntaxError* が _A_.Link へ伝播し、_stack_ 上の ~linking~ モジュール（_A_, _B_）を ~unlinked~ へ戻す。_C_ は ~linked~ のまま。</p>

          <p>別に _A_ が評価エラー（ソースが例外 throw）ケース。評価版のステップが進み、二度目の InnerModuleEvaluation(_A_) から早期戻り後、最初へ戻って失敗。例外は _A_.Evaluate() へ伝播し、_stack_ 上の ~evaluating~ モジュールと [[AsyncParentModules]] 経由（top-level await 連鎖）にエラーを記録。_A_, _B_ は ~evaluated~ となり両 [[EvaluationError]] に記録、_C_ は例外なく ~evaluated~。</p>

          <p>最後に、全モジュールが非同期に完了するサイクル付きグラフ:</p>
          <emu-figure id="figure-module-graph-cycle-async" caption="非同期循環モジュールグラフ">
            <img alt="モジュール A が B と C に依存、B が D に、C が D と E に、D が A に依存" width="241" height="211" src="https://tc39.es/ecma262/img/module-graph-cycle-async.svg">
          </emu-figure>
          <p>読み込みとリンクは同様で全て [[Status]] ~linked~。</p>

          <p>_A_.Evaluate() は _A_, _B_, _D_ に InnerModuleEvaluation を呼び ~evaluating~ に。再度 _A_ に当たるが ~evaluating~ のため無操作。ここで _D_.[[PendingAsyncDependencies]] = 0 なので ExecuteAsyncModule(_D_) を呼び PromiseCapability 付きで _D_.ExecuteModule。戻って _B_ の InnerModuleEvaluation で _B_.[[PendingAsyncDependencies]] = 1, [[AsyncEvaluationOrder]] = 1。さらに _A_ の元へ戻り _A_.[[PendingAsyncDependencies]] = 1。次に _C_ へ遷移し _D_（無操作）と _E_ を訪れる。_E_ は依存もサイクル参加もないため ExecuteAsyncModule(_E_) を呼び直ちにスタックから除去。戻って _C_.[[AsyncEvaluationOrder]] = 3。_A_ の依存ループ完了後 _A_.[[AsyncEvaluationOrder]] = 4 を設定し、強連結成分全体をスタックから除去、全モジュールを一度に ~evaluating-async~。状態は <emu-xref href="#table-module-graph-cycle-async-fields-1"></emu-xref> の通り。</p>

          <emu-table id="table-module-graph-cycle-async-fields-1" caption="初回 Evaluate() 呼び出し後のフィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
                <td>3</td>
                <td>0</td>
                <td>2</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>2 (_B_ と _C_)</td>
                <td>1 (_D_)</td>
                <td>2 (_D_ と _E_)</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>最初に _E_ が終了すると仮定。終了で AsyncModuleExecutionFulfilled が呼ばれ _E_.[[Status]] = ~evaluated~、_C_.[[PendingAsyncDependencies]] が 1 に減少。状態は <emu-xref href="#table-module-graph-cycle-async-fields-2"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-2" caption="モジュール _E_ 実行完了後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_C_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_D_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>次に _D_ が終了（唯一の実行中だった）。AsyncModuleExecutionFulfilled が再度呼ばれ _D_.[[Status]] = ~evaluated~。実行可能祖先は _B_ ([[AsyncEvaluationOrder]] 1) と _C_ (3) で _B_ を先に処理: _B_.[[PendingAsyncDependencies]] が 0、ExecuteAsyncModule(_B_) で実行開始。_C_.[[PendingAsyncDependencies]] も 0 になり _C_ も実行（_B_ が await を含めば並列）。状態は <emu-xref href="#table-module-graph-cycle-async-fields-3"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-3" caption="モジュール _D_ 実行完了後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>1</td>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>次に _C_ が終了。AsyncModuleExecutionFulfilled が呼ばれ _C_.[[Status]] = ~evaluated~、_A_.[[PendingAsyncDependencies]] が 1 に。状態は <emu-xref href="#table-module-graph-cycle-async-fields-4"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-4" caption="モジュール _C_ 実行完了後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>次いで _B_ が終了。AsyncModuleExecutionFulfilled が呼ばれ _B_.[[Status]] = ~evaluated~、_A_.[[PendingAsyncDependencies]] が 0 となり ExecuteAsyncModule が呼ばれ実行開始。状態は <emu-xref href="#table-module-graph-cycle-async-fields-5"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-5" caption="モジュール _B_ 実行完了後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>最後に _A_ が終了し AsyncModuleExecutionFulfilled を再度呼び _A_.[[Status]] = ~evaluated~。_A_.[[TopLevelCapability]] の Promise（_A_.Evaluate() が返したもの）が解決され終了。状態は <emu-xref href="#table-module-graph-cycle-async-fields-6"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-6" caption="モジュール _A_ 実行完了後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>別の失敗例として _B_ 完了前に _C_ がエラーで失敗。AsyncModuleExecutionRejected が呼ばれ _C_.[[Status]] = ~evaluated~, _C_.[[EvaluationError]] にエラーを設定し、AsyncParentModules へ伝播。状態は <emu-xref href="#table-module-graph-cycle-async-fields-7"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-7" caption="モジュール _C_ がエラー終了後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>~empty~</td>
                <td>_C_ の評価エラー</td>
              </tr>
            </table>
          </emu-table>

          <p>_C_ が _A_ に対しそのエラーで AsyncModuleExecutionRejected を呼ぶため _A_ も同じエラーで拒否され、_A_.[[Status]] = ~evaluated~。_A_.[[TopLevelCapability]] の Promise は拒否。状態は <emu-xref href="#table-module-graph-cycle-async-fields-8"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-8" caption="モジュール _A_ が拒否された後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>

                <td>_C_ の Evaluation Error</td>
              </tr>
            </table>
          </emu-table>

          <p>その後 _B_ がエラーなく完了。AsyncModuleExecutionFulfilled が呼ばれ _B_.[[Status]] = ~evaluated~。GatherAvailableAncestors(_B_) が呼ばれるが _A_.[[CycleRoot]] = _A_ が評価エラーを持つため _sortedExecList_ に追加されず処理終了。後続で _B_ を import する者はサイクルルート _A_ に設定された _C_ の評価エラーを参照して拒否を見る。状態は <emu-xref href="#table-module-graph-cycle-async-fields-9"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-9" caption="エラーグラフで _B_ 実行完了後フィールド">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>_C_ の Evaluation Error</td>
                <td>~empty~</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>ソーステキストモジュールレコード (Source Text Module Records)</h1>

        <p><dfn id="sourctextmodule-record" variants="Source Text Module Records">Source Text Module Record</dfn> は、ゴール記号 |Module| でパースされた ECMAScript ソーステキスト (<emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>) から定義されたモジュールに関する情報を表す。フィールドにはモジュールが import / export する名前の要約が格納され、具象メソッドはこれを利用してリンクと評価を行う。</p>

        <p>Source Text Module Record は抽象 Module Record 型の他サブクラスと同一グラフに存在でき、Cyclic Module Record 型の他サブクラスとのサイクルにも参加できる。</p>

        <p><emu-xref href="#table-cyclic-module-fields"></emu-xref> で定義されたフィールドに加え、Source Text Module Record は <emu-xref href="#table-additional-fields-of-source-text-module-records"></emu-xref> に列挙される追加フィールドを持つ。各フィールドは ParseModule で初期設定される。</p>
        <emu-table id="table-additional-fields-of-source-text-module-records" caption="Source Text Module Record の追加フィールド" oldids="table-38">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値の型
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                Parse Node
              </td>
              <td>
                ゴール記号 |Module| でソーステキストをパースした結果。
              </td>
            </tr>
            <tr>
              <td>
                [[Context]]
              </td>
              <td>
                ECMAScript 実行コンテキストまたは ~empty~
              </td>
              <td>
                このモジュールに関連付けられる実行コンテキスト。環境初期化まで ~empty~。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportMeta]]
              </td>
              <td>
                Object または ~empty~
              </td>
              <td>
                `import.meta` メタプロパティを通じて公開されるオブジェクト。アクセスされるまで ~empty~。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                ImportEntry Record のリスト
              </td>
              <td>
                モジュールコードから導出された ImportEntry レコードのリスト。
              </td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                ExportEntry Record のリスト
              </td>
              <td>
                モジュール内部宣言に対応する ExportEntry のリスト。
              </td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                ExportEntry Record のリスト
              </td>
              <td>
                モジュール内の再エクスポート import または `export * as namespace` 宣言に対応する ExportEntry のリスト。
              </td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                ExportEntry Record のリスト
              </td>
              <td>
                `export *` 宣言（`export * as namespace` を除く）に対応する ExportEntry のリスト。
              </td>
            </tr>
          </table>
        </emu-table>
        <p><dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> は単一の宣言的 import を要約する Record。各 ImportEntry Record は <emu-xref href="#table-importentry-record-fields"></emu-xref> のフィールドを持つ:</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry Record フィールド" oldids="table-39">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値の型
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record
              </td>
              <td>
                |ImportDeclaration| の |ModuleSpecifier| と import 属性を表す ModuleRequest Record。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                文字列または ~namespace-object~
              </td>
              <td>
                [[ModuleRequest]] が指すモジュールで束縛がエクスポートされる名前。~namespace-object~ は対象モジュールの namespace オブジェクトを要求することを示す。
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                文字列
              </td>
              <td>
                インポート値へローカルアクセスするための名前。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-import-forms-mapping-to-importentry-records"></emu-xref> は構文 import 形と ImportEntry フィールドの対応例を示す:</p>
          <emu-table id="table-import-forms-mapping-to-importentry-records" caption="Import 構文と ImportEntry Record の対応" informative oldids="table-40">
            <table>
              <thead>
                <tr>
                  <th>
                    Import 文形式
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `import v from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import * as ns from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~namespace-object~
                </td>
                <td>
                  *"ns"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x as v} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import "mod";`
                </td>
                <td colspan="3">
                  ImportEntry Record は作成されない。
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p><dfn id="exportentry-record" variants="ExportEntry Records">ExportEntry Record</dfn> は単一の宣言的 export を要約する Record。各 ExportEntry Record は <emu-xref href="#table-exportentry-records"></emu-xref> のフィールドを持つ:</p>
        <emu-table id="table-exportentry-records" caption="ExportEntry Record フィールド" oldids="table-41">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値の型
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ExportName]]
              </td>
              <td>
                文字列または *null*
              </td>
              <td>
                このモジュールがこの束縛をエクスポートする際の名前。
              </td>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record または *null*
              </td>
              <td>
                |ExportDeclaration| の |ModuleSpecifier| と import 属性を表す ModuleRequest Record。|ModuleSpecifier| が無い場合 *null*。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                文字列, *null*, ~all~, ~all-but-default~
              </td>
              <td>
                [[ModuleRequest]] が指すモジュールがこの束縛をエクスポートする名前。|ModuleSpecifier| が無い場合 *null*。~all~ は `export * as ns from "mod"`、~all-but-default~ は `export * from "mod"` に使用。
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                文字列または *null*
              </td>
              <td>
                モジュール内部からエクスポート値へアクセスするためのローカル名。内部で直接アクセスできない場合 *null*。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-export-forms-mapping-to-exportentry-records"></emu-xref> は構文 export 形と ExportEntry フィールドの対応例:</p>
          <emu-table id="table-export-forms-mapping-to-exportentry-records" caption="Export 構文と ExportEntry Record の対応" informative oldids="table-42">
            <table>
              <thead>
                <tr>
                  <th>
                    Export 文形式
                  </th>
                  <th>
                    [[ExportName]]
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `export var v;`
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function f() {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"f"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function () {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default 42;`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * from "mod";`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all-but-default~
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * as ns from "mod";`
                </td>
                <td>
                  *"ns"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all~
                </td>
                <td>
                  *null*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p>以下の定義は Source Text Module Record に必要な具象メソッドおよび抽象操作を規定する。</p>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript ソーステキスト,
              _realm_: Realm Record,
              _hostDefined_: 任意,
            ): Source Text Module Record または *SyntaxError* オブジェクトの空でないリスト
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_sourceText_ を |Module| としてパースした結果に基づき Source Text Module Record を生成。</dd>
          </dl>
          <emu-alg>
            1. _body_ を ParseText(_sourceText_, |Module|) とする。
            1. _body_ がエラーのリストなら _body_ を返す。
            1. _requestedModules_ を _body_ の ModuleRequests とする。
            1. _importEntries_ を _body_ の ImportEntries とする。
            1. _importedBoundNames_ を ImportedLocalNames(_importEntries_) とする。
            1. _indirectExportEntries_ を空リスト。
            1. _localExportEntries_ を空リスト。
            1. _starExportEntries_ を空リスト。
            1. _exportEntries_ を _body_ の ExportEntries とする。
            1. 各 ExportEntry Record _ee_ について
              1. もし _ee_.[[ModuleRequest]] が *null* なら
                1. もし _importedBoundNames_ が _ee_.[[LocalName]] を含まないなら
                  1. _ee_ を _localExportEntries_ に追加。
                1. それ以外
                  1. _ie_ を [[LocalName]] = _ee_.[[LocalName]] の _importEntries_ 要素とする。
                  1. もし _ie_.[[ImportName]] が ~namespace-object~ なら
                    1. 注: インポートされたモジュール namespace オブジェクトの再エクスポート。
                    1. _ee_ を _localExportEntries_ に追加。
                  1. それ以外
                    1. 注: 単一名の再エクスポート。
                    1. ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } を _indirectExportEntries_ に追加。
              1. それ以外で _ee_.[[ImportName]] が ~all-but-default~ なら
                1. Assert: _ee_.[[ExportName]] は *null*。
                1. _ee_ を _starExportEntries_ に追加。
              1. それ以外
                1. _ee_ を _indirectExportEntries_ に追加。
            1. _async_ を _body_ Contains `await` とする。
            1. Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluationOrder]]: ~unset~, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSAncestorIndex]]: ~empty~ } を返す。
          </emu-alg>
          <emu-note>
            <p>実装は ParseModule 評価前にモジュールソースをパースし早期エラー解析を行ってもよいが、エラー報告は仕様が実際に ParseModule を行う時点まで遅延しなければならない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-module-record-methods">
          <h1>Module Record 抽象メソッドの実装 (Source Text)</h1>

          <p>以下は <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> に対応する Source Text Module Record の具象メソッド。</p>

          <emu-clause id="sec-getexportednames" type="concrete method">
            <h1>
              GetExportedNames (
                optional _exportStarSet_: Source Text Module Record のリスト,
              ): 文字列リスト
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>
            <emu-alg>
              1. Assert: _module_.[[Status]] は ~new~ でない。
              1. _exportStarSet_ が無ければ空リストに設定。
              1. もし _exportStarSet_ が _module_ を含むなら
                1. Assert: `export *` 循環の開始点に到達。
                1. 空リストを返す。
              1. _module_ を _exportStarSet_ に追加。
              1. _exportedNames_ を空リスト。
              1. _module_.[[LocalExportEntries]] の各 ExportEntry Record _e_ について
                1. Assert: 直接束縛を提供。
                1. Assert: _e_.[[ExportName]] は *null* でない。
                1. _e_.[[ExportName]] を _exportedNames_ に追加。
              1. _module_.[[IndirectExportEntries]] の各 _e_ について
                1. Assert: 特定束縛 import の再エクスポート。
                1. Assert: _e_.[[ExportName]] は *null* でない。
                1. _e_.[[ExportName]] を追加。
              1. _module_.[[StarExportEntries]] の各 _e_ について
                1. Assert: _e_.[[ModuleRequest]] は *null* でない。
                1. _requestedModule_ を GetImportedModule(_module_, _e_.[[ModuleRequest]])。
                1. _starNames_ を _requestedModule_.GetExportedNames(_exportStarSet_)。
                1. 各 _n_ について
                  1. もし _n_ ≠ *"default"* なら
                    1. かつ _exportedNames_ に含まれないなら追加。
              1. _exportedNames_ を返す。
            </emu-alg>
            <emu-note>
              <p>GetExportedNames は曖昧な star export の名前を除去も例外化もしない。</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: 文字列,
                optional _resolveSet_: [[Module]](Module Record), [[ExportName]](文字列) を持つ Record のリスト,
              ): ResolvedBinding Record, *null*, または ~ambiguous~
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>

              <dt>description</dt>
              <dd>
                <p>ResolveExport は要求されたエクスポート名を最終的な定義モジュールとローカル束縛名へ解決する。定義モジュールは自身または import 先モジュール。_resolveSet_ は循環 import/export 経路検出に使われ、既に同一 (_module_, _exportName_) ペアが存在すれば循環で *null* を返す。再帰前に (_module_, _exportName_) を追加。</p>
                <p>定義が見つかれば ResolvedBinding Record { [[Module]], [[BindingName]] } を返す。namespace のみでローカル束縛が無い場合 [[BindingName]] は ~namespace~。定義が見つからない／循環なら *null*、曖昧なら ~ambiguous~ を返す。</p>
              </dd>
            </dl>

            <emu-alg>
              1. Assert: _module_.[[Status]] は ~new~ でない。
              1. _resolveSet_ がなければ空リスト。
              1. _resolveSet_ の各 Record _r_ について
                1. もし _module_ と _r_.[[Module]] が同一で _exportName_ = _r_.[[ExportName]] なら
                  1. Assert: 循環 import 要求。
                  1. *null* を返す。
              1. Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } を _resolveSet_ に追加。
              1. _module_.[[LocalExportEntries]] の各 _e_ について
                1. もし _e_.[[ExportName]] = _exportName_ なら
                  1. Assert: 直接束縛。
                  1. ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] } を返す。
              1. _module_.[[IndirectExportEntries]] の各 _e_ について
                1. もし _e_.[[ExportName]] = _exportName_ なら
                  1. Assert: _e_.[[ModuleRequest]] は *null* でない。
                  1. _importedModule_ を GetImportedModule(_module_, _e_.[[ModuleRequest]])。
                  1. もし _e_.[[ImportName]] が ~all~ なら
                    1. ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ } を返す。
                  1. それ以外
                    1. Assert: 具体的束縛 import。
                    1. Assert: _e_.[[ImportName]] は文字列。
                    1. _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_) を返す。
              1. もし _exportName_ = *"default"* なら
                1. Assert: 明示的な `default` export 非定義。
                1. *null* を返す。
                1. 注: `export * from "mod"` で `default` は供給されない。
              1. _starResolution_ を *null* とする。
              1. _module_.[[StarExportEntries]] の各 _e_ について
                1. Assert: _e_.[[ModuleRequest]] は *null* でない。
                1. _importedModule_ を GetImportedModule(_module_, _e_.[[ModuleRequest]])。
                1. _resolution_ を _importedModule_.ResolveExport(_exportName_, _resolveSet_)。
                1. _resolution_ が ~ambiguous~ なら ~ambiguous~ を返す。
                1. _resolution_ が *null* でないなら
                  1. Assert: _resolution_ は ResolvedBinding。
                  1. もし _starResolution_ が *null* なら _starResolution_ = _resolution_。
                  1. それ以外
                    1. Assert: 複数の `*` import が同名を含む。
                    1. もし _resolution_.[[Module]] ≠ _starResolution_.[[Module]] なら ~ambiguous~。
                    1. もし [[BindingName]] が異なり、いずれかが ~namespace~ なら ~ambiguous~。
                    1. 両方文字列かつ異なれば ~ambiguous~。
              1. _starResolution_ を返す。
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-cyclic-module-record-methods">
          <h1>Cyclic Module Record 抽象メソッドの実装 (Source Text)</h1>

          <p><emu-xref href="#table-cyclic-module-methods"></emu-xref> で定義された Cyclic Module Record 抽象メソッドに対応する Source Text Module Record の具象メソッド。</p>

          <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
            <h1>InitializeEnvironment ( ): ~unused~ を含む通常完了または throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[IndirectExportEntries]] の各 ExportEntry Record _e_ について
                1. Assert: _e_.[[ExportName]] は *null* でない。
                1. _resolution_ を _module_.ResolveExport(_e_.[[ExportName]]) とする。
                1. もし _resolution_ が *null* または ~ambiguous~ なら *SyntaxError* を投げる。
                1. Assert: _resolution_ は ResolvedBinding。
              1. Assert: すべての名前付き export は解決可能。
              1. _realm_ を _module_.[[Realm]]。
              1. Assert: _realm_ は *undefined* でない。
              1. _env_ を NewModuleEnvironment(_realm_.[[GlobalEnv]])。
              1. _module_.[[Environment]] を _env_ に設定。
              1. _module_.[[ImportEntries]] の各 ImportEntry Record _in_ について
                1. _importedModule_ を GetImportedModule(_module_, _in_.[[ModuleRequest]])。
                1. もし _in_.[[ImportName]] が ~namespace-object~ なら
                  1. _namespace_ を GetModuleNamespace(_importedModule_)。
                  1. ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*)。
                  1. ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_)。
                1. それ以外
                  1. _resolution_ を _importedModule_.ResolveExport(_in_.[[ImportName]])。
                  1. もし _resolution_ が *null* または ~ambiguous~ なら *SyntaxError*。
                  1. もし _resolution_.[[BindingName]] が ~namespace~ なら
                    1. _namespace_ を GetModuleNamespace(_resolution_.[[Module]])。
                    1. ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*)。
                    1. ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_)。
                  1. それ以外
                    1. CreateImportBinding(_env_, _in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]])。
              1. _moduleContext_ を新 ECMAScript 実行コンテキスト。
              1. Function を *null*。
              1. Assert: _module_.[[Realm]] は *undefined* でない。
              1. Realm を _module_.[[Realm]]。
              1. ScriptOrModule を _module_。
              1. VariableEnvironment / LexicalEnvironment を _module_.[[Environment]]。
              1. PrivateEnvironment を *null*。
              1. _module_.[[Context]] を _moduleContext_ に。
              1. _moduleContext_ を実行コンテキストスタックに push。
              1. _code_ を _module_.[[ECMAScriptCode]]。
              1. _varDeclarations_ を _code_ の VarScopedDeclarations。
              1. _declaredVarNames_ を空リスト。
              1. 各 _d_ ∈ _varDeclarations_ について
                1. _d_ の BoundNames 各 _dn_ について
                  1. _declaredVarNames_ に含まれなければ
                    1. ! _env_.CreateMutableBinding(_dn_, *false*)。
                    1. ! _env_.InitializeBinding(_dn_, *undefined*)。
                    1. _declaredVarNames_ に追加。
              1. _lexDeclarations_ を _code_ の LexicallyScopedDeclarations。
              1. _privateEnv_ を *null*。
              1. 各 _d_ ∈ _lexDeclarations_ について
                1. _d_ の BoundNames 各 _dn_ について
                  1. もし IsConstantDeclaration(_d_) が *true* なら
                    1. ! _env_.CreateImmutableBinding(_dn_, *true*)。
                  1. それ以外
                    1. ! _env_.CreateMutableBinding(_dn_, *false*)。
                  1. もし _d_ が |FunctionDeclaration| / |GeneratorDeclaration| / |AsyncFunctionDeclaration| / |AsyncGeneratorDeclaration| のいずれかなら
                    1. _fo_ を InstantiateFunctionObject(_d_, _env_, _privateEnv_)。
                    1. ! _env_.InitializeBinding(_dn_, _fo_)。
              1. 実行コンテキストスタックから _moduleContext_ を除去。
              1. ~unused~ を返す。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method">
            <h1>
              ExecuteModule (
                optional _capability_: PromiseCapability Record,
              ): ~unused~ を含む通常完了または throw completion
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _moduleContext_ を新 ECMAScript 実行コンテキスト。
              1. Function を *null*。
              1. Realm を _module_.[[Realm]]。
              1. ScriptOrModule を _module_。
              1. Assert: モジュールはリンク済みで環境宣言インスタンス化済み。
              1. VariableEnvironment / LexicalEnvironment を _module_.[[Environment]]。
              1. 実行中コンテキストを中断。
              1. もし _module_.[[HasTLA]] が *false* なら
                1. Assert: _capability_ は存在しない。
                1. _moduleContext_ をスタックへ push。
                1. _result_ を Completion(Evaluation of _module_.[[ECMAScriptCode]])。
                1. _moduleContext_ を中断しスタックから除去。
                1. 上位コンテキストを再開。
                1. もし _result_ が abrupt completion なら ? _result_ を返す。
              1. それ以外
                1. Assert: _capability_ は PromiseCapability Record。
                1. AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_) を実行。
              1. ~unused~ を返す。
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-synthetic-module-records">
        <h1>シンセティックモジュールレコード (Synthetic Module Records)</h1>

        <p><dfn variants="Synthetic Module Records">Synthetic Module Record</dfn> は仕様によって定義されるモジュール情報を表す。エクスポート名は作成時に静的定義され、対応値は SetSyntheticModuleExport で変化し得る。インポートや依存は持たない。</p>

        <emu-note>Synthetic Module Record は JSON モジュールや CSS モジュールなど多様なモジュール形式を定義するために利用できる。</emu-note>

        <p><emu-xref href="#table-module-record-fields"></emu-xref> で定義されたフィールドに加え、Synthetic Module Record は <emu-xref href="#table-synthetic-module-record-fields"></emu-xref> の追加フィールドを持つ。</p>

        <emu-table id="table-synthetic-module-record-fields" caption="Synthetic Module Record の追加フィールド">
          <table>
            <thead>
              <tr>
                <th>フィールド名</th>
                <th>値の型</th>
                <th>意味</th>
              </tr>
            </thead>
            <tr>
              <td>[[ExportNames]]</td>
              <td>文字列のリスト</td>
              <td>モジュールのエクスポート名（重複なし）。</td>
            </tr>
            <tr>
              <td>[[EvaluationSteps]]</td>
              <td>Abstract Closure</td>
              <td>評価時に実行する初期化ロジック。Synthetic Module Record を唯一の引数とし [[ExportNames]] を変更してはならない。abrupt completion を返し得る。</td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-create-default-export-synthetic-module" type="abstract operation">
          <h1>
            CreateDefaultExportSyntheticModule (
              _defaultExport_: ECMAScript 言語値,
            ): Synthetic Module Record
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_defaultExport_ を default export とする Synthetic Module Record を生成。</dd>
          </dl>
          <emu-alg>
            1. _realm_ を現在の Realm Record。
            1. _setDefaultExport_ を引数 (_module_) を取り _defaultExport_ を捕捉し以下を行う Abstract Closure:
              1. SetSyntheticModuleExport(_module_, *"default"*, _defaultExport_)。
              1. NormalCompletion(~unused~) を返す。
            1. Synthetic Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[HostDefined]]: *undefined*, [[ExportNames]]: « *"default"* », [[EvaluationSteps]]: _setDefaultExport_ } を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parse-json-module" type="abstract operation">
          <h1>
            ParseJSONModule (
              _source_: 文字列,
            ): Synthetic Module Record を含む通常完了または throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. _json_ を ? ParseJSON(_source_) とする。
            1. CreateDefaultExportSyntheticModule(_json_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-setsyntheticmoduleexport" type="abstract operation">
          <h1>
            SetSyntheticModuleExport (
              _module_: Synthetic Module Record,
              _exportName_: 文字列,
              _exportValue_: ECMAScript 言語値,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Synthetic Module Record の既存エクスポート値を設定または変更する。</dd>
          </dl>

          <emu-alg>
            1. Assert: _module_.[[ExportNames]] は _exportName_ を含む。
            1. _envRec_ を _module_.[[Environment]]。
            1. Assert: _envRec_ は ~empty~ でない。
            1. _envRec_.SetMutableBinding(_exportName_, _exportValue_, *true*) を実行。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-smr-module-record-methods">
          <h1>Module Record 抽象メソッドの実装 (Synthetic)</h1>

          <p>以下は Synthetic Module Record の Module Record 抽象メソッド具象実装。</p>

          <emu-clause id="sec-smr-LoadRequestedModules" type="concrete method">
            <h1>LoadRequestedModules ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. ! PromiseResolve(%Promise%, *undefined*) を返す。
            </emu-alg>

            <emu-note>
              Synthetic Module Record に依存はない。
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-smr-getexportednames" type="concrete method">
            <h1>GetExportedNames ( ): 文字列リスト</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[ExportNames]] を返す。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: 文字列,
              ): ResolvedBinding Record または *null*
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. もし _module_.[[ExportNames]] が _exportName_ を含まなければ *null*。
              1. ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _exportName_ } を返す。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Link" type="concrete method">
            <h1>Link ( ): ~unused~ を含む通常完了</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _realm_ を _module_.[[Realm]]。
              1. _env_ を NewModuleEnvironment(_realm_.[[GlobalEnv]])。
              1. _module_.[[Environment]] を _env_ に。
              1. _module_.[[ExportNames]] の各文字列 _exportName_ について
                1. ! _env_.CreateMutableBinding(_exportName_, *false*)。
                1. ! _env_.InitializeBinding(_exportName_, *undefined*)。
              1. NormalCompletion(~unused~) を返す。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Evaluate" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _moduleContext_ を新 ECMAScript 実行コンテキスト。
              1. Function を *null*。
              1. Realm を _module_.[[Realm]]。
              1. ScriptOrModule を _module_。
              1. VariableEnvironment / LexicalEnvironment を _module_.[[Environment]]。
              1. 実行中コンテキストを中断。
              1. _moduleContext_ をスタックに push。
              1. _steps_ を _module_.[[EvaluationSteps]]。
              1. _result_ を Completion(_steps_(_module_))。
              1. _moduleContext_ を中断・除去。
              1. 上位コンテキストを再開。
              1. _pc_ を ! NewPromiseCapability(%Promise%)。
              1. IfAbruptRejectPromise(_result_, _pc_)。
              1. ! Call(_pc_.[[Resolve]], *undefined*, « *undefined* »)。
              1. _pc_.[[Promise]] を返す。
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-GetImportedModule" type="abstract operation">
        <h1>
          GetImportedModule (
            _referrer_: Cyclic Module Record,
            _request_: ModuleRequest Record,
          ): Module Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. [declared="r"] _records_ を _referrer_.[[LoadedModules]] のうち ModuleRequestsEqual(_r_, _request_) が *true* となる各 LoadedModuleRequest Record _r_ からなるリストとする。
          1. Assert: LoadRequestedModules が _referrer_ に正常完了しているため _records_ は正確に 1 要素。
          1. _record_ をその唯一要素。
          1. _record_.[[Module]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation" oldids="sec-hostresolveimportedmodule,sec-hostimportmoduledynamically">
        <h1>
          HostLoadImportedModule (
            _referrer_: Script Record, Cyclic Module Record, または Realm Record,
            _moduleRequest_: ModuleRequest Record,
            _hostDefined_: 任意,
            _payload_: GraphLoadingState Record または PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>_referrer_ が Realm Record になり得る例は Web ブラウザホスト。例えばユーザが</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>をクリックすると、`import()` 式実行時点でアクティブなスクリプトやモジュールが存在しない。ホストが ScriptOrModule *null* の実行コンテキストをスタックに積む状況全般で起こり得る。</p>
        </emu-note>

        <p>HostLoadImportedModule の実装は以下要件に従う:</p>
        <ul>
          <li>
            ホストは同期または非同期に、読み込まれた Module Record を含む通常完了または throw completion _result_ を用いて FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_) を行う。
          </li>
          <li>
            <p>同じ _referrer_ かつ ModuleRequestsEqual が *true* となる (_referrer_, _moduleRequest_) ペアで複数回呼ばれ、かつ _result_ が通常完了の場合、毎回同じ _result_ で FinishLoadingImportedModule を行わねばならない。</p>
          </li>
          <li>
            <p>_moduleRequest_.[[Attributes]] に [[Key]] *"type"* かつ [[Value]] *"json"* のエントリがある場合、FinishLoadingImportedModule 呼び出し時 _result_ は ParseJSONModule 呼び出し結果の Completion Record または throw completion でなければならない。</p>
          </li>
          <li>
            _payload_ は FinishLoadingImportedModule へ透過的に渡す不透明値として扱う。
          </li>
        </ul>

        <p>実際の処理はホスト定義だが、通常は適切な Module Record をロードするための各種 I/O を行う。異なる複数の (_referrer_, _moduleRequest_.[[Specifier]], _moduleRequest_.[[Attributes]]) 組が同一 Module Record インスタンスにマップされることがある。マッピングは通常 _specifier_ の正規化（相対・短縮パス展開など）を含む。</p>

        <emu-note>
          <p>上記は `type: "json"` でインポートされた JSON モジュールをホストがサポートすることを要求するが、`type: "json"` なしでの JSON モジュールサポートを禁止しない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" oldids="sec-finishdynamicimport">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: Script Record、Cyclic Module Record、または Realm Record,
            _moduleRequest_: ModuleRequest Record,
            _payload_: GraphLoadingState Record または PromiseCapability Record,
            _result_: Module Record を含む通常完了または throw completion のいずれか,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. _result_ が通常完了なら、
            1. もし _referrer_.[[LoadedModules]] が ModuleRequestsEqual(_record_, _moduleRequest_) が *true* となる LoadedModuleRequest Record _record_ を含むなら、
              1. Assert: _record_.[[Module]] と _result_.[[Value]] は同じ Module Record である。
            1. それ以外なら、
              1. LoadedModuleRequest Record { [[Specifier]]: _moduleRequest_.[[Specifier]], [[Attributes]]: _moduleRequest_.[[Attributes]], [[Module]]: _result_.[[Value]] } を _referrer_.[[LoadedModules]] に追加する。
          1. _payload_ が GraphLoadingState Record であれば、
            1. ContinueModuleLoading(_payload_, _result_) を実行する。
          1. それ以外なら、
            1. ContinueDynamicImport(_payload_, _result_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-AllImportAttributesSupported" type="abstract operation">
        <h1>
          AllImportAttributesSupported (
            _attributes_: ImportAttribute Record のリスト,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. _supported_ を HostGetSupportedImportAttributes() とする。
          1. _attributes_ の各 ImportAttribute Record _attribute_ について、
            1. もし _supported_ が _attribute_.[[Key]] を含まなければ *false* を返す。
          1. *true* を返す。
        </emu-alg>

        <emu-clause id="sec-hostgetsupportedimportattributes" type="host-defined abstract operation">
          <h1>HostGetSupportedImportAttributes ( ): 文字列リスト</h1>
          <dl class="header">
            <dt>description</dt>
            <dd>ホスト環境がサポートする import 属性を指定できる。サポートされるキーを持つ属性のみがホストへ提供される。</dd>
          </dl>

          <p>HostGetSupportedImportAttributes の実装は次の要件に従わなければならない:</p>

          <ul>
            <li>各要素がサポートされる属性を示す文字列であるリストを返さなければならない。</li>

            <li>この操作が呼び出されるたびに、同一内容・同一順序の同一リストを返さなければならない。</li>
          </ul>

          <p>HostGetSupportedImportAttributes のデフォルト実装は、新しい空リストを返すことである。</p>

          <emu-note>ホストに全ての属性を渡して選別させるのではなく、サポートしている属性キーをホストが明示することを要求する目的は、サポートされない属性の扱いを異なるホスト間で一貫させるためである。</emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-getmodulenamespace" type="abstract operation">
        <h1>
          GetModuleNamespace (
            _module_: Module Record の具象サブクラスのインスタンス,
          ): Module Namespace Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_module_ のエクスポートを表す Module Namespace Object を取得する。初回要求時に遅延生成し、以後の取得のために _module_.[[Namespace]] に格納する。</dd>
        </dl>

        <emu-alg>
          1. Assert: _module_ が Cyclic Module Record なら _module_.[[Status]] は ~new~ でも ~unlinked~ でもない。
          1. _namespace_ を _module_.[[Namespace]] とする。
          1. もし _namespace_ が ~empty~ なら
            1. _exportedNames_ を _module_.GetExportedNames() とする。
            1. _unambiguousNames_ を新しい空リストとする。
            1. _exportedNames_ の各要素 _name_ について
              1. _resolution_ を _module_.ResolveExport(_name_) とする。
              1. _resolution_ が ResolvedBinding Record なら _name_ を _unambiguousNames_ に追加する。
            1. _namespace_ を ModuleNamespaceCreate(_module_, _unambiguousNames_) とする。
          1. _namespace_ を返す。
        </emu-alg>
        <emu-note>
          <p>GetModuleNamespace は例外を投げない。解決不能な名前はこの時点では単に namespace から除外される。それらがすべてどこからも明示的に要求されない曖昧な star export でない限り、後で実際のリンクエラーにつながる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. *undefined* を返す。
        </emu-alg>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <emu-alg>
          1. _result_ を Completion(Evaluation of |ModuleItemList|) とする。
          1. _result_ が通常完了で _result_.[[Value]] が ~empty~ なら
            1. *undefined* を返す。
          1. ? _result_ を返す。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _sl_ を ? Evaluation of |ModuleItemList| とする。
          1. _s_ を Completion(Evaluation of |ModuleItem|) とする。
          1. ? UpdateEmpty(_s_, _sl_) を返す。
        </emu-alg>
        <emu-note>
          <p>|ModuleItemList| の値は、その中で最後に値を生成した項目の値である。</p>
        </emu-note>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. ~empty~ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>インポート</h1>
      <h2>構文</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause WithClause? `;`
          `import` ModuleSpecifier WithClause? `;`

        ImportClause :
          ImportedDefaultBinding
          NameSpaceImport
          NamedImports
          ImportedDefaultBinding `,` NameSpaceImport
          ImportedDefaultBinding `,` NamedImports

        ImportedDefaultBinding :
          ImportedBinding

        NameSpaceImport :
          `*` `as` ImportedBinding

        NamedImports :
          `{` `}`
          `{` ImportsList `}`
          `{` ImportsList `,` `}`

        FromClause :
          `from` ModuleSpecifier

        ImportsList :
          ImportSpecifier
          ImportsList `,` ImportSpecifier

        ImportSpecifier :
          ImportedBinding
          ModuleExportName `as` ImportedBinding

        ModuleSpecifier :
          StringLiteral

        ImportedBinding :
          BindingIdentifier[~Yield, +Await]

        WithClause :
          `with` `{` `}`
          `with` `{` WithEntries `,`? `}`

        WithEntries :
          AttributeKey `:` StringLiteral
          AttributeKey `:` StringLiteral `,` WithEntries

        AttributeKey :
          IdentifierName
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-imports-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <ul>
          <li>
            |ImportDeclaration| の BoundNames に重複するエントリが含まれている場合は構文エラー。
          </li>
        </ul>

        <emu-grammar>WithClause : `with` `{` WithEntries `,`? `}`</emu-grammar>
        <ul>
          <li>
            |WithClause| の WithClauseToAttributes に、_a_.[[Key]] が _b_.[[Key]] と同じになる 2 つの異なるエントリ _a_ と _b_ がある場合、構文エラー。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="sdo">
        <h1>静的意味論: ImportEntries ( ): ImportEntry Record のリスト</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _entries1_ を |ModuleItemList| の ImportEntries とする。
          1. _entries2_ を |ModuleItem| の ImportEntries とする。
          1. _entries1_ と _entries2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ExportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. _module_ を |ImportDeclaration| の ModuleRequests の唯一の要素とする。
          1. 引数 _module_ で |ImportClause| の ImportEntriesForModule を返す。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentriesformodule" type="sdo">
        <h1>
          静的意味論: ImportEntriesForModule (
          _module_: ModuleRequest Record,
          ): ImportEntry Record のリスト
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
        <emu-alg>
          1. _entries1_ を 引数 _module_ で |ImportedDefaultBinding| の ImportEntriesForModule とする。
          1. _entries2_ を 引数 _module_ で |NameSpaceImport| の ImportEntriesForModule とする。
          1. _entries1_ と _entries2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
        <emu-alg>
          1. _entries1_ を 引数 _module_ で |ImportedDefaultBinding| の ImportEntriesForModule とする。
          1. _entries2_ を 引数 _module_ で |NamedImports| の ImportEntriesForModule とする。
          1. _entries1_ と _entries2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ImportedDefaultBinding : ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ を |ImportedBinding| の BoundNames の唯一の要素とする。
          1. _defaultEntry_ を ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *"default"*, [[LocalName]]: _localName_ } とする。
          1. « _defaultEntry_ » を返す。
        </emu-alg>
        <emu-grammar>NameSpaceImport : `*` `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ を |ImportedBinding| の StringValue とする。
          1. _entry_ を ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ } とする。
          1. « _entry_ » を返す。
        </emu-alg>
        <emu-grammar>NamedImports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
        <emu-alg>
          1. _specs1_ を 引数 _module_ で |ImportsList| の ImportEntriesForModule とする。
          1. _specs2_ を 引数 _module_ で |ImportSpecifier| の ImportEntriesForModule とする。
          1. _specs1_ と _specs2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ImportSpecifier : ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ を |ImportedBinding| の BoundNames の唯一の要素とする。
          1. _entry_ を ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ } とする。
          1. « _entry_ » を返す。
        </emu-alg>
        <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. _importName_ を |ModuleExportName| の StringValue とする。
          1. _localName_ を |ImportedBinding| の StringValue とする。
          1. _entry_ を ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ } とする。
          1. « _entry_ » を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-withclausetoattributes" type="sdo">
        <h1>静的意味論: WithClauseToAttributes ( ): ImportAttribute Record のリスト</h1>
        <dl class="header">
        </dl>

        <emu-grammar>
          WithClause : `with` `{` `}`
        </emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>

        <emu-grammar>
          WithClause : `with` `{` WithEntries `,`? `}`
        </emu-grammar>
        <emu-alg>
          1. _attributes_ を |WithEntries| の WithClauseToAttributes とする。
          1. _attributes_ を各 [[Key]] フィールド値を UTF-16 符号単位列として扱い、辞書順でソートする。注: このソートが観測可能なのは、ホストが列挙順序によって挙動を変えることが禁止されている点のみである。
          1. _attributes_ を返す。
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral</emu-grammar>
        <emu-alg>
          1. _key_ を |AttributeKey| の PropName とする。
          1. _entry_ を ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| の SV } とする。
          1. « _entry_ » を返す。
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral `,` WithEntries</emu-grammar>
        <emu-alg>
          1. _key_ を |AttributeKey| の PropName とする。
          1. _entry_ を ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| の SV } とする。
          1. _rest_ を |WithEntries| の WithClauseToAttributes とする。
          1. « _entry_ » と _rest_ のリスト連結を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>エクスポート</h1>
      <h2>構文</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`

        ExportFromClause :
          `*`
          `*` `as` ModuleExportName
          NamedExports

        NamedExports :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          ModuleExportName
          ModuleExportName `as` ModuleExportName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>静的意味論: 早期エラー</h1>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <ul>
          <li>
            |NamedExports| の ReferencedBindings に |StringLiteral| が含まれている場合は構文エラー。
          </li>
          <li>
            |NamedExports| の ReferencedBindings 内の各 |IdentifierName| _n_ について: _n_ の StringValue が |ReservedWord| であるか、または *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, *"static"* のいずれかである場合は構文エラー。
          </li>
        </ul>
        <emu-note>
          <p>上記規則により |NamedExports| の各 ReferencedBindings は |IdentifierReference| として扱われる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportedbindings" oldids="sec-module-semantics-static-semantics-exportedbindings,sec-exports-static-semantics-exportedbindings" type="sdo">
        <h1>静的意味論: ExportedBindings ( ): 文字列リスト</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedBindings は |Module| の ExportedNames に明示的に関連付けられるローカル束縛名である。</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _names1_ を |ModuleItemList| の ExportedBindings とする。
          1. _names2_ を |ModuleItem| の ExportedBindings とする。
          1. _names1_ と _names2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. |NamedExports| の ExportedBindings を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| の BoundNames を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| の BoundNames を返す。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. この |ExportDeclaration| の BoundNames を返す。
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ を |ExportsList| の ExportedBindings とする。
          1. _names2_ を |ExportSpecifier| の ExportedBindings とする。
          1. _names1_ と _names2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. 唯一の要素が |ModuleExportName| の StringValue であるリストを返す。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 唯一の要素が最初の |ModuleExportName| の StringValue であるリストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" oldids="sec-module-semantics-static-semantics-exportednames,sec-exports-static-semantics-exportednames" type="sdo">
        <h1>静的意味論: ExportedNames ( ): 文字列リスト</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedNames は |Module| がローカル束縛名の一つに明示的に対応付ける外部可視名である。</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _names1_ を |ModuleItemList| の ExportedNames とする。
          1. _names2_ を |ModuleItem| の ExportedNames とする。
          1. _names1_ と _names2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. |ExportDeclaration| の ExportedNames を返す。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. |ExportFromClause| の ExportedNames を返す。
        </emu-alg>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 唯一の要素が |ModuleExportName| の StringValue であるリストを返す。
        </emu-alg>
        <emu-grammar>ExportFromClause : NamedExports</emu-grammar>
        <emu-alg>
          1. |NamedExports| の ExportedNames を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| の BoundNames を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| の BoundNames を返す。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. « *"default"* » を返す。
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ を |ExportsList| の ExportedNames とする。
          1. _names2_ を |ExportSpecifier| の ExportedNames とする。
          1. _names1_ と _names2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. 唯一の要素が |ModuleExportName| の StringValue であるリストを返す。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 唯一の要素が 2つ目の |ModuleExportName| の StringValue であるリストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" oldids="sec-module-semantics-static-semantics-exportentries,sec-exports-static-semantics-exportentries" type="sdo">
        <h1>静的意味論: ExportEntries ( ): ExportEntry Record のリスト</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _entries1_ を |ModuleItemList| の ExportEntries とする。
          1. _entries2_ を |ModuleItem| の ExportEntries とする。
          1. _entries1_ と _entries2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. _module_ を |ExportDeclaration| の ModuleRequests の唯一の要素とする。
          1. 引数 _module_ で |ExportFromClause| の ExportEntriesForModule を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. 引数 *null* で |NamedExports| の ExportEntriesForModule を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. _entries_ を新しい空リストとする。
          1. _names_ を |VariableStatement| の BoundNames とする。
          1. _names_ の各要素 _name_ について
            1. ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } を _entries_ に追加。
          1. _entries_ を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. _entries_ を新しい空リストとする。
          1. _names_ を |Declaration| の BoundNames とする。
          1. _names_ の各要素 _name_ について
            1. ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } を _entries_ に追加。
          1. _entries_ を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. _names_ を |HoistableDeclaration| の BoundNames とする。
          1. _localName_ を _names_ の唯一の要素とする。
          1. 唯一の要素が新しい ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } であるリストを返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. _names_ を |ClassDeclaration| の BoundNames とする。
          1. _localName_ を _names_ の唯一の要素とする。
          1. 唯一の要素が新しい ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } であるリストを返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. _entry_ を ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* } とする。
          1. « _entry_ » を返す。
        </emu-alg>
        <emu-note>
          <p>*"\*default\*"* は無名の default export 値のための合成名として仕様内で使用される。詳細は <emu-xref href="#note-star-default-star">このノート</emu-xref> を参照。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentriesformodule" type="sdo">
        <h1>
          静的意味論: ExportEntriesForModule (
          _module_: ModuleRequest Record または *null*,
          ): ExportEntry Record のリスト
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. _entry_ を ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* } とする。
          1. « _entry_ » を返す。
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. _exportName_ を |ModuleExportName| の StringValue とする。
          1. _entry_ を ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ } とする。
          1. « _entry_ » を返す。
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _specs1_ を 引数 _module_ で |ExportsList| の ExportEntriesForModule とする。
          1. _specs2_ を 引数 _module_ で |ExportSpecifier| の ExportEntriesForModule とする。
          1. _specs1_ と _specs2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. _sourceName_ を |ModuleExportName| の StringValue とする。
          1. もし _module_ が *null* なら
            1. _localName_ を _sourceName_ とする。
            1. _importName_ を *null* とする。
          1. それ以外
            1. _localName_ を *null* とする。
            1. _importName_ を _sourceName_ とする。
          1. 唯一の要素が ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ } であるリストを返す。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. _sourceName_ を 最初の |ModuleExportName| の StringValue とする。
          1. _exportName_ を 2つ目の |ModuleExportName| の StringValue とする。
          1. もし _module_ が *null* なら
            1. _localName_ を _sourceName_ とする。
            1. _importName_ を *null* とする。
          1. それ以外
            1. _localName_ を *null* とする。
            1. _importName_ を _sourceName_ とする。
          1. 唯一の要素が ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ } であるリストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-referencedbindings" type="sdo">
        <h1>静的意味論: ReferencedBindings ( ): Parse Node のリスト</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 新しい空リストを返す。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ を |ExportsList| の ReferencedBindings とする。
          1. _names2_ を |ExportSpecifier| の ReferencedBindings とする。
          1. _names1_ と _names2_ のリスト連結を返す。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 最初の |ModuleExportName| の ReferencedBindings を返す。
        </emu-alg>
        <emu-grammar>ModuleExportName : IdentifierName</emu-grammar>
        <emu-alg>
          1. 唯一の要素が |IdentifierName| であるリストを返す。
        </emu-alg>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <emu-alg>
          1. 唯一の要素が |StringLiteral| であるリストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-runtime-semantics-evaluation" type="sdo">
        <h1>実行時意味論: 評価</h1>
        <emu-grammar>
          ExportDeclaration :
            `export` ExportFromClause FromClause WithClause? `;`
            `export` NamedExports `;`
        </emu-grammar>
        <emu-alg>
          1. ~empty~ を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. ? Evaluation of |VariableStatement| を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. ? Evaluation of |Declaration| を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. ? Evaluation of |HoistableDeclaration| を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. _value_ を ? BindingClassDeclarationEvaluation of |ClassDeclaration| とする。
          1. _className_ を |ClassDeclaration| の BoundNames の唯一の要素とする。
          1. もし _className_ が *"\*default\*"* なら
            1. _env_ を実行中実行コンテキストの LexicalEnvironment とする。
            1. ? InitializeBoundName(*"\*default\*"*, _value_, _env_) を実行。
          1. ~empty~ を返す。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) が *true* なら
            1. _value_ を 引数 *"default"* で ? NamedEvaluation of |AssignmentExpression| とする。
          1. それ以外
            1. _rhs_ を ? Evaluation of |AssignmentExpression| とする。
            1. _value_ を ? GetValue(_rhs_) とする。
          1. _env_ を実行中実行コンテキストの LexicalEnvironment とする。
          1. ? InitializeBoundName(*"\*default\*"*, _value_, _env_) を実行。
          1. ~empty~ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-error-handling-and-language-extensions">
  <h1>エラー処理と言語拡張</h1>
  <p>実装は、関連する ECMAScript 言語構成要素が評価される時点でほとんどのエラーを報告しなければならない。<dfn id="early-error" variants="early errors">早期エラー (early error)</dfn> とは、そのエラーを含む |Script| 内のいかなる構成要素の評価よりも前に検出・報告できるエラーである。早期エラーが存在する場合、その構成要素の評価は行われない。実装は ParseScript における |Script| の構文解析の一部として |Script| 内の早期エラーを報告しなければならない。|Module| 内の早期エラーは、その |Module| が評価される時点で報告され、その |Module| は決して初期化されない。<b>eval</b> コード内の早期エラーは `eval` が呼び出された時点で報告され、<b>eval</b> コードの評価を阻止する。早期エラーでないすべてのエラーは実行時エラーである。</p>
  <p>実装は、本仕様の「静的意味論: 早期エラー」小節に列挙されている条件が発生したあらゆる箇所を早期エラーとして報告しなければならない。</p>
  <p>実装は、たとえコンパイラがある構成要素がいかなる状況でもエラーなく実行されないと証明できる場合であっても、他種のエラーを早期エラーとして扱ってはならない。そのような場合、実装は早期警告を発することは許されるが、関連する構成要素が実際に実行されるまでエラーを報告すべきではない。</p>
  <p>実装は、以下を除き、規定どおりにすべてのエラーを報告しなければならない:</p>
  <ul>
    <li>
      <emu-xref href="#sec-forbidden-extensions"></emu-xref> による制限を除き、ホストまたは実装は |Script| 構文、|Module| 構文、正規表現パターンまたはフラグの構文を拡張してよい。これを許容するため、*SyntaxError* を送出し得るすべての操作（`eval` の呼び出し、正規表現リテラルの使用、Function や RegExp コンストラクタの使用など）は、スクリプト構文または正規表現パターン／フラグ構文に対するホスト定義拡張に遭遇した際、*SyntaxError* を送出する代わりにホスト定義の挙動を示すことが許される。
    </li>
    <li>
      <emu-xref href="#sec-forbidden-extensions"></emu-xref> による制限を除き、ホストまたは実装は本仕様で記述されているものを超える追加の型、値、オブジェクト、プロパティ、関数を提供してよい。これは（グローバルスコープでの変数参照などの）構成要素がエラー（たとえば *ReferenceError*）を送出する代わりにホスト定義の挙動を示す原因となり得る。
    </li>
  </ul>

  <emu-clause id="sec-forbidden-extensions">
    <h1>禁止される拡張</h1>
    <p>実装は以下の方法で本仕様を拡張してはならない:</p>
    <ul>
      <li>
        厳格モードコード内の構文コンストラクタで定義された ECMAScript 関数オブジェクトは、*"caller"* または *"arguments"* という名前の独自プロパティを持つように作成されてはならない。|ArrowFunction|, |MethodDefinition|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |ClassDeclaration|, |ClassExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncArrowFunction| によって定義された関数オブジェクトについても、定義が厳格モードコード内に含まれるか否かにかかわらず、同様の独自プロパティを作成してはならない。組み込み関数、Function コンストラクタで生成された厳格関数、Generator コンストラクタで生成された generator 関数、AsyncFunction コンストラクタで生成された async 関数、`bind` メソッドで生成された関数についても、これらの独自プロパティを持ってはならない。
      </li>
      <li>
        実装が任意の関数オブジェクトを *"caller"* という名前の独自プロパティで拡張する場合、そのプロパティ値（[[Get]] または [[GetOwnProperty]] で観測される値）は厳格関数オブジェクトであってはならない。それがアクセサプロパティである場合、その [[Get]] 属性の値である関数は呼び出されたとき決して厳格関数を返してはならない。
      </li>
      <li>
        対応／非対応引数オブジェクトのいずれも *"caller"* という名前の独自プロパティを持つように作成されてはならない。
      </li>
      <li>
        ECMA-402 で規定される組み込みメソッド（`toLocaleString` など）の挙動は、ECMA-402 に規定される場合を除き拡張してはならない。
      </li>
      <li>
        <emu-xref href="#sec-patterns"></emu-xref> および <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> にある RegExp パターン文法は、<sub>[UnicodeMode]</sub> 文法パラメータが存在する場合に、ソース文字 A-Z または a-z のいずれかを |IdentityEscape[+UnicodeMode]| として認識するよう拡張してはならない。
      </li>
      <li>
        構文文法は、|BindingIdentifier| 非終端記号でマッチしたソーステキストの直後にトークン `:` が続くことを許すいかなる方法でも拡張してはならない。
      </li>
      <li>
        厳格モードコードを処理する際、実装は <emu-xref href="#sec-numeric-literals-early-errors"></emu-xref> の早期エールールを緩和してはならない。
      </li>
      <li>
        |TemplateEscapeSequence| を <emu-xref href="#sec-literals-string-literals"></emu-xref> で定義される |LegacyOctalEscapeSequence| または |NonOctalDecimalEscapeSequence| を含むよう拡張してはならない。
      </li>
      <li>
        厳格モードコードを処理する際、<emu-xref href="#sec-labelled-function-declarations"></emu-xref>、<emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>、<emu-xref href="#sec-functiondeclarations-in-ifstatement-statement-clauses"></emu-xref>、<emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> で定義される拡張はサポートしてはならない。
      </li>
      <li>
        |Module| ゴール記号に対する構文解析時、<emu-xref href="#sec-html-like-comments"></emu-xref> で定義される字句文法拡張はサポートしてはならない。
      </li>
      <!-- The following is so that in the future we can potentially add new arguments or support ArgumentList. -->
      <li>
        |ImportCall| は拡張してはならない。
      </li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-standard-built-in-objects">
  <h1>ECMAScript 標準組み込みオブジェクト</h1>
  <p>ECMAScript の |Script| または |Module| が実行を開始するとき、特定の組み込みオブジェクトが利用可能である。1 つはグローバルオブジェクトで、実行中プログラムのグローバル環境の一部である。その他はグローバルオブジェクトの初期プロパティ、またはアクセス可能な組み込みオブジェクトのプロパティとして間接的にアクセスできる。</p>
  <p>特に規定がない限り、関数として呼び出し可能な組み込みオブジェクトは <emu-xref href="#sec-built-in-function-objects"></emu-xref> に記述される特性を持つ組み込み関数オブジェクトである。特に規定がない限り、組み込みオブジェクトの [[Extensible]] 内部スロットは初期値 *true* を持つ。すべての組み込み関数オブジェクトは、そのオブジェクトが最初に生成されたレルムの Realm Record を値とする [[Realm]] 内部スロットを持つ。</p>
  <p>多くの組み込みオブジェクトは関数であり、引数付きで呼び出すことができる。そのうちいくつかはコンストラクタでもあり、`new` 演算子とともに使用されることを意図した関数である。各組み込み関数について、本仕様はその関数が要求する引数およびその関数オブジェクトのプロパティを記述する。各組み込みコンストラクタについては、さらにそのコンストラクタのプロトタイプオブジェクトのプロパティと、そのコンストラクタを呼び出す `new` 式が返す特定オブジェクトインスタンスのプロパティを記述する。</p>
  <p>特に規定がない限り、ある関数またはコンストラクタが規定されたより少ない個数の引数を与えられた場合、その関数またはコンストラクタは不足引数（各々 *undefined* 値）を与えられたかのように正確に動作しなければならない。これら不足引数は「存在しない (not present)」ものと見なされ、仕様アルゴリズムによってそのように識別され得る。個別の関数の記述において、用語 “*this* value” および “NewTarget” は <emu-xref href="#sec-built-in-function-objects"></emu-xref> に示される意味を持つ。</p>
  <p>特に規定がない限り、記述された組み込み関数またはコンストラクタが許容されるより多い引数を与えられた場合、余剰引数は呼び出しにより評価された後その関数によって無視される。ただし、実装は単に余剰引数が存在することだけを条件として *TypeError* 例外を投げるのでない範囲で、そうした引数に関連する実装固有の挙動を定義してよい。</p>
  <emu-note>
    <p>組み込み関数集合に追加能力を加える実装は、既存関数へ新しいパラメータを追加するよりも、新しい関数を追加することで行うことが推奨される。</p>
  </emu-note>
  <p>特に規定がない限り、すべての組み込み関数および組み込みコンストラクタは、その [[Prototype]] 内部スロットの値として Function プロトタイプオブジェクト（式 `Function.prototype` の初期値 (<emu-xref href="#sec-properties-of-the-function-prototype-object"></emu-xref>)) を持つ。</p>
  <p>特に規定がない限り、すべての組み込みプロトタイプオブジェクトは、その [[Prototype]] 内部スロットの値として Object プロトタイプオブジェクト（式 `Object.prototype` の初期値 (<emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>)）を持つ。ただし Object プロトタイプオブジェクト自身は除く。</p>
  <p>本仕様が組み込みコンストラクタの挙動をアルゴリズム手順で定義する場合、[[Call]] と [[Construct]] の双方の目的における挙動はそれである。アルゴリズムが両者を区別する必要がある場合、NewTarget が *undefined* であるかを確認する（これは [[Call]] 呼び出しを示す）。</p>
  <p>コンストラクタでない組み込み関数オブジェクトは、特別な規定がない限り [[Construct]] 内部メソッドを実装しない。</p>
  <p>コンストラクタでない組み込み関数オブジェクトは、特別な規定がない限り *"prototype"* プロパティを持たない。</p>
  <p>本仕様で定義される各組み込み関数は CreateBuiltinFunction 抽象操作 (<emu-xref href="#sec-createbuiltinfunction"></emu-xref>) を呼び出すことで生成される。パラメータ _length_ および _name_ の値は、それぞれ下記で述べられる *"length"* および *"name"* プロパティの初期値である。_prefix_ パラメータの値も同様に下記で述べられる。</p>
  <p>コンストラクタを含むすべての組み込み関数オブジェクトは、値が非負整数 Number である *"length"* プロパティを持つ。特に規定がない限り、この値は関数説明小節見出しに示される必須パラメータ数である。オプションパラメータおよび rest パラメータはカウントに含まれない。</p>
  <emu-note>
    <p>例えば、Array プロトタイプオブジェクトの *"map"* プロパティの初期値である関数オブジェクトは、小節見出し «Array.prototype.map (callback [ , thisArg])» で記述され、ふたつの名前付き引数 callback と thisArg を示し、後者はオプションである；したがってその関数オブジェクトの *"length"* プロパティ値は *1*<sub>𝔽</sub> である。</p>
  </emu-note>
  <p>特に規定がない限り、組み込み関数オブジェクトの *"length"* プロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
  <p>コンストラクタを含むすべての組み込み関数オブジェクトは、値が String である *"name"* プロパティを持つ。特に規定がない限り、この値は本仕様でその関数に与えられる名前である。匿名関数として指定される関数は、*"name"* プロパティ値として空文字列を使用する。オブジェクトのプロパティとして指定される関数については、その関数へアクセスする際に使用されるプロパティ名文字列が name 値となる。組み込みプロパティの get または set アクセサ関数として指定される関数は、CreateBuiltinFunction を呼ぶ際 _prefix_ パラメータに *"get"* または *"set"*（それぞれ）を渡す。</p>
  <p>プロパティキーが Symbol 値である各組み込み関数については、*"name"* プロパティの値が明示的に規定される。明示値が接頭辞 *"get "* または *"set "* で始まり、その関数が組み込みプロパティの get / set アクセサ関数である場合、接頭辞を除いた値が _name_ パラメータへ、*"get"* または *"set"*（それぞれ）が _prefix_ パラメータへ渡される。</p>
  <p>特に規定がない限り、組み込み関数オブジェクトの *"name"* プロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> から <emu-xref href="#sec-reflection"></emu-xref>、および付録 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> に記述されるその他のすべてのデータプロパティは、特に規定がない限り属性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> から <emu-xref href="#sec-reflection"></emu-xref>、および付録 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> に記述されるその他のすべてのアクセサプロパティは、特に規定がない限り属性 { [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。get アクセサ関数のみが記述される場合、set アクセサ関数はデフォルト値 *undefined* である。set アクセサのみが記述される場合、get アクセサはデフォルト値 *undefined* である。</p>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>グローバルオブジェクト</h1>
  <p><dfn variants="global objects">グローバルオブジェクト</dfn>:</p>
  <ul>
    <li>いかなる実行コンテキストへ制御が入る前に作成される。</li>
    <li>[[Construct]] 内部メソッドを持たない；`new` 演算子でコンストラクタとして使用できない。</li>
    <li>[[Call]] 内部メソッドを持たない；関数として呼び出せない。</li>
    <li>[[Prototype]] 内部スロットを持ち、その値はホスト定義である。</li>
    <li>本仕様で定義されるプロパティに加えてホスト定義プロパティを持ち得る。これには、その値がグローバルオブジェクト自身であるプロパティを含み得る。</li>
  </ul>

  <emu-clause id="sec-value-properties-of-the-global-object">
    <h1>グローバルオブジェクトの値プロパティ</h1>

    <emu-clause id="sec-globalthis">
      <h1>globalThis</h1>
      <p>Realm Record _realm_ におけるグローバルオブジェクトの *"globalThis"* プロパティの初期値は _realm_.[[GlobalEnv]].[[GlobalThisValue]] である。</p>
      <p>このプロパティは属性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-infinity">
      <h1>Infinity</h1>
      <p>`Infinity` の値は *+∞*<sub>𝔽</sub> である (<emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 参照)。このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-nan">
      <h1>NaN</h1>
      <p>`NaN` の値は *NaN* である (<emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 参照)。このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
    </emu-clause>

    <emu-clause id="sec-undefined">
      <h1>undefined</h1>
      <p>`undefined` の値は *undefined* である (<emu-xref href="#sec-ecmascript-language-types-undefined-type"></emu-xref> 参照)。このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>グローバルオブジェクトの関数プロパティ</h1>

    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <p>この関数は <dfn>%eval%</dfn> 組み込みオブジェクトである。</p>
      <p>呼び出されたとき、次の手順を実行する:</p>
      <emu-alg>
        1. ? PerformEval(_x_, *false*, *false*) を返す。
      </emu-alg>

      <emu-clause id="sec-performeval" type="abstract operation" oldids="sec-performeval-rules-outside-functions,sec-performeval-rules-outside-methods,sec-performeval-rules-outside-constructors">
        <h1>
          PerformEval (
            _x_: ECMAScript 言語値,
            _strictCaller_: Boolean,
            _direct_: Boolean,
          ): ECMAScript 言語値を含む通常完了または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _direct_ が *false* なら _strictCaller_ も *false*。
          1. もし _x_ が String でなければ _x_ を返す。
          1. _evalRealm_ を現在の Realm Record とする。
          1. 注: 直接 eval の場合、_evalRealm_ は `eval` 呼出元と `eval` 関数自身の双方のレルムである。
          1. ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_) を実行。
          1. _inFunction_ を *false* とする。
          1. _inMethod_ を *false* とする。
          1. _inDerivedConstructor_ を *false* とする。
          1. _inClassFieldInitializer_ を *false* とする。
          1. もし _direct_ が *true* なら
            1. _thisEnvRec_ を GetThisEnvironment() とする。
            1. もし _thisEnvRec_ が Function Environment Record なら
              1. _F_ を _thisEnvRec_.[[FunctionObject]] とする。
              1. _inFunction_ を *true* に設定。
              1. _inMethod_ を _thisEnvRec_.HasSuperBinding() に設定。
              1. もし _F_.[[ConstructorKind]] が ~derived~ なら _inDerivedConstructor_ を *true* に設定。
              1. _classFieldInitializerName_ を _F_.[[ClassFieldInitializerName]] とする。
              1. もし _classFieldInitializerName_ が ~empty~ でなければ _inClassFieldInitializer_ を *true* に設定。
          1. 以下のサブステップを実装定義の順序（構文解析とエラー検出をインタリーブしてもよい）で実行:
            1. _script_ を ParseText(_x_, |Script|) とする。
            1. もし _script_ がエラーのリストなら *SyntaxError* 例外を投げる。
            1. もし _script_ Contains |ScriptBody| が *false* なら *undefined* を返す。
            1. _body_ を _script_ の |ScriptBody| とする。
            1. もし _inFunction_ が *false* かつ _body_ が |NewTarget| を含むなら *SyntaxError* を投げる。
            1. もし _inMethod_ が *false* かつ _body_ が |SuperProperty| を含むなら *SyntaxError* を投げる。
            1. もし _inDerivedConstructor_ が *false* かつ _body_ が |SuperCall| を含むなら *SyntaxError* を投げる。
            1. もし _inClassFieldInitializer_ が *true* かつ _body_ の ContainsArguments が *true* なら *SyntaxError* を投げる。
          1. もし _strictCaller_ が *true* なら _strictEval_ を *true* とする。
          1. それ以外は _strictEval_ を ScriptIsStrict of _script_ とする。
          1. _runningContext_ を実行中実行コンテキストとする。
          1. 注: _direct_ が *true* の場合 _runningContext_ は直接 eval を実行した実行コンテキストである。_direct_ が *false* の場合 _runningContext_ は `eval` 呼出の実行コンテキストである。
          1. もし _direct_ が *true* なら
            1. _lexEnv_ を NewDeclarativeEnvironment(_runningContext_ の LexicalEnvironment) とする。
            1. _varEnv_ を _runningContext_ の VariableEnvironment とする。
            1. _privateEnv_ を _runningContext_ の PrivateEnvironment とする。
          1. それ以外
            1. _lexEnv_ を NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]) とする。
            1. _varEnv_ を _evalRealm_.[[GlobalEnv]] とする。
            1. _privateEnv_ を *null* とする。
          1. もし _strictEval_ が *true* なら _varEnv_ を _lexEnv_ に設定。
          1. もし _runningContext_ がまだサスペンドされていなければ _runningContext_ をサスペンド。
          1. _evalContext_ を新 ECMAScript コード実行コンテキストとする。
          1. _evalContext_.Function を *null* に設定。
          1. _evalContext_.Realm を _evalRealm_ に設定。
          1. _evalContext_.ScriptOrModule を _runningContext_.ScriptOrModule に設定。
          1. _evalContext_.VariableEnvironment を _varEnv_ に設定。
          1. _evalContext_.LexicalEnvironment を _lexEnv_ に設定。
          1. _evalContext_.PrivateEnvironment を _privateEnv_ に設定。
          1. _evalContext_ を実行コンテキストスタックにプッシュ；_evalContext_ が実行中実行コンテキストとなる。
          1. _result_ を Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_)) とする。
          1. もし _result_ が通常完了なら
            1. _result_ を Completion(Evaluation of _body_) に設定。
          1. もし _result_ が通常完了かつ _result_.[[Value]] が ~empty~ なら
            1. _result_ を NormalCompletion(*undefined*) に設定。
          1. _evalContext_ をサスペンドし実行コンテキストスタックから除去。
          1. スタック最上位のコンテキストを再開。
          1. ? _result_ を返す。
        </emu-alg>
        <emu-note>
          <p>eval コードは、呼び出し側コンテキストまたは eval コードのどちらか一方でも厳格モードコードである場合、呼び出し側の変数環境に変数や関数束縛をインスタンス化できない。代わりに、それら束縛は eval コードからのみアクセス可能な新しい VariableEnvironment にインスタンス化される。`let`、`const`、`class` 宣言によって導入される束縛は常に新しい LexicalEnvironment にインスタンス化される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hostensurecancompilestrings" type="host-defined abstract operation">
        <h1>
          HostEnsureCanCompileStrings (
            _calleeRealm_: Realm Record,
            _parameterStrings_: 文字列リスト,
            _bodyString_: 文字列,
            _direct_: Boolean,
          ): ~unused~ を含む通常完了または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>開発者が文字列を ECMAScript コードとして解釈・評価できる特定の ECMAScript 関数をホスト環境がブロックすることを可能にする。</dd>
        </dl>
        <p>
          _parameterStrings_ は（関数コンストラクタの一つを使用する際）連結されてパラメータリストを組み立てる文字列群を表す。_bodyString_ は関数本体または `eval` 呼び出しに渡される文字列を表す。
          _direct_ は評価が直接 eval かどうかを示す。
        </p>
        <p>HostEnsureCanCompileStrings のデフォルト実装は NormalCompletion(~unused~) を返す。</p>
      </emu-clause>

      <emu-clause id="sec-evaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-evaldeclarationinstantiation">
        <h1>
          EvalDeclarationInstantiation (
            _body_: |ScriptBody| Parse Node,
            _varEnv_: Environment Record,
            _lexEnv_: Declarative Environment Record,
            _privateEnv_: PrivateEnvironment Record または *null*,
            _strict_: Boolean,
          ): ~unused~ を含む通常完了または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _varNames_ を _body_ の VarDeclaredNames とする。
          1. _varDeclarations_ を _body_ の VarScopedDeclarations とする。
          1. もし _strict_ が *false* なら
            1. もし _varEnv_ が Global Environment Record なら
              1. 各 _name_ ∈ _varNames_ について
                1. もし HasLexicalDeclaration(_varEnv_, _name_) が *true* なら *SyntaxError* 例外を投げる。
                1. 注: `eval` はグローバル lexical 宣言にシャドーされるグローバル var 宣言を作らない。
            1. _thisEnv_ を _lexEnv_ とする。
            1. Assert: 以下のループは終了する。
            1. _thisEnv_ と _varEnv_ が同一 Environment Record でない間繰り返す
              1. もし _thisEnv_ が Object Environment Record でなければ
                1. 注: with 文の環境は lexical 宣言を含まないため var/let 衝突検査不要。
                1. 各 _name_ ∈ _varNames_ について
                  1. もし ! _thisEnv_.HasBinding(_name_) が *true* なら
                    1. [id="step-evaldeclarationinstantiation-throw-duplicate-binding", normative-optional] ホストが Web ブラウザまたは <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> をサポートする場合、
                      1. もし _thisEnv_ が |Catch| 節の Environment Record でなければ *SyntaxError* 例外を投げる。
                    1. それ以外
                      1. *SyntaxError* 例外を投げる。
                  1. 注: 直接 eval は同名 lexical 宣言を越えて var を巻き上げない。
              1. _thisEnv_ を _thisEnv_.[[OuterEnv]] に設定。
          1. _privateIdentifiers_ を空リストとする。
          1. _pointer_ を _privateEnv_ とする。
          1. _pointer_ が *null* でない間繰り返す
            1. 各 Private Name _binding_ ∈ _pointer_.[[Names]] について
              1. もし _privateIdentifiers_ が _binding_.[[Description]] を含まなければ追加。
            1. _pointer_ を _pointer_.[[OuterPrivateEnvironment]] に設定。
          1. AllPrivateIdentifiersValid of _body_ (引数 _privateIdentifiers_) が *false* なら *SyntaxError* 例外。
          1. _functionsToInitialize_ を空リストとする。
          1. _declaredFunctionNames_ を空リストとする。
          1. _varDeclarations_ の各 _d_ を逆順で
            1. もし _d_ が |VariableDeclaration|, |ForBinding|, |BindingIdentifier| いずれでもなければ
              1. Assert: _d_ は |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| のいずれか。
              1. 注: 同名関数宣言が複数ある場合、最後が使用される。
              1. _fn_ を _d_ の BoundNames の唯一要素とする。
              1. もし _declaredFunctionNames_ が _fn_ を含まなければ
                1. もし _varEnv_ が Global Environment Record なら
                  1. _fnDefinable_ を ? CanDeclareGlobalFunction(_varEnv_, _fn_) とする。
                  1. もし _fnDefinable_ が *false* なら *TypeError*。
                1. _fn_ を _declaredFunctionNames_ に追加。
                1. _d_ を _functionsToInitialize_ の先頭に挿入。
          1. _declaredVarNames_ を空リストとする。
          1. _varDeclarations_ の各 _d_ について
            1. もし _d_ が |VariableDeclaration|, |ForBinding|, |BindingIdentifier| のいずれかなら
              1. 各文字列 _vn_ ∈ BoundNames(_d_) について
                1. もし _declaredFunctionNames_ が _vn_ を含まなければ
                  1. もし _varEnv_ が Global Environment Record なら
                    1. _vnDefinable_ を ? CanDeclareGlobalVar(_varEnv_, _vn_) とする。
                    1. もし _vnDefinable_ が *false* なら *TypeError*。
                  1. もし _declaredVarNames_ が _vn_ を含まなければ追加。
          1. [id="step-evaldeclarationinstantiation-web-compat-insertion-point", normative-optional] もし _strict_ が *false* かつホストが Web ブラウザまたは <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> をサポートするなら
            1. _declaredFunctionOrVarNames_ を _declaredFunctionNames_ と _declaredVarNames_ の連結とする。
            1. _body_ Contains _x_ が *true* となる任意の |Block|, |CaseClause|, |DefaultClause| _x_ の |StatementList| に直接含まれる各 |FunctionDeclaration| _f_ について
              1. _F_ を _f_ の |BindingIdentifier| の StringValue とする。
              1. |FunctionDeclaration| _f_ を |BindingIdentifier| が _F_ の |VariableStatement| に置換しても _body_ に早期エラーが生じないなら
                1. _bindingExists_ を *false* とする。
                1. _thisEnv_ を _lexEnv_ とする。
                1. Assert: 以下のループは終了。
                1. _thisEnv_ ≠ _varEnv_ の間繰り返す
                  1. もし _thisEnv_ が Object Environment Record でなければ
                    1. もし ! _thisEnv_.HasBinding(_F_) が *true* なら
                      1. [id="step-evaldeclarationinstantiation-web-compat-bindingexists", normative-optional] ホストが Web ブラウザまたは <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> をサポートするなら
                        1. もし _thisEnv_ が |Catch| 節の Environment Record でなければ _bindingExists_ を *true* に設定。
                      1. それ以外
                        1. _bindingExists_ を *true* に設定。
                  1. _thisEnv_ を _thisEnv_.[[OuterEnv]] に設定。
                1. もし _bindingExists_ が *false* かつ _varEnv_ が Global Environment Record なら
                  1. もし HasLexicalDeclaration(_varEnv_, _F_) が *false* なら
                    1. _fnDefinable_ を ? CanDeclareGlobalVar(_varEnv_, _F_) とする。
                  1. それ以外
                    1. _fnDefinable_ を *false* とする。
                1. それ以外
                  1. _fnDefinable_ を *true* とする。
                1. もし _bindingExists_ が *false* かつ _fnDefinable_ が *true* なら
                  1. もし _declaredFunctionOrVarNames_ が _F_ を含まなければ
                    1. もし _varEnv_ が Global Environment Record なら
                      1. ? CreateGlobalVarBinding(_varEnv_, _F_, *true*) を実行。
                    1. それ以外
                      1. _bindingExists_ を ! _varEnv_.HasBinding(_F_) とする。
                      1. もし _bindingExists_ が *false* なら
                        1. ! _varEnv_.CreateMutableBinding(_F_, *true*)。
                        1. ! _varEnv_.InitializeBinding(_F_, *undefined*)。
                    1. _F_ を _declaredFunctionOrVarNames_ に追加。
                  1. [id="step-evaldeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_ を評価する際、<emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> で規定される |FunctionDeclaration| 評価アルゴリズムの代わりに次を行う:
                    1. _gEnv_ を実行中実行コンテキストの VariableEnvironment とする。
                    1. _bEnv_ を実行中実行コンテキストの LexicalEnvironment とする。
                    1. _fObj_ を ! _bEnv_.GetBindingValue(_F_, *false*) とする。
                    1. ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*) を実行。
                    1. ~unused~ を返す。
          1. [id="step-evaldeclarationinstantiation-post-validation"] 注: このアルゴリズムステップ以降は、_varEnv_ が Global Environment Record かつグローバルオブジェクトが Proxy exotic でない限り異常終了しない。
          1. _lexDeclarations_ を _body_ の LexicallyScopedDeclarations とする。
          1. 各 _d_ ∈ _lexDeclarations_ について
            1. 注: 字句的宣言名はここでインスタンス化されるが初期化されない。
            1. 各 _dn_ ∈ BoundNames(_d_) について
              1. もし IsConstantDeclaration(_d_) が *true* なら
                1. ? _lexEnv_.CreateImmutableBinding(_dn_, *true*) を実行。
              1. それ以外
                1. ? _lexEnv_.CreateMutableBinding(_dn_, *false*) を実行。
          1. 各 Parse Node _f_ ∈ _functionsToInitialize_ について
            1. _fn_ を BoundNames(_f_) の唯一要素とする。
            1. _fo_ を InstantiateFunctionObject(_f_, _lexEnv_, _privateEnv_) とする。
            1. もし _varEnv_ が Global Environment Record なら
              1. ? CreateGlobalFunctionBinding(_varEnv_, _fn_, _fo_, *true*) を実行。
            1. それ以外
              1. _bindingExists_ を ! _varEnv_.HasBinding(_fn_) とする。
              1. もし _bindingExists_ が *false* なら
                1. 注: 前段階の検証により以下は異常終了を返さない。
                1. ! _varEnv_.CreateMutableBinding(_fn_, *true*)。
                1. ! _varEnv_.InitializeBinding(_fn_, _fo_)。
              1. それ以外
                1. ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*)。
          1. 各文字列 _vn_ ∈ _declaredVarNames_ について
            1. もし _varEnv_ が Global Environment Record なら
              1. ? CreateGlobalVarBinding(_varEnv_, _vn_, *true*) を実行。
            1. それ以外
              1. _bindingExists_ を ! _varEnv_.HasBinding(_vn_) とする。
              1. もし _bindingExists_ が *false* なら
                1. 注: 前段階の検証により以下は異常終了しない。
                1. ! _varEnv_.CreateMutableBinding(_vn_, *true*)。
                1. ! _varEnv_.InitializeBinding(_vn_, *undefined*)。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-isfinite-number">
      <h1>isFinite ( _number_ )</h1>
      <p>この関数は <dfn>%isFinite%</dfn> 組み込みオブジェクトである。</p>
      <p>呼び出されたとき次を実行:</p>
      <emu-alg>
        1. _num_ を ? ToNumber(_number_) とする。
        1. もし _num_ が有限でなければ *false* を返す。
        1. それ以外 *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isnan-number">
      <h1>isNaN ( _number_ )</h1>
      <p>この関数は <dfn>%isNaN%</dfn> 組み込みオブジェクトである。</p>
      <p>呼び出されたとき次を実行:</p>
      <emu-alg>
        1. _num_ を ? ToNumber(_number_) とする。
        1. もし _num_ が *NaN* なら *true* を返す。
        1. それ以外 *false* を返す。
      </emu-alg>
      <emu-note>
        <p>値 `X` が *NaN* かどうかを ECMAScript コードで信頼性高く判定する方法は、`X !== X` という形式の式である。結果は `X` が *NaN* のときかつそのときのみ *true* となる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parsefloat-string">
      <h1>parseFloat ( _string_ )</h1>
      <p>この関数は _string_ 引数の内容を 10 進リテラルとして解釈した結果により Number 値を生成する。</p>
      <p>これは <dfn>%parseFloat%</dfn> 組み込みオブジェクトである。</p>
      <p>呼び出されたとき次を実行:</p>
      <emu-alg>
        1. _inputString_ を ? ToString(_string_) とする。
        1. _trimmedString_ を ! TrimString(_inputString_, ~start~) とする。
        1. _trimmed_ を StringToCodePoints(_trimmedString_) とする。
        1. _trimmedPrefix_ を |StrDecimalLiteral| の構文を満たす最長接頭辞（_trimmed_ 自身の場合もある）とする。存在しなければ *NaN* を返す。
        1. _parsedNumber_ を ParseText(_trimmedPrefix_, |StrDecimalLiteral|) とする。
        1. Assert: _parsedNumber_ は Parse Node。
        1. _parsedNumber_ の StringNumericValue を返す。
      </emu-alg>
      <emu-note>
        <p>この関数は _string_ の先頭部分のみを Number 値として解釈する場合がある；10 進リテラル記法の一部として解釈できないコード単位は無視され、それらが無視されたことは通知されない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parseint-string-radix">
      <h1>parseInt ( _string_, _radix_ )</h1>
      <p>この関数は指定された _radix_ に従って _string_ の内容を解釈した結果により整数 Number を生成する。_string_ 先頭の空白は無視される。_radix_ が 0 に強制変換される（*undefined* など）場合、数表現が *"0x"* または *"0X"* で始まる場合を除き 10 とみなす。その場合は 16 とみなす。_radix_ が 16 の場合、数表現は任意で *"0x"* または *"0X"* で始まり得る。</p>
      <p>これは <dfn>%parseInt%</dfn> 組み込みオブジェクトである。</p>
      <p>呼び出されたとき次を実行:</p>
      <emu-alg>
        1. _inputString_ を ? ToString(_string_) とする。
        1. _S_ を ! TrimString(_inputString_, ~start~) とする。
        1. _sign_ を 1 とする。
        1. もし _S_ が空でなく先頭コード単位が 0x002D (HYPHEN-MINUS) なら _sign_ を -1 に設定。
        1. もし _S_ が空でなく先頭コード単位が 0x002B (PLUS SIGN) または 0x002D (HYPHEN-MINUS) なら _S_ を先頭 1 文字除去後の部分文字列に設定。
        1. _R_ を ℝ(? ToInt32(_radix_)) とする。
        1. _stripPrefix_ を *true* とする。
        1. もし _R_ ≠ 0 なら
          1. もし _R_ &lt; 2 または _R_ > 36 なら *NaN* を返す。
          1. もし _R_ ≠ 16 なら _stripPrefix_ を *false* に設定。
        1. それ以外
          1. _R_ を 10 に設定。
        1. もし _stripPrefix_ が *true* なら
          1. もし _S_ の長さが少なくとも 2 で先頭 2 コード単位が *"0x"* または *"0X"* なら
            1. _S_ をインデックス 2 以降の部分文字列に設定。
            1. _R_ を 16 に設定。
        1. もし _S_ が radix-_R_ の数字でないコード単位を含むなら _end_ をその最初の位置、そうでなければ _end_ を _S_ の長さとする。
        1. _Z_ を _S_ の 0 から _end_ までの部分文字列とする。
        1. もし _Z_ が空なら *NaN* を返す。
        1. _mathInt_ を _Z_ が radix-_R_ 表記で表す整数値とする（10〜35 に値を持つ数字には大文字 <b>A</b>〜<b>Z</b> および小文字 <b>a</b>〜<b>z</b> を使用）。（ただし _R_=10 で _Z_ が 20 を超える有効桁を含む場合、20 桁目以降の各有効桁は実装選択で 0 に置き換えてよく、かつ _R_ が 2,4,8,10,16,32 のいずれでもない場合、_mathInt_ は _Z_ の値を表す実装近似整数でよい。）
        1. もし _mathInt_ = 0 なら
          1. もし _sign_ = -1 なら *-0*<sub>𝔽</sub> を返す。
          1. *+0*<sub>𝔽</sub> を返す。
        1. 𝔽(_sign_ × _mathInt_) を返す。
      </emu-alg>
      <emu-note>
        <p>この関数は _string_ の先頭部分のみを整数値として解釈する場合がある；整数表記の一部と解釈できないコード単位は無視され、それらが無視されたことは通知されない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-uri-handling-functions" oldids="sec-uri-syntax-and-semantics">
      <h1>URI 取扱関数</h1>
      <p>Uniform Resource Identifier (URI) は（ウェブページやファイル等の）リソースや、それへアクセスするための転送プロトコル（HTTP や FTP など）をインターネット上で識別する文字列である。ECMAScript 言語自体は、本節で説明されるように URI をエンコードおよびデコードする関数を除き URI 使用のためのサポートを提供しない。`encodeURI` と `decodeURI` は完全な URI を扱うことを意図し、予約文字は特別な意味（区切りなど）を持つことを前提としてエンコードしない。`encodeURIComponent` と `decodeURIComponent` は URI の個々の構成要素を扱うことを意図し、予約文字がテキストを表し完全な URI の一部となるときに特別な意味を持たないようエンコードされるべきであると仮定する。</p>
      <emu-note>
        <p>予約文字集合は RFC 2396 に基づき、より新しい RFC 3986 による変更を反映していない。</p>
      </emu-note>
      <emu-note>
        <p>ECMAScript の多くの実装はウェブページを操作する追加関数やメソッドを提供する；それらは本標準の範囲外である。</p>
      </emu-note>

      <emu-clause id="sec-decodeuri-encodeduri">
        <h1>decodeURI ( _encodedURI_ )</h1>
        <p>この関数は、`encodeURI` 関数によって導入された可能性がある種類の各エスケープシーケンスおよび UTF-8 エンコーディングを、その表すコードポイントの UTF-16 エンコーディングへ置換した新しいバージョンの URI を計算する。`encodeURI` によって導入され得なかったエスケープシーケンスは置換されない。</p>
        <p>これは <dfn>%decodeURI%</dfn> 組み込みオブジェクトである。</p>
        <p>呼び出されたとき次を実行:</p>
        <emu-alg>
          1. _uriString_ を ? ToString(_encodedURI_) とする。
          1. _preserveEscapeSet_ を *";/?:@&=+$,#"* とする。
          1. ? Decode(_uriString_, _preserveEscapeSet_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decodeuricomponent-encodeduricomponent">
        <h1>decodeURIComponent ( _encodedURIComponent_ )</h1>
        <p>この関数は、`encodeURIComponent` によって導入された可能性がある各エスケープシーケンスおよび UTF-8 エンコーディングを、その表すコードポイントの UTF-16 エンコーディングへ置換した新しいバージョンの URI を計算する。</p>
        <p>これは <dfn>%decodeURIComponent%</dfn> 組み込みオブジェクトである。</p>
        <p>呼び出されたとき次を実行:</p>
        <emu-alg>
          1. _componentString_ を ? ToString(_encodedURIComponent_) とする。
          1. _preserveEscapeSet_ を空文字列とする。
          1. ? Decode(_componentString_, _preserveEscapeSet_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuri-uri">
        <h1>encodeURI ( _uri_ )</h1>
        <p>この関数は、UTF-16 エンコード (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) された URI の新しいバージョンを計算し、特定コードポイントの各出現を、そのコードポイントの UTF-8 エンコーディングを表す 1〜4 個のエスケープシーケンスへ置換する。</p>
        <p>これは <dfn>%encodeURI%</dfn> 組み込みオブジェクトである。</p>
        <p>呼び出されたとき次を実行:</p>
        <emu-alg>
          1. _uriString_ を ? ToString(_uri_) とする。
          1. _extraUnescaped_ を *";/?:@&=+$,#"* とする。
          1. ? Encode(_uriString_, _extraUnescaped_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuricomponent-uricomponent">
        <h1>encodeURIComponent ( _uriComponent_ )</h1>
        <p>この関数は、UTF-16 エンコード (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) された URI 構成要素の新しいバージョンを計算し、特定コードポイントの各出現を、そのコードポイントの UTF-8 エンコーディングを表す 1〜4 個のエスケープシーケンスへ置換する。</p>
        <p>これは <dfn>%encodeURIComponent%</dfn> 組み込みオブジェクトである。</p>
        <p>呼び出されたとき次を実行:</p>
        <emu-alg>
          1. _componentString_ を ? ToString(_uriComponent_) とする。
          1. _extraUnescaped_ を空文字列とする。
          1. ? Encode(_componentString_, _extraUnescaped_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encode" type="abstract operation">
        <h1>
          Encode (
            _string_: 文字列,
            _extraUnescaped_: 文字列,
          ): 文字列を含む通常完了または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_string_ を <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> に記述される UTF-16 エンコードされたコードポイント列とみなし URI エンコードとエスケープを行う。文字が RFC 2396 で非予約 (unreserved) と識別されるか _extraUnescaped_ に現れる場合はエスケープされない。</dd>
        </dl>
        <emu-alg>
          1. _len_ を _string_ の長さとする。
          1. _R_ を空文字列とする。
          1. _alwaysUnescaped_ を ASCII 単語文字列と *"-.!~\*'()"* の連結とする。
          1. _unescapedSet_ を _alwaysUnescaped_ と _extraUnescaped_ の連結とする。
          1. _k_ を 0 とする。
          1. _k_ &lt; _len_ の間繰り返す
            1. _C_ を _string_ のインデックス _k_ のコード単位とする。
            1. もし _unescapedSet_ が _C_ を含むなら
              1. _k_ を _k_ + 1 に。
              1. _R_ を _R_ と _C_ の連結に。
            1. それ以外
              1. _cp_ を CodePointAt(_string_, _k_) とする。
              1. もし _cp_.[[IsUnpairedSurrogate]] が *true* なら *URIError* 例外。
              1. _k_ を _k_ + _cp_.[[CodeUnitCount]] に。
              1. _Octets_ を _cp_.[[CodePoint]] に UTF-8 変換を適用して得るオクテット列とする。
              1. 各 _octet_ ∈ _Octets_ について
                1. _hex_ を _octet_ の 16 進大文字表現文字列とする。
                1. _R_ を _R_、*"%"*、StringPad(_hex_, 2, *"0"*, ~start~) の連結に。
          1. _R_ を返す。
        </emu-alg>
        <emu-note>
          <p>パーセントエンコーディングは個々のオクテットを表すため、単一のコードポイントが複数連続エスケープシーケンス（その UTF-8 コードユニット毎に 1 つ）で表現され得る。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-decode" type="abstract operation">
        <h1>
          Decode (
            _string_: 文字列,
            _preserveEscapeSet_: 文字列,
          ): 文字列を含む通常完了または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_preserveEscapeSet_ 内の Basic Latin 文字に対応するエスケープシーケンスを保持しつつ URI のアンエスケープとデコードを行う。</dd>
        </dl>
        <emu-alg>
          1. _len_ を _string_ の長さとする。
          1. _R_ を空文字列とする。
          1. _k_ を 0 とする。
          1. _k_ &lt; _len_ の間繰り返す
            1. _C_ を _string_ のインデックス _k_ のコード単位とする。
            1. _S_ を _C_ とする。
            1. もし _C_ がコード単位 0x0025 (PERCENT SIGN) なら
              1. もし _k_ + 3 > _len_ なら *URIError* 例外。
              1. _escape_ を _string_ の _k_ から _k_ + 3 までの部分文字列とする。
              1. _B_ を ParseHexOctet(_string_, _k_ + 1) とする。
              1. もし _B_ が整数でなければ *URIError* 例外。
              1. _k_ を _k_ + 2 に。
              1. _n_ を _B_ の先頭連続 1 ビット数とする。
              1. もし _n_ = 0 なら
                1. _asciiChar_ を数値が _B_ のコード単位とする。
                1. もし _preserveEscapeSet_ が _asciiChar_ を含むなら _S_ を _escape_ に、そうでなければ _S_ を _asciiChar_ に設定。
              1. それ以外
                1. もし _n_ = 1 または _n_ > 4 なら *URIError* 例外。
                1. _Octets_ を « _B_ » とする。
                1. _j_ を 1 とする。
                1. _j_ &lt; _n_ の間繰り返す
                  1. _k_ を _k_ + 1 に。
                  1. もし _k_ + 3 > _len_ なら *URIError* 例外。
                  1. もし _string_ のインデックス _k_ のコード単位が 0x0025 でなければ *URIError* 例外。
                  1. _continuationByte_ を ParseHexOctet(_string_, _k_ + 1) とする。
                  1. もし _continuationByte_ が整数でなければ *URIError* 例外。
                  1. _continuationByte_ を _Octets_ に追加。
                  1. _k_ を _k_ + 2 に。
                  1. _j_ を _j_ + 1 に。
                1. Assert: _Octets_ の長さは _n_。
                1. もし _Octets_ が Unicode コードポイントの有効な UTF-8 エンコーディングを含まなければ *URIError* 例外。
                1. _V_ を _Octets_ に UTF-8 変換を適用して得るコードポイント（オクテット列から 21 ビット値）とする。
                1. _S_ を UTF16EncodeCodePoint(_V_) に設定。
            1. _R_ を _R_ と _S_ の連結に。
            1. _k_ を _k_ + 1 に。
          1. _R_ を返す。
        </emu-alg>
        <emu-note>
          <p>RFC 3629 は無効な UTF-8 オクテットシーケンスのデコードを禁止する。例えば無効なシーケンス 0xC0 0x80 はコード単位 0x0000 にデコードされてはならない。Decode アルゴリズムの実装は、そのような無効シーケンスに遭遇した際 *URIError* を投げる必要がある。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-parsehexoctet" type="abstract operation">
        <h1>
          ParseHexOctet (
            _string_: 文字列,
            _position_: 非負整数,
          ): 非負整数または *SyntaxError* オブジェクトの空でないリスト
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_string_ の指定 _position_ にある 2 つの 16 進文字を符号なし 8 ビット整数にパースする。</dd>
        </dl>
        <emu-alg>
          1. _len_ を _string_ の長さとする。
          1. Assert: _position_ + 2 ≤ _len_。
          1. _hexDigits_ を _string_ の _position_ から _position_ + 2 までの部分文字列とする。
          1. _parseResult_ を ParseText(_hexDigits_, |HexDigits[~Sep]|) とする。
          1. もし _parseResult_ が Parse Node でなければ _parseResult_ を返す。
          1. _n_ を _parseResult_ の MV とする。
          1. Assert: _n_ は 0 から 255 の閉区間内。
          1. _n_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-constructor-properties-of-the-global-object">
    <h1>グローバルオブジェクトのコンストラクタプロパティ</h1>

    <emu-clause id="sec-constructor-properties-of-the-global-object-aggregate-error">
      <h1>AggregateError ( . . . )</h1>
      <p><emu-xref href="#sec-aggregate-error-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-array">
      <h1>Array ( . . . )</h1>
      <p><emu-xref href="#sec-array-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-arraybuffer">
      <h1>ArrayBuffer ( . . . )</h1>
      <p><emu-xref href="#sec-arraybuffer-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint">
      <h1>BigInt ( . . . )</h1>
      <p><emu-xref href="#sec-bigint-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint64array">
      <h1>BigInt64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-biguint64array">
      <h1>BigUint64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-boolean">
      <h1>Boolean ( . . . )</h1>
      <p><emu-xref href="#sec-boolean-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-dataview">
      <h1>DataView ( . . . )</h1>
      <p><emu-xref href="#sec-dataview-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-date">
      <h1>Date ( . . . )</h1>
      <p><emu-xref href="#sec-date-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-error">
      <h1>Error ( . . . )</h1>
      <p><emu-xref href="#sec-error-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-evalerror">
      <h1>EvalError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-finalization-registry" oldids="sec-constructor-properties-of-the-global-object-finnalization-registry">
      <h1>FinalizationRegistry ( . . . )</h1>
      <p><emu-xref href="#sec-finalization-registry-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-float16array">
      <h1>Float16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-float32array">
      <h1>Float32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-float64array">
      <h1>Float64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-function">
      <h1>Function ( . . . )</h1>
      <p><emu-xref href="#sec-function-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-int8array">
      <h1>Int8Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-int16array">
      <h1>Int16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-int32array">
      <h1>Int32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-iterator">
      <h1>Iterator ( . . . )</h1>
      <p><emu-xref href="#sec-iterator-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-map">
      <h1>Map ( . . . )</h1>
      <p><emu-xref href="#sec-map-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-number">
      <h1>Number ( . . . )</h1>
      <p><emu-xref href="#sec-number-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-object">
      <h1>Object ( . . . )</h1>
      <p><emu-xref href="#sec-object-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-promise">
      <h1>Promise ( . . . )</h1>
      <p><emu-xref href="#sec-promise-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-proxy">
      <h1>Proxy ( . . . )</h1>
      <p><emu-xref href="#sec-proxy-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-rangeerror">
      <h1>RangeError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-referenceerror">
      <h1>ReferenceError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-regexp">
      <h1>RegExp ( . . . )</h1>
      <p><emu-xref href="#sec-regexp-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-set">
      <h1>Set ( . . . )</h1>
      <p><emu-xref href="#sec-set-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-sharedarraybuffer">
      <h1>SharedArrayBuffer ( . . . )</h1>
      <p><emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-string">
      <h1>String ( . . . )</h1>
      <p><emu-xref href="#sec-string-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-symbol">
      <h1>Symbol ( . . . )</h1>
      <p><emu-xref href="#sec-symbol-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-syntaxerror">
      <h1>SyntaxError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-typeerror">
      <h1>TypeError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-uint8array">
      <h1>Uint8Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-uint8clampedarray">
      <h1>Uint8ClampedArray ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-uint16array">
      <h1>Uint16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-uint32array">
      <h1>Uint32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-urierror">
      <h1>URIError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakmap">
      <h1>WeakMap ( . . . )</h1>
      <p><emu-xref href="#sec-weakmap-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakref">
      <h1>WeakRef ( . . . )</h1>
      <p><emu-xref href="#sec-weak-ref-constructor"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakset">
      <h1>WeakSet ( . . . )</h1>
      <p><emu-xref href="#sec-weakset-objects"></emu-xref> を参照。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-other-properties-of-the-global-object">
    <h1>グローバルオブジェクトのその他のプロパティ</h1>

    <emu-clause id="sec-atomics">
      <h1>Atomics</h1>
      <p><emu-xref href="#sec-atomics-object"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-json">
      <h1>JSON</h1>
      <p><emu-xref href="#sec-json-object"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-math">
      <h1>Math</h1>
      <p><emu-xref href="#sec-math-object"></emu-xref> を参照。</p>
    </emu-clause>

    <emu-clause id="sec-reflect">
      <h1>Reflect</h1>
      <p><emu-xref href="#sec-reflect-object"></emu-xref> を参照。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>基礎オブジェクト (Fundamental Objects)</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object オブジェクト</h1>

    <emu-clause id="sec-object-constructor">
      <h1>Object コンストラクタ</h1>
      <p>Object コンストラクタ:</p>
      <ul>
        <li><dfn>%Object%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Object"* プロパティの初期値である。</li>
        <li>コンストラクタとして呼び出されたとき新しい通常オブジェクトを生成する。</li>
        <li>コンストラクタではなく関数として呼び出されたとき型変換を行う。</li>
        <li>クラス定義の `extends` 節の値として使用できる。</li>
      </ul>

      <emu-clause id="sec-object-value">
        <h1>Object ( [ _value_ ] )</h1>
        <p>この関数は呼び出されたとき次の手順を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* でもアクティブな関数オブジェクトでもないなら
            1. ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*) を返す。
          1. _value_ が *undefined* または *null* なら OrdinaryObjectCreate(%Object.prototype%) を返す。
          1. ! ToObject(_value_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-constructor">
      <h1>Object コンストラクタのプロパティ</h1>
      <p>Object コンストラクタ:</p>
      <ul>
        <li>値 %Function.prototype% を持つ [[Prototype]] 内部スロットを有する。</li>
        <li>値 *1*<sub>𝔽</sub> の *"length"* プロパティを持つ。</li>
        <li>以下の追加プロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-object.assign">
        <h1>Object.assign ( _target_, ..._sources_ )</h1>
        <p>この関数は 1 つ以上のソースオブジェクトの列挙可能な自身のプロパティ（値）を _target_ オブジェクトへコピーする。</p>
        <p>呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _to_ を ? ToObject(_target_) とする。
          1. 引数が 1 個だけなら _to_ を返す。
          1. _sources_ の各要素 _nextSource_ について
            1. _nextSource_ が *undefined* でも *null* でもなければ
              1. _from_ を ! ToObject(_nextSource_) とする。
              1. _keys_ を ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]()</emu-meta> とする。
              1. _keys_ の各 _nextKey_ について
                1. _desc_ を ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_) とする。
                1. _desc_ が *undefined* でなく _desc_.[[Enumerable]] が *true* なら
                  1. _propValue_ を ? Get(_from_, _nextKey_) とする。
                  1. ? Set(_to_, _nextKey_, _propValue_, *true*) を実行。
          1. _to_ を返す。
        </emu-alg>
        <p>この関数の *"length"* プロパティは *2*<sub>𝔽</sub>。</p>
      </emu-clause>

      <emu-clause id="sec-object.create">
        <h1>Object.create ( _O_, _Properties_ )</h1>
        <p>この関数は指定されたプロトタイプを持つ新しいオブジェクトを生成する。</p>
        <p>呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなく かつ *null* でもないなら *TypeError* 例外を投げる。
          1. _obj_ を OrdinaryObjectCreate(_O_) とする。
          1. _Properties_ が *undefined* でなければ
            1. ? ObjectDefineProperties(_obj_, _Properties_) を返す。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.defineproperties">
        <h1>Object.defineProperties ( _O_, _Properties_ )</h1>
        <p>この関数はオブジェクトに自身のプロパティを追加し／または既存自身プロパティの属性を更新する。</p>
        <p>呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ *TypeError* 例外。
          1. ? ObjectDefineProperties(_O_, _Properties_) を返す。
        </emu-alg>

        <emu-clause id="sec-objectdefineproperties" type="abstract operation">
          <h1>
            ObjectDefineProperties (
              _O_: Object,
              _Properties_: ECMAScript 言語値,
            ): オブジェクトを含む通常完了または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _props_ を ? ToObject(_Properties_) とする。
            1. _keys_ を ? <emu-meta effects="user-code">_props_.[[OwnPropertyKeys]]()</emu-meta> とする。
            1. _descriptors_ を空リストとする。
            1. _keys_ の各 _nextKey_ について
              1. _propDesc_ を ? <emu-meta effects="user-code">_props_.[[GetOwnProperty]]</emu-meta>(_nextKey_) とする。
              1. _propDesc_ が *undefined* でなく _propDesc_.[[Enumerable]] が *true* なら
                1. _descObj_ を ? Get(_props_, _nextKey_) とする。
                1. _desc_ を ? ToPropertyDescriptor(_descObj_) とする。
                1. Record { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } を _descriptors_ に追加。
            1. _descriptors_ の各 _property_ について
              1. ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]]) を実行。
            1. _O_ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.defineproperty">
        <h1>Object.defineProperty ( _O_, _P_, _Attributes_ )</h1>
        <p>この関数は自身のプロパティを追加し／または既存自身プロパティの属性を更新する。</p>
        <p>呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ *TypeError*。
          1. _key_ を ? ToPropertyKey(_P_) とする。
          1. _desc_ を ? ToPropertyDescriptor(_Attributes_) とする。
          1. ? DefinePropertyOrThrow(_O_, _key_, _desc_)。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.entries">
        <h1>Object.entries ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _obj_ を ? ToObject(_O_) とする。
          1. _entryList_ を ? EnumerableOwnProperties(_obj_, ~key+value~) とする。
          1. CreateArrayFromList(_entryList_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.freeze">
        <h1>Object.freeze ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ _O_ を返す。
          1. _status_ を ? SetIntegrityLevel(_O_, ~frozen~) とする。
          1. _status_ が *false* なら *TypeError*。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.fromentries" oldids="sec-create-data-property-on-object-functions">
        <h1>Object.fromEntries ( _iterable_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_iterable_) を実行。
          1. _obj_ を OrdinaryObjectCreate(%Object.prototype%) とする。
          1. Assert: _obj_ は拡張可能な通常オブジェクトで自身プロパティを持たない。
          1. _closure_ を引数 (_key_, _value_) を取り _obj_ を捕捉し次を行う新しい Abstract Closure とする:
            1. _propertyKey_ を ? ToPropertyKey(_key_) とする。
            1. ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_)。
            1. NormalCompletion(*undefined*) を返す。
          1. _adder_ を CreateBuiltinFunction(_closure_, 2, *""*, « ») とする。
          1. ? AddEntriesFromIterable(_obj_, _iterable_, _adder_) を返す。
        </emu-alg>
        <emu-note>
          _adder_ 向けに生成された関数は ECMAScript コードから直接はアクセスできない。
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptor">
        <h1>Object.getOwnPropertyDescriptor ( _O_, _P_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _obj_ を ? ToObject(_O_) とする。
          1. _key_ を ? ToPropertyKey(_P_) とする。
          1. _desc_ を ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_) とする。
          1. FromPropertyDescriptor(_desc_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptors">
        <h1>Object.getOwnPropertyDescriptors ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _obj_ を ? ToObject(_O_) とする。
          1. _ownKeys_ を ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta> とする。
          1. _descriptors_ を OrdinaryObjectCreate(%Object.prototype%) とする。
          1. _ownKeys_ の各 _key_ について
            1. _desc_ を ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_) とする。
            1. _descriptor_ を FromPropertyDescriptor(_desc_) とする。
            1. _descriptor_ が *undefined* でなければ ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_)。
          1. _descriptors_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertynames">
        <h1>Object.getOwnPropertyNames ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertysymbols">
        <h1>Object.getOwnPropertySymbols ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~)) を返す。
        </emu-alg>

        <emu-clause id="sec-getownpropertykeys" type="abstract operation">
          <h1>
            GetOwnPropertyKeys (
              _O_: ECMAScript 言語値,
              _type_: ~string~ または ~symbol~,
            ): プロパティキーリストを含む通常完了または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _obj_ を ? ToObject(_O_) とする。
            1. _keys_ を ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta> とする。
            1. _nameList_ を空リストとする。
            1. _keys_ の各 _nextKey_ について
              1. _nextKey_ が Symbol で _type_ が ~symbol~ の場合、または _nextKey_ が String で _type_ が ~string~ の場合
                1. _nextKey_ を _nameList_ に追加。
            1. _nameList_ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.getprototypeof">
        <h1>Object.getPrototypeOf ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _obj_ を ? ToObject(_O_) とする。
          1. ? <emu-meta effects="user-code">_obj_.[[GetPrototypeOf]]()</emu-meta> を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.groupby">
        <h1>Object.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ は 2 引数を受け取る関数であるべき。`groupBy` は _items_ の各要素に昇順で 1 回ずつ _callback_ を呼び出し新しいオブジェクトを構築する。_callback_ から返された各値はプロパティキーに変換され、そのキーごとに結果オブジェクトはキーをそのキーに変換された値を持つ要素すべての配列に対応付ける。</p>
          <p>_callback_ は (要素の値, そのインデックス) の 2 引数で呼ばれる。</p>
          <p>`groupBy` の返す値は %Object.prototype% を継承しないオブジェクト。</p>
        </emu-note>
        <p>呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _groups_ を ? GroupBy(_items_, _callback_, ~property~) とする。
          1. _obj_ を OrdinaryObjectCreate(*null*) とする。
          1. 各 Record { [[Key]], [[Elements]] } _g_ ∈ _groups_ について
            1. _elements_ を CreateArrayFromList(_g_.[[Elements]]) とする。
            1. ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_)。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.hasown">
        <h1>Object.hasOwn ( _O_, _P_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _obj_ を ? ToObject(_O_) とする。
          1. _key_ を ? ToPropertyKey(_P_) とする。
          1. ? HasOwnProperty(_obj_, _key_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.is">
        <h1>Object.is ( _value1_, _value2_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. SameValue(_value1_, _value2_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isextensible">
        <h1>Object.isExtensible ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ *false* を返す。
          1. ? IsExtensible(_O_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isfrozen">
        <h1>Object.isFrozen ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ *true* を返す。
          1. ? TestIntegrityLevel(_O_, ~frozen~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.issealed">
        <h1>Object.isSealed ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ *true* を返す。
          1. ? TestIntegrityLevel(_O_, ~sealed~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.keys">
        <h1>Object.keys ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _obj_ を ? ToObject(_O_) とする。
          1. _keyList_ を ? EnumerableOwnProperties(_obj_, ~key~) とする。
          1. CreateArrayFromList(_keyList_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.preventextensions">
        <h1>Object.preventExtensions ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ _O_ を返す。
          1. _status_ を ? <emu-meta effects="user-code">_O_.[[PreventExtensions]]()</emu-meta> とする。
          1. _status_ が *false* なら *TypeError*。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype">
        <h1>Object.prototype</h1>
        <p>`Object.prototype` の初期値は Object プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-object.seal">
        <h1>Object.seal ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ が Object でなければ _O_ を返す。
          1. _status_ を ? SetIntegrityLevel(_O_, ~sealed~) とする。
          1. _status_ が *false* なら *TypeError*。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.setprototypeof">
        <h1>Object.setPrototypeOf ( _O_, _proto_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_O_) を実行。
          1. _proto_ が Object でなく かつ *null* でもないなら *TypeError*。
          1. _O_ が Object でなければ _O_ を返す。
          1. _status_ を ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_) とする。
          1. _status_ が *false* なら *TypeError*。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.values">
        <h1>Object.values ( _O_ )</h1>
        <p>この関数は呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _obj_ を ? ToObject(_O_) とする。
          1. _valueList_ を ? EnumerableOwnProperties(_obj_, ~value~) とする。
          1. CreateArrayFromList(_valueList_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-prototype-object" oldids="sec-additional-properties-of-the-object.prototype-object">
      <h1>Object プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Object プロトタイプオブジェクト</dfn> は次を満たす:</p>
      <ul>
        <li><dfn>%Object.prototype%</dfn> である。</li>
        <li>値 *true* の [[Extensible]] 内部スロットを持つ。</li>
        <li>通常オブジェクトに定義された内部メソッドを持つ（ただし [[SetPrototypeOf]] は <emu-xref href="#sec-immutable-prototype-exotic-objects-setprototypeof-v"></emu-xref> で定義されたもの）。（すなわち不変プロトタイプエキゾチックオブジェクト。）</li>
        <li>値 *null* の [[Prototype]] 内部スロットを持つ。</li>
      </ul>

      <emu-clause id="sec-object.prototype.constructor">
        <h1>Object.prototype.constructor</h1>
        <p>`Object.prototype.constructor` の初期値は %Object% である。</p>
      </emu-clause>

      <emu-clause id="sec-object.prototype.hasownproperty">
        <h1>Object.prototype.hasOwnProperty ( _V_ )</h1>
        <p>このメソッドは呼び出されたとき次を行う:</p>
        <emu-alg>
          1. [id="step-hasownproperty-topropertykey"] _P_ を ? ToPropertyKey(_V_) とする。
          1. [id="step-hasownproperty-toobject"] _O_ を ? ToObject(*this* value) とする。
          1. ? HasOwnProperty(_O_, _P_) を返す。
        </emu-alg>
        <emu-note>
          <p>手順 <emu-xref href="#step-hasownproperty-topropertykey"></emu-xref> と <emu-xref href="#step-hasownproperty-toobject"></emu-xref> の順序は、以前の版で最初の手順が投げていた可能性のある例外を *this* が *undefined* / *null* の場合でも維持するために選ばれている。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.isprototypeof">
        <h1>Object.prototype.isPrototypeOf ( _V_ )</h1>
        <p>このメソッドは呼び出されたとき次を行う:</p>
        <emu-alg>
          1. [id="step-isprototypeof-check-object"] _V_ が Object でなければ *false* を返す。
          1. [id="step-isprototypeof-toobject"] _O_ を ? ToObject(*this* value) とする。
          1. 繰り返し:
            1. _V_ を ? <emu-meta effects="user-code">_V_.[[GetPrototypeOf]]()</emu-meta> に設定。
            1. _V_ が *null* なら *false* を返す。
            1. SameValue(_O_, _V_) が *true* なら *true* を返す。
        </emu-alg>
        <emu-note>
          <p>手順順序は前版との互換性（_V_ がオブジェクトでない場合の挙動）を保つ。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.propertyisenumerable">
        <h1>Object.prototype.propertyIsEnumerable ( _V_ )</h1>
        <p>このメソッドは呼び出されたとき次を行う:</p>
        <emu-alg>
          1. [id="step-propertyisenumerable-topropertykey"] _P_ を ? ToPropertyKey(_V_) とする。
          1. [id="step-propertyisenumerable-toobject"] _O_ を ? ToObject(*this* value) とする。
          1. _desc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) とする。
          1. _desc_ が *undefined* なら *false*。
          1. _desc_.[[Enumerable]] を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドはプロトタイプチェーン上のオブジェクトを考慮しない。</p>
        </emu-note>
        <emu-note>
          <p>手順順序は過去との互換性保持のため。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tolocalestring">
        <h1>Object.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>このメソッドは呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. ? Invoke(_O_, *"toString"*) を返す。
        </emu-alg>
        <p>オプション引数は使用されないが ECMA-402 の `toLocaleString` 形式と整合させるために予約される。ECMA-402 を実装しない実装は他目的に使ってはならない。</p>
        <emu-note>
          <p>ロケール依存の `toString` を持たないオブジェクト用の汎用実装。`Array`, `Number`, `Date`, %TypedArray% は固有実装を持つ。</p>
        </emu-note>
        <emu-note>
          <p>ECMA-402 はこのデフォルト実装の代替を意図的に提供しない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tostring">
        <h1>Object.prototype.toString ( )</h1>
        <p>このメソッドは呼び出されたとき次を行う:</p>
        <emu-alg>
          1. *this* 値が *undefined* なら *"[object Undefined]"* を返す。
          1. *this* 値が *null* なら *"[object Null]"* を返す。
          1. _O_ を ! ToObject(*this* value) とする。
          1. _isArray_ を ? IsArray(_O_) とする。
          1. _isArray_ が *true* なら _builtinTag_ を *"Array"*。
          1. Else _O_ が [[ParameterMap]] 内部スロットを持つなら _builtinTag_ = *"Arguments"*。
          1. Else _O_ が [[Call]] 内部メソッドを持つなら _builtinTag_ = *"Function"*。
          1. Else _O_ が [[ErrorData]] 内部スロットを持つなら _builtinTag_ = *"Error"*。
          1. Else _O_ が [[BooleanData]] 内部スロットを持つなら *"Boolean"*。
          1. Else _O_ が [[NumberData]] 内部スロットを持つなら *"Number"*。
          1. Else _O_ が [[StringData]] 内部スロットを持つなら *"String"*。
          1. Else _O_ が [[DateValue]] 内部スロットを持つなら *"Date"*。
          1. Else _O_ が [[RegExpMatcher]] 内部スロットを持つなら *"RegExp"*。
          1. Else _builtinTag_ = *"Object"*。
          1. _tag_ を ? Get(_O_, %Symbol.toStringTag%) とする。
          1. _tag_ が String でなければ _tag_ = _builtinTag_。
          1. *"[object "* と _tag_ と *"]"* の連結を返す。
        </emu-alg>
        <emu-note>
          <p>歴史的にこのメソッドは [[Class]] 内部スロットの文字列表現取得に使われた。定義は互換性保持のためであり汎用型判定手段ではない。%Symbol.toStringTag% の利用で信頼性が損なわれ得る。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.valueof">
        <h1>Object.prototype.valueOf ( )</h1>
        <p>このメソッドは呼び出されたとき次を行う:</p>
        <emu-alg>
          1. ? ToObject(*this* value) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype.__proto__" legacy normative-optional>
        <h1>Object.prototype.__proto__</h1>
        <p>`Object.prototype.__proto__` は属性 { [[Enumerable]]: *false*, [[Configurable]]: *true* } のアクセサプロパティで、[[Get]] / [[Set]] は以下:</p>

        <emu-clause id="sec-get-object.prototype.__proto__">
          <h1>get Object.prototype.__proto__</h1>
          <p>引数不要の組み込み関数。呼び出し時:</p>
          <emu-alg>
            1. _O_ を ? ToObject(*this* value) とする。
            1. ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-object.prototype.__proto__">
          <h1>set Object.prototype.__proto__</h1>
          <p>引数 _proto_ を取る組み込み関数。呼び出し時:</p>
          <emu-alg>
            1. _O_ を *this* 値とする。
            1. ? RequireObjectCoercible(_O_)。
            1. _proto_ が Object でなく *null* でもなければ *undefined* を返す。
            1. _O_ が Object でなければ *undefined* を返す。
            1. _status_ を ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_) とする。
            1. _status_ が *false* なら *TypeError*。
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.prototype-legacy-accessor-methods" legacy normative-optional>
        <h1>レガシー Object.prototype アクセサメソッド</h1>

        <emu-clause id="sec-object.prototype.__defineGetter__">
          <h1>Object.prototype.__defineGetter__ ( _P_, _getter_ )</h1>
          <p>呼び出し手順:</p>
          <emu-alg>
            1. _O_ を ? ToObject(*this* value) とする。
            1. IsCallable(_getter_) が *false* なら *TypeError*。
            1. _desc_ を PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* } とする。
            1. _key_ を ? ToPropertyKey(_P_) とする。
            1. ? DefinePropertyOrThrow(_O_, _key_, _desc_)。
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__defineSetter__">
          <h1>Object.prototype.__defineSetter__ ( _P_, _setter_ )</h1>
          <p>呼び出し手順:</p>
          <emu-alg>
            1. _O_ を ? ToObject(*this* value) とする。
            1. IsCallable(_setter_) が *false* なら *TypeError*。
            1. _desc_ を PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* } とする。
            1. _key_ を ? ToPropertyKey(_P_) とする。
            1. ? DefinePropertyOrThrow(_O_, _key_, _desc_)。
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupGetter__">
          <h1>Object.prototype.__lookupGetter__ ( _P_ )</h1>
          <p>呼び出し手順:</p>
          <emu-alg>
            1. _O_ を ? ToObject(*this* value) とする。
            1. _key_ を ? ToPropertyKey(_P_) とする。
            1. 繰り返し:
              1. _desc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_) とする。
              1. _desc_ が *undefined* でなければ
                1. IsAccessorDescriptor(_desc_) が *true* なら _desc_.[[Get]] を返す。
                1. *undefined* を返す。
              1. _O_ を ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> とする。
              1. _O_ が *null* なら *undefined* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupSetter__">
          <h1>Object.prototype.__lookupSetter__ ( _P_ )</h1>
          <p>呼び出し手順:</p>
          <emu-alg>
            1. _O_ を ? ToObject(*this* value)。
            1. _key_ を ? ToPropertyKey(_P_)。
            1. 繰り返し:
              1. _desc_ を ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_)。
              1. _desc_ が *undefined* でなければ
                1. IsAccessorDescriptor(_desc_) が *true* なら _desc_.[[Set]] を返す。
                1. *undefined* を返す。
              1. _O_ を ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>。
              1. _O_ が *null* なら *undefined* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-object-instances">
      <h1>Object インスタンスのプロパティ</h1>
      <p>Object インスタンスは Object プロトタイプオブジェクトから継承するもの以外の特別なプロパティを持たない。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function オブジェクト</h1>

    <emu-clause id="sec-function-constructor">
      <h1>Function コンストラクタ</h1>
      <p>Function コンストラクタ:</p>
      <ul>
        <li><dfn>%Function%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Function"* プロパティの初期値である。</li>
        <li>コンストラクタでなく関数として呼び出されたとき新しい関数オブジェクトを生成し初期化する。すなわち `Function(…)` は同じ引数での `new Function(…)` と等価。</li>
        <li>クラス定義の `extends` 節値として使用できる。指定の Function 挙動を継承するサブクラスコンストラクタは内部スロットを持つインスタンス生成と初期化のため `super` 呼び出しが必要。ECMAScript の全ての構文的関数定義形式は Function のインスタンスを生成し、組み込み GeneratorFunction / AsyncFunction / AsyncGeneratorFunction のサブクラス以外にサブクラスインスタンスを生成する構文はない。</li>
      </ul>

      <emu-clause id="sec-function-p1-p2-pn-body">
        <h1>Function ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最後の引数（存在すれば）が関数本体（実行コード）を指定し、それ以前は仮引数を指定する。</p>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _C_ をアクティブな関数オブジェクトとする。
          1. _bodyArg_ が与えられなければ空文字列に設定。
          1. ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_) を返す。
        </emu-alg>
        <emu-note>
          <p>各仮引数に個別の引数を与える必要はない。以下 3 例は同じ結果:</p>
          <pre><code class="javascript">
            new Function("a", "b", "c", "return a+b+c")
            new Function("a, b, c", "return a+b+c")
            new Function("a,b", "c", "return a+b+c")
          </code></pre>
        </emu-note>

        <emu-clause id="sec-createdynamicfunction" type="abstract operation" oldids="table-dynamic-function-sourcetext-prefixes">
          <h1>
            CreateDynamicFunction (
              _constructor_: コンストラクタ,
              _newTarget_: コンストラクタまたは *undefined*,
              _kind_: ~normal~, ~generator~, ~async~, ~async-generator~,
              _parameterArgs_: ECMAScript 言語値リスト,
              _bodyArg_: ECMAScript 言語値,
            ): 関数オブジェクトを含む通常完了または throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_constructor_ はこの操作を実行中のコンストラクタ。_newTarget_ は最初に `new` が適用されたコンストラクタ。_parameterArgs_, _bodyArg_ は _constructor_ に渡された引数値。</dd>
          </dl>
          <emu-alg>
            1. _newTarget_ が *undefined* なら _newTarget_ = _constructor_。
            1. _kind_ が ~normal~ なら
              1. _prefix_ = *"function"*。
              1. _exprSym_ = |FunctionExpression|。
              1. _bodySym_ = |FunctionBody[~Yield, ~Await]|。
              1. _parameterSym_ = |FormalParameters[~Yield, ~Await]|。
              1. _fallbackProto_ = *"%Function.prototype%"*。
            1. Else if _kind_ = ~generator~
              1. _prefix_ = *"function\*"*。
              1. _exprSym_ = |GeneratorExpression|。
              1. _bodySym_ = |GeneratorBody|。
              1. _parameterSym_ = |FormalParameters[+Yield, ~Await]|。
              1. _fallbackProto_ = *"%GeneratorFunction.prototype%"*。
            1. Else if _kind_ = ~async~
              1. _prefix_ = *"async function"*。
              1. _exprSym_ = |AsyncFunctionExpression|。
              1. _bodySym_ = |AsyncFunctionBody|。
              1. _parameterSym_ = |FormalParameters[~Yield, +Await]|。
              1. _fallbackProto_ = *"%AsyncFunction.prototype%"*。
            1. Else
              1. Assert: _kind_ = ~async-generator~。
              1. _prefix_ = *"async function\*"*。
              1. _exprSym_ = |AsyncGeneratorExpression|。
              1. _bodySym_ = |AsyncGeneratorBody|。
              1. _parameterSym_ = |FormalParameters[+Yield, +Await]|。
              1. _fallbackProto_ = *"%AsyncGeneratorFunction.prototype%"*。
            1. _argCount_ を _parameterArgs_ の要素数とする。
            1. _parameterStrings_ を空リストとする。
            1. _parameterArgs_ の各 _arg_ について
              1. ? ToString(_arg_) を _parameterStrings_ に追加。
            1. _bodyString_ を ? ToString(_bodyArg_) とする。
            1. _currentRealm_ を現在の Realm Record とする。
            1. ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*)。
            1. _P_ を空文字列とする。
            1. _argCount_ > 0 なら
              1. _P_ = _parameterStrings_[0]。
              1. _k_ = 1。
              1. _k_ &lt; _argCount_ の間
                1. _nextArgString_ = _parameterStrings_[_k_]。
                1. _P_ を (_P_ + "," + _nextArgString_) に。
                1. _k_ = _k_ + 1。
            1. _bodyParseString_ を LF, _bodyString_, LF の連結とする。
            1. _sourceString_ を _prefix_, *" anonymous("*, _P_, LF, *") {"*, _bodyParseString_, *"}"* の連結とする。
            1. _sourceText_ = StringToCodePoints(_sourceString_)。
            1. _parameters_ = ParseText(_P_, _parameterSym_)。
            1. _parameters_ がエラーリストなら *SyntaxError*。
            1. _body_ = ParseText(_bodyParseString_, _bodySym_)。
            1. _body_ がエラーリストなら *SyntaxError*。
            1. （注）パラメータと本体を個別にパースすることでそれぞれ単独でも妥当性を保証。
            1. （注）ここに到達したら _sourceText_ は _exprSym_ の構文を満たすはず。次の 2 手順で Early Error を適用。
            1. _expr_ = ParseText(_sourceText_, _exprSym_)。
            1. _expr_ がエラーリストなら *SyntaxError*。
            1. _proto_ を ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_) とする。
            1. _env_ を _currentRealm_.[[GlobalEnv]]。
            1. _privateEnv_ = *null*。
            1. _F_ = OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_)。
            1. SetFunctionName(_F_, *"anonymous"*)。
            1. _kind_ = ~generator~ なら
              1. _prototype_ = OrdinaryObjectCreate(%GeneratorPrototype%)。
              1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
            1. Else if _kind_ = ~async-generator~
              1. _prototype_ = OrdinaryObjectCreate(%AsyncGeneratorPrototype%)。
              1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
            1. Else if _kind_ = ~normal~
              1. MakeConstructor(_F_) を実行。
            1. （注）_kind_ = ~async~ の関数は構築不能で *"prototype"* を持たない。
            1. _F_ を返す。
          </emu-alg>
          <emu-note>
            <p>CreateDynamicFunction は _kind_ が ~async~ でない関数に *"prototype"* プロパティを付与しコンストラクタとして利用され得るようにする。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-constructor">
      <h1>Function コンストラクタのプロパティ</h1>
      <p>Function コンストラクタ:</p>
      <ul>
        <li>自身が組み込み関数オブジェクト。</li>
        <li>[[Prototype]] 内部スロットの値は %Function.prototype%。</li>
        <li oldids="sec-function.length">*"length"* プロパティ値は *1*<sub>𝔽</sub>。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-function.prototype">
        <h1>Function.prototype</h1>
        <p>`Function.prototype` の値は Function プロトタイプオブジェクト。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-prototype-object">
      <h1>Function プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Function プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Function.prototype%</dfn> である。</li>
        <li>自身が組み込み関数オブジェクト。</li>
        <li>任意の引数を受け取り *undefined* を返す。</li>
        <li>[[Construct]] 内部メソッドを持たず `new` でコンストラクタ使用不可。</li>
        <li>[[Prototype]] 内部スロットは %Object.prototype%。</li>
        <li>*"prototype"* プロパティを持たない。</li>
        <li>*"length"* プロパティ値は *+0*<sub>𝔽</sub>。</li>
        <li>*"name"* プロパティ値は空文字列。</li>
      </ul>
      <emu-note>
        <p>互換性のため関数オブジェクトと規定される。</p>
      </emu-note>

      <emu-clause id="sec-function.prototype.apply">
        <h1>Function.prototype.apply ( _thisArg_, _argArray_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _func_ を *this* 値とする。
          1. IsCallable(_func_) が *false* なら *TypeError*。
          1. _argArray_ が *undefined* または *null* なら
            1. PrepareForTailCall() を実行。
            1. ? Call(_func_, _thisArg_) を返す。
          1. _argList_ を ? CreateListFromArrayLike(_argArray_) とする。
          1. PrepareForTailCall()。
          1. [id="step-function-proto-apply-call"] ? Call(_func_, _thisArg_, _argList_) を返す。
        </emu-alg>
        <emu-note>
          <p>_thisArg_ は変換なしに渡される（Edition 3 との違い）。非厳格関数は入口で再度変換を行う。</p>
        </emu-note>
        <emu-note>
          <p>_func_ がアローまたはバウンド関数なら _thisArg_ は手順 <emu-xref href="#step-function-proto-apply-call"></emu-xref> の [[Call]] に無視される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.bind">
        <h1>Function.prototype.bind ( _thisArg_, ..._args_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _Target_ を *this* 値とする。
          1. IsCallable(_Target_) が *false* なら *TypeError*。
          1. _F_ を ? BoundFunctionCreate(_Target_, _thisArg_, _args_) とする。
          1. _L_ = 0。
          1. _targetHasLength_ = ? HasOwnProperty(_Target_, *"length"*)。
          1. _targetHasLength_ が *true* なら
            1. _targetLen_ = ? Get(_Target_, *"length"*)。
            1. _targetLen_ が Number なら
              1. _targetLen_ が *+∞*<sub>𝔽</sub> なら _L_ = +∞。
              1. Else if _targetLen_ が *-∞*<sub>𝔽</sub> なら _L_ = 0。
              1. Else
                1. _targetLenAsInt_ = ! ToIntegerOrInfinity(_targetLen_)。
                1. Assert: 有限。
                1. _argCount_ = _args_ の要素数。
                1. _L_ = max(_targetLenAsInt_ - _argCount_, 0)。
          1. SetFunctionLength(_F_, _L_)。
          1. _targetName_ = ? Get(_Target_, *"name"*)。
          1. _targetName_ が String でなければ空文字列。
          1. SetFunctionName(_F_, _targetName_, *"bound"*)。
          1. _F_ を返す。
        </emu-alg>
        <emu-note>
          <p>`bind` で生成される関数はエキゾチックオブジェクトで *"prototype"* を持たない。</p>
        </emu-note>
        <emu-note>
          <p>_Target_ がアローまたはバウンド関数なら _thisArg_ は後続呼出で使用されない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.call">
        <h1>Function.prototype.call ( _thisArg_, ..._args_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _func_ を *this* 値とする。
          1. IsCallable(_func_) が *false* なら *TypeError*。
          1. PrepareForTailCall()。
          1. [id="step-function-proto-call-call"] ? Call(_func_, _thisArg_, _args_) を返す。
        </emu-alg>
        <emu-note>
          <p>_thisArg_ は変換されないが非厳格関数は入口で変換。</p>
        </emu-note>
        <emu-note>
          <p>_func_ がアロー/バウンド関数なら _thisArg_ は手順 <emu-xref href="#step-function-proto-call-call"></emu-xref> で無視。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.constructor">
        <h1>Function.prototype.constructor</h1>
        <p>`Function.prototype.constructor` の初期値は %Function%。</p>
      </emu-clause>

      <emu-clause id="sec-function.prototype.tostring">
        <h1>Function.prototype.toString ( )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _func_ を *this* 値とする。
          1. _func_ が Object で [[SourceText]] 内部スロットを持ち Unicode コードポイント列で HostHasSourceTextAvailable(_func_) が *true* なら
            1. CodePointsToString(_func_.[[SourceText]]) を返す。
          1. _func_ が <emu-xref href="#sec-built-in-function-objects">組み込み関数オブジェクト</emu-xref> なら実装定義の文字列（構文は |NativeFunction|）を返す。さらに [[InitialName]] があれば PropertyName 部にそれを用いる。
          1. _func_ が Object かつ IsCallable(_func_) が *true* なら実装定義文字列（|NativeFunction| 構文）を返す。
          1. *TypeError* 例外。
        </emu-alg>

        <emu-grammar type="definition">
          NativeFunction :
            `function` NativeFunctionAccessor? PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` `[` `native` `code` `]` `}`

          NativeFunctionAccessor :
            `get`
            `set`
        </emu-grammar>
      </emu-clause>

      <emu-clause oldids="sec-function.prototype-@@hasinstance" id="sec-function.prototype-%symbol.hasinstance%">
        <h1>Function.prototype [ %Symbol.hasInstance% ] ( _V_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _F_ を *this* 値とする。
          1. ? OrdinaryHasInstance(_F_, _V_) を返す。
        </emu-alg>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>多くの関数が継承するデフォルト実装。`instanceof` はこれを用いる。例</p>
          <pre><code class="javascript">
            v instanceof F
          </code></pre>
          <p>は</p>
          <pre><code class="javascript">
            F[%Symbol.hasInstance%](v)
          </code></pre>
          <p>と評価される。コンストラクタは別実装を公開することで判定を制御可能。</p>
        </emu-note>
        <p>改ざん防止のため非書換・非再構成。</p>
        <p>このメソッドの *"name"* プロパティ値は *"[Symbol.hasInstance]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-instances">
      <h1>Function インスタンス</h1>
      <p>全 Function インスタンスは ECMAScript 関数オブジェクトであり <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> の内部スロットを持つ。`Function.prototype.bind` により生成されたものは <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> の内部スロットを持つ。</p>
      <p>Function インスタンスは以下のプロパティを持つ:</p>

      <emu-clause id="sec-function-instances-length">
        <h1>length</h1>
        <p>*"length"* プロパティ値は典型的に期待される引数個数（整数）。他個数で呼び出し可能でその挙動は関数次第。このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-name">
        <h1>name</h1>
        <p>*"name"* プロパティ値は説明的な String。意味的影響はなく定義位置で参照に使われる識別的名称。属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        <p>文脈名を持たない匿名関数は空文字列を用いる。</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-prototype">
        <h1>prototype</h1>
        <p>コンストラクタとして使用可能な関数インスタンスは *"prototype"* プロパティを持ち、生成時に別の通常オブジェクトが作られ初期値となる。特に規定がない限りこの値はコンストラクタとして呼び出されたとき生成オブジェクトの [[Prototype]] 初期化に用いられる。</p>
        <p>属性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>`Function.prototype.bind` や |MethodDefinition|（|GeneratorMethod| / |AsyncGeneratorMethod| 以外）評価、|ArrowFunction| によるものは *"prototype"* を持たない。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-hosthassourcetextavailable" type="host-defined abstract operation">
      <h1>
        HostHasSourceTextAvailable (
          _func_: 関数オブジェクト,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ホストが _func_ のソーステキスト提供を防止するために用いる。</dd>
      </dl>
      <p>HostHasSourceTextAvailable の実装要件:</p>
      <ul>
        <li>引数に対して決定的であること。同一 _func_ への各呼出で同じ結果を返す。</li>
      </ul>
      <p>デフォルト実装は *true* を返す。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean オブジェクト</h1>

    <emu-clause id="sec-boolean-constructor">
      <h1>Boolean コンストラクタ</h1>
      <p>Boolean コンストラクタ:</p>
      <ul>
        <li><dfn>%Boolean%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Boolean"* プロパティ初期値。</li>
        <li>コンストラクタとして呼ぶと新 Boolean オブジェクト生成初期化。</li>
        <li>関数呼出時は型変換を行う。</li>
        <li>`extends` 節で利用可能。継承意図のサブクラスは `super` 呼び出しで [[BooleanData]] 内部スロットを持つインスタンスを生成初期化する必要。</li>
      </ul>

      <emu-clause id="sec-boolean-constructor-boolean-value">
        <h1>Boolean ( _value_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _b_ を ToBoolean(_value_) とする。
          1. NewTarget が *undefined* なら _b_ を返す。
          1. _O_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%Boolean.prototype%"*, « [[BooleanData]] »)。
          1. _O_.[[BooleanData]] = _b_。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-constructor">
      <h1>Boolean コンストラクタのプロパティ</h1>
      <p>Boolean コンストラクタ:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値は %Function.prototype%。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-boolean.prototype">
        <h1>Boolean.prototype</h1>
        <p>`Boolean.prototype` の初期値は Boolean プロトタイプオブジェクト。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-prototype-object">
      <h1>Boolean プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Boolean プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Boolean.prototype%</dfn> である。</li>
        <li>通常オブジェクト。</li>
        <li>自身が Boolean オブジェクトで [[BooleanData]] 内部スロット値 *false*。</li>
        <li>[[Prototype]] 内部スロット値は %Object.prototype%。</li>
      </ul>

      <emu-clause id="sec-boolean.prototype.constructor">
        <h1>Boolean.prototype.constructor</h1>
        <p>`Boolean.prototype.constructor` の初期値は %Boolean%。</p>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.tostring">
        <h1>Boolean.prototype.toString ( )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _b_ を ? ThisBooleanValue(*this* value) とする。
          1. _b_ が *true* なら *"true"* それ以外 *"false"* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.valueof">
        <h1>Boolean.prototype.valueOf ( )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. ? ThisBooleanValue(*this* value) を返す。
        </emu-alg>

        <emu-clause id="sec-thisbooleanvalue" type="abstract operation" oldids="thisbooleanvalue">
          <h1>
            ThisBooleanValue (
              _value_: ECMAScript 言語値,
            ): Boolean を含む通常完了または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ が Boolean なら返す。
            1. _value_ が Object かつ [[BooleanData]] 内部スロットを持つなら
              1. _b_ = _value_.[[BooleanData]]。
              1. Assert: _b_ は Boolean。
              1. _b_ を返す。
            1. *TypeError* 例外。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-boolean-instances">
      <h1>Boolean インスタンスのプロパティ</h1>
      <p>Boolean インスタンスは Boolean プロトタイプオブジェクトを継承する通常オブジェクトで [[BooleanData]] 内部スロットを持つ。これは当該 Boolean オブジェクトが表す値。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol オブジェクト</h1>

    <emu-clause id="sec-symbol-constructor">
      <h1>Symbol コンストラクタ</h1>
      <p>Symbol コンストラクタ:</p>
      <ul>
        <li><dfn>%Symbol%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Symbol"* プロパティ初期値。</li>
        <li>関数呼出で新しい Symbol 値を返す。</li>
        <li>`new` 演算子と共に使うことを意図しない。</li>
        <li>サブクラス化を意図しない。</li>
        <li>`extends` 節に使用可能だが `super` 呼出しは例外を投げる。</li>
      </ul>

      <emu-clause id="sec-symbol-description">
        <h1>Symbol ( [ _description_ ] )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. NewTarget が *undefined* でない場合、*TypeError* 例外を投げる。
          1. _description_ が *undefined* の場合、_descString_ を *undefined* とする。
          1. それ以外の場合、_descString_ を ? ToString(_description_) とする。
          1. &#8203;[[Description]] が _descString_ である新しい Symbol を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-constructor">
      <h1>Symbol コンストラクタのプロパティ</h1>
      <p>Symbol コンストラクタ:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値は %Function.prototype%。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-symbol.asynciterator">
        <h1>Symbol.asyncIterator</h1>
        <p>`Symbol.asyncIterator` の初期値は well-known symbol %Symbol.asyncIterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.for">
        <h1>Symbol.for ( _key_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _stringKey_ を ? ToString(_key_) とする。
          1. GlobalSymbolRegistry List の各 _e_ について
            1. _e_.[[Key]] が _stringKey_ なら _e_.[[Symbol]] を返す。
          1. Assert: 現時点で _stringKey_ のエントリはない。
          1. _newSymbol_ を [[Description]]=_stringKey_ の新しい Symbol とする。
          1. Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } を GlobalSymbolRegistry List に追加。
          1. _newSymbol_ を返す。
        </emu-alg>
        <p><dfn>GlobalSymbolRegistry List</dfn> は全レルム共有の追記専用リスト。ECMAScript コード評価前に空リストで初期化。要素は <emu-xref href="#table-globalsymbolregistry-record-fields"></emu-xref> の構造。</p>
        <emu-table id="table-globalsymbolregistry-record-fields" caption="GlobalSymbolRegistry Record Fields" oldids="table-44">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Usage
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                a String
              </td>
              <td>
                シンボルをグローバル識別する文字列キー。
              </td>
            </tr>
            <tr>
              <td>
                [[Symbol]]
              </td>
              <td>
                a Symbol
              </td>
              <td>
                どのレルムからも取得可能なシンボル。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-symbol.hasinstance">
        <h1>Symbol.hasInstance</h1>
        <p>`Symbol.hasInstance` の初期値は well-known symbol %Symbol.hasInstance%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.isconcatspreadable">
        <h1>Symbol.isConcatSpreadable</h1>
        <p>`Symbol.isConcatSpreadable` の初期値は well-known symbol %Symbol.isConcatSpreadable%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.iterator">
        <h1>Symbol.iterator</h1>
        <p>`Symbol.iterator` の初期値は well-known symbol %Symbol.iterator%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.keyfor">
        <h1>Symbol.keyFor ( _sym_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _sym_ が Symbol でなければ *TypeError*。
          1. KeyForSymbol(_sym_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.match">
        <h1>Symbol.match</h1>
        <p>`Symbol.match` 初期値は %Symbol.match%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.matchall">
        <h1>Symbol.matchAll</h1>
        <p>`Symbol.matchAll` 初期値は %Symbol.matchAll%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype">
        <h1>Symbol.prototype</h1>
        <p>`Symbol.prototype` の初期値は Symbol プロトタイプオブジェクト。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.replace">
        <h1>Symbol.replace</h1>
        <p>`Symbol.replace` 初期値は %Symbol.replace%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.search">
        <h1>Symbol.search</h1>
        <p>`Symbol.search` 初期値は %Symbol.search%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.species">
        <h1>Symbol.species</h1>
        <p>`Symbol.species` 初期値は %Symbol.species%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.split">
        <h1>Symbol.split</h1>
        <p>`Symbol.split` 初期値は %Symbol.split%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.toprimitive">
        <h1>Symbol.toPrimitive</h1>
        <p>`Symbol.toPrimitive` 初期値は %Symbol.toPrimitive%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.tostringtag">
        <h1>Symbol.toStringTag</h1>
        <p>`Symbol.toStringTag` 初期値は %Symbol.toStringTag%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.unscopables">
        <h1>Symbol.unscopables</h1>
        <p>`Symbol.unscopables` 初期値は %Symbol.unscopables%。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-prototype-object">
      <h1>Symbol プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Symbol プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Symbol.prototype%</dfn> である。</li>
        <li>通常オブジェクト。</li>
        <li>Symbol インスタンスでなく [[SymbolData]] 内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロット値は %Object.prototype%。</li>
      </ul>

      <emu-clause id="sec-symbol.prototype.constructor">
        <h1>Symbol.prototype.constructor</h1>
        <p>`Symbol.prototype.constructor` 初期値は %Symbol%。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.description">
        <h1>get Symbol.prototype.description</h1>
        <p>`Symbol.prototype.description` は set アクセサ *undefined* のアクセサプロパティで get は次:</p>
        <emu-alg>
          1. _s_ = *this* 値。
          1. _sym_ = ? ThisSymbolValue(_s_)。
          1. _sym_.[[Description]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.tostring">
        <h1>Symbol.prototype.toString ( )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _sym_ = ? ThisSymbolValue(*this* value)。
          1. SymbolDescriptiveString(_sym_) を返す。
        </emu-alg>

        <emu-clause id="sec-symboldescriptivestring" type="abstract operation">
          <h1>
            SymbolDescriptiveString (
              _sym_: Symbol,
            ): String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _desc_ = _sym_.[[Description]]。
            1. _desc_ が *undefined* なら空文字列に。
            1. Assert: _desc_ は String。
            1. *"Symbol("* + _desc_ + *")"* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.valueof">
        <h1>Symbol.prototype.valueOf ( )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. ? ThisSymbolValue(*this* value) を返す。
        </emu-alg>

        <emu-clause id="sec-thissymbolvalue" type="abstract operation" oldids="thissymbolvalue">
          <h1>
            ThisSymbolValue (
              _value_: ECMAScript 言語値,
            ): Symbol を含む通常完了または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ が Symbol なら返す。
            1. _value_ が Object かつ [[SymbolData]] 内部スロットを持つなら
              1. _s_ = _value_.[[SymbolData]]。
              1. Assert: _s_ は Symbol。
              1. _s_ を返す。
            1. *TypeError* 例外。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@toprimitive" id="sec-symbol.prototype-%symbol.toprimitive%">
        <h1>Symbol.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>このメソッドは Symbol オブジェクトをプリミティブに変換する際に呼ばれる。</p>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. ? ThisSymbolValue(*this* value) を返す。
        </emu-alg>
        <emu-note>
          <p>引数は無視される。</p>
        </emu-note>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        <p>*"name"* プロパティ値は *"[Symbol.toPrimitive]"*。</p>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@tostringtag" id="sec-symbol.prototype-%symbol.tostringtag%">
        <h1>Symbol.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティ初期値は *"Symbol"*。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-symbol-instances">
      <h1>Symbol インスタンスのプロパティ</h1>
      <p>Symbol インスタンスは Symbol プロトタイプオブジェクトを継承する通常オブジェクトで [[SymbolData]] 内部スロットを持ち、その値が表現する Symbol 値である。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-symbols">
      <h1>Symbol 用抽象操作</h1>

      <emu-clause id="sec-keyforsymbol" type="abstract operation">
        <h1>
          KeyForSymbol (
            _sym_: Symbol,
          ): String または *undefined*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_sym_ が GlobalSymbolRegistry List にあるなら登録時の文字列を返す。</dd>
        </dl>
        <emu-alg>
          1. GlobalSymbolRegistry List の各 _e_ について
            1. SameValue(_e_.[[Symbol]], _sym_) が *true* なら _e_.[[Key]] を返す。
          1. Assert: _sym_ のエントリは存在しない。
          1. *undefined* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error オブジェクト</h1>
    <p>実行時エラー発生時に例外として投げられる。ユーザー定義例外クラスの基底にも利用可能。</p>
    <p>実行時エラー検出時、<emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> の _NativeError_ か <emu-xref href="#sec-aggregate-error-objects"></emu-xref> の AggregateError の新インスタンスが投げられる。</p>

    <emu-clause id="sec-error-constructor">
      <h1>Error コンストラクタ</h1>
      <p>Error コンストラクタ:</p>
      <ul>
        <li><dfn>%Error%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Error"* プロパティ初期値。</li>
        <li>関数呼出しでもコンストラクタと同様に新 Error オブジェクトを生成初期化（`Error(…)` は `new Error(…)` と等価）。</li>
        <li>`extends` 節で使用可。継承意図のサブクラスは [[ErrorData]] 内部スロット付きで初期化するため `super` 呼出しが必要。</li>
      </ul>

      <emu-clause id="sec-error-message">
        <h1>Error ( _message_ [ , _options_ ] )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら _newTarget_ = アクティブ関数オブジェクト; Else _newTarget_ = NewTarget。
          1. _O_ を ? OrdinaryCreateFromConstructor(_newTarget_, *"%Error.prototype%"*, « [[ErrorData]] ») とする。
          1. _message_ が *undefined* でなければ
            1. _msg_ = ? ToString(_message_)。
            1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_)。
          1. ? InstallErrorCause(_O_, _options_)。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructor">
      <h1>Error コンストラクタのプロパティ</h1>
      <p>Error コンストラクタ:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値は %Function.prototype%。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-error.iserror">
        <h1>Error.isError ( _arg_ )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _arg_ が Object でなければ *false*。
          1. _arg_ が [[ErrorData]] 内部スロットを持たなければ *false*。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-error.prototype">
        <h1>Error.prototype</h1>
        <p>`Error.prototype` 初期値は Error プロトタイプオブジェクト。</p>
        <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-prototype-object">
      <h1>Error プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Error プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Error.prototype%</dfn>。</li>
        <li>通常オブジェクト。</li>
        <li>Error インスタンスではなく [[ErrorData]] 内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロット値は %Object.prototype%。</li>
      </ul>

      <emu-clause id="sec-error.prototype.constructor">
        <h1>Error.prototype.constructor</h1>
        <p>`Error.prototype.constructor` 初期値は %Error%。</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.message">
        <h1>Error.prototype.message</h1>
        <p>`Error.prototype.message` 初期値は空文字列。</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.name">
        <h1>Error.prototype.name</h1>
        <p>`Error.prototype.name` 初期値は *"Error"*。</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.tostring">
        <h1>Error.prototype.toString ( )</h1>
        <p>呼び出し手順:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _O_ が Object でなければ *TypeError*。
          1. _name_ = ? Get(_O_, *"name"*)。
          1. _name_ が *undefined* なら *"Error"* に; それ以外は ? ToString(_name_)。
          1. _msg_ = ? Get(_O_, *"message"*)。
          1. _msg_ が *undefined* なら空文字列; Else ? ToString(_msg_)。
          1. _name_ が空なら _msg_ を返す。
          1. _msg_ が空なら _name_ を返す。
          1. _name_, 0x003A, 0x0020, _msg_ の連結を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-error-instances">
      <h1>Error インスタンスのプロパティ</h1>
      <p>Error インスタンスは Error プロトタイプオブジェクトを継承する通常オブジェクトで [[ErrorData]] 内部スロット値 *undefined*。このスロットの唯一の用途は `Object.prototype.toString` と `Error.isError` による識別。</p>
    </emu-clause>

    <emu-clause id="sec-native-error-types-used-in-this-standard">
      <h1>本仕様で使用されるネイティブエラー型</h1>
      <p>以下の _NativeError_ 又は AggregateError の新インスタンスがランタイムエラーで投げられる。全 _NativeError_ は <emu-xref href="#sec-nativeerror-object-structure"></emu-xref> の構造。</p>

      <emu-clause id="sec-native-error-types-used-in-this-standard-evalerror">
        <h1>EvalError</h1>
        <p>EvalError コンストラクタは <dfn>%EvalError%</dfn>。</p>
        <p>現在仕様内で使用されない。互換性目的で残る。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-rangeerror">
        <h1>RangeError</h1>
        <p>RangeError コンストラクタは <dfn>%RangeError%</dfn>。</p>
        <p>許容範囲外値を示す。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-referenceerror">
        <h1>ReferenceError</h1>
        <p>ReferenceError コンストラクタは <dfn>%ReferenceError%</dfn>。</p>
        <p>不正な参照検出を示す。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-syntaxerror">
        <h1>SyntaxError</h1>
        <p>SyntaxError コンストラクタは <dfn>%SyntaxError%</dfn>。</p>
        <p>構文解析エラー発生を示す。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-typeerror">
        <h1>TypeError</h1>
        <p>TypeError コンストラクタは <dfn>%TypeError%</dfn>。</p>
        <p>他の _NativeError_ が適切でない失敗原因を示す失敗時に使用。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-urierror">
        <h1>URIError</h1>
        <p>URIError コンストラクタは <dfn>%URIError%</dfn>。</p>
        <p>グローバル URI 処理関数の不適切利用を示す。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ オブジェクト構造</h1>
      <p>以下の各オブジェクトは記述に従う構造を持ち、コンストラクタ名とプロトタイプオブジェクトの *"name"* のみ異なる。</p>
      <p>各エラーオブジェクトの定義内の _NativeError_ 参照は該当エラー名に置換される。</p>

      <emu-clause id="sec-nativeerror-constructors">
        <h1>_NativeError_ コンストラクタ</h1>
        <p>各 _NativeError_ コンストラクタ:</p>
        <ul>
          <li>関数呼出でコンストラクタ呼出と同等に新 _NativeError_ オブジェクトを生成初期化（`NativeError(…)` は `new NativeError(…)` と等価）。</li>
          <li>`extends` 節で利用可。継承意図のサブクラスは [[ErrorData]] 付きインスタンス生成のため `super` 呼出しが必要。</li>
        </ul>

        <emu-clause id="sec-nativeerror">
          <h1>_NativeError_ ( _message_ [ , _options_ ] )</h1>
          <p>各 _NativeError_ 関数は呼び出し時次を行う:</p>
          <emu-alg>
            1. NewTarget が *undefined* なら _newTarget_ = アクティブ関数オブジェクト; Else _newTarget_ = NewTarget。
            1. [id="step-nativeerror-ordinarycreatefromconstructor"] _O_ を ? OrdinaryCreateFromConstructor(_newTarget_, <code>"%<var>NativeError</var>.prototype%"</code>, « [[ErrorData]] »)。
            1. _message_ が *undefined* でなければ
              1. _msg_ = ? ToString(_message_)。
              1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_)。
            1. ? InstallErrorCause(_O_, _options_)。
            1. _O_ を返す。
          </emu-alg>
          <p>手順 <emu-xref href="#step-nativeerror-ordinarycreatefromconstructor"></emu-xref> の文字列は定義対象に応じ *"%EvalError.prototype%"*, *"%RangeError.prototype%"*, *"%ReferenceError.prototype%"*, *"%SyntaxError.prototype%"*, *"%TypeError.prototype%"*, *"%URIError.prototype%"* のいずれか。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors">
        <h1>_NativeError_ コンストラクタのプロパティ</h1>
        <p>各 _NativeError_ コンストラクタ:</p>
        <ul>
          <li>[[Prototype]] 内部スロット値は %Error%。</li>
          <li>*"name"* プロパティ値は <emu-val>"<var>NativeError</var>"</emu-val>。</li>
          <li>以下のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype">
          <h1>_NativeError_.prototype</h1>
          <p><code><var>NativeError</var>.prototype</code> 初期値は _NativeError_ プロトタイプオブジェクト (<emu-xref href="#sec-properties-of-the-nativeerror-prototype-objects"></emu-xref>)。各コンストラクタは固有プロトタイプを持つ。</p>
          <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-prototype-objects">
        <h1>_NativeError_ プロトタイプオブジェクトのプロパティ</h1>
        <p>各 <dfn>_NativeError_ プロトタイプオブジェクト</dfn>:</p>
        <ul>
          <li>通常オブジェクト。</li>
          <li>Error インスタンスでなく [[ErrorData]] 内部スロットを持たない。</li>
          <li>[[Prototype]] 内部スロット値は %Error.prototype%。</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype.constructor">
          <h1>_NativeError_.prototype.constructor</h1>
          <p>該当 _NativeError_ コンストラクタのプロトタイプ *"constructor"* 初期値はそのコンストラクタ自身。</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.message">
          <h1>_NativeError_.prototype.message</h1>
          <p>*"message"* 初期値は空文字列。</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.name">
          <h1>_NativeError_.prototype.name</h1>
          <p>*"name"* 初期値はコンストラクタ名（_NativeError_ の代わりに用いる名称）。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-nativeerror-instances">
        <h1>_NativeError_ インスタンスのプロパティ</h1>
        <p>_NativeError_ インスタンスは独自プロトタイプを継承する通常オブジェクトで [[ErrorData]] 内部スロット値 *undefined*。用途は `Object.prototype.toString` と `Error.isError` による識別。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects">
      <h1>AggregateError オブジェクト</h1>

      <emu-clause id="sec-aggregate-error-constructor">
        <h1>AggregateError コンストラクタ</h1>
        <p>AggregateError コンストラクタ:</p>
        <ul>
          <li><dfn>%AggregateError%</dfn> である。</li>
          <li>グローバルオブジェクトの *"AggregateError"* プロパティ初期値。</li>
          <li>関数呼出しでも `new` と同等。</li>
          <li>`extends` 節に使用可能。継承意図サブクラスは [[ErrorData]] 用に `super` 呼出しが必要。</li>
        </ul>

        <emu-clause id="sec-aggregate-error">
          <h1>AggregateError ( _errors_, _message_ [ , _options_ ] )</h1>
          <p>呼び出し手順:</p>
          <emu-alg>
            1. NewTarget が *undefined* なら _newTarget_ = アクティブ関数; Else _newTarget_ = NewTarget。
            1. _O_ = ? OrdinaryCreateFromConstructor(_newTarget_, *"%AggregateError.prototype%"*, « [[ErrorData]] »)。
            1. _message_ が *undefined* でなければ
              1. _msg_ = ? ToString(_message_)。
              1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_)。
            1. ? InstallErrorCause(_O_, _options_)。
            1. _errorsList_ = ? IteratorToList(? GetIterator(_errors_, ~sync~))。
            1. ! DefinePropertyOrThrow(_O_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) })。
            1. _O_ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-constructors">
        <h1>AggregateError コンストラクタのプロパティ</h1>
        <p>AggregateError コンストラクタ:</p>
        <ul>
          <li>[[Prototype]] 内部スロット値は %Error%。</li>
          <li>以下のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype">
          <h1>AggregateError.prototype</h1>
          <p>`AggregateError.prototype` 初期値は %AggregateError.prototype%。</p>
          <p>属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-prototype-objects">
        <h1>AggregateError プロトタイプオブジェクトのプロパティ</h1>
        <p><dfn>AggregateError プロトタイプオブジェクト</dfn>:</p>
        <ul>
          <li><dfn>%AggregateError.prototype%</dfn>。</li>
          <li>通常オブジェクト。</li>
          <li>Error でも AggregateError インスタンスでもなく [[ErrorData]] を持たない。</li>
          <li>[[Prototype]] 内部スロット値は %Error.prototype%。</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype.constructor">
          <h1>AggregateError.prototype.constructor</h1>
          <p>`AggregateError.prototype.constructor` 初期値は %AggregateError%。</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.message">
          <h1>AggregateError.prototype.message</h1>
          <p>`AggregateError.prototype.message` 初期値は空文字列。</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.name">
          <h1>AggregateError.prototype.name</h1>
          <p>`AggregateError.prototype.name` 初期値は *"AggregateError"*。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-aggregate-error-instances">
        <h1>AggregateError インスタンスのプロパティ</h1>
        <p>AggregateError インスタンスは AggregateError プロトタイプを継承し [[ErrorData]] 内部スロット値 *undefined*。用途は `Object.prototype.toString` と `Error.isError` での識別。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-error-objects">
      <h1>Error オブジェクト用抽象操作</h1>

      <emu-clause id="sec-installerrorcause" type="abstract operation">
        <h1>
          InstallErrorCause (
            _O_: Object,
            _options_: ECMAScript 言語値,
          ): ~unused~ を含む通常完了または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_options_ に *"cause"* プロパティがある場合 _O_ に *"cause"* プロパティを作成する。</dd>
        </dl>
        <emu-alg>
          1. _options_ が Object かつ ? HasProperty(_options_, *"cause"*) が *true* なら
            1. _cause_ = ? Get(_options_, *"cause"*)。
            1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"cause"*, _cause_)。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>数値と日付 (Numbers and Dates)</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number オブジェクト</h1>

    <emu-clause id="sec-number-constructor">
      <h1>Number コンストラクタ</h1>
      <p>Number コンストラクタ:</p>
      <ul>
        <li><dfn>%Number%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Number"* プロパティの初期値である。</li>
        <li>コンストラクタとして呼び出されたとき新しい Number オブジェクトを生成し初期化する。</li>
        <li>コンストラクタではなく関数として呼び出されたとき型変換を行う。</li>
        <li>クラス定義の `extends` 節の値として使用できる。指定の Number 挙動を継承する意図を持つサブクラスコンストラクタは、[[NumberData]] 内部スロットを持つサブクラスインスタンスを生成および初期化するために Number コンストラクタへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>この関数は呼び出されたとき次の手順を実行する:</p>
        <emu-alg>
          1. _value_ が存在するなら、
            1. _prim_ を ? ToNumeric(_value_) とする。
            1. _prim_ が BigInt なら _n_ を 𝔽(ℝ(_prim_)) とする。
            1. それ以外は _n_ を _prim_ とする。
          1. それ以外なら、
            1. _n_ を *+0*<sub>𝔽</sub> とする。
          1. NewTarget が *undefined* なら _n_ を返す。
          1. _O_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] ») とする。
          1. _O_.[[NumberData]] を _n_ に設定する。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-constructor">
      <h1>Number コンストラクタのプロパティ</h1>
      <p>Number コンストラクタ:</p>
      <ul>
        <li>値 %Function.prototype% を持つ [[Prototype]] 内部スロットを有する。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-number.epsilon">
        <h1>Number.EPSILON</h1>
        <p>`Number.EPSILON` の値は、1 と、Number 値として表現可能な 1 より大きい最小の値との差の大きさに相当する Number 値であり、これはおよそ 2.2204460492503130808472633361816 × 10<sup>-16</sup> である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.isfinite">
        <h1>Number.isFinite ( _number_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _number_ が Number でなければ *false* を返す。
          1. _number_ が有限でなければ *false* を返す。
          1. それ以外なら *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isinteger">
        <h1>Number.isInteger ( _number_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _number_ が整数の Number なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isnan">
        <h1>Number.isNaN ( _number_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _number_ が Number でなければ *false* を返す。
          1. _number_ が *NaN* なら *true* を返す。
          1. それ以外は *false* を返す。
        </emu-alg>
        <emu-note>
          <p>この関数は、引数を *NaN* かどうか判定する前に Number へ変換しない点で、グローバルの isNaN 関数 (<emu-xref href="#sec-isnan-number"></emu-xref>) と異なる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.issafeinteger">
        <h1>Number.isSafeInteger ( _number_ )</h1>
        <emu-note>
          <p>整数 _n_ は、その Number 値が他のいかなる整数の Number 値とも一致しない場合に限り「<dfn id="safe-integer">安全な整数 (safe integer)</dfn>」である。</p>
        </emu-note>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _number_ が整数の Number なら、
            1. abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1 なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.max_safe_integer">
        <h1>Number.MAX_SAFE_INTEGER</h1>
        <emu-note>
          <p>IEEE 754-2019 の精度制限に起因する丸め挙動のため、`Number.MAX_SAFE_INTEGER` より大きいすべての整数の Number 値は少なくとも 1 つ別の整数と共有される。そのような大きな整数は <emu-xref href="#safe-integer">安全</emu-xref> ではなく、Number 値として正確に表現できる保証も、互いに区別できる保証もない。例えば `9007199254740992` と `9007199254740993` はどちらも Number 値 *9007199254740992*<sub>𝔽</sub> になる。</p>
        </emu-note>
        <p>`Number.MAX_SAFE_INTEGER` の値は *9007199254740991*<sub>𝔽</sub> (𝔽(2<sup>53</sup> - 1)) である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.max_value">
        <h1>Number.MAX_VALUE</h1>
        <p>`Number.MAX_VALUE` の値は Number 型の正の有限値で最大のものであり、およそ <emu-eqn>1.7976931348623157 × 10<sup>308</sup></emu-eqn> である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.min_safe_integer">
        <h1>Number.MIN_SAFE_INTEGER</h1>
        <emu-note>
          <p>IEEE 754-2019 の精度制限に起因する丸め挙動のため、`Number.MIN_SAFE_INTEGER` より小さいすべての整数の Number 値は少なくとも 1 つ別の整数と共有される。そのような大きな（絶対値が大きい）整数は <emu-xref href="#safe-integer">安全</emu-xref> ではなく、Number 値として正確に表現・相互識別できる保証はない。例えば `-9007199254740992` と `-9007199254740993` はどちらも Number 値 *-9007199254740992*<sub>𝔽</sub> になる。</p>
        </emu-note>
        <p>`Number.MIN_SAFE_INTEGER` の値は *-9007199254740991*<sub>𝔽</sub> (𝔽(-(2<sup>53</sup> - 1))) である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.min_value">
        <h1>Number.MIN_VALUE</h1>
        <p>`Number.MIN_VALUE` の値は Number 型の最小の正の値であり、およそ <emu-eqn>5 × 10<sup>-324</sup></emu-eqn> である。</p>
        <p>IEEE 754-2019 倍精度の 2 進表現において最小値は非正規化数である。実装が非正規化数をサポートしない場合、`Number.MIN_VALUE` の値はその実装で実際に表現可能な最小の非ゼロ正値でなければならない。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.nan">
        <h1>Number.NaN</h1>
        <p>`Number.NaN` の値は *NaN* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.negative_infinity">
        <h1>Number.NEGATIVE_INFINITY</h1>
        <p>`Number.NEGATIVE_INFINITY` の値は *-∞*<sub>𝔽</sub> である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.parsefloat">
        <h1>Number.parseFloat ( _string_ )</h1>
        <p>*"parseFloat"* プロパティの初期値は %parseFloat% である。</p>
      </emu-clause>

      <emu-clause id="sec-number.parseint">
        <h1>Number.parseInt ( _string_, _radix_ )</h1>
        <p>*"parseInt"* プロパティの初期値は %parseInt% である。</p>
      </emu-clause>

      <emu-clause id="sec-number.positive_infinity">
        <h1>Number.POSITIVE_INFINITY</h1>
        <p>`Number.POSITIVE_INFINITY` の値は *+∞*<sub>𝔽</sub> である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype">
        <h1>Number.prototype</h1>
        <p>`Number.prototype` の初期値は Number プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-prototype-object">
      <h1>Number プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Number プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Number.prototype%</dfn> である。</li>
        <li>通常オブジェクトである。</li>
        <li>それ自体が Number オブジェクトであり、値 *+0*<sub>𝔽</sub> を持つ [[NumberData]] 内部スロットを持つ。</li>
        <li>値 %Object.prototype% を持つ [[Prototype]] 内部スロットを有する。</li>
      </ul>
      <p>明示的に別段の記述がない限り、以下で定義される Number プロトタイプオブジェクトのメソッドはジェネリックではなく、それらに渡される *this* 値は Number 値か、Number 値で初期化された [[NumberData]] 内部スロットを持つオブジェクトでなければならない。</p>
      <p>メソッド仕様内の語句 “this Number value” は、メソッド呼び出しの *this* 値を引数として抽象操作 ThisNumberValue を呼び出した結果を指す。</p>

      <emu-clause id="sec-number.prototype.constructor">
        <h1>Number.prototype.constructor</h1>
        <p>`Number.prototype.constructor` の初期値は %Number% である。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toexponential">
        <h1>Number.prototype.toExponential ( _fractionDigits_ )</h1>
        <p>このメソッドは、この Number 値を 10 進指数表記で仮数部の小数点前 1 桁およびその後に _fractionDigits_ 桁の仮数部桁を伴う形で表現した文字列を返す。_fractionDigits_ が *undefined* の場合、Number を一意に特定するために必要な仮数桁数（常に指数表記）を含める（ToString と同様だが常に指数表記で出力される点が異なる）。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _x_ を ? ThisNumberValue(*this* value) とする。
          1. _f_ を ? ToIntegerOrInfinity(_fractionDigits_) とする。
          1. Assert: _fractionDigits_ が *undefined* なら _f_ は 0。
          1. _x_ が有限でなければ Number::toString(_x_, 10) を返す。
          1. _f_ &lt; 0 または _f_ > 100 なら *RangeError* 例外。
          1. _x_ を ℝ(_x_) に設定。
          1. _s_ を空文字列とする。
          1. _x_ &lt; 0 なら
            1. _s_ を *"-"* に設定。
            1. _x_ を -_x_ に設定。
          1. _x_ = 0 なら
            1. _m_ を _f_ + 1 個のコード単位 0x0030 (DIGIT ZERO) からなる文字列とする。
            1. _e_ を 0 とする。
          1. それ以外
            1. _fractionDigits_ が *undefined* でなければ
              1. 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup> かつ _n_ × 10<sup>_e_ - _f_</sup> - _x_ がゼロに最も近くなるような整数 _e_, _n_ をとる。複数あるなら _n_ × 10<sup>_e_ - _f_</sup> が大きい方。
            1. それ以外
              1. [id="step-number-proto-toexponential-intermediate-values"] _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ &lt; 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) が 𝔽(_x_) に等しく、_ff_ が最小となる整数 _e_, _n_, _ff_ をとる。_n_ の 10 進表記は _ff_ + 1 桁で 0 で割り切れない（最下位桁は一意とは限らない）。
              1. _f_ を _ff_ に設定。
            1. _m_ を _n_ の 10 進表記の桁（先頭 0 なし）からなる文字列とする。
          1. _f_ ≠ 0 なら
            1. _a_ を _m_ の最初のコード単位。
            1. _b_ を残りの _f_ 個のコード単位。
            1. _m_ を _a_, *"."*, _b_ の連結に設定。
          1. _e_ = 0 なら
            1. _c_ を *"+"* とする。
            1. _d_ を *"0"* とする。
          1. それ以外
            1. _e_ > 0 なら
              1. _c_ を *"+"* とする。
            1. それ以外
              1. Assert: _e_ &lt; 0。
              1. _c_ を *"-"* とする。
              1. _e_ を -_e_ に設定。
            1. _d_ を _e_ の 10 進表記（先頭 0 なし）からなる文字列とする。
          1. _m_ を _m_, *"e"*, _c_, _d_ の連結に設定。
          1. _s_ と _m_ の連結を返す。
        </emu-alg>
        <emu-note>
          <p>上記規則より高精度な変換を提供する実装では、手順 <emu-xref href="#step-number-proto-toexponential-intermediate-values"></emu-xref> の代替指針として以下を推奨する:</p>
          <emu-alg replaces-step="step-number-proto-toexponential-intermediate-values">
            1. _f_ ≥ 0, 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _f_</sup>) が 𝔽(_x_) に等しく、_f_ が最小となる整数 _e_, _n_, _f_ をとる。_n_ の候補が複数ある場合、𝔽(_n_ × 10<sup>_e_ - _f_</sup>) が 𝔽(_x_) に最も近いものを選び、2 つあるなら偶数を選ぶ。
          </emu-alg>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tofixed">
        <h1>Number.prototype.toFixed ( _fractionDigits_ )</h1>
        <emu-note>
          <p>このメソッドは、この Number 値を 10 進固定小数点表記で小数点以下に _fractionDigits_ 桁を含む文字列を返す。_fractionDigits_ が *undefined* の場合 0 を仮定する。</p>
        </emu-note>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _x_ を ? ThisNumberValue(*this* value) とする。
          1. _f_ を ? ToIntegerOrInfinity(_fractionDigits_) とする。
          1. Assert: _fractionDigits_ が *undefined* なら _f_ は 0。
          1. _f_ が有限でなければ *RangeError*。
          1. _f_ &lt; 0 または _f_ > 100 なら *RangeError*。
          1. _x_ が有限でなければ Number::toString(_x_, 10) を返す。
          1. _x_ を ℝ(_x_) に設定。
          1. _s_ を空文字列とする。
          1. _x_ &lt; 0 なら
            1. _s_ を *"-"* に設定。
            1. _x_ を -_x_ に設定。
          1. _x_ ≥ 10<sup>21</sup> なら
            1. _m_ を ! ToString(𝔽(_x_)) とする。
          1. それ以外
            1. _n_ を _n_ / 10<sup>_f_</sup> - _x_ が 0 に最も近くなる整数とする（2 つあれば大きい方）。
            1. _n_ = 0 なら _m_ = *"0"*、そうでなければ _m_ を _n_ の 10 進表記（先頭 0 なし）の桁列とする。
            1. _f_ ≠ 0 なら
              1. _k_ を _m_ の長さとする。
              1. _k_ ≤ _f_ なら
                1. _z_ を _f_ + 1 - _k_ 個の 0x0030 からなる文字列とする。
                1. _m_ を _z_ + _m_ に設定。
                1. _k_ を _f_ + 1 に設定。
              1. _a_ を _m_ の先頭 _k_ - _f_ 文字。
              1. _b_ を残りの _f_ 文字。
              1. _m_ を _a_, *"."*, _b_ の連結に設定。
          1. _s_ + _m_ を返す。
        </emu-alg>
        <emu-note>
          <p>`toFixed` の出力は、ある値について `toString` より精密になる場合がある。`toString` は隣接する Number 値と区別するのに十分な有効桁のみを出力するためである。例:</p>
          <p>
            `(1000000000000000128).toString()` は *"1000000000000000100"* を返す一方、<br>
            `(1000000000000000128).toFixed(0)` は *"1000000000000000128"* を返す。
          </p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tolocalestring">
        <h1>Number.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 国際化 API を含む ECMAScript 実装は ECMA-402 仕様に従ってこのメソッドを実装しなければならない。ECMA-402 API を含まない実装では以下の仕様が用いられる:</p>
        <p>このメソッドは、この Number 値をホスト環境の現在のロケール規約に従って書式化した文字列を生成する。このメソッドは実装定義であり、`toString` と同じものを返すことは許容されるが推奨はされない。</p>
        <p>このメソッドのオプション引数の意味は ECMA-402 仕様で定義される; ECMA-402 をサポートしない実装はこれらの位置を他目的に使用してはならない。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toprecision">
        <h1>Number.prototype.toPrecision ( _precision_ )</h1>
        <p>このメソッドは、この Number 値を、仮数部の小数点前 1 桁および <emu-eqn>_precision_ - 1</emu-eqn> 桁を小数点後に持つ 10 進指数表記、または _precision_ 個の有効桁を持つ 10 進固定表記で表現した文字列を返す。_precision_ が *undefined* の場合は代わりに ToString を呼び出す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _x_ を ? ThisNumberValue(*this* value) とする。
          1. _precision_ が *undefined* なら ! ToString(_x_) を返す。
          1. _p_ を ? ToIntegerOrInfinity(_precision_) とする。
          1. _x_ が有限でなければ Number::toString(_x_, 10) を返す。
          1. _p_ &lt; 1 または _p_ > 100 なら *RangeError*。
          1. _x_ を ℝ(_x_) に設定。
          1. _s_ を空文字列とする。
          1. _x_ &lt; 0 なら
            1. _s_ をコード単位 0x002D (HYPHEN-MINUS) に設定。
            1. _x_ を -_x_ に設定。
          1. _x_ = 0 なら
            1. _m_ を _p_ 個の 0x0030 (DIGIT ZERO) からなる文字列とする。
            1. _e_ を 0 とする。
          1. それ以外
            1. 10<sup>_p_ - 1</sup> ≤ _n_ &lt; 10<sup>_p_</sup> かつ _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ が 0 に最も近い整数 _e_, _n_ をとる（複数あるなら積が大きい方）。
            1. _m_ を _n_ の 10 進表記桁列（先頭 0 なし）とする。
            1. _e_ &lt; -6 または _e_ ≥ _p_ なら
              1. Assert: _e_ ≠ 0。
              1. _p_ ≠ 1 なら
                1. _a_ を _m_ の最初のコード単位。
                1. _b_ を残りの _p_ - 1 文字。
                1. _m_ を _a_, *"."*, _b_ の連結に設定。
              1. _e_ > 0 なら
                1. _c_ をコード単位 0x002B (PLUS SIGN) とする。
              1. それ以外
                1. Assert: _e_ &lt; 0。
                1. _c_ をコード単位 0x002D (HYPHEN-MINUS) とする。
                1. _e_ を -_e_ に設定。
              1. _d_ を _e_ の 10 進表記（先頭 0 なし）文字列とする。
              1. _s_, _m_, コード単位 0x0065 ('e'), _c_, _d_ の連結を返す。
          1. _e_ = _p_ - 1 なら _s_ + _m_ を返す。
          1. _e_ ≥ 0 なら
            1. _m_ を 先頭 _e_ + 1 文字, コード単位 0x002E (FULL STOP), 残り _p_ - (_e_ + 1) 文字 の連結に設定。
          1. それ以外
            1. _m_ を コード単位 0x0030, コード単位 0x002E, -(_e_ + 1) 個の 0x0030, 文字列 _m_ の連結に設定。
          1. _s_ + _m_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tostring">
        <h1>Number.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>オプションの _radix_ は *2*<sub>𝔽</sub> から *36*<sub>𝔽</sub> までの整数 Number 値であるべきである。_radix_ が *undefined* の場合 _radix_ の値として *10*<sub>𝔽</sub> が用いられる。</p>
        </emu-note>
        <p>このメソッドは呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _x_ を ? ThisNumberValue(*this* value) とする。
          1. _radix_ が *undefined* なら _radixMV_ = 10。
          1. それ以外は _radixMV_ = ? ToIntegerOrInfinity(_radix_)。
          1. _radixMV_ が 2 から 36 の範囲外なら *RangeError*。
          1. Number::toString(_x_, _radixMV_) を返す。
        </emu-alg>
        <p>このメソッドはジェネリックではなく、*this* 値が Number または Number オブジェクトでない場合 *TypeError* を投げる。したがって他種オブジェクトに転用できない。</p>
        <p>このメソッドの *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.valueof">
        <h1>Number.prototype.valueOf ( )</h1>
        <emu-alg>
          1. ? ThisNumberValue(*this* value) を返す。
        </emu-alg>

        <emu-clause id="sec-thisnumbervalue" type="abstract operation" oldids="thisnumbervalue">
          <h1>
            ThisNumberValue (
              _value_: ECMAScript 言語値,
            ): Number を含む通常完了または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ が Number なら _value_ を返す。
            1. _value_ が Object で [[NumberData]] 内部スロットを持つなら
              1. _n_ を _value_.[[NumberData]] とする。
              1. Assert: _n_ は Number。
              1. _n_ を返す。
            1. *TypeError* 例外を投げる。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-number-instances">
      <h1>Number インスタンスのプロパティ</h1>
      <p>Number インスタンスは Number プロトタイプオブジェクトからプロパティを継承する通常オブジェクトである。Number インスタンスは [[NumberData]] 内部スロットも持つ。[[NumberData]] 内部スロットはこの Number オブジェクトが表す Number 値である。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt オブジェクト</h1>

    <emu-clause id="sec-bigint-constructor">
      <h1>BigInt コンストラクタ</h1>
      <p>BigInt コンストラクタ:</p>
      <ul>
        <li><dfn>%BigInt%</dfn> である。</li>
        <li>グローバルオブジェクトの *"BigInt"* プロパティの初期値である。</li>
        <li>コンストラクタではなく関数として呼び出されたとき型変換を行う。</li>
        <li>`new` 演算子で使用することやサブクラス化することを意図しない。クラス定義の `extends` 節の値として使用することはできるが、BigInt コンストラクタへの `super` 呼び出しは例外を引き起こす。</li>
      </ul>

      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>この関数は呼び出されたとき次の手順を実行する:</p>
        <emu-alg>
          1. NewTarget が *undefined* でなければ *TypeError* 例外を投げる。
          1. _prim_ を ? ToPrimitive(_value_, ~number~) とする。
          1. _prim_ が Number なら ? NumberToBigInt(_prim_) を返す。
          1. それ以外なら ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta> を返す。
        </emu-alg>

        <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            NumberToBigInt (
              _number_: a Number,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _number_ が整数の Number でなければ *RangeError* 例外を投げる。
            1. ℤ(ℝ(_number_)) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-constructor">
      <h1>BigInt コンストラクタのプロパティ</h1>
      <p>BigInt コンストラクタ:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値が %Function.prototype% である。</li>
        <li>次のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-bigint.asintn">
        <h1>BigInt.asIntN ( _bits_, _bigint_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _bits_ を ? ToIndex(_bits_) に設定する。
          1. _bigint_ を ? ToBigInt(_bigint_) に設定する。
          1. _mod_ を ℝ(_bigint_) modulo 2<sup>_bits_</sup> とする。
          1. もし _mod_ ≥ 2<sup>_bits_ - 1</sup> なら ℤ(_mod_ - 2<sup>_bits_</sup>) を返す; そうでなければ ℤ(_mod_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.asuintn">
        <h1>BigInt.asUintN ( _bits_, _bigint_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _bits_ を ? ToIndex(_bits_) に設定する。
          1. _bigint_ を ? ToBigInt(_bigint_) に設定する。
          1. ℤ(ℝ(_bigint_) modulo 2<sup>_bits_</sup>) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype">
        <h1>BigInt.prototype</h1>
        <p>`BigInt.prototype` の初期値は BigInt プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-prototype-object">
      <h1>BigInt プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>BigInt プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%BigInt.prototype%</dfn> である。</li>
        <li>通常オブジェクトである。</li>
        <li>BigInt オブジェクトではない（[[BigIntData]] 内部スロットを持たない）。</li>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      </ul>
      <p>メソッド仕様内の語句 “this BigInt value” は、そのメソッド呼び出しの *this* 値を引数として抽象操作 ThisBigIntValue を呼び出した結果を指す。</p>

      <emu-clause id="sec-bigint.prototype.constructor">
        <h1>BigInt.prototype.constructor</h1>
        <p>`BigInt.prototype.constructor` の初期値は %BigInt% である。</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tolocalestring">
        <h1>BigInt.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 国際化 API を含む ECMAScript 実装は、このメソッドを ECMA-402 仕様に従って実装しなければならない。ECMA-402 API を含まない実装では以下の仕様が用いられる:</p>
        <p>このメソッドは、この BigInt 値をホスト環境の現在のロケール規約に従って書式化した文字列値を生成する。実装定義であり、`toString` と同じものを返すことも許容されるが推奨されない。</p>
        <p>このメソッドのオプション引数の意味は ECMA-402 仕様で定義される；ECMA-402 をサポートしない実装はこれらの位置を他用途に用いてはならない。</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tostring">
        <h1>BigInt.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>オプションの _radix_ は *2*<sub>𝔽</sub> から *36*<sub>𝔽</sub> までの整数 Number 値であるべきである。_radix_ が *undefined* なら *10*<sub>𝔽</sub> が用いられる。</p>
        </emu-note>
        <p>このメソッドは呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _x_ を ? ThisBigIntValue(*this* value) とする。
          1. _radix_ が *undefined* なら _radixMV_ を 10 とする。
          1. それ以外なら _radixMV_ を ? ToIntegerOrInfinity(_radix_) とする。
          1. _radixMV_ が 2 から 36 の包含区間にないなら *RangeError* 例外を投げる。
          1. BigInt::toString(_x_, _radixMV_) を返す。
        </emu-alg>
        <p>このメソッドはジェネリックではなく、*this* 値が BigInt でも BigInt オブジェクトでもない場合 *TypeError* 例外を投げる。したがって他種類のオブジェクトへ移してメソッドとして使用できない。</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.valueof">
        <h1>BigInt.prototype.valueOf ( )</h1>
        <emu-alg>
          1. ? ThisBigIntValue(*this* value) を返す。
        </emu-alg>

        <emu-clause id="sec-thisbigintvalue" type="abstract operation" oldids="thisbigintvalue">
          <h1>
            ThisBigIntValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ が BigInt なら _value_ を返す。
            1. _value_ が Object で [[BigIntData]] 内部スロットを持つなら
              1. Assert: _value_.[[BigIntData]] は BigInt である。
              1. _value_.[[BigIntData]] を返す。
            1. *TypeError* 例外を投げる。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-bigint.prototype-@@tostringtag" id="sec-bigint.prototype-%symbol.tostringtag%">
        <h1>BigInt.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"BigInt"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-bigint-instances">
      <h1>BigInt インスタンスのプロパティ</h1>
      <p>BigInt インスタンスは BigInt プロトタイプオブジェクトからプロパティを継承する通常オブジェクトである。BigInt インスタンスは [[BigIntData]] 内部スロットも持つ。[[BigIntData]] 内部スロットはその BigInt オブジェクトが表す BigInt 値である。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-math-object">
    <h1>Math オブジェクト</h1>
    <p>Math オブジェクト:</p>
    <ul>
      <li><dfn>%Math%</dfn> である。</li>
      <li>グローバルオブジェクトの *"Math"* プロパティの初期値である。</li>
      <li>通常オブジェクトである。</li>
      <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      <li>関数オブジェクトではない。</li>
      <li>[[Construct]] 内部メソッドを持たず、`new` 演算子でコンストラクタとして使用できない。</li>
      <li>[[Call]] 内部メソッドを持たず、関数として呼び出せない。</li>
    </ul>
    <emu-note>
      <p>本仕様において語句 “the Number value for _x_” は <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> で定義される技術的意味を持つ。</p>
    </emu-note>

    <emu-clause id="sec-value-properties-of-the-math-object">
      <h1>Math オブジェクトの値プロパティ</h1>

      <emu-clause id="sec-math.e">
        <h1>Math.E</h1>
        <p>自然対数の底 <i>e</i> の Number 値（およそ 2.7182818284590452354）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-math.ln10">
        <h1>Math.LN10</h1>
        <p>10 の自然対数の Number 値（およそ 2.302585092994046）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-math.ln2">
        <h1>Math.LN2</h1>
        <p>2 の自然対数の Number 値（およそ 0.6931471805599453）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-math.log10e">
        <h1>Math.LOG10E</h1>
        <p>自然対数の底 <i>e</i> の常用対数（底10）の Number 値（およそ 0.4342944819032518）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
        <emu-note>
          <p>`Math.LOG10E` の値はおよそ `Math.LN10` の逆数である。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log2e">
        <h1>Math.LOG2E</h1>
        <p>自然対数の底 <i>e</i> の底2対数の Number 値（およそ 1.4426950408889634）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
        <emu-note>
          <p>`Math.LOG2E` の値はおよそ `Math.LN2` の逆数である。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.pi">
        <h1>Math.PI</h1>
        <p>円周率 π（円の周長と直径の比）の Number 値（およそ 3.1415926535897932）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-math.sqrt1_2">
        <h1>Math.SQRT1_2</h1>
        <p>1/2 の平方根の Number 値（およそ 0.7071067811865476）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
        <emu-note>
          <p>`Math.SQRT1_2` の値はおよそ `Math.SQRT2` の逆数である。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt2">
        <h1>Math.SQRT2</h1>
        <p>2 の平方根の Number 値（およそ 1.4142135623730951）。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-math-@@tostringtag" id="sec-math-%symbol.tostringtag%">
        <h1>Math [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"Math"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Math オブジェクトの関数プロパティ</h1>
      <emu-note>
        <p>`acos`, `acosh`, `asin`, `asinh`, `atan`, `atanh`, `atan2`, `cbrt`, `cos`, `cosh`, `exp`, `expm1`, `hypot`, `log`, `log1p`, `log2`, `log10`, `pow`, `random`, `sin`, `sinh`, `tan`, `tanh` の各関数の動作は、特定の境界的引数値に対する結果を要求する点を除きここでは厳密には規定されない。他の引数値に対しては、これらの関数は周知の数学関数の結果を近似することを意図するが、近似アルゴリズムの選択には一定の裁量が許される。目的は、実装者があるハードウェアプラットフォームにおいて C 言語プログラマが利用できる数学ライブラリを ECMAScript でも利用できるようにすることである。</p>
        <p>アルゴリズム選択は実装に委ねられるが（規格では規定しない）、Sun Microsystems の自由配布数学ライブラリ `fdlibm`（<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>）に含まれる IEEE 754-2019 演算用近似アルゴリズムを用いることが推奨される。</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>この関数は _x_ の絶対値を返す。結果は _x_ と同じ大きさで正の符号を持つ。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* なら *NaN* を返す。
          1. _n_ が *-0*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ が *-∞*<sub>𝔽</sub> なら *+∞*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> なら -_n_ を返す。
          1. _n_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acos">
        <h1>Math.acos ( _x_ )</h1>
        <p>この関数は _x_ の逆余弦を返す。結果はラジアンで *+0*<sub>𝔽</sub> から 𝔽(π) の包含区間内にある。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* または _n_ > *1*<sub>𝔽</sub> または _n_ &lt; *-1*<sub>𝔽</sub> なら *NaN* を返す。
          1. _n_ が *1*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. ℝ(_n_) の逆余弦を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acosh">
        <h1>Math.acosh ( _x_ )</h1>
        <p>この関数は _x_ の逆双曲線余弦を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* または *+∞*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ が *1*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *1*<sub>𝔽</sub> なら *NaN* を返す。
          1. ℝ(_n_) の逆双曲線余弦を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asin">
        <h1>Math.asin ( _x_ )</h1>
        <p>この関数は _x_ の逆正弦を返す。結果はラジアンで 𝔽(-π / 2) から 𝔽(π / 2) の包含区間内。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ > *1*<sub>𝔽</sub> または _n_ &lt; *-1*<sub>𝔽</sub> なら *NaN* を返す。
          1. ℝ(_n_) の逆正弦を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asinh">
        <h1>Math.asinh ( _x_ )</h1>
        <p>この関数は _x_ の逆双曲線正弦を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないか、*_n_* が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> の場合 _n_ を返す。
          1. ℝ(_n_) の逆双曲線正弦を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan">
        <h1>Math.atan ( _x_ )</h1>
        <p>この関数は _x_ の逆正接を返す。結果はラジアンで 𝔽(-π / 2) から 𝔽(π / 2) の包含区間内。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ が *+∞*<sub>𝔽</sub> なら π / 2 を表す実装近似 Number 値を返す。
          1. _n_ が *-∞*<sub>𝔽</sub> なら -π / 2 を表す実装近似 Number 値を返す。
          1. ℝ(_n_) の逆正接を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atanh">
        <h1>Math.atanh ( _x_ )</h1>
        <p>この関数は _x_ の逆双曲線正接を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ > *1*<sub>𝔽</sub> または _n_ &lt; *-1*<sub>𝔽</sub> なら *NaN* を返す。
          1. _n_ が *1*<sub>𝔽</sub> なら *+∞*<sub>𝔽</sub> を返す。
          1. _n_ が *-1*<sub>𝔽</sub> なら *-∞*<sub>𝔽</sub> を返す。
          1. ℝ(_n_) の逆双曲線正接を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan2">
        <h1>Math.atan2 ( _y_, _x_ )</h1>
        <p>この関数は引数 _y_ と _x_ の商 <emu-eqn>_y_ / _x_</emu-eqn> の逆正接を返し、_y_ と _x_ の符号で象限を決定する。2 引数逆正接関数において第 1 引数名が _y_、第 2 引数名が _x_ であるのは慣習的意図的仕様である。結果はラジアンで -π から +π の包含区間内。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _ny_ を ? ToNumber(_y_) とする。
          1. _nx_ を ? ToNumber(_x_) とする。
          1. _ny_ が *NaN* か _nx_ が *NaN* なら *NaN* を返す。
          1. _ny_ が *+∞*<sub>𝔽</sub> のとき
            1. _nx_ が *+∞*<sub>𝔽</sub> なら π / 4 を表す実装近似 Number 値を返す。
            1. _nx_ が *-∞*<sub>𝔽</sub> なら 3π / 4 を表す実装近似 Number 値を返す。
            1. π / 2 を表す実装近似 Number 値を返す。
          1. _ny_ が *-∞*<sub>𝔽</sub> のとき
            1. _nx_ が *+∞*<sub>𝔽</sub> なら -π / 4 を表す実装近似 Number 値を返す。
            1. _nx_ が *-∞*<sub>𝔽</sub> なら -3π / 4 を表す実装近似 Number 値を返す。
            1. -π / 2 を表す実装近似 Number 値を返す。
          1. _ny_ が *+0*<sub>𝔽</sub> のとき
            1. _nx_ > *+0*<sub>𝔽</sub> または _nx_ が *+0*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
            1. π を表す実装近似 Number 値を返す。
          1. _ny_ が *-0*<sub>𝔽</sub> のとき
            1. _nx_ > *+0*<sub>𝔽</sub> または _nx_ が *+0*<sub>𝔽</sub> なら *-0*<sub>𝔽</sub> を返す。
            1. -π を表す実装近似 Number 値を返す。
          1. Assert: _ny_ は有限で *+0*<sub>𝔽</sub> でも *-0*<sub>𝔽</sub> でもない。
          1. _ny_ > *+0*<sub>𝔽</sub> のとき
            1. _nx_ が *+∞*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
            1. _nx_ が *-∞*<sub>𝔽</sub> なら π を表す実装近似 Number 値を返す。
            1. _nx_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら π / 2 を表す実装近似 Number 値を返す。
          1. _ny_ &lt; *-0*<sub>𝔽</sub> のとき
            1. _nx_ が *+∞*<sub>𝔽</sub> なら *-0*<sub>𝔽</sub> を返す。
            1. _nx_ が *-∞*<sub>𝔽</sub> なら -π を表す実装近似 Number 値を返す。
            1. _nx_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら -π / 2 を表す実装近似 Number 値を返す。
          1. Assert: _nx_ は有限で *+0*<sub>𝔽</sub> でも *-0*<sub>𝔽</sub> でもない。
          1. _r_ を abs(ℝ(_ny_) / ℝ(_nx_)) の逆正接とする。
          1. _nx_ &lt; *-0*<sub>𝔽</sub> のとき
            1. _ny_ > *+0*<sub>𝔽</sub> なら _r_ を π - _r_ に設定。
            1. それ以外は _r_ を -π + _r_ に設定。
          1. それ以外 (_nx_ ≥ *-0*<sub>𝔽</sub>) のとき
            1. _ny_ &lt; *-0*<sub>𝔽</sub> なら _r_ を -_r_ に設定。
          1. _r_ を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>この関数は _x_ の立方根を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないか *_n_* が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら _n_ を返す。
          1. ℝ(_n_) の立方根を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>この関数は _x_ 以上で最も小さい（-∞ に最も近い）整数 Number 値を返す。_x_ が既に整数なら結果は _x_ である。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないか *_n_* が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> かつ _n_ > *-1*<sub>𝔽</sub> なら *-0*<sub>𝔽</sub> を返す。
          1. _n_ が整数の Number なら _n_ を返す。
          1. _n_ 以上で最小の整数 Number 値（-∞ に最も近い）を返す。
        </emu-alg>
        <emu-note>
          <p>`Math.ceil(x)` の値は `-Math.floor(-x)` の値と同じである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.clz32">
        <h1>Math.clz32 ( _x_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToUint32(_x_) とする。
          1. _p_ を _n_ の 32 ビット符号なし 2 進表現における先頭の 0 ビット数とする。
          1. 𝔽(_p_) を返す。
        </emu-alg>
        <emu-note>
          <p>_n_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> の場合このメソッドは *32*<sub>𝔽</sub> を返す。_n_ の 32 ビット表現の最上位ビットが 1 の場合、このメソッドは *+0*<sub>𝔽</sub> を返す。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.cos">
        <h1>Math.cos ( _x_ )</h1>
        <p>この関数は _x_ の余弦を返す。引数はラジアン。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないなら *NaN* を返す。
          1. _n_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら *1*<sub>𝔽</sub> を返す。
          1. ℝ(_n_) の余弦を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cosh">
        <h1>Math.cosh ( _x_ )</h1>
        <p>この関数は _x_ の双曲線余弦を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* なら *NaN* を返す。
          1. _n_ が *+∞*<sub>𝔽</sub> または *-∞*<sub>𝔽</sub> なら *+∞*<sub>𝔽</sub> を返す。
          1. _n_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら *1*<sub>𝔽</sub> を返す。
          1. ℝ(_n_) の双曲線余弦を表す実装近似 Number 値を返す。
        </emu-alg>
        <emu-note>
          <p>`Math.cosh(x)` の値は `(Math.exp(x) + Math.exp(-x)) / 2` と同じである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.exp">
        <h1>Math.exp ( _x_ )</h1>
        <p>この関数は _x_ の指数関数（自然対数の底 _e_ の _x_ 乗）を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* または *+∞*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら *1*<sub>𝔽</sub> を返す。
          1. _n_ が *-∞*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. ℝ(_n_) の指数関数を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.expm1">
        <h1>Math.expm1 ( _x_ )</h1>
        <p>この関数は _x_ の指数関数から 1 を引いた結果を返す。_x_ が 0 に近い場合でも精度を保つ方法で計算される。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ が *-∞*<sub>𝔽</sub> なら *-1*<sub>𝔽</sub> を返す。
          1. _exp_ を ℝ(_n_) の指数関数とする。
          1. _exp_ - 1 を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>この関数は _x_ 以下で最大（+∞ に最も近い）の整数 Number 値を返す。_x_ が既に整数なら結果は _x_。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないか *_n_* が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ &lt; *1*<sub>𝔽</sub> かつ _n_ > *+0*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ が整数 Number なら _n_ を返す。
          1. _n_ 以下で最大の整数 Number 値（+∞ に最も近い）を返す。
        </emu-alg>
        <emu-note>
          <p>`Math.floor(x)` の値は `-Math.ceil(-x)` の値と同じである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.fround">
        <h1>Math.fround ( _x_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* なら *NaN* を返す。
          1. _n_ が *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, *-∞*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n32_ を _n_ を丸めモード roundTiesToEven で IEEE 754-2019 binary32 形式に変換した結果とする。
          1. _n64_ を _n32_ を IEEE 754-2019 binary64 形式に変換した結果とする。
          1. _n64_ に対応する ECMAScript Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.f16round">
        <h1>Math.f16round ( _x_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* なら *NaN* を返す。
          1. _n_ が *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, *-∞*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n16_ を _n_ を丸めモード roundTiesToEven で IEEE 754-2019 binary16 形式に変換した結果とする。
          1. _n64_ を _n16_ を IEEE 754-2019 binary64 形式に変換した結果とする。
          1. _n64_ に対応する ECMAScript Number 値を返す。
        </emu-alg>
        <emu-note>
          <p>この操作は double-rounding の可能性があるため binary32 へ変換後 binary16 へ変換するのと同じではない。例として _k_ = *1.00048828125000022204*<sub>𝔽</sub> では Math.f16round(_k_) は *1.0009765625*<sub>𝔽</sub> だが Math.f16round(Math.fround(_k_)) は *1*<sub>𝔽</sub> となる。</p>
          <p>全てのプラットフォームが binary64 から binary16 へのネイティブ変換を提供するわけではない。MIT ライセンスの <a href="https://half.sourceforge.net/">half</a> ライブラリ等で可能である。別案として、まず roundTiesToEven で binary64 から binary32 に変換し、結果が誤った二重丸めを生む可能性があるか検査できる。該当する場合 binary32 値の仮数を roundTiesToOdd で初期変換した場合に得られる値に調整し、その調整値を binary16 に roundTiesToEven で変換することで正しい値を得られる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.hypot">
        <h1>Math.hypot ( ..._args_ )</h1>
        <p>0 個以上の引数について、それらの二乗和の平方根を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _coerced_ を新しい空リストとする。
          1. _args_ の各要素 _arg_ について
            1. _n_ を ? ToNumber(_arg_) とする。
            1. _n_ を _coerced_ に追加。
          1. _coerced_ の各要素 _number_ について
            1. _number_ が *+∞*<sub>𝔽</sub> または *-∞*<sub>𝔽</sub> なら *+∞*<sub>𝔽</sub> を返す。
          1. _onlyZero_ を *true* とする。
          1. _coerced_ の各要素 _number_ について
            1. _number_ が *NaN* なら *NaN* を返す。
            1. _number_ が *+0*<sub>𝔽</sub> でも *-0*<sub>𝔽</sub> でもなければ _onlyZero_ を *false* に設定。
          1. _onlyZero_ が *true* なら *+0*<sub>𝔽</sub> を返す。
          1. _coerced_ の要素の数学的値の二乗和の平方根を表す実装近似 Number 値を返す。
        </emu-alg>
        <p>この関数の *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>複数引数で呼ばれる際のオーバーフローやアンダーフローによる精度損失を避けるよう配慮すべきである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.imul">
        <h1>Math.imul ( _x_, _y_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _a_ を ℝ(? ToUint32(_x_)) とする。
          1. _b_ を ℝ(? ToUint32(_y_)) とする。
          1. _product_ を (_a_ × _b_) modulo 2<sup>32</sup> とする。
          1. _product_ ≥ 2<sup>31</sup> なら 𝔽(_product_ - 2<sup>32</sup>) を返す; そうでなければ 𝔽(_product_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log">
        <h1>Math.log ( _x_ )</h1>
        <p>この関数は _x_ の自然対数を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* または *+∞*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ が *1*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら *-∞*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> なら *NaN* を返す。
          1. ℝ(_n_) の自然対数を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log1p">
        <h1>Math.log1p ( _x_ )</h1>
        <p>この関数は 1 + _x_ の自然対数を返す。_x_ が 0 に近い場合も精度良く計算される。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ が *-1*<sub>𝔽</sub> なら *-∞*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *-1*<sub>𝔽</sub> なら *NaN* を返す。
          1. 1 + ℝ(_n_) の自然対数を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>この関数は _x_ の常用対数（底 10）を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* または *+∞*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ が *1*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら *-∞*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> なら *NaN* を返す。
          1. ℝ(_n_) の常用対数を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>この関数は _x_ の底 2 対数を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN* または *+∞*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ が *1*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら *-∞*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> なら *NaN* を返す。
          1. ℝ(_n_) の底 2 対数を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.max">
        <h1>Math.max ( ..._args_ )</h1>
        <p>0 個以上の引数について、各引数に ToNumber を適用し最大の値を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _coerced_ を新しい空リストとする。
          1. _args_ の各要素 _arg_ について
            1. _n_ を ? ToNumber(_arg_) とする。
            1. _n_ を _coerced_ に追加。
          1. _highest_ を *-∞*<sub>𝔽</sub> とする。
          1. _coerced_ の各要素 _number_ について
            1. _number_ が *NaN* なら *NaN* を返す。
            1. _number_ が *+0*<sub>𝔽</sub> かつ _highest_ が *-0*<sub>𝔽</sub> なら _highest_ を *+0*<sub>𝔽</sub> に設定。
            1. _number_ > _highest_ なら _highest_ を _number_ に設定。
          1. _highest_ を返す。
        </emu-alg>
        <emu-note>
          <p>最大値判定の比較は IsLessThan アルゴリズムを用いるが、*+0*<sub>𝔽</sub> は *-0*<sub>𝔽</sub> より大きいと見なす点が異なる。</p>
        </emu-note>
        <p>この関数の *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>
      </emu-clause>

      <emu-clause id="sec-math.min">
        <h1>Math.min ( ..._args_ )</h1>
        <p>0 個以上の引数について、各引数に ToNumber を適用し最小の値を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _coerced_ を新しい空リストとする。
          1. _args_ の各要素 _arg_ について
            1. _n_ を ? ToNumber(_arg_) とする。
            1. _n_ を _coerced_ に追加。
          1. _lowest_ を *+∞*<sub>𝔽</sub> とする。
          1. _coerced_ の各要素 _number_ について
            1. _number_ が *NaN* なら *NaN* を返す。
            1. _number_ が *-0*<sub>𝔽</sub> かつ _lowest_ が *+0*<sub>𝔽</sub> なら _lowest_ を *-0*<sub>𝔽</sub> に設定。
            1. _number_ &lt; _lowest_ なら _lowest_ を _number_ に設定。
          1. _lowest_ を返す。
        </emu-alg>
        <emu-note>
          <p>最大値判定と同様、比較は IsLessThan に準じるが *+0*<sub>𝔽</sub> を *-0*<sub>𝔽</sub> より大きいと見なす。</p>
        </emu-note>
        <p>この関数の *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <p>この関数は呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _base_ を ? ToNumber(_base_) に設定。
          1. _exponent_ を ? ToNumber(_exponent_) に設定。
          1. Number::exponentiate(_base_, _exponent_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.random">
        <h1>Math.random ( )</h1>
        <p>この関数は符号正で *+0*<sub>𝔽</sub> 以上 *1*<sub>𝔽</sub> 未満の Number 値を、その範囲にほぼ一様な分布で（実装定義のアルゴリズムまたは戦略を用いて）ランダムまたは疑似ランダムに返す。</p>
        <p>異なるレルムで生成された各 `Math.random` 関数は、連続呼び出しで異なる値列を生成しなければならない。</p>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>この関数は _x_ に最も近い整数の Number 値を返す。2 つの整数が同じ距離の場合 +∞ に近い方を返す。_x_ が既に整数なら結果は _x_。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないか _n_ が整数 Number なら _n_ を返す。
          1. _n_ &lt; *0.5*<sub>𝔽</sub> かつ _n_ > *+0*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> かつ _n_ ≥ *-0.5*<sub>𝔽</sub> なら *-0*<sub>𝔽</sub> を返す。
          1. _n_ に最も近い整数 Number を返す（距離が同じ場合は +∞ に近い方）。
        </emu-alg>
        <emu-note>
          <p>`Math.round(3.5)` は 4 を返すが `Math.round(-3.5)` は -3 を返す。</p>
        </emu-note>
        <emu-note>
          <p>`Math.round(x)` の値は常に `Math.floor(x + 0.5)` の値と同じではない。`x` が *-0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> より小さく *-0.5*<sub>𝔽</sub> 以上のとき `Math.round(x)` は *-0*<sub>𝔽</sub> を返すが `Math.floor(x + 0.5)` は *+0*<sub>𝔽</sub> を返す。また `x + 0.5` の内部丸めにより差異が生じる場合がある。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>この関数は _x_ の符号（正/負/ゼロ）を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> なら *-1*<sub>𝔽</sub> を返す。
          1. *1*<sub>𝔽</sub> を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sin">
        <h1>Math.sin ( _x_ )</h1>
        <p>この関数は _x_ の正弦を返す。引数はラジアン。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ が *+∞*<sub>𝔽</sub> または *-∞*<sub>𝔽</sub> なら *NaN* を返す。
          1. ℝ(_n_) の正弦を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sinh">
        <h1>Math.sinh ( _x_ )</h1>
        <p>この関数は _x_ の双曲線正弦を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないか *_n_* が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら _n_ を返す。
          1. ℝ(_n_) の双曲線正弦を表す実装近似 Number 値を返す。
        </emu-alg>
        <emu-note>
          <p>`Math.sinh(x)` の値は `(Math.exp(x) - Math.exp(-x)) / 2` と同じである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>この関数は _x_ の平方根を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> なら *NaN* を返す。
          1. 𝔽(ℝ(_n_) の平方根) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sumprecise">
        <h1>Math.sumPrecise ( _items_ )</h1>
        <p>Number の iterable が与えられたとき、その各値を加算し合計を返す。任意の値が Number でなければ *TypeError* 例外を投げる。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_items_) を実行。
          1. _iteratorRecord_ を ? GetIterator(_items_, ~sync~) とする。
          1. _state_ を ~minus-zero~ とする。
          1. _sum_ を 0 とする。
          1. _count_ を 0 とする。
          1. _next_ を ~not-started~ とする。
          1. _next_ が ~done~ でない間繰り返す
            1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
            1. _next_ が ~done~ でなければ
              1. _count_ ≥ 2<sup>53</sup> - 1 なら
                1. 注: この段階に到達することは実用上想定されず、実装が「合理的なサイズ」の入力を仮定できるようにするためのみ存在する。
                1. _error_ を ThrowCompletion(新たに生成した *RangeError* オブジェクト) とする。
                1. ? IteratorClose(_iteratorRecord_, _error_) を返す。
              1. _next_ が Number でなければ
                1. _error_ を ThrowCompletion(新たに生成した *TypeError* オブジェクト) とする。
                1. ? IteratorClose(_iteratorRecord_, _error_) を返す。
              1. _n_ を _next_ とする。
              1. _state_ が ~not-a-number~ でないなら
                1. _n_ が *NaN* なら
                  1. _state_ を ~not-a-number~ に設定。
                1. Else if _n_ が *+∞*<sub>𝔽</sub> なら
                  1. _state_ が ~minus-infinity~ なら _state_ を ~not-a-number~ に設定。
                  1. Else _state_ を ~plus-infinity~ に設定。
                1. Else if _n_ が *-∞*<sub>𝔽</sub> なら
                  1. _state_ が ~plus-infinity~ なら _state_ を ~not-a-number~ に設定。
                  1. Else _state_ を ~minus-infinity~ に設定。
                1. Else if _n_ が *-0*<sub>𝔽</sub> でなく、_state_ が ~minus-zero~ または ~finite~ なら
                  1. _state_ を ~finite~ に設定。
                  1. _sum_ を _sum_ + ℝ(_n_) に設定。
              1. _count_ を _count_ + 1 に設定。
          1. _state_ が ~not-a-number~ なら *NaN* を返す。
          1. _state_ が ~plus-infinity~ なら *+∞*<sub>𝔽</sub> を返す。
          1. _state_ が ~minus-infinity~ なら *-∞*<sub>𝔽</sub> を返す。
          1. _state_ が ~minus-zero~ なら *-0*<sub>𝔽</sub> を返す。
          1. 𝔽(_sum_) を返す。
        </emu-alg>
        <emu-note>
          <p>_sum_ の値は任意精度演算なしに多様なアルゴリズムで計算可能である。例として Jonathan Richard Shewchuk による “Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates” の "Grow-Expansion" アルゴリズムがある。より新しい手法は "<a href="https://arxiv.org/abs/1505.05571">Fast exact summation using small and large superaccumulators</a>" に示され、コードは <a href="https://gitlab.com/radfordneal/xsum">https://gitlab.com/radfordneal/xsum</a> で利用可能。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.tan">
        <h1>Math.tan ( _x_ )</h1>
        <p>この関数は _x_ の正接を返す。引数はラジアン。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ が *+∞*<sub>𝔽</sub> または *-∞*<sub>𝔽</sub> なら *NaN* を返す。
          1. ℝ(_n_) の正接を表す実装近似 Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.tanh">
        <h1>Math.tanh ( _x_ )</h1>
        <p>この関数は _x_ の双曲線正接を返す。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> のいずれかなら _n_ を返す。
          1. _n_ が *+∞*<sub>𝔽</sub> なら *1*<sub>𝔽</sub> を返す。
          1. _n_ が *-∞*<sub>𝔽</sub> なら *-1*<sub>𝔽</sub> を返す。
          1. ℝ(_n_) の双曲線正接を表す実装近似 Number 値を返す。
        </emu-alg>
        <emu-note>
          <p>`Math.tanh(x)` の値は `(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))` と同じである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>この関数は数 _x_ の小数部分を取り除いた整数部分を返す。_x_ が既に整数なら結果は _x_。</p>
        <p>呼び出されたとき次を実行する:</p>
        <emu-alg>
          1. _n_ を ? ToNumber(_x_) とする。
          1. _n_ が有限でないか *_n_* が *+0*<sub>𝔽</sub> または *-0*<sub>𝔽</sub> なら _n_ を返す。
          1. _n_ &lt; *1*<sub>𝔽</sub> かつ _n_ > *+0*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _n_ &lt; *-0*<sub>𝔽</sub> かつ _n_ > *-1*<sub>𝔽</sub> なら *-0*<sub>𝔽</sub> を返す。
          1. *+0*<sub>𝔽</sub> 方向で _n_ に最も近い整数 Number を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-date-objects">
    <h1>Date オブジェクト</h1>

    <emu-clause id="sec-overview-of-date-objects-and-definitions-of-abstract-operations">
      <h1>Date オブジェクトの概要と抽象操作の定義</h1>
      <p>以下の抽象操作は（<emu-xref href="#sec-time-values-and-time-range"></emu-xref> で定義される）時間値に対して動作する。いずれの場合も、これらの関数への引数のいずれかが *NaN* であれば、結果は *NaN* になることに注意。</p>

      <emu-clause id="sec-time-values-and-time-range">
        <h1>時間値と時間範囲</h1>
        <p>ECMAScript における時間計測は POSIX における時間計測に類似し、とくに先発グレゴリオ暦（proleptic Gregorian calendar）、1970 年 1 月 1 日 UTC の開始時刻（真夜中）を <dfn id="epoch">エポック</dfn> として定義し、1 日を正確に 86,400 秒（各秒は 1000 ミリ秒）とする会計的扱いを共有する。</p>
        <p>ECMAScript の <dfn variants="time values">時間値</dfn> は Number であり、ミリ秒精度での時点を表す有限な整数の Number か、特定の時点を表さない *NaN* のいずれかである。<emu-eqn>24 × 60 × 60 × 1000 = 86,400,000</emu-eqn> の倍数（すなわちある整数 _d_ について 86,400,000 × _d_）である時間値は、エポックから _d_ 個の完全な UTC 日を経過した UTC 日の開始時点（_d_ が負であればエポックより前）を表す。それ以外の有限時間値 _t_ は、その値以下で最大のかつ前述の倍数である時間値 _s_ を基準とし、同一の UTC 日内で _s_ の後に (_t_ - _s_) ミリ秒経過した時点を表す。</p>
        <p>時間値は UTC のうるう秒を考慮しない—正のうるう秒内の瞬間を表す時間値は存在せず、負のうるう秒によって UTC タイムラインから除去された瞬間を表す時間値は存在する。それでもなお、時間値の定義は区分的に UTC と整合し、うるう秒境界のみ不連続で、それ以外では差はゼロである。</p>
        <p>Number は -9,007,199,254,740,992 から 9,007,199,254,740,992 までのすべての整数を正確に表現できる（<emu-xref href="#sec-number.min_safe_integer"></emu-xref> および <emu-xref href="#sec-number.max_safe_integer"></emu-xref>）。時間値は -8,640,000,000,000,000 から 8,640,000,000,000,000 ミリ秒というやや小さい範囲をサポートする。これは 1970 年 1 月 1 日 UTC の真夜中を基準に正確に -100,000,000 日から 100,000,000 日の範囲を与える。</p>
        <p>1970 年 1 月 1 日 UTC の開始時刻の正確な瞬間は時間値 *+0*<sub>𝔽</sub> で表される。</p>
        <emu-note>
          <p>先発グレゴリオ暦においてうるう年は、4 で割り切れ、かつ 400 で割り切れるか 100 で割り切れない年である。</p>
          <p>先発グレゴリオ暦の 400 年周期には 97 のうるう年が含まれる。これは平均 365.2425 日/年（31,556,952,000 ミリ秒）となる。したがって Number がミリ秒精度で正確に表現できる最大範囲は 1970 年を基準に概ね -285,426 年から 285,426 年である。本節で規定される時間値がサポートするより小さい範囲はおよそ -273,790 年から 273,790 年である。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-related-constants">
        <h1>時間関連の定数</h1>
        <p>これらの定数は以下の節のアルゴリズムで参照される。</p>
        <emu-eqn id="eqn-HoursPerDay" aoid="HoursPerDay">HoursPerDay = 24</emu-eqn>
        <emu-eqn id="eqn-MinutesPerHour" aoid="MinutesPerHour">MinutesPerHour = 60</emu-eqn>
        <emu-eqn id="eqn-SecondsPerMinute" aoid="SecondsPerMinute">SecondsPerMinute = 60</emu-eqn>
        <emu-eqn id="eqn-msPerSecond" aoid="msPerSecond">msPerSecond = *1000*<sub>𝔽</sub></emu-eqn>
        <emu-eqn id="eqn-msPerMinute" aoid="msPerMinute">msPerMinute = *60000*<sub>𝔽</sub> = msPerSecond × 𝔽(SecondsPerMinute)</emu-eqn>
        <emu-eqn id="eqn-msPerHour" aoid="msPerHour">msPerHour = *3600000*<sub>𝔽</sub> = msPerMinute × 𝔽(MinutesPerHour)</emu-eqn>
        <emu-eqn id="eqn-msPerDay" aoid="msPerDay">msPerDay = *86400000*<sub>𝔽</sub> = msPerHour × 𝔽(HoursPerDay)</emu-eqn>
      </emu-clause>

      <emu-clause id="sec-day" type="abstract operation" oldids="eqn-Day,sec-day-number-and-time-within-day">
        <h1>
          Day (
            _t_: 有限な時間値,
          ): 整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する日の通し日数（day number）を返す。</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerDay))) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timewithinday" type="abstract operation" oldids="eqn-TimeWithinDay">
        <h1>
          TimeWithinDay (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub>（含む）から msPerDay（含まない）までの整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する日の開始からの経過ミリ秒数を返す。</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(_t_) modulo ℝ(msPerDay)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daysinyear" type="abstract operation" oldids="eqn-DaysInYear,sec-year-number">
        <h1>
          DaysInYear (
            _y_: 整数の Number,
          ): *365*<sub>𝔽</sub> または *366*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>年 _y_ の日数を返す。うるう年は 366 日、それ以外は 365 日。</dd>
        </dl>
        <emu-alg>
          1. _ry_ を ℝ(_y_) とする。
          1. (_ry_ modulo 400) = 0 なら *366*<sub>𝔽</sub> を返す。
          1. (_ry_ modulo 100) = 0 なら *365*<sub>𝔽</sub> を返す。
          1. (_ry_ modulo 4) = 0 なら *366*<sub>𝔽</sub> を返す。
          1. *365*<sub>𝔽</sub> を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dayfromyear" type="abstract operation" oldids="eqn-DaysFromYear">
        <h1>
          DayFromYear (
            _y_: 整数の Number,
          ): 整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>年 _y_ の初日（1 月 1 日）の day number を返す。</dd>
        </dl>
        <emu-alg>
          1. _ry_ を ℝ(_y_) とする。
          1. [declared="numYears1,numYears4,numYears100,numYears400"] 注: 以降の手順で _numYears1_, _numYears4_, _numYears100_, _numYears400_ はエポックから年 _y_ の開始までに含まれる、それぞれ 1, 4, 100, 400 で割り切れる年数を表す。_y_ がエポックより前なら負の数。
          1. _numYears1_ を (_ry_ - 1970) とする。
          1. _numYears4_ を floor((_ry_ - 1969) / 4) とする。
          1. _numYears100_ を floor((_ry_ - 1901) / 100) とする。
          1. _numYears400_ を floor((_ry_ - 1601) / 400) とする。
          1. 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timefromyear" type="abstract operation" oldids="eqn-TimeFromYear">
        <h1>
          TimeFromYear (
            _y_: 整数の Number,
          ): 時間値
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>年 _y_ の開始の時間値を返す。</dd>
        </dl>
        <emu-alg>
          1. msPerDay × DayFromYear(_y_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yearfromtime" type="abstract operation" oldids="eqn-YearFromTime">
        <h1>
          YearFromTime (
            _t_: 有限な時間値,
          ): 整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する年を返す。</dd>
        </dl>
        <emu-alg>
          1. [declared="y"] TimeFromYear(_y_) ≤ _t_ を満たす最大の整数 Number _y_（+∞ に最も近い）を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daywithinyear" type="abstract operation" oldids="eqn-DayWithinYear">
        <h1>
          DayWithinYear (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> から *365*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Day(_t_) - DayFromYear(YearFromTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-inleapyear" type="abstract operation" oldids="eqn-InLeapYear">
        <h1>
          InLeapYear (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> または *1*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ がうるう年内なら *1*<sub>𝔽</sub>、そうでなければ *+0*<sub>𝔽</sub> を返す。</dd>
        </dl>
        <emu-alg>
          1. DaysInYear(YearFromTime(_t_)) が *366*<sub>𝔽</sub> なら *1*<sub>𝔽</sub> を返し、そうでなければ *+0*<sub>𝔽</sub> を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-monthfromtime" type="abstract operation" oldids="eqn-MonthFromTime,sec-month-number">
        <h1>
          MonthFromTime (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> から *11*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する月を識別する Number を返す。*+0*<sub>𝔽</sub> は 1 月、*1*<sub>𝔽</sub> は 2 月、*2*<sub>𝔽</sub> は 3 月、*3*<sub>𝔽</sub> は 4 月、*4*<sub>𝔽</sub> は 5 月、*5*<sub>𝔽</sub> は 6 月、*6*<sub>𝔽</sub> は 7 月、*7*<sub>𝔽</sub> は 8 月、*8*<sub>𝔽</sub> は 9 月、*9*<sub>𝔽</sub> は 10 月、*10*<sub>𝔽</sub> は 11 月、*11*<sub>𝔽</sub> は 12 月を表す。<emu-eqn>MonthFromTime(*+0*<sub>𝔽</sub>) = *+0*<sub>𝔽</sub></emu-eqn> は 1970 年 1 月 1 日（木曜日）に対応する。</dd>
        </dl>
        <emu-alg>
          1. _inLeapYear_ を InLeapYear(_t_) とする。
          1. _dayWithinYear_ を DayWithinYear(_t_) とする。
          1. _dayWithinYear_ &lt; *31*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *59*<sub>𝔽</sub> + _inLeapYear_ なら *1*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *90*<sub>𝔽</sub> + _inLeapYear_ なら *2*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *120*<sub>𝔽</sub> + _inLeapYear_ なら *3*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *151*<sub>𝔽</sub> + _inLeapYear_ なら *4*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *181*<sub>𝔽</sub> + _inLeapYear_ なら *5*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *212*<sub>𝔽</sub> + _inLeapYear_ なら *6*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *243*<sub>𝔽</sub> + _inLeapYear_ なら *7*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *273*<sub>𝔽</sub> + _inLeapYear_ なら *8*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *304*<sub>𝔽</sub> + _inLeapYear_ なら *9*<sub>𝔽</sub> を返す。
          1. _dayWithinYear_ &lt; *334*<sub>𝔽</sub> + _inLeapYear_ なら *10*<sub>𝔽</sub> を返す。
          1. 事前条件: _dayWithinYear_ &lt; *365*<sub>𝔽</sub> + _inLeapYear_。
          1. *11*<sub>𝔽</sub> を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-datefromtime" type="abstract operation" oldids="sec-date-number">
        <h1>
          DateFromTime (
            _t_: 有限な時間値,
          ): *1*<sub>𝔽</sub> から *31*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する月の日（day of month）を返す。</dd>
        </dl>
        <emu-alg>
          1. _inLeapYear_ を InLeapYear(_t_) とする。
          1. _dayWithinYear_ を DayWithinYear(_t_) とする。
          1. _month_ を MonthFromTime(_t_) とする。
          1. _month_ が *+0*<sub>𝔽</sub> なら _dayWithinYear_ + *1*<sub>𝔽</sub> を返す。
          1. _month_ が *1*<sub>𝔽</sub> なら _dayWithinYear_ - *30*<sub>𝔽</sub> を返す。
          1. _month_ が *2*<sub>𝔽</sub> なら _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *3*<sub>𝔽</sub> なら _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *4*<sub>𝔽</sub> なら _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *5*<sub>𝔽</sub> なら _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *6*<sub>𝔽</sub> なら _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *7*<sub>𝔽</sub> なら _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *8*<sub>𝔽</sub> なら _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *9*<sub>𝔽</sub> なら _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. _month_ が *10*<sub>𝔽</sub> なら _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_ を返す。
          1. 事前条件: _month_ は *11*<sub>𝔽</sub>。
          1. _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weekday" type="abstract operation" oldids="sec-week-day">
        <h1>
          WeekDay (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> から *6*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する曜日を識別する Number を返す。*+0*<sub>𝔽</sub> は日曜日、*1*<sub>𝔽</sub> は月曜日、*2*<sub>𝔽</sub> は火曜日、*3*<sub>𝔽</sub> は水曜日、*4*<sub>𝔽</sub> は木曜日、*5*<sub>𝔽</sub> は金曜日、*6*<sub>𝔽</sub> は土曜日。<emu-eqn>WeekDay(*+0*<sub>𝔽</sub>) = *4*<sub>𝔽</sub></emu-eqn> は 1970 年 1 月 1 日（木曜日）に対応する。</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) modulo 7) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hourfromtime" type="abstract operation" oldids="eqn-HourFromTime,sec-hours-minutes-second-and-milliseconds">
        <h1>
          HourFromTime (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> から *23*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する日の時（hour）を返す。</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-minfromtime" type="abstract operation" oldids="eqn-MinFromTime">
        <h1>
          MinFromTime (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> から *59*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する時間の分（minute）を返す。</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-secfromtime" type="abstract operation" oldids="eqn-SecFromTime">
        <h1>
          SecFromTime (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> から *59*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する分の秒（second）を返す。</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-msfromtime" type="abstract operation" oldids="eqn-msFromTime">
        <h1>
          msFromTime (
            _t_: 有限な時間値,
          ): *+0*<sub>𝔽</sub> から *999*<sub>𝔽</sub> まで（両端含む）の整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_ が属する秒のミリ秒（millisecond）を返す。</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(_t_) modulo ℝ(msPerSecond)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getutcepochnanoseconds" type="abstract operation">
        <h1>
          GetUTCEpochNanoseconds (
            _year_: 整数,
            _month_: 1 から 12（両端含む）の整数,
            _day_: 1 から 31（両端含む）の整数,
            _hour_: 0 から 23（両端含む）の整数,
            _minute_: 0 から 59（両端含む）の整数,
            _second_: 0 から 59（両端含む）の整数,
            _millisecond_: 0 から 999（両端含む）の整数,
            _microsecond_: 0 から 999（両端含む）の整数,
            _nanosecond_: 0 から 999（両端含む）の整数,
          ): BigInt
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>返される値は、与えられた ISO 8601 暦日と UTC の壁時計時刻に対応する、エポックからのナノ秒数を表す。</dd>
        </dl>
        <emu-alg>
          1. _date_ を MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_)) とする。
          1. _time_ を MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_)) とする。
          1. _ms_ を MakeDate(_date_, _time_) とする。
          1. 事前条件: _ms_ は整数の Number。
          1. ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifiers">
        <h1>タイムゾーン識別子</h1>

        <p>
          ECMAScript におけるタイムゾーンは <dfn variants="time zone identifier">タイムゾーン識別子</dfn> により表され、これは 0x0000 から 0x007F（両端含む）のコードユニットのみから構成される文字列である。
          ECMAScript 実装がサポートするタイムゾーンは、AvailableNamedTimeZoneIdentifiers が返す Time Zone Identifier Record の [[Identifier]] フィールドで表される <dfn variants="available named time zone">利用可能な名前付きタイムゾーン</dfn>、または IsTimeZoneOffsetString が *true* を返す文字列で表される <dfn variants="offset time zone">オフセットタイムゾーン</dfn> のいずれかであり得る。
        </p>
        <p>
          <dfn variants="primary time zone identifiers">一次タイムゾーン識別子</dfn> は、ある利用可能な名前付きタイムゾーンの推奨識別子である。
          <dfn variants="non-primary time zone identifiers">非一次タイムゾーン識別子</dfn> は、一次タイムゾーン識別子ではない利用可能な名前付きタイムゾーンの識別子である。
          <dfn variants="available named time zone identifiers">利用可能な名前付きタイムゾーン識別子</dfn> は一次または非一次のいずれかである。
          各利用可能な名前付きタイムゾーン識別子は厳密に 1 つの名前付きタイムゾーンに対応し、
          各利用可能な名前付きタイムゾーンは厳密に 1 つの一次タイムゾーン識別子と 0 個以上の非一次タイムゾーン識別子に対応する。
        </p>
        <p>
          ECMAScript 実装は識別子 *"UTC"* を持つ利用可能な名前付きタイムゾーンをサポートしなければならず、これは UTC タイムゾーンの一次タイムゾーン識別子でなければならない。
          さらに実装は他の任意個数の利用可能な名前付きタイムゾーンをサポートしてもよい。
        </p>
        <p>
          ECMA-402 Internationalization API 仕様で記述されるタイムゾーン要件に従う実装は <dfn>タイムゾーン対応 (time zone aware)</dfn> と呼ばれる。
          タイムゾーン対応実装は IANA Time Zone Database の Zone 名および Link 名に対応する利用可能な名前付きタイムゾーンをサポートし、かつそれらのみをサポートしなければならない。
          タイムゾーン対応実装では、一次タイムゾーン識別子は Zone 名であり、非一次タイムゾーン識別子は Link 名である（ただし ECMA-402 仕様で規定される AvailableNamedTimeZoneIdentifiers により特に上書きされる場合を除く）。
          IANA Time Zone Database 全体をサポートしない実装であっても、タイムゾーンを表す識別子として IANA Time Zone Database の名前を用いることが推奨される。
        </p>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneepochnanoseconds" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneEpochNanoseconds (
            _timeZoneIdentifier_: String,
            _year_: 整数,
            _month_: 1 から 12（両端含む）の整数,
            _day_: 1 から 31（両端含む）の整数,
            _hour_: 0 から 23（両端含む）の整数,
            _minute_: 0 から 59（両端含む）の整数,
            _second_: 0 から 59（両端含む）の整数,
            _millisecond_: 0 から 999（両端含む）の整数,
            _microsecond_: 0 から 999（両端含む）の整数,
            _nanosecond_: 0 から 999（両端含む）の整数,
          ): BigInt の List
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            返される List の各要素は、_timeZoneIdentifier_ で識別される名前付きタイムゾーン内で、与えられた ISO 8601 暦日と壁時計時刻に対応する、エポックからのナノ秒数を表す。
          </dd>
        </dl>
        <p>
          入力が負のタイムゾーン遷移（例: 夏時間終了やルール変更によるオフセット減少）により複数回出現するローカル時刻を表す場合、返される List は複数要素を持ち、数値昇順で並ぶ。
          入力が正のタイムゾーン遷移（例: 夏時間開始やルール変更によるオフセット増加）でスキップされるローカル時刻を表す場合、返される List は空となる。
          それ以外の場合、返される List は 1 要素を持つ。
        </p>
        <p>ローカルの政治的ルールをいかなるタイムゾーンについても含まない ECMAScript 実装で利用される GetNamedTimeZoneEpochNanoseconds のデフォルト実装は、呼び出されたとき次を行う:</p>
        <emu-alg>
          1. 事前条件: _timeZoneIdentifier_ は *"UTC"*。
          1. _epochNanoseconds_ を GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) とする。
          1. « _epochNanoseconds_ » を返す。
        </emu-alg>
        <emu-note>
          <p>タイムゾーン対応実装（および他のすべての実装にも推奨）は IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a> のタイムゾーン情報を使用することが要求される。</p>
          <p>2017 年 11 月 5 日の America/New_York における午前 1:30 は 2 回繰り返されるため、GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 11, 5, 1, 30, 0, 0, 0, 0) は長さ 2 の List を返し、最初の要素は 05:30 UTC（UTC-04:00 の米国東部夏時間の 01:30）を、第二の要素は 06:30 UTC（UTC-05:00 の米国東部標準時の 01:30）を表す。</p>
          <p>2017 年 3 月 12 日の America/New_York における午前 2:30 は存在しないので、GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 3, 12, 2, 30, 0, 0, 0, 0) は空の List を返す。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneoffsetnanoseconds" oldids="sec-local-time-zone-adjustment" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneOffsetNanoseconds (
            _timeZoneIdentifier_: String,
            _epochNanoseconds_: BigInt,
          ): 整数
        </h1>
        <dl class="header">
        </dl>
        <p>返される整数は、_timeZoneIdentifier_ で識別される名前付きタイムゾーンの、エポックからの _epochNanoseconds_ が表す瞬間における UTC からのオフセット（いずれもナノ秒）を表す。</p>
        <p>ローカルの政治的ルールをいかなるタイムゾーンについても含まない ECMAScript 実装で利用される GetNamedTimeZoneOffsetNanoseconds のデフォルト実装は、呼び出されたとき次を行う:</p>
        <emu-alg>
          1. 事前条件: _timeZoneIdentifier_ は *"UTC"*。
          1. 0 を返す。
        </emu-alg>
        <emu-note>
          <p>タイムゾーンオフセット値は正または負になり得る。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifier-record">
        <h1>タイムゾーン識別子レコード</h1>
        <p><dfn variants="Time Zone Identifier Records">タイムゾーン識別子レコード</dfn> は利用可能な名前付きタイムゾーン識別子とその対応する一次タイムゾーン識別子を記述するための Record である。</p>
        <p>タイムゾーン識別子レコードは <emu-xref href="#table-time-zone-identifier-record-fields"></emu-xref> に掲げるフィールドを持つ。</p>
        <emu-table id="table-time-zone-identifier-record-fields" caption="タイムゾーン識別子レコードのフィールド">
          <table>
            <thead>
              <tr>
                <th>フィールド名</th>
                <th>値</th>
                <th>意味</th>
              </tr>
            </thead>
            <tr>
              <td>[[Identifier]]</td>
              <td>String</td>
              <td>実装がサポートする利用可能な名前付きタイムゾーン識別子。</td>
            </tr>
            <tr>
              <td>[[PrimaryIdentifier]]</td>
              <td>String</td>
              <td>[[Identifier]] が解決される一次タイムゾーン識別子。</td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>[[Identifier]] が一次タイムゾーン識別子である場合、[[Identifier]] は [[PrimaryIdentifier]] と等しい。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-availablenamedtimezoneidentifiers" type="implementation-defined abstract operation">
        <h1>AvailableNamedTimeZoneIdentifiers ( ): Time Zone Identifier Record の List</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            戻り値はこの実装内のすべての利用可能な名前付きタイムゾーン識別子と、それぞれに対応する一次タイムゾーン識別子を記述する。
            List は各 Time Zone Identifier Record の [[Identifier]] フィールド順に並ぶ。
          </dd>
        </dl>
        <p>
          タイムゾーン対応実装（ECMA-402 Internationalization API を実装するすべての実装を含む）は AvailableNamedTimeZoneIdentifiers 抽象操作を ECMA-402 仕様に従って実装しなければならない。
          タイムゾーン対応でない実装では、AvailableNamedTimeZoneIdentifiers は呼び出されたとき以下を行う:
        </p>
        <emu-alg>
          1. 実装がいかなるタイムゾーンについてもローカルの政治的ルールを含まないなら
            1. « Time Zone Identifier Record { [[Identifier]]: *"UTC"*, [[PrimaryIdentifier]]: *"UTC"* } » を返す。
          1. _identifiers_ を、重複しない利用可能な名前付きタイムゾーン識別子の List（辞書式コードユニット順にソート）とする。
          1. _result_ を新しい空の List とする。
          1. _identifiers_ の各要素 _identifier_ について、
            1. _primary_ を _identifier_ とする。
            1. _identifier_ がこの実装における非一次タイムゾーン識別子でありかつ _identifier_ が *"UTC"* でないなら
              1. _primary_ を _identifier_ に関連付けられた一次タイムゾーン識別子に設定する。
              1. 注: 実装は一次タイムゾーン識別子を得るために _identifier_ を反復的に解決する必要があるかもしれない。
            1. _record_ を Time Zone Identifier Record { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ } とする。
            1. _record_ を _result_ に追加する。
          1. 事前条件: _result_ は [[Identifier]] が *"UTC"* で [[PrimaryIdentifier]] が *"UTC"* である Time Zone Identifier Record _r_ を含む。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-systemtimezoneidentifier" oldids="sec-defaulttimezone" type="implementation-defined abstract operation">
        <h1>SystemTimeZoneIdentifier ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            ホスト環境の現在のタイムゾーンを表す文字列を返す。それは IsTimeZoneOffsetString が *true* を返す UTC オフセットを表す文字列、または一次タイムゾーン識別子のいずれかである。
          </dd>
        </dl>

        <emu-alg>
          1. 実装が UTC タイムゾーンのみをサポートするなら *"UTC"* を返す。
          1. _systemTimeZoneString_ をホスト環境の現在のタイムゾーンを表す文字列（一次タイムゾーン識別子またはオフセットタイムゾーン識別子）とする。
          1. _systemTimeZoneString_ を返す。
        </emu-alg>

        <emu-note>
          <p>
            Date オブジェクトのメソッドで一般的に提供される機能レベルを確実にするため、SystemTimeZoneIdentifier はホスト環境のタイムゾーン設定に対応する IANA タイムゾーン名（存在するなら）を返すことが推奨される。
            GetNamedTimeZoneEpochNanoseconds と GetNamedTimeZoneOffsetNanoseconds はそのタイムゾーンの標準時および夏時間のローカル政治的ルールを反映しなければならない（存在する場合）。
          </p>
          <p>例えば、ホスト環境がユーザが US Eastern Time を選択したシステム上のブラウザである場合、SystemTimeZoneIdentifier は *"America/New_York"* を返す。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-localtime" type="abstract operation">
        <h1>
          LocalTime (
            _t_: 有限な時間値,
          ): 整数の Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            _t_ を UTC からローカル時刻に変換する。
            _t_ に有効な標準時と夏時間のローカル政治的ルールを、この節で規定される方法で用いて結果を決定するべきである。
          </dd>
        </dl>
        <emu-alg>
          1. _systemTimeZoneIdentifier_ を SystemTimeZoneIdentifier() とする。
          1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) が *true* なら
            1. _offsetNs_ を ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_) とする。
          1. そうでなければ、
            1. _offsetNs_ を GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>)) とする。
          1. _offsetMs_ を truncate(_offsetNs_ / 10<sup>6</sup>) とする。
          1. _t_ + 𝔽(_offsetMs_) を返す。
        </emu-alg>
        <emu-note>
          <p>実装内にローカル時刻 _t_ の政治的ルールが利用可能でない場合、SystemTimeZoneIdentifier が *"UTC"* を返し GetNamedTimeZoneOffsetNanoseconds が 0 を返すため、結果は _t_ と同じになる。</p>
        </emu-note>
        <emu-note>
          <p>タイムゾーン対応実装（および他のすべての実装にも推奨）は IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a> のタイムゾーン情報を使用することが要求される。</p>
        </emu-note>
        <emu-note>
          <p>負のタイムゾーン遷移で時刻が繰り返されるとき（例: 夏時間終了やオフセット減少）、2 つの異なる入力時間値 <emu-eqn>_t_<sub>UTC</sub></emu-eqn> が同じローカル時刻 <emu-eqn>t<sub>local</sub></emu-eqn> に変換される。</p>
          <p><emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> は常に <emu-eqn>_t_<sub>local</sub></emu-eqn> と等しいとは限らない。同様に <emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> も常に <emu-eqn>_t_<sub>UTC</sub></emu-eqn> と等しいとは限らない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-utc-t" type="abstract operation">
        <h1>
          UTC (
            _t_: Number,
          ): 時間値
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            _t_ をローカル時刻から UTC の時間値に変換する。
            _t_ に有効な標準時と夏時間のローカル政治的ルールを、この節で規定される方法で用いて結果を決定するべきである。
          </dd>
        </dl>
        <emu-alg>
          1. _t_ が有限でなければ *NaN* を返す。
          1. _systemTimeZoneIdentifier_ を SystemTimeZoneIdentifier() とする。
          1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) が *true* なら
            1. _offsetNs_ を ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_) とする。
          1. そうでなければ、
            1. _possibleInstants_ を GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0) とする。
            1. 注: 以下の手順は _t_ が負のタイムゾーン遷移（例: 夏時間終了やオフセット減少）で複数回繰り返されるローカル時刻、または正のタイムゾーン遷移（例: 夏時間開始やオフセット増加）でスキップされるローカル時刻を表すとき、_t_ が遷移前のタイムゾーンオフセットを用いて解釈されることを保証する。
            1. _possibleInstants_ が空でなければ
              1. _disambiguatedInstant_ を _possibleInstants_[0] とする。
            1. そうでなければ、
              1. 注: _t_ は正のタイムゾーン遷移（例: 夏時間開始やオフセット増加）でスキップされたローカル時刻を表す。
              1. [declared="tBefore"] _possibleInstantsBefore_ を GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0) とし、ここで _tBefore_ は _possibleInstantsBefore_ が空でない最大の整数 Number かつ _t_ より小さいもの（すなわち遷移直前の最後のローカル時刻）である。
              1. _disambiguatedInstant_ を _possibleInstantsBefore_ の最後の要素とする。
            1. _offsetNs_ を GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_) とする。
          1. _offsetMs_ を truncate(_offsetNs_ / 10<sup>6</sup>) とする。
          1. _t_ - 𝔽(_offsetMs_) を返す。
        </emu-alg>
        <p>
          入力 _t_ は名目上時間値だが、任意の Number 値でよい。
          アルゴリズムは _t_ を時間値範囲に制限してはならず、これにより時間値範囲の境界に対応する入力がローカル UTC オフセットに関わらずサポート可能となる。
          例えば最大時間値は 8.64 × 10<sup>15</sup> で *"+275760-09-13T00:00:00Z"* に対応する。
          その瞬間にローカルタイムゾーンオフセットが UTC より 1 時間進んでいる環境では、より大きい入力 8.64 × 10<sup>15</sup> + 3.6 × 10<sup>6</sup> で表され、*"+275760-09-13T01:00:00+01:00"* に対応する。
        </p>
        <p>実装内にローカル時刻 _t_ の政治的ルールが利用可能でない場合、SystemTimeZoneIdentifier が *"UTC"* を返し GetNamedTimeZoneOffsetNanoseconds が 0 を返すため、結果は _t_ と同じになる。</p>
        <emu-note>
          <p>タイムゾーン対応実装（および他のすべての実装にも推奨）は IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a> のタイムゾーン情報を使用することが要求される。</p>
          <p>2017 年 11 月 5 日の America/New_York の午前 1:30 は 2 回繰り返される（秋の戻し）が、UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0)))) では _offsetMs_ の値は <emu-eqn>-4 × msPerHour</emu-eqn> となり、1:30 AM UTC-04 として解釈されなければならない。</p>
          <p>
            2017 年 3 月 12 日の America/New_York の午前 2:30 は存在しないが、2:30 AM UTC-05（3:30 AM UTC-04 と同等）として解釈されなければならない。
            UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0)))) において _offsetMs_ の値は <emu-eqn>-5 × msPerHour</emu-eqn> である。
          </p>
        </emu-note>
        <emu-note>
          <p><emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> は常に <emu-eqn>_t_<sub>UTC</sub></emu-eqn> と等しいとは限らない。同様に <emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> も常に <emu-eqn>_t_<sub>local</sub></emu-eqn> と等しいとは限らない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-maketime" type="abstract operation">
        <h1>
          MakeTime (
            _hour_: Number,
            _min_: Number,
            _sec_: Number,
            _ms_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ミリ秒数を計算する。</dd>
        </dl>
        <emu-alg>
          1. _hour_ が有限でない、_min_ が有限でない、_sec_ が有限でない、または _ms_ が有限でないなら *NaN* を返す。
          1. _h_ を 𝔽(! ToIntegerOrInfinity(_hour_)) とする。
          1. _m_ を 𝔽(! ToIntegerOrInfinity(_min_)) とする。
          1. _s_ を 𝔽(! ToIntegerOrInfinity(_sec_)) とする。
          1. _milli_ を 𝔽(! ToIntegerOrInfinity(_ms_)) とする。
          1. ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_ を返す。
        </emu-alg>
        <emu-note>
          <p>MakeTime の算術は浮動小数点算術であり結合的でないため、演算は正しい順序で行われなければならない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-makeday" type="abstract operation">
        <h1>
          MakeDay (
            _year_: Number,
            _month_: Number,
            _date_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>日数を計算する。</dd>
        </dl>
        <emu-alg>
          1. _year_ が有限でない、_month_ が有限でない、または _date_ が有限でないなら *NaN* を返す。
          1. _y_ を 𝔽(! ToIntegerOrInfinity(_year_)) とする。
          1. _m_ を 𝔽(! ToIntegerOrInfinity(_month_)) とする。
          1. _dt_ を 𝔽(! ToIntegerOrInfinity(_date_)) とする。
          1. _ym_ を _y_ + 𝔽(floor(ℝ(_m_) / 12)) とする。
          1. _ym_ が有限でなければ *NaN* を返す。
          1. _mn_ を 𝔽(ℝ(_m_) modulo 12) とする。
          1. YearFromTime(_t_) が _ym_、MonthFromTime(_t_) が _mn_、DateFromTime(_t_) が *1*<sub>𝔽</sub> である有限の時間値 _t_ を見つける。ただし（引数が範囲外であるなどにより）不可能なら *NaN* を返す。
          1. Day(_t_) + _dt_ - *1*<sub>𝔽</sub> を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makedate" type="abstract operation">
        <h1>
          MakeDate (
            _day_: Number,
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ミリ秒数を計算する。</dd>
        </dl>
        <emu-alg>
          1. _day_ が有限でないまたは _time_ が有限でないなら *NaN* を返す。
          1. _tv_ を _day_ × msPerDay + _time_ とする。
          1. _tv_ が有限でないなら *NaN* を返す。
          1. _tv_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makefullyear" type="abstract operation">
        <h1>
          MakeFullYear (
            _year_: Number,
          ): 整数の Number または *NaN*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_year_ の整数部分に関連付けられた完全な年（full year）を返す。0 から 99（両端含む）の値は 1900 年の開始からの年数として解釈する。先発グレゴリオ暦との整合のため、「full year」は年 0（紀元前 1 年）の開始からの完了した年の符号付き個数と定義される。</dd>
        </dl>
        <emu-alg>
          1. _year_ が *NaN* なら *NaN* を返す。
          1. _truncated_ を ! ToIntegerOrInfinity(_year_) とする。
          1. _truncated_ が 0 から 99（両端含む）なら *1900*<sub>𝔽</sub> + 𝔽(_truncated_) を返す。
          1. 𝔽(_truncated_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timeclip" type="abstract operation">
        <h1>
          TimeClip (
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ミリ秒数を計算する。</dd>
        </dl>
        <emu-alg>
          1. _time_ が有限でなければ *NaN* を返す。
          1. abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup> なら *NaN* を返す。
          1. 𝔽(! ToIntegerOrInfinity(_time_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date-time-string-format">
        <h1>日時文字列フォーマット</h1>
        <p>ECMAScript は ISO 8601 暦日の拡張形式を単純化した日時の文字列交換フォーマットを定義する。形式は次のとおり: `YYYY-MM-DDTHH:mm:ss.sssZ`</p>
        <p>要素の意味は以下のとおり:</p>
        <figure>
          <table class="lightweight-table">
            <tr>
              <td>
                `YYYY`
              </td>
              <td>
                0000 から 9999 までの 4 桁の 10 進数、または *"+"* または *"-"* に続く 6 桁の 10 進数による <emu-xref href="#sec-expanded-years">拡張年</emu-xref> としての先発グレゴリオ暦の年。
              </td>
            </tr>
            <tr>
              <td>
                `-`
              </td>
              <td>
                *"-"*（ハイフン）が文字列中に 2 回字義通りに現れる。
              </td>
            </tr>
            <tr>
              <td>
                `MM`
              </td>
              <td>
                01（1 月）から 12（12 月）までの 2 桁の 10 進数としての月。
              </td>
            </tr>
            <tr>
              <td>
                `DD`
              </td>
              <td>
                01 から 31 までの 2 桁の 10 進数としての月の日。
              </td>
            </tr>
            <tr>
              <td>
                `T`
              </td>
              <td>
                時刻要素の開始を示すために *"T"* が文字列中に字義通りに現れる。
              </td>
            </tr>
            <tr>
              <td>
                `HH`
              </td>
              <td>
                深夜から経過した完全な時数を 00 から 24 までの 2 桁の 10 進数で表したもの。
              </td>
            </tr>
            <tr>
              <td>
                `:`
              </td>
              <td>
                *":"*（コロン）が文字列中に 2 回字義通りに現れる。
              </td>
            </tr>
            <tr>
              <td>
                `mm`
              </td>
              <td>
                時の開始から経過した完全な分数を 00 から 59 までの 2 桁の 10 進数で表したもの。
              </td>
            </tr>
            <tr>
              <td>
                `ss`
              </td>
              <td>
                分の開始から経過した完全な秒数を 00 から 59 までの 2 桁の 10 進数で表したもの。
              </td>
            </tr>
            <tr>
              <td>
                `.`
              </td>
              <td>
                *"."*（ドット）が文字列中に字義通りに現れる。
              </td>
            </tr>
            <tr>
              <td>
                `sss`
              </td>
              <td>
                秒の開始から経過した完全なミリ秒数を 3 桁の 10 進数で表したもの。
              </td>
            </tr>
            <tr>
              <td>
                `Z`
              </td>
              <td>
                UTC オフセット表現。*"Z"*（UTC でオフセットなし）または *"+"* もしくは *"-"* に続く時刻表現 `HH:mm`（<emu-xref href="#sec-time-zone-offset-strings">タイムゾーンオフセット文字列形式</emu-xref> の部分集合で、UTC より進んでいる/遅れているローカル時刻を示す）
              </td>
            </tr>
          </table>
        </figure>
        <p>この形式には日付のみの形式も含まれる:</p>
        <pre>
YYYY
YYYY-MM
YYYY-MM-DD
        </pre>
        <p>また、上記の日付のみの形式に続けて以下のいずれかの時刻形式（オプションの UTC オフセット表現付き）を直後に置いた “日時 (date-time)” 形式も含まれる:</p>
        <pre>
THH:mm
THH:mm:ss
THH:mm:ss.sss
        </pre>
        <p>範囲外または不適合な要素を含む文字列はこの形式の有効なインスタンスではない。</p>
        <emu-note>
          <p>各日が深夜で始まり終わるため、2 つの深夜を区別するために `00:00` と `24:00` の 2 つの表記が利用可能である。これは `1995-02-04T24:00` と `1995-02-05T00:00` の 2 つの表記が正確に同一の時点を指すことを意味する。この後者形式を「暦日終端」と解釈することは ISO 8601 と整合している（同仕様では時間間隔の記述に予約され、単一時点の表現には許容されないが）。</p>
        </emu-note>
        <emu-note>
          <p>CET や EST などの市民タイムゾーン略称を規定する国際標準は存在せず、同じ略称が別の非常に異なるタイムゾーンに使われることもある。このため ISO 8601 と本形式はいずれもタイムゾーンオフセットの数値表現を規定する。</p>
        </emu-note>

        <emu-clause id="sec-expanded-years" oldids="sec-extended-years">
          <h1>拡張年 (Expanded Years)</h1>
          <p>1 January 1970（<emu-xref href="#sec-time-values-and-time-range"></emu-xref>）から約 273,790 年前後の時間値範囲全体をカバーするには 0 より前または 9999 より後の年を表現する必要がある。ISO 8601 は年表現の拡張を許容するが、情報交換の当事者間の合意が必要である。単純化された ECMAScript 形式では、そのような拡張年表現は 6 桁であり、常に + または - の符号を前置する。年 0 は正とみなされ + 符号を前置しなければならない。年 0 を -000000 と表すことは無効である。拡張年が時間値の範囲外の時点を表す <emu-xref href="#sec-date-time-string-format">日時文字列形式</emu-xref> にマッチする文字列は <emu-xref href="#sec-date.parse">`Date.parse`</emu-xref> によって認識不能として扱われ、実装依存の挙動やヒューリスティクスにフォールバックせず *NaN* を返す。</p>
          <emu-note>
            <p>拡張年を用いた日時（<emu-not-ref>time values</emu-not-ref>）の例:</p>
            <figure>
              <table class="lightweight-table">
                <tr>
                  <td>-271821-04-20T00:00:00Z</td>
                  <td>271822 B.C.</td>
                </tr>
                <tr>
                  <td>-000001-01-01T00:00:00Z</td>
                  <td>2 B.C.</td>
                </tr>
                <tr>
                  <td>+000000-01-01T00:00:00Z</td>
                  <td>1 B.C.</td>
                </tr>
                <tr>
                  <td>+000001-01-01T00:00:00Z</td>
                  <td>1 A.D.</td>
                </tr>
                <tr>
                  <td>+001970-01-01T00:00:00Z</td>
                  <td>1970 A.D.</td>
                </tr>
                <tr>
                  <td>+002009-12-15T00:00:00Z</td>
                  <td>2009 A.D.</td>
                </tr>
                <tr>
                  <td>+275760-09-13T00:00:00Z</td>
                  <td>275760 A.D.</td>
                </tr>
              </table>
            </figure>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-time-zone-offset-strings">
        <h1>タイムゾーンオフセット文字列形式</h1>

        <p>
          ECMAScript は ISO 8601 に由来する UTC オフセットの文字列交換形式を定義する。
          形式は以下の文法で記述される。
        </p>

        <h2>構文</h2>
        <emu-grammar type="definition">
          UTCOffset :::
            ASCIISign Hour
            ASCIISign Hour HourSubcomponents[+Extended]
            ASCIISign Hour HourSubcomponents[~Extended]

          ASCIISign ::: one of
            `+` `-`

          Hour :::
            `0` DecimalDigit
            `1` DecimalDigit
            `20`
            `21`
            `22`
            `23`

          HourSubcomponents[Extended] :::
            TimeSeparator[?Extended] MinuteSecond
            TimeSeparator[?Extended] MinuteSecond TimeSeparator[?Extended] MinuteSecond TemporalDecimalFraction?

          TimeSeparator[Extended] :::
            [+Extended] `:`
            [~Extended] [empty]

          MinuteSecond :::
            `0` DecimalDigit
            `1` DecimalDigit
            `2` DecimalDigit
            `3` DecimalDigit
            `4` DecimalDigit
            `5` DecimalDigit

          TemporalDecimalFraction :::
            TemporalDecimalSeparator DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

          TemporalDecimalSeparator ::: one of
            `.` `,`
        </emu-grammar>

        <emu-clause id="sec-istimezoneoffsetstring" type="abstract operation">
          <h1>
            IsTimeZoneOffsetString (
              _offsetString_: String,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>戻り値は _offsetString_ が |UTCOffset| の文法に適合するかどうかを示す。</dd>
          </dl>
          <emu-alg>
            1. _parseResult_ を ParseText(_offsetString_, |UTCOffset|) とする。
            1. _parseResult_ がエラーの List なら *false* を返す。
            1. *true* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parsetimezoneoffsetstring" type="abstract operation">
          <h1>
            ParseTimeZoneOffsetString (
              _offsetString_: String,
            ): 整数
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>戻り値は _offsetString_ に対応する UTC オフセット（ナノ秒数）である。</dd>
          </dl>
          <emu-alg>
            1. _parseResult_ を ParseText(_offsetString_, |UTCOffset|) とする。
            1. 事前条件: _parseResult_ はエラーの List ではない。
            1. 事前条件: _parseResult_ は |ASCIISign| の構文ノードを含む。
            1. _parsedSign_ を _parseResult_ に含まれる |ASCIISign| 構文ノードがマッチしたソーステキストとする。
            1. _parsedSign_ が単一コードポイント U+002D (HYPHEN-MINUS) なら
              1. _sign_ を -1 とする。
            1. そうでなければ
              1. _sign_ を 1 とする。
            1. 注: 以下の StringToNumber の適用は、各解析値が十分に短い 10 進数字列であることが保証されるため精度を失わない。
            1. 事前条件: _parseResult_ は |Hour| 構文ノードを含む。
            1. _parsedHours_ を _parseResult_ に含まれる |Hour| 構文ノードがマッチしたソーステキストとする。
            1. _hours_ を ℝ(StringToNumber(CodePointsToString(_parsedHours_))) とする。
            1. _parseResult_ が |MinuteSecond| 構文ノードを含まないなら
              1. _minutes_ を 0 とする。
            1. そうでなければ
              1. _parsedMinutes_ を _parseResult_ に含まれる最初の |MinuteSecond| 構文ノードがマッチしたソーステキストとする。
              1. _minutes_ を ℝ(StringToNumber(CodePointsToString(_parsedMinutes_))) とする。
            1. _parseResult_ が 2 つの |MinuteSecond| 構文ノードを含まないなら
              1. _seconds_ を 0 とする。
            1. そうでなければ
              1. _parsedSeconds_ を _parseResult_ に含まれる 2 番目の |MinuteSecond| 構文ノードがマッチしたソーステキストとする。
              1. _seconds_ を ℝ(StringToNumber(CodePointsToString(_parsedSeconds_))) とする。
            1. _parseResult_ が |TemporalDecimalFraction| 構文ノードを含まないなら
              1. _nanoseconds_ を 0 とする。
            1. そうでなければ
              1. _parsedFraction_ を _parseResult_ に含まれる |TemporalDecimalFraction| 構文ノードがマッチしたソーステキストとする。
              1. _fraction_ を CodePointsToString(_parsedFraction_) と *"000000000"* の文字列連結とする。
              1. _nanosecondsString_ を _fraction_ の先頭から 10 文字の部分文字列とする。
              1. _nanoseconds_ を ℝ(StringToNumber(_nanosecondsString_)) とする。
            1. _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-date-constructor" oldids="this-time-value,sec-thistimevalue,thistimevalue,this-Date-object">
      <h1>Date コンストラクター</h1>
      <p>Date コンストラクター:</p>
      <ul>
        <li><dfn>%Date%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Date"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼び出されたとき、新しい Date を作成し初期化する。</li>
        <li>コンストラクターではなく関数として呼び出された場合、現在の時刻（UTC）を表す文字列を返す。</li>
        <li>引数の数や型によって動作が異なる関数である。</li>
        <li>クラス定義の `extends` 節の値として利用できる。指定された Date の動作を継承したいサブクラスのコンストラクターは、サブクラスインスタンスを [[DateValue]] 内部スロット付きで生成・初期化するために Date コンストラクターへの `super` 呼び出しを含める必要がある。</li>
      </ul>

      <emu-clause id="sec-date" oldids="sec-date-constructor-date,sec-date-value,sec-date-year-month-date-hours-minutes-seconds-ms">
        <h1>Date ( ..._values_ )</h1>
        <p>この関数は呼び出されたとき、以下の手順を実行する:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら
            1. _now_ を現在時刻（UTC）を示す時刻値とする。
            1. ToDateString(_now_) を返す。
          1. _numberOfArgs_ を _values_ の要素数とする。
          1. _numberOfArgs_ = 0 の場合
            1. _dv_ を現在時刻（UTC）を示す時刻値とする。
          1. _numberOfArgs_ = 1 の場合
            1. _value_ を _values_[0] とする。
            1. _value_ がオブジェクトで [[DateValue]] 内部スロットを持つなら
              1. _tv_ を _value_.[[DateValue]] とする。
            1. それ以外の場合
              1. _v_ を ? ToPrimitive(_value_) とする。
              1. _v_ が文字列ならば
                1. アサート: 次のステップで突然の完了になることはない（_v_ は文字列）。
                1. _tv_ を `parse` メソッド (<emu-xref href="#sec-date.parse"></emu-xref>) と全く同じ方法で _v_ を日付としてパースした結果とする。
              1. それ以外の場合
                1. _tv_ を ? ToNumber(_v_) とする。
            1. _dv_ を TimeClip(_tv_) とする。
          1. それ以外の場合
            1. アサート: _numberOfArgs_ ≥ 2。
            1. _y_ を ? ToNumber(_values_[0]) とする。
            1. _m_ を ? ToNumber(_values_[1]) とする。
            1. _numberOfArgs_ > 2 なら _dt_ を ? ToNumber(_values_[2]); そうでなければ _dt_ を *1*<sub>𝔽</sub> とする。
            1. _numberOfArgs_ > 3 なら _h_ を ? ToNumber(_values_[3]); そうでなければ _h_ を *+0*<sub>𝔽</sub> とする。
            1. _numberOfArgs_ > 4 なら _min_ を ? ToNumber(_values_[4]); そうでなければ _min_ を *+0*<sub>𝔽</sub> とする。
            1. _numberOfArgs_ > 5 なら _s_ を ? ToNumber(_values_[5]); そうでなければ _s_ を *+0*<sub>𝔽</sub> とする。
            1. _numberOfArgs_ > 6 なら _milli_ を ? ToNumber(_values_[6]); そうでなければ _milli_ を *+0*<sub>𝔽</sub> とする。
            1. _yr_ を MakeFullYear(_y_) とする。
            1. _finalDate_ を MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)) とする。
            1. _dv_ を TimeClip(UTC(_finalDate_)) とする。
          1. _O_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%Date.prototype%"*, « [[DateValue]] ») とする。
          1. _O_.[[DateValue]] に _dv_ を設定する。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-constructor">
      <h1>Date コンストラクターのプロパティ</h1>
      <p>Date コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値は %Function.prototype% である。</li>
        <li>*"length"* プロパティの値は *7*<sub>𝔽</sub> である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-date.now">
        <h1>Date.now ( )</h1>
        <p>この関数は、呼び出し時点の UTC 日付と時刻を示す時刻値を返す。</p>
      </emu-clause>

      <emu-clause id="sec-date.parse">
        <h1>Date.parse ( _string_ )</h1>
        <p>この関数は引数に ToString 演算子を適用する。ToString の結果が突然の完了となった場合、その完了レコードを直ちに返す。それ以外の場合、この関数は得られた文字列を日付と時刻として解釈し、その日付と時刻に対応する UTC 時刻値（数値）を返す。文字列は内容に応じてローカル時刻、UTC、その他のタイムゾーンとして解釈されることがある。関数はまず Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>) および拡張年の形式に従ってパースを試みる。文字列がその形式に合致しない場合、実装依存のヒューリスティックや日付形式にフォールバックすることがある。判別できない、または範囲外の値を含む文字列は *NaN* を返す。</p>
        <p>文字列が <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> に適合する場合、代替値が欠落した書式要素の代わりに用いられる。`MM` や `DD` 要素が欠落している場合は *"01"*、`HH`, `mm`, `ss` 要素が欠落している場合は *"00"*、`sss` 要素がない場合は *"000"*、UTC オフセット表現がない場合は日付のみの形式は UTC として、日付時刻形式はローカル時刻として解釈される。</p>
        <p>ECMAScript の特定の実装において、任意の Date のミリ秒部分がゼロの場合、以下すべての式はその実装で同じ数値を生成するはずである（すべての参照プロパティが初期値ならば）:</p>
        <pre><code class="javascript">
          x.valueOf()
          Date.parse(x.toString())
          Date.parse(x.toUTCString())
          Date.parse(x.toISOString())
        </code></pre>
        <p>ただし、次の式</p>
        <pre><code class="javascript">
          Date.parse(x.toLocaleString())
        </code></pre>
        <p>は前の3つの式と同じ数値を生成することは要求されず、一般にこの関数が Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>) に適合せず、その実装で `toString` や `toUTCString` メソッドによって生成できない任意の文字列を与えたときの値は実装依存である。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype">
        <h1>Date.prototype</h1>
        <p>`Date.prototype` の初期値は Date プロトタイプオブジェクトである。</p>
        <p>このプロパティの属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } である。</p>
      </emu-clause>

      <emu-clause id="sec-date.utc">
        <h1>Date.UTC ( _year_ [ , _month_ [ , _date_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _ms_ ] ] ] ] ] ] )</h1>
        <p>この関数は呼び出されたとき、以下の手順を実行する:</p>
        <emu-alg>
          1. _y_ を ? ToNumber(_year_) とする。
          1. _month_ が与えられていれば _m_ を ? ToNumber(_month_) とし、なければ _m_ を *+0*<sub>𝔽</sub> とする。
          1. _date_ が与えられていれば _dt_ を ? ToNumber(_date_) とし、なければ _dt_ を *1*<sub>𝔽</sub> とする。
          1. _hours_ が与えられていれば _h_ を ? ToNumber(_hours_) とし、なければ _h_ を *+0*<sub>𝔽</sub> とする。
          1. _minutes_ が与えられていれば _min_ を ? ToNumber(_minutes_) とし、なければ _min_ を *+0*<sub>𝔽</sub> とする。
          1. _seconds_ が与えられていれば _s_ を ? ToNumber(_seconds_) とし、なければ _s_ を *+0*<sub>𝔽</sub> とする。
          1. _ms_ が与えられていれば _milli_ を ? ToNumber(_ms_) とし、なければ _milli_ を *+0*<sub>𝔽</sub> とする。
          1. _yr_ を MakeFullYear(_y_) とする。
          1. TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))) を返す。
        </emu-alg>
        <p>この関数の *"length"* プロパティは *7*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>この関数は Date コンストラクターと2つの点で異なる。数値として時刻値を返し、引数をローカル時刻ではなく UTC として解釈する。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-prototype-object">
      <h1>Date プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Date プロトタイプオブジェクト</dfn>は:</p>
      <ul>
        <li><dfn>%Date.prototype%</dfn> である。</li>
        <li>それ自体が通常のオブジェクトである。</li>
        <li>Date インスタンスではなく [[DateValue]] 内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      </ul>
      <p>特別に定義されていない限り、以下で定義される Date プロトタイプオブジェクトのメソッドはジェネリックではなく、*this* に渡される値は初期化済みの [[DateValue]] 内部スロットを持つオブジェクトでなければならない。</p>

      <emu-clause id="sec-date.prototype.constructor">
        <h1>Date.prototype.constructor</h1>
        <p>`Date.prototype.constructor` の初期値は %Date% である。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getdate">
        <h1>Date.prototype.getDate ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. DateFromTime(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getday">
        <h1>Date.prototype.getDay ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. WeekDay(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getfullyear">
        <h1>Date.prototype.getFullYear ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. YearFromTime(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gethours">
        <h1>Date.prototype.getHours ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. HourFromTime(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmilliseconds">
        <h1>Date.prototype.getMilliseconds ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. msFromTime(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getminutes">
        <h1>Date.prototype.getMinutes ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. MinFromTime(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmonth">
        <h1>Date.prototype.getMonth ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. MonthFromTime(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getseconds">
        <h1>Date.prototype.getSeconds ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. SecFromTime(LocalTime(_t_)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettime">
        <h1>Date.prototype.getTime ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _dateObject_.[[DateValue]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettimezoneoffset">
        <h1>Date.prototype.getTimezoneOffset ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. (_t_ - LocalTime(_t_)) / msPerMinute を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcdate">
        <h1>Date.prototype.getUTCDate ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. DateFromTime(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcday">
        <h1>Date.prototype.getUTCDay ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. WeekDay(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcfullyear">
        <h1>Date.prototype.getUTCFullYear ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. YearFromTime(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutchours">
        <h1>Date.prototype.getUTCHours ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. HourFromTime(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmilliseconds">
        <h1>Date.prototype.getUTCMilliseconds ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. msFromTime(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcminutes">
        <h1>Date.prototype.getUTCMinutes ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. MinFromTime(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmonth">
        <h1>Date.prototype.getUTCMonth ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. MonthFromTime(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcseconds">
        <h1>Date.prototype.getUTCSeconds ( )</h1>
        <p>このメソッドは呼び出されると、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. SecFromTime(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setdate">
        <h1>Date.prototype.setDate ( _date_ )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _dt_ を ? ToNumber(_date_) とする。
          1. _t_ が *NaN* なら、*NaN* を返す。
          1. _t_ を LocalTime(_t_) に設定する。
          1. _newDate_ を MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)) とする。
          1. _u_ を TimeClip(UTC(_newDate_)) とする。
          1. _dateObject_.[[DateValue]] に _u_ を設定する。
          1. _u_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setfullyear">
        <h1>Date.prototype.setFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _y_ を ? ToNumber(_year_) とする。
          1. _t_ が *NaN* なら _t_ を *+0*<sub>𝔽</sub> に設定し、そうでなければ LocalTime(_t_) に設定する。
          1. _month_ が存在しない場合、_m_ を MonthFromTime(_t_) とし、そうでなければ ? ToNumber(_month_) とする。
          1. _date_ が存在しない場合、_dt_ を DateFromTime(_t_) とし、そうでなければ ? ToNumber(_date_) とする。
          1. _newDate_ を MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)) とする。
          1. _u_ を TimeClip(UTC(_newDate_)) とする。
          1. _dateObject_.[[DateValue]] に _u_ を設定する。
          1. _u_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *3*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_month_ が存在しない場合、このメソッドは `getMonth()` の値が指定されたかのように振る舞う。_date_ が存在しない場合は `getDate()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.sethours">
        <h1>Date.prototype.setHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _h_ を ? ToNumber(_hour_) とする。
          1. _min_ が存在するなら _m_ を ? ToNumber(_min_) とする。
          1. _sec_ が存在するなら _s_ を ? ToNumber(_sec_) とする。
          1. _ms_ が存在するなら _milli_ を ? ToNumber(_ms_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _t_ を LocalTime(_t_) に設定する。
          1. _min_ が存在しない場合、_m_ を MinFromTime(_t_) とする。
          1. _sec_ が存在しない場合、_s_ を SecFromTime(_t_) とする。
          1. _ms_ が存在しない場合、_milli_ を msFromTime(_t_) とする。
          1. _date_ を MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)) とする。
          1. _u_ を TimeClip(UTC(_date_)) とする。
          1. _dateObject_.[[DateValue]] に _u_ を設定する。
          1. _u_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *4*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_min_ が存在しない場合、このメソッドは `getMinutes()` の値が指定されたかのように振る舞う。_sec_ が存在しない場合は `getSeconds()` の値が指定されたかのように振る舞う。_ms_ が存在しない場合は `getMilliseconds()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmilliseconds">
        <h1>Date.prototype.setMilliseconds ( _ms_ )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _ms_ を ? ToNumber(_ms_) に設定する。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _t_ を LocalTime(_t_) に設定する。
          1. _time_ を MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_) とする。
          1. _u_ を TimeClip(UTC(MakeDate(Day(_t_), _time_))) とする。
          1. _dateObject_.[[DateValue]] に _u_ を設定する。
          1. _u_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setminutes">
        <h1>Date.prototype.setMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _m_ を ? ToNumber(_min_) とする。
          1. _sec_ が存在するなら _s_ を ? ToNumber(_sec_) とする。
          1. _ms_ が存在するなら _milli_ を ? ToNumber(_ms_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _t_ を LocalTime(_t_) に設定する。
          1. _sec_ が存在しない場合、_s_ を SecFromTime(_t_) とする。
          1. _ms_ が存在しない場合、_milli_ を msFromTime(_t_) とする。
          1. _date_ を MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)) とする。
          1. _u_ を TimeClip(UTC(_date_)) とする。
          1. _dateObject_.[[DateValue]] に _u_ を設定する。
          1. _u_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *3*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_sec_ が存在しない場合、このメソッドは `getSeconds()` の値が指定されたかのように振る舞う。_ms_ が存在しない場合は `getMilliseconds()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmonth">
        <h1>Date.prototype.setMonth ( _month_ [ , _date_ ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _m_ を ? ToNumber(_month_) とする。
          1. _date_ が存在するなら _dt_ を ? ToNumber(_date_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _t_ を LocalTime(_t_) に設定する。
          1. _date_ が存在しない場合、_dt_ を DateFromTime(_t_) とする。
          1. _newDate_ を MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)) とする。
          1. _u_ を TimeClip(UTC(_newDate_)) とする。
          1. _dateObject_.[[DateValue]] に _u_ を設定する。
          1. _u_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_date_ が存在しない場合、このメソッドは `getDate()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setseconds">
        <h1>Date.prototype.setSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _s_ を ? ToNumber(_sec_) とする。
          1. _ms_ が存在するなら _milli_ を ? ToNumber(_ms_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _t_ を LocalTime(_t_) に設定する。
          1. _ms_ が存在しない場合、_milli_ を msFromTime(_t_) とする。
          1. _date_ を MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)) とする。
          1. _u_ を TimeClip(UTC(_date_)) とする。
          1. _dateObject_.[[DateValue]] に _u_ を設定する。
          1. _u_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_ms_ が存在しない場合、このメソッドは `getMilliseconds()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.settime">
        <h1>Date.prototype.setTime ( _time_ )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を ? ToNumber(_time_) とする。
          1. _v_ を TimeClip(_t_) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcdate">
        <h1>Date.prototype.setUTCDate ( _date_ )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _dt_ を ? ToNumber(_date_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _newDate_ を MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)) とする。
          1. _v_ を TimeClip(_newDate_) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcfullyear">
        <h1>Date.prototype.setUTCFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _t_ が *NaN* なら _t_ を *+0*<sub>𝔽</sub> に設定する。
          1. _y_ を ? ToNumber(_year_) とする。
          1. _month_ が存在しない場合、_m_ を MonthFromTime(_t_) とし、そうでなければ ? ToNumber(_month_) とする。
          1. _date_ が存在しない場合、_dt_ を DateFromTime(_t_) とし、そうでなければ ? ToNumber(_date_) とする。
          1. _newDate_ を MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)) とする。
          1. _v_ を TimeClip(_newDate_) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *3*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_month_ が存在しない場合、このメソッドは `getUTCMonth()` の値が指定されたかのように振る舞う。_date_ が存在しない場合は `getUTCDate()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutchours">
        <h1>Date.prototype.setUTCHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _h_ を ? ToNumber(_hour_) とする。
          1. _min_ が存在するなら _m_ を ? ToNumber(_min_) とする。
          1. _sec_ が存在するなら _s_ を ? ToNumber(_sec_) とする。
          1. _ms_ が存在するなら _milli_ を ? ToNumber(_ms_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _min_ が存在しない場合、_m_ を MinFromTime(_t_) とする。
          1. _sec_ が存在しない場合、_s_ を SecFromTime(_t_) とする。
          1. _ms_ が存在しない場合、_milli_ を msFromTime(_t_) とする。
          1. _date_ を MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)) とする。
          1. _v_ を TimeClip(_date_) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *4*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_min_ が存在しない場合、このメソッドは `getUTCMinutes()` の値が指定されたかのように振る舞う。_sec_ が存在しない場合は `getUTCSeconds()` の値が指定されたかのように振る舞う。_ms_ が存在しない場合は `getUTCMilliseconds()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmilliseconds">
        <h1>Date.prototype.setUTCMilliseconds ( _ms_ )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _ms_ を ? ToNumber(_ms_) に設定する。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _time_ を MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_) とする。
          1. _v_ を TimeClip(MakeDate(Day(_t_), _time_)) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcminutes">
        <h1>Date.prototype.setUTCMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _m_ を ? ToNumber(_min_) とする。
          1. _sec_ が存在するなら _s_ を ? ToNumber(_sec_) とする。
          1. _ms_ が存在するなら _milli_ を ? ToNumber(_ms_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _sec_ が存在しない場合、_s_ を SecFromTime(_t_) とする。
          1. _ms_ が存在しない場合、_milli_ を msFromTime(_t_) とする。
          1. _date_ を MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)) とする。
          1. _v_ を TimeClip(_date_) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *3*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_sec_ が存在しない場合、このメソッドは `getUTCSeconds()` の値が指定されたかのように振る舞う。_ms_ が存在しない場合は `getUTCMilliseconds()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmonth">
        <h1>Date.prototype.setUTCMonth ( _month_ [ , _date_ ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _m_ を ? ToNumber(_month_) とする。
          1. _date_ が存在するなら _dt_ を ? ToNumber(_date_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _date_ が存在しない場合、_dt_ を DateFromTime(_t_) とする。
          1. _newDate_ を MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)) とする。
          1. _v_ を TimeClip(_newDate_) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_date_ が存在しない場合、このメソッドは `getUTCDate()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcseconds">
        <h1>Date.prototype.setUTCSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _s_ を ? ToNumber(_sec_) とする。
          1. _ms_ が存在するなら _milli_ を ? ToNumber(_ms_) とする。
          1. _t_ が *NaN* なら *NaN* を返す。
          1. _ms_ が存在しない場合、_milli_ を msFromTime(_t_) とする。
          1. _date_ を MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)) とする。
          1. _v_ を TimeClip(_date_) とする。
          1. _dateObject_.[[DateValue]] に _v_ を設定する。
          1. _v_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>_ms_ が存在しない場合、このメソッドは `getUTCMilliseconds()` の値が指定されたかのように振る舞う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.todatestring">
        <h1>Date.prototype.toDateString ( )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _tv_ を _dateObject_.[[DateValue]] とする。
          1. _tv_ が *NaN* なら *"Invalid Date"* を返す。
          1. _t_ を LocalTime(_tv_) とする。
          1. DateString(_t_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toisostring">
        <h1>Date.prototype.toISOString ( )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _tv_ を _dateObject_.[[DateValue]] とする。
          1. _tv_ が *NaN* なら *RangeError* 例外をスローする。
          1. アサート: _tv_ は整数値である。
          1. _tv_ が <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> で表現できない年に該当するなら *RangeError* 例外をスローする。
          1. _tv_ の <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> に従ったUTC時刻表現（全ての書式要素およびUTCオフセット "Z" を含む）を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tojson">
        <h1>Date.prototype.toJSON ( _key_ )</h1>
        <p>このメソッドは `JSON.stringify` (<emu-xref href="#sec-json.stringify"></emu-xref>) で利用するための Date の文字列表現を提供する。</p>
        <p>呼び出されると以下の手順を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* の値) とする。
          1. _tv_ を ? ToPrimitive(_O_, ~number~) とする。
          1. _tv_ が数値かつ有限でなければ *null* を返す。
          1. ? Invoke(_O_, *"toISOString"*) を返す。
        </emu-alg>
        <emu-note>
          <p>この引数は無視される。</p>
        </emu-note>
        <emu-note>
          <p>このメソッドは意図的にジェネリックであり、*this* の値が Date であることを要求しない。そのため他のオブジェクトに転送してメソッドとして利用できる。ただしその場合、`toISOString` メソッドが必要である。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaledatestring">
        <h1>Date.prototype.toLocaleDateString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 Internationalization API を含む ECMAScript 実装はこのメソッドを ECMA-402 仕様に従って実装しなければならない。ECMA-402 API を含まない実装の場合、以下の仕様が用いられる:</p>
        <p>このメソッドは文字列値を返す。その内容は実装定義だが、現在のタイムゾーンにおける Date の「日付」部分をホスト環境の現在のロケールの慣習に従った便利で人間に読みやすい形で表現することを意図している。</p>
        <p>このメソッドのオプションパラメータの意味は ECMA-402 仕様で定義されている。ECMA-402 を含まない実装ではこれらのパラメータ位置を他の用途に使ってはならない。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocalestring">
        <h1>Date.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 Internationalization API を含む ECMAScript 実装はこのメソッドを ECMA-402 仕様に従って実装しなければならない。ECMA-402 API を含まない実装の場合、以下の仕様が用いられる:</p>
        <p>このメソッドは文字列値を返す。その内容は実装定義だが、現在のタイムゾーンにおける Date をホスト環境の現在のロケールの慣習に従った便利で人間に読みやすい形で表現することを意図している。</p>
        <p>このメソッドのオプションパラメータの意味は ECMA-402 仕様で定義されている。ECMA-402 を含まない実装ではこれらのパラメータ位置を他の用途に使ってはならない。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaletimestring">
        <h1>Date.prototype.toLocaleTimeString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 Internationalization API を含む ECMAScript 実装はこのメソッドを ECMA-402 仕様に従って実装しなければならない。ECMA-402 API を含まない実装の場合、以下の仕様が用いられる:</p>
        <p>このメソッドは文字列値を返す。その内容は実装定義だが、現在のタイムゾーンにおける Date の「時刻」部分をホスト環境の現在のロケールの慣習に従った便利で人間に読みやすい形で表現することを意図している。</p>
        <p>このメソッドのオプションパラメータの意味は ECMA-402 仕様で定義されている。ECMA-402 を含まない実装ではこれらのパラメータ位置を他の用途に使ってはならない。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tostring">
        <h1>Date.prototype.toString ( )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _tv_ を _dateObject_.[[DateValue]] とする。
          1. ToDateString(_tv_) を返す。
        </emu-alg>
        <emu-note>
          <p>`d.[[DateValue]]` が 1000 で割り切れる任意の Date `d` について、`Date.parse(d.toString())` の結果は `d.valueOf()` と等しい。<emu-xref href="#sec-date.parse"></emu-xref> を参照。</p>
        </emu-note>
        <emu-note>
          <p>このメソッドはジェネリックではなく、*this* の値が Date でない場合は *TypeError* 例外をスローする。そのため他のオブジェクトに転送してメソッドとして利用することはできない。</p>
        </emu-note>

        <emu-clause id="sec-timestring" type="abstract operation">
          <h1>
            TimeString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _hour_ を ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2) とする。
            1. _minute_ を ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2) とする。
            1. _second_ を ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2) とする。
            1. _hour_, *":"*, _minute_, *":"*, _second_, コードユニット 0x0020 (スペース), *"GMT"* を連結した文字列を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-datestring" type="abstract operation">
          <h1>
            DateString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _weekday_ を <emu-xref href="#sec-todatestring-day-names"></emu-xref> の WeekDay(_tv_) の番号に対応する名前とする。
            1. _month_ を <emu-xref href="#sec-todatestring-month-names"></emu-xref> の MonthFromTime(_tv_) の番号に対応する名前とする。
            1. _day_ を ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2) とする。
            1. _yv_ を YearFromTime(_tv_) とする。
            1. _yv_ が *+0*<sub>𝔽</sub> または _yv_ > *+0*<sub>𝔽</sub> なら _yearSign_ を空文字列に、そうでなければ *"-"* にする。
            1. _paddedYear_ を ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4) とする。
            1. _weekday_, コードユニット 0x0020 (スペース), _month_, コードユニット 0x0020 (スペース), _day_, コードユニット 0x0020 (スペース), _yearSign_, _paddedYear_ を連結した文字列を返す。
          </emu-alg>
          <emu-table id="sec-todatestring-day-names" caption="曜日名">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sun"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mon"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Tue"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Wed"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"Thu"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Fri"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sat"*
                </td>
              </tr>
            </table>
          </emu-table>
          <emu-table id="sec-todatestring-month-names" caption="月名">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jan"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Feb"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mar"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Apr"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"May"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jun"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jul"*
                </td>
              </tr>
              <tr>
                <td>
                  *7*<sub>𝔽</sub>
                </td>
                <td>
                  *"Aug"*
                </td>
              </tr>
              <tr>
                <td>
                  *8*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sep"*
                </td>
              </tr>
              <tr>
                <td>
                  *9*<sub>𝔽</sub>
                </td>
                <td>
                  *"Oct"*
                </td>
              </tr>
              <tr>
                <td>
                  *10*<sub>𝔽</sub>
                </td>
                <td>
                  *"Nov"*
                </td>
              </tr>
              <tr>
                <td>
                  *11*<sub>𝔽</sub>
                </td>
                <td>
                  *"Dec"*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>

        <emu-clause id="sec-timezoneestring" type="abstract operation">
          <h1>
            TimeZoneString (
              _tv_: an integral Number,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _systemTimeZoneIdentifier_ を SystemTimeZoneIdentifier() とする。
            1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) が *true* なら
              1. _offsetNs_ を ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_) とする。
            1. それ以外の場合
              1. _offsetNs_ を GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>)) とする。
            1. _offset_ を 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>)) とする。
            1. _offset_ が *+0*<sub>𝔽</sub> または _offset_ > *+0*<sub>𝔽</sub> なら
              1. _offsetSign_ を *"+"* とする。
              1. _absOffset_ を _offset_ とする。
            1. それ以外の場合
              1. _offsetSign_ を *"-"* とする。
              1. _absOffset_ を -_offset_ とする。
            1. _offsetMin_ を ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2) とする。
            1. _offsetHour_ を ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2) とする。
            1. _tzName_ を空文字列またはコードユニット 0x0020 (スペース)、0x0028 (左括弧)、実装定義のタイムゾーン名、0x0029 (右括弧) を連結した文字列のいずれかとする。
            1. _offsetSign_, _offsetHour_, _offsetMin_, _tzName_ を連結した文字列を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-todatestring" type="abstract operation">
          <h1>
            ToDateString (
              _tv_: an integral Number or *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _tv_ が *NaN* なら *"Invalid Date"* を返す。
            1. _t_ を LocalTime(_tv_) とする。
            1. DateString(_t_)、コードユニット 0x0020 (スペース)、TimeString(_t_)、TimeZoneString(_tv_) を連結した文字列を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-date.prototype.totimestring">
        <h1>Date.prototype.toTimeString ( )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _tv_ を _dateObject_.[[DateValue]] とする。
          1. _tv_ が *NaN* なら *"Invalid Date"* を返す。
          1. _t_ を LocalTime(_tv_) とする。
          1. TimeString(_t_) と TimeZoneString(_tv_) を連結した文字列を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toutcstring">
        <h1>Date.prototype.toUTCString ( )</h1>
        <p>このメソッドは *this* 値に対応する時点を表す文字列値を返す。文字列の形式は RFC 7231 の "HTTP-date" をベースとし、ECMAScript Dates でサポートされる全範囲の時刻を一般化している。</p>
        <p>呼び出されると以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _tv_ を _dateObject_.[[DateValue]] とする。
          1. _tv_ が *NaN* なら *"Invalid Date"* を返す。
          1. _weekday_ を <emu-xref href="#sec-todatestring-day-names"></emu-xref> の WeekDay(_tv_) の番号に対応する名前とする。
          1. _month_ を <emu-xref href="#sec-todatestring-month-names"></emu-xref> の MonthFromTime(_tv_) の番号に対応する名前とする。
          1. _day_ を ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2) とする。
          1. _yv_ を YearFromTime(_tv_) とする。
          1. _yv_ が *+0*<sub>𝔽</sub> または _yv_ > *+0*<sub>𝔽</sub> なら _yearSign_ を空文字列に、そうでなければ *"-"* にする。
          1. _paddedYear_ を ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4) とする。
          1. _weekday_, *","*, コードユニット 0x0020 (スペース), _day_, コードユニット 0x0020 (スペース), _month_, コードユニット 0x0020 (スペース), _yearSign_, _paddedYear_, コードユニット 0x0020 (スペース), TimeString(_tv_) を連結した文字列を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.valueof">
        <h1>Date.prototype.valueOf ( )</h1>
        <p>このメソッドは呼び出された時、以下の手順を実行する:</p>
        <emu-alg>
          1. _dateObject_ を *this* の値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _dateObject_.[[DateValue]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-date.prototype-@@toprimitive" id="sec-date.prototype-%symbol.toprimitive%">
        <h1>Date.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>このメソッドは ECMAScript の演算子によって Date をプリミティブ値へ変換するために呼び出される。_hint_ の許可される値は *"default"*、*"number"*、*"string"* である。Date は組み込み ECMAScript オブジェクトの中で唯一 *"default"* を *"string"* と同等に扱う。他の組み込みオブジェクトは *"default"* を *"number"* と同等に扱う。</p>
        <p>呼び出されると以下の手順を実行する:</p>
        <emu-alg>
          1. _O_ を *this* の値とする。
          1. _O_ がオブジェクトでなければ *TypeError* 例外をスローする。
          1. _hint_ が *"string"* または *"default"* なら
            1. _tryFirst_ を ~string~ とする。
          1. それ以外で _hint_ が *"number"* なら
            1. _tryFirst_ を ~number~ とする。
          1. それ以外の場合
            1. *TypeError* 例外をスローする。
          1. ? OrdinaryToPrimitive(_O_, _tryFirst_) を返す。
        </emu-alg>
        <p>このプロパティの属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } である。</p>
        <p>このメソッドの *"name"* プロパティの値は *"[Symbol.toPrimitive]"* である。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-date-instances">
      <h1>Date インスタンスのプロパティ</h1>
      <p>Date インスタンスは Date プロトタイプオブジェクトからプロパティを継承する通常のオブジェクトである。Date インスタンスは [[DateValue]] 内部スロットも持ち、[[DateValue]] 内部スロットはこの Date が表す時刻値である。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>テキスト処理</h1>

  <emu-clause id="sec-string-objects">
    <h1>String オブジェクト</h1>

    <emu-clause id="sec-string-constructor">
      <h1>String コンストラクター</h1>
      <p>String コンストラクター:</p>
      <ul>
        <li><dfn>%String%</dfn> である。</li>
        <li>グローバルオブジェクトの *"String"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼び出されたとき、新しい String オブジェクトを生成し初期化する。</li>
        <li>コンストラクターではなく関数として呼び出されたとき、型変換を行う。</li>
        <li>クラス定義の `extends` 句の値として利用できる。指定された String の挙動を継承したいサブクラスのコンストラクターは、サブクラスインスタンスを [[StringData]] 内部スロット付きで生成・初期化するために String コンストラクターへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-string-constructor-string-value">
        <h1>String ( _value_ )</h1>
        <p>この関数は呼び出されたとき以下の手順を実行する:</p>
        <emu-alg>
          1. _value_ が存在しないなら
            1. _s_ を空文字列とする。
          1. それ以外の場合、
            1. NewTarget が *undefined* で かつ _value_ が Symbol なら、SymbolDescriptiveString(_value_) を返す。
            1. _s_ を ? ToString(_value_) とする。
          1. NewTarget が *undefined* なら _s_ を返す。
          1. StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *"%String.prototype%"*)) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-constructor">
      <h1>String コンストラクターのプロパティ</h1>
      <p>String コンストラクター:</p>
      <ul>
        <li>値 %Function.prototype% の [[Prototype]] 内部スロットを持つ。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-string.fromcharcode">
        <h1>String.fromCharCode ( ..._codeUnits_ )</h1>
        <p>この関数は残余引数 _codeUnits_ を構成する任意個の引数で呼び出すことができる。</p>
        <p>呼び出されたとき以下を行う:</p>
        <emu-alg>
          1. _result_ を空文字列とする。
          1. _codeUnits_ の各要素 _next_ について
            1. _nextCU_ を ℝ(? ToUint16(_next_)) の数値を持つコードユニットとする。
            1. _result_ を _result_ と _nextCU_ の文字列連結とする。
          1. _result_ を返す。
        </emu-alg>
        <p>この関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
      </emu-clause>

      <emu-clause id="sec-string.fromcodepoint">
        <h1>String.fromCodePoint ( ..._codePoints_ )</h1>
        <p>この関数は残余引数 _codePoints_ を構成する任意個の引数で呼び出すことができる。</p>
        <p>呼び出されたとき以下を行う:</p>
        <emu-alg>
          1. _result_ を空文字列とする。
          1. _codePoints_ の各要素 _next_ について
            1. _nextCP_ を ? ToNumber(_next_) とする。
            1. _nextCP_ が整数 Number でなければ *RangeError* 例外を投げる。
            1. ℝ(_nextCP_) &lt; 0 または ℝ(_nextCP_) > 0x10FFFF なら *RangeError* 例外を投げる。
            1. _result_ を _result_ と UTF16EncodeCodePoint(ℝ(_nextCP_)) の文字列連結とする。
          1. アサート: _codePoints_ が空なら _result_ は空文字列。
          1. _result_ を返す。
        </emu-alg>
        <p>この関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype">
        <h1>String.prototype</h1>
        <p>`String.prototype` の初期値は String プロトタイプオブジェクトである。</p>
        <p>このプロパティの属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } である。</p>
      </emu-clause>

      <emu-clause id="sec-string.raw">
        <h1>String.raw ( _template_, ..._substitutions_ )</h1>
        <p>この関数は可変個の引数で呼び出される。最初の引数が _template_、残りがリスト _substitutions_ を構成する。</p>
        <p>呼び出されたとき以下を行う:</p>
        <emu-alg>
          1. _substitutionCount_ を _substitutions_ の要素数とする。
          1. _cooked_ を ? ToObject(_template_) とする。
          1. _literals_ を ? ToObject(? Get(_cooked_, *"raw"* )) とする。
          1. _literalCount_ を ? LengthOfArrayLike(_literals_) とする。
          1. _literalCount_ ≤ 0 なら空文字列を返す。
          1. _R_ を空文字列とする。
          1. _nextIndex_ を 0 とする。
          1. 繰り返し、
            1. _nextLiteralVal_ を ? Get(_literals_, ! ToString(𝔽(_nextIndex_))) とする。
            1. _nextLiteral_ を ? ToString(_nextLiteralVal_) とする。
            1. _R_ を _R_ と _nextLiteral_ の文字列連結とする。
            1. _nextIndex_ + 1 = _literalCount_ なら _R_ を返す。
            1. _nextIndex_ &lt; _substitutionCount_ なら
              1. _nextSubVal_ を _substitutions_[_nextIndex_] とする。
              1. _nextSub_ を ? ToString(_nextSubVal_) とする。
              1. _R_ を _R_ と _nextSub_ の文字列連結とする。
            1. _nextIndex_ を _nextIndex_ + 1 とする。
        </emu-alg>
        <emu-note>
          <p>この関数はタグ付きテンプレート (<emu-xref href="#sec-tagged-templates"></emu-xref>) のタグ関数として使用することを意図している。その場合最初の引数は正しく整形されたテンプレートオブジェクトであり、残りが置換値となる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-prototype-object">
      <h1>String プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>String プロトタイプオブジェクト</dfn>は以下を満たす:</p>
      <ul>
        <li><dfn>%String.prototype%</dfn> である。</li>
        <li>String エキゾチックオブジェクトであり、そのようなオブジェクトに規定された内部メソッドを持つ。</li>
        <li>値が空文字列の [[StringData]] 内部スロットを持つ。</li>
        <li>初期値 *+0*<sub>𝔽</sub> の *"length"* プロパティを持ち、その属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } である。</li>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      </ul>
      <p>特に明記されない限り、以下で定義される String プロトタイプオブジェクトのメソッドはジェネリックではなく、渡される *this* 値は String 値か、String 値に初期化された [[StringData]] 内部スロットを持つオブジェクトでなければならない。</p>

      <emu-clause id="sec-string.prototype.at">
        <h1>String.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. _O_ を *this* の値とする。
          1. ? RequireObjectCoercible(_O_) を実行する。
          1. _S_ を ? ToString(_O_) とする。
          1. _len_ を _S_ の長さとする。
          1. _relativeIndex_ を ? ToIntegerOrInfinity(_index_) とする。
          1. _relativeIndex_ ≥ 0 なら
            1. _k_ を _relativeIndex_ とする。
          1. それ以外なら
            1. _k_ を _len_ + _relativeIndex_ とする。
          1. _k_ &lt; 0 または _k_ ≥ _len_ なら *undefined* を返す。
          1. _S_ の _k_ から _k_ + 1 までの部分文字列を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charat">
        <h1>String.prototype.charAt ( _pos_ )</h1>
        <emu-note>
          <p>このメソッドは、このオブジェクトを String に変換した値のインデックス _pos_ にあるコードユニットを含む 1 文字の String を返す。その位置に要素がなければ結果は空文字列となる。結果は String オブジェクトではなく String 値である。</p>
          <p>`pos` が整数 Number なら `x.charAt(pos)` の結果は `x.substring(pos, pos + 1)` の結果と等価である。</p>
        </emu-note>
        <p>呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* の値とする。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_) とする。
          1. _position_ を ? ToIntegerOrInfinity(_pos_) とする。
          1. _size_ を _S_ の長さとする。
          1. _position_ &lt; 0 または _position_ ≥ _size_ なら空文字列を返す。
          1. _S_ の _position_ から _position_ + 1 までの部分文字列を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的にジェネリックであり、*this* が String オブジェクトであることを要求しない。そのため他のオブジェクトへ転用できる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charcodeat">
        <h1>String.prototype.charCodeAt ( _pos_ )</h1>
        <emu-note>
          <p>このメソッドは、このオブジェクトを String に変換した結果内のインデックス _pos_ のコードユニットの数値 (0 以上 2<sup>16</sup> 未満の整数 Number) を返す。その位置に要素がなければ *NaN* を返す。</p>
        </emu-note>
        <p>呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* の値とする。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_) とする。
          1. _position_ を ? ToIntegerOrInfinity(_pos_) とする。
          1. _size_ を _S_ の長さとする。
          1. _position_ &lt; 0 または _position_ ≥ _size_ なら *NaN* を返す。
          1. _S_ のインデックス _position_ のコードユニットの数値を表す Number を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的にジェネリックであり、*this* が String オブジェクトであることを要求しない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.codepointat">
        <h1>String.prototype.codePointAt ( _pos_ )</h1>
        <emu-note>
          <p>このメソッドは *0x10FFFF*<sub>𝔽</sub> 以下の非負整数 Number を返し、これはこのオブジェクトを String に変換した結果のインデックス _pos_ で始まる UTF-16 エンコードされたコードポイント (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) の数値である。その位置に要素がなければ *undefined* を返す。_pos_ で有効なサロゲートペアが開始しなければ、その位置のコードユニットを返す。</p>
        </emu-note>
        <p>呼び出し時の手順:</p>
        <emu-alg>
          1. _O_ を *this* の値とする。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_) とする。
          1. _position_ を ? ToIntegerOrInfinity(_pos_) とする。
          1. _size_ を _S_ の長さとする。
          1. _position_ &lt; 0 または _position_ ≥ _size_ なら *undefined* を返す。
          1. _cp_ を CodePointAt(_S_, _position_) とする。
          1. 𝔽(_cp_.[[CodePoint]]) を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドはジェネリックであり他オブジェクトに転用可能。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.concat">
        <h1>String.prototype.concat ( ..._args_ )</h1>
        <emu-note>
          <p>このメソッドは *this* の値 (String に変換) のコードユニットに、各引数を String に変換した結果のコードユニットを順に連結した String 値を返す。結果は String オブジェクトではなく String 値。</p>
        </emu-note>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this* の値とする。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_) とする。
          1. _R_ を _S_ とする。
          1. _args_ の各要素 _next_ について
            1. _nextString_ を ? ToString(_next_) とする。
            1. _R_ を _R_ と _nextString_ の文字列連結とする。
          1. _R_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* は *1*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>ジェネリックであり他オブジェクトに転用可能。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.constructor">
        <h1>String.prototype.constructor</h1>
        <p>`String.prototype.constructor` の初期値は %String% である。</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype.endswith">
        <h1>String.prototype.endsWith ( _searchString_ [ , _endPosition_ ] )</h1>
        <p>呼び出し時の手順:</p>
        <emu-alg>
          1. _O_ を *this* の値とする。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_) とする。
          1. _isRegExp_ を ? IsRegExp(_searchString_) とする。
          1. _isRegExp_ が *true* なら *TypeError* を投げる。
          1. _searchStr_ を ? ToString(_searchString_) とする。
          1. _len_ を _S_ の長さとする。
          1. _endPosition_ が *undefined* なら _pos_ を _len_ とし、そうでなければ _pos_ を ? ToIntegerOrInfinity(_endPosition_) とする。
          1. _end_ を _pos_ を 0 と _len_ の間にクランプした結果とする。
          1. _searchLength_ を _searchStr_ の長さとする。
          1. _searchLength_ = 0 なら *true* を返す。
          1. _start_ を _end_ - _searchLength_ とする。
          1. _start_ &lt; 0 なら *false* を返す。
          1. _substring_ を _S_ の _start_ から _end_ の部分文字列とする。
          1. _substring_ が _searchStr_ なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>_endPosition_ - length(this) から始まる対応するコードユニット列が一致すれば *true*。</p>
        </emu-note>
        <emu-note>
          <p>最初の引数が RegExp の場合に例外を投げるのは将来の拡張余地のため。</p>
        </emu-note>
        <emu-note>
          <p>ジェネリックであり転用可能。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.includes">
        <h1>String.prototype.includes ( _searchString_ [ , _position_ ] )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this* の値。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _isRegExp_ を ? IsRegExp(_searchString_)。
          1. _isRegExp_ が *true* なら *TypeError*。
          1. _searchStr_ を ? ToString(_searchString_)。
          1. _pos_ を ? ToIntegerOrInfinity(_position_)。
          1. アサート: _position_ が *undefined* なら _pos_ は 0。
          1. _len_ を _S_ の長さ。
          1. _start_ を _pos_ を 0 と _len_ の間にクランプした結果。
          1. _index_ を StringIndexOf(_S_, _searchStr_, _start_)。
          1. _index_ が ~not-found~ なら *false*。
          1. *true* を返す。
        </emu-alg>
        <emu-note>
          <p>_position_ 以上の位置で _searchString_ が部分文字列として現れれば *true*。</p>
        </emu-note>
        <emu-note>
          <p>RegExp の場合例外を投げる理由は将来拡張のため。</p>
        </emu-note>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.indexof">
        <h1>String.prototype.indexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>_position_ 以上で最初に現れるインデックスを返し、存在しなければ *-1*<sub>𝔽</sub>。_position_ が *undefined* なら *+0*<sub>𝔽</sub>。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _searchStr_ を ? ToString(_searchString_)。
          1. _pos_ を ? ToIntegerOrInfinity(_position_)。
          1. アサート: _position_ が *undefined* なら _pos_ は 0。
          1. _len_ を _S_ の長さ。
          1. _start_ を _pos_ を 0 と _len_ の間にクランプした結果。
          1. _result_ を StringIndexOf(_S_, _searchStr_, _start_)。
          1. _result_ が ~not-found~ なら *-1*<sub>𝔽</sub> を返す。
          1. 𝔽(_result_) を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.iswellformed">
        <h1>String.prototype.isWellFormed ( )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. IsStringWellFormedUnicode(_S_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.lastindexof">
        <h1>String.prototype.lastIndexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>_position_ 以下で最後に現れるインデックスを返し、存在しなければ *-1*<sub>𝔽</sub>。_position_ が *undefined* なら文字列長を仮定。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _searchStr_ を ? ToString(_searchString_)。
          1. _numPos_ を ? ToNumber(_position_)。
          1. アサート: _position_ が *undefined* なら _numPos_ は *NaN*。
          1. _numPos_ が *NaN* なら _pos_ を +∞ とし、そうでなければ _pos_ を ! ToIntegerOrInfinity(_numPos_)。
          1. _len_ を _S_ の長さ。
          1. _searchLen_ を _searchStr_ の長さ。
          1. _start_ を _pos_ を 0 と _len_ - _searchLen_ の間にクランプ。
          1. _result_ を StringLastIndexOf(_S_, _searchStr_, _start_)。
          1. _result_ が ~not-found~ なら *-1*<sub>𝔽</sub>。
          1. 𝔽(_result_) を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.localecompare">
        <h1>String.prototype.localeCompare ( _that_ [ , _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 国際化 API を含む実装は ECMA-402 の規定に従う。含まない実装では次を用いる:</p>
        <p>このメソッドは *this* 値 (String に変換した _S_) と _that_ (String に変換した _thatValue_) のロケール依存比較の結果を *NaN* 以外の Number で返す。結果はホスト環境の現在のロケールの慣習に従うソート順を表し、_S_ が _thatValue_ の前なら負、後なら正、その他は 0（順序なし）となる。</p>
        <p>比較の前に以下を行う:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _thatValue_ を ? ToString(_that_)。
        </emu-alg>
        <p>第2・第3引数の意味は ECMA-402 仕様に定義され、未実装の場合他用途に用いてはならない。</p>
        <p>実際の戻り値は追加情報符号化のため実装定義だが、このメソッドは全 String 上の全順序を与える一貫した比較子でなければならず、Unicode 標準の正規等価性を尊重し、正規等価な区別可能文字列の比較で *+0*<sub>𝔽</sub> を返さねばならない。</p>
        <emu-note>
          <p>2 引数関数を要求する `Array.prototype.sort` の引数に直接適切ではない。</p>
        </emu-note>
        <emu-note>
          <p>このメソッドはホスト環境の言語・ロケール機能を利用し得るが、常に Unicode の正規等価性を尊重する必要がある。以下はすべて *+0*<sub>𝔽</sub> を返さねばならない例である:</p>
          <pre><code class="javascript">
            // &#x212B; ANGSTROM SIGN vs.
            // A&#x030A; LATIN CAPITAL LETTER A + COMBINING RING ABOVE
            "\u212B".localeCompare("A\u030A")

            // &#x2126; OHM SIGN vs.
            // &#x03A9; GREEK CAPITAL LETTER OMEGA
            "\u2126".localeCompare("\u03A9")

            // &#x1E69; LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
            // s&#x0307;&#x0323; LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
            "\u1E69".localeCompare("s\u0307\u0323")

            // &#x1E0B;&#x0323; LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
            // &#x1E0D;&#x0307; LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
            "\u1E0B\u0323".localeCompare("\u1E0D\u0307")

            // &#x1100;&#x1161; HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
            // &#xAC00; HANGUL SYLLABLE GA
            "\u1100\u1161".localeCompare("\uAC00")
          </code></pre>
          <p>正規等価性の定義と議論は Unicode Standard 2章・3章、<a href="https://unicode.org/reports/tr15/">UAX #15</a>、<a href="https://unicode.org/notes/tn5/">UTN #5</a>、および <a href="https://unicode.org/reports/tr10/">UTS #10</a> を参照。</p>
          <p>Unicode 互換等価や互換分解は尊重しないことが推奨される。</p>
        </emu-note>
        <emu-note>
          <p>ジェネリックであり転用可能。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.match">
        <h1>String.prototype.match ( _regexp_ )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _regexp_ が *undefined* でも *null* でもないなら
            1. _matcher_ を ? GetMethod(_regexp_, %Symbol.match%)。
            1. _matcher_ が *undefined* でなければ
              1. ? Call(_matcher_, _regexp_, « _O_ ») を返す。
          1. _S_ を ? ToString(_O_)。
          1. _rx_ を ? RegExpCreate(_regexp_, *undefined*)。
          1. ? Invoke(_rx_, %Symbol.match%, « _S_ ») を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.matchall">
        <h1>String.prototype.matchAll ( _regexp_ )</h1>
        <p>このメソッドは *this* を表す String に対して _regexp_ で正規表現マッチを行い、マッチ結果を生成するイテレータを返す。各結果は最初の要素にマッチ全体、その後にキャプチャグループを含む配列。マッチしなければ結果を生成しない。</p>
        <p>呼び出し時:</p>

        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _regexp_ が *undefined* でも *null* でもないなら
            1. _isRegExp_ を ? IsRegExp(_regexp_)。
            1. _isRegExp_ が *true* なら
              1. _flags_ を ? Get(_regexp_, *"flags"*)。
              1. ? RequireObjectCoercible(_flags_)。
              1. ? ToString(_flags_) が *"g"* を含まなければ *TypeError*。
            1. _matcher_ を ? GetMethod(_regexp_, %Symbol.matchAll%)。
            1. _matcher_ が *undefined* でなければ
              1. ? Call(_matcher_, _regexp_, « _O_ ») を返す。
          1. _S_ を ? ToString(_O_)。
          1. _rx_ を ? RegExpCreate(_regexp_, *"g"*)。
          1. ? Invoke(_rx_, %Symbol.matchAll%, « _S_ ») を返す。
        </emu-alg>
        <emu-note>このメソッドはジェネリックで、*this* が String オブジェクトである必要はない。</emu-note>
        <emu-note>`String.prototype.split` と同様に通常入力を破壊しないよう設計されている。</emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.normalize">
        <h1>String.prototype.normalize ( [ _form_ ] )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _form_ が *undefined* なら _f_ を *"NFC"* とする。
          1. それ以外なら _f_ を ? ToString(_form_)。
          1. _f_ が *"NFC"*, *"NFD"*, *"NFKC"*, *"NFKD"* のいずれでもなければ *RangeError*。
          1. _ns_ を最新の Unicode Standard の正規化 (Normalization Forms) に従い _S_ を _f_ 指定の正規形に変換した String 値とする。
          1. _ns_ を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padend">
        <h1>String.prototype.padEnd ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padstart">
        <h1>String.prototype.padStart ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~) を返す。
        </emu-alg>

        <emu-clause id="sec-stringpaddingbuiltinsimpl" type="abstract operation">
          <h1>
            StringPaddingBuiltinsImpl (
              _O_: an ECMAScript language value,
              _maxLength_: an ECMAScript language value,
              _fillString_: an ECMAScript language value,
              _placement_: ~start~ or ~end~,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _S_ を ? ToString(_O_)。
            1. _intMaxLength_ を ℝ(? ToLength(_maxLength_))。
            1. _stringLength_ を _S_ の長さ。
            1. _intMaxLength_ ≤ _stringLength_ なら _S_ を返す。
            1. _fillString_ が *undefined* なら _fillString_ をコードユニット 0x0020 (SPACE) のみからなる String とする。
            1. それ以外なら _fillString_ を ? ToString(_fillString_)。
            1. StringPad(_S_, _intMaxLength_, _fillString_, _placement_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-stringpad" type="abstract operation">
          <h1>
            StringPad (
              _S_: a String,
              _maxLength_: a non-negative integer,
              _fillString_: a String,
              _placement_: ~start~ or ~end~,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _stringLength_ を _S_ の長さ。
            1. _maxLength_ ≤ _stringLength_ なら _S_。
            1. _fillString_ が空文字列なら _S_。
            1. _fillLen_ を _maxLength_ - _stringLength_。
            1. _truncatedStringFiller_ を _fillString_ を繰り返し連結し長さ _fillLen_ に切り詰めた String。
            1. _placement_ が ~start~ なら _truncatedStringFiller_ と _S_ の連結を返す。
            1. それ以外は _S_ と _truncatedStringFiller_ の連結を返す。
          </emu-alg>
          <emu-note>
            <p>_maxLength_ は _S_ の長さ未満にならないようクランプされる。</p>
          </emu-note>
          <emu-note>
            <p>_fillString_ の既定は *" "* (0x0020 SPACE)。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-tozeropaddeddecimalstring" type="abstract operation">
          <h1>
            ToZeroPaddedDecimalString (
              _n_: a non-negative integer,
              _minLength_: a non-negative integer,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _S_ を _n_ を 10 進数表記した文字列表現。
            1. StringPad(_S_, _minLength_, *"0"*, ~start~) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.repeat">
        <h1>String.prototype.repeat ( _count_ )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _n_ を ? ToIntegerOrInfinity(_count_)。
          1. _n_ &lt; 0 または _n_ = +∞ なら *RangeError*。
          1. _n_ = 0 なら空文字列。
          1. _S_ を _n_ 回連結した String を返す。
        </emu-alg>
        <emu-note>
          <p>*this* の値を繰り返したコードユニット列を生成。</p>
        </emu-note>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replace">
        <h1>String.prototype.replace ( _searchValue_, _replaceValue_ )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _searchValue_ が *undefined* でも *null* でもないなら
            1. _replacer_ を ? GetMethod(_searchValue_, %Symbol.replace%)。
            1. _replacer_ が *undefined* でなければ
              1. ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ ») を返す。
          1. _string_ を ? ToString(_O_)。
          1. _searchString_ を ? ToString(_searchValue_)。
          1. _functionalReplace_ を IsCallable(_replaceValue_)。
          1. _functionalReplace_ が *false* なら
            1. _replaceValue_ を ? ToString(_replaceValue_) に設定。
          1. _searchLength_ を _searchString_ の長さ。
          1. _position_ を StringIndexOf(_string_, _searchString_, 0)。
          1. _position_ が ~not-found~ なら _string_ を返す。
          1. _preceding_ を _string_ の 0 から _position_ まで。
          1. _following_ を _string_ の _position_ + _searchLength_ 以降。
          1. _functionalReplace_ が *true* なら
            1. _replacement_ を ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »))。
          1. それ以外
            1. アサート: _replaceValue_ は String。
            1. _captures_ を空リスト。
            1. _replacement_ を ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_)。
          1. _preceding_, _replacement_, _following_ を連結して返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>

        <emu-clause id="sec-getsubstitution" type="abstract operation" oldids="table-replacement-text-symbol-substitutions,table-45">
          <h1>
            GetSubstitution (
              _matched_: a String,
              _str_: a String,
              _position_: a non-negative integer,
              _captures_: a List of either Strings or *undefined*,
              _namedCaptures_: an Object or *undefined*,
              _replacementTemplate_: a String,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>この抽象操作において <em>decimal digit</em> は 0x0030 (DIGIT ZERO) から 0x0039 (DIGIT NINE) までのコードユニット。</dd>
          </dl>
          <emu-alg>
            1. _stringLength_ を _str_ の長さ。
            1. アサート: _position_ ≤ _stringLength_。
            1. _result_ を空文字列。
            1. _templateRemainder_ を _replacementTemplate_。
            1. _templateRemainder_ が空文字列でない間繰り返し、
              1. [declared="ref,refReplacement"] 注記: 以下の手順で接頭辞 _ref_ を分離し、その置換 _refReplacement_ を決定し _result_ に追加する。
              1. _templateRemainder_ が *"$$"* で始まるなら
                1. _ref_ を *"$$"*。
                1. _refReplacement_ を *"$"*。
              1. それ以外で *"$`"* で始まるなら
                1. _ref_ を *"$`"*。
                1. _refReplacement_ を _str_ の 0 から _position_ まで。
              1. それ以外で *"$&amp;"* で始まるなら
                1. _ref_ を *"$&amp;"*。
                1. _refReplacement_ を _matched_。
              1. それ以外で *"$'"* (0x0024 + 0x0027) で始まるなら
                1. _ref_ を *"$'"*。
                1. _matchLength_ を _matched_ の長さ。
                1. _tailPos_ を _position_ + _matchLength_。
                1. _refReplacement_ を _str_ の min(_tailPos_, _stringLength_) から末尾まで。
                1. 注: _tailPos_ が _stringLength_ を超えるのは %RegExp.prototype% でない *"exec"* を持つオブジェクトにより呼ばれた場合のみ。
              1. それ以外で *"$"* に 1 個以上の 10 進数字が続くなら
                1. 2 つ以上の数字が続くなら _digitCount_ を 2、そうでなければ 1。
                1. _digits_ を 1 から 1 + _digitCount_ の部分文字列。
                1. _index_ を ℝ(StringToNumber(_digits_))。
                1. アサート: 0 ≤ _index_ ≤ 99。
                1. _captureLen_ を _captures_ の要素数。
                1. _index_ > _captureLen_ かつ _digitCount_ = 2 なら
                  1. 注: 2 桁が範囲外なら 1 桁とリテラル数字に扱い直す。
                  1. _digitCount_ を 1。
                  1. _digits_ をその先頭 1 桁に。
                  1. _index_ を ℝ(StringToNumber(_digits_))。
                1. _ref_ を 0 から 1 + _digitCount_ の部分文字列。
                1. 1 ≤ _index_ ≤ _captureLen_ なら
                  1. _capture_ を _captures_[_index_ - 1]。
                  1. _capture_ が *undefined* なら
                    1. _refReplacement_ を空文字列。
                  1. それ以外
                    1. _refReplacement_ を _capture_。
                1. それ以外
                  1. _refReplacement_ を _ref_。
              1. それ以外で *"$&lt;"* で始まるなら
                1. _gtPos_ を StringIndexOf(_templateRemainder_, *">"*, 0)。
                1. _gtPos_ が ~not-found~ または _namedCaptures_ が *undefined* なら
                  1. _ref_ を *"$&lt;"*。
                  1. _refReplacement_ を _ref_。
                1. それ以外
                  1. _ref_ を 0 から _gtPos_ + 1 の部分。
                  1. _groupName_ を 2 から _gtPos_ の部分。
                  1. アサート: _namedCaptures_ はオブジェクト。
                  1. _capture_ を ? Get(_namedCaptures_, _groupName_)。
                  1. _capture_ が *undefined* なら
                    1. _refReplacement_ を空文字列。
                  1. それ以外
                    1. _refReplacement_ を ? ToString(_capture_)。
              1. それ以外
                1. _ref_ を 0 から 1 の部分。
                1. _refReplacement_ を _ref_。
              1. _refLength_ を _ref_ の長さ。
              1. _templateRemainder_ を _refLength_ 以降の部分へ。
              1. _result_ を _result_ と _refReplacement_ の連結。
            1. _result_ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replaceall">
        <h1>String.prototype.replaceAll ( _searchValue_, _replaceValue_ )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _searchValue_ が *undefined* でも *null* でもないなら
            1. _isRegExp_ を ? IsRegExp(_searchValue_)。
            1. _isRegExp_ が *true* なら
              1. _flags_ を ? Get(_searchValue_, *"flags"*)。
              1. ? RequireObjectCoercible(_flags_)。
              1. ? ToString(_flags_) に *"g"* が含まれなければ *TypeError*。
            1. _replacer_ を ? GetMethod(_searchValue_, %Symbol.replace%)。
            1. _replacer_ が *undefined* でなければ
              1. ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ ») を返す。
          1. _string_ を ? ToString(_O_)。
          1. _searchString_ を ? ToString(_searchValue_)。
          1. _functionalReplace_ を IsCallable(_replaceValue_)。
          1. _functionalReplace_ が *false* なら
            1. _replaceValue_ を ? ToString(_replaceValue_)。
          1. _searchLength_ を _searchString_ の長さ。
          1. _advanceBy_ を max(1, _searchLength_)。
          1. _matchPositions_ を空リスト。
          1. _position_ を StringIndexOf(_string_, _searchString_, 0)。
          1. _position_ が ~not-found~ でない間繰り返し、
            1. _matchPositions_ に _position_ を追加。
            1. _position_ を StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_) に設定。
          1. _endOfLastMatch_ を 0。
          1. _result_ を空文字列。
          1. _matchPositions_ の各 _p_ について
            1. _preserved_ を _string_ の _endOfLastMatch_ から _p_ まで。
            1. _functionalReplace_ が *true* なら
              1. _replacement_ を ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »))。
            1. それ以外
              1. アサート: _replaceValue_ は String。
              1. _captures_ を空リスト。
              1. _replacement_ を ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_)。
            1. _result_ を _result_, _preserved_, _replacement_ の連結に。
            1. _endOfLastMatch_ を _p_ + _searchLength_ に。
          1. _endOfLastMatch_ &lt; _string_ の長さ なら
            1. _result_ を _result_ と _string_ の _endOfLastMatch_ 以降の部分の連結に。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.search">
        <h1>String.prototype.search ( _regexp_ )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _regexp_ が *undefined* でも *null* でもないなら
            1. _searcher_ を ? GetMethod(_regexp_, %Symbol.search%)。
            1. _searcher_ が *undefined* でなければ
              1. ? Call(_searcher_, _regexp_, « _O_ ») を返す。
          1. _string_ を ? ToString(_O_)。
          1. _rx_ を ? RegExpCreate(_regexp_, *undefined*)。
          1. ? Invoke(_rx_, %Symbol.search%, « _string_ ») を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.slice">
        <h1>String.prototype.slice ( _start_, _end_ )</h1>
        <p>このメソッドは、このオブジェクトを String に変換した結果の _start_ から (含まない)_end_ まで（_end_ が *undefined* なら末尾まで）の <emu-not-ref>substring</emu-not-ref> を返す。_start_ が負なら _sourceLength_ + _start_ とみなし、_end_ が負なら _sourceLength_ + _end_ とみなす。結果は String 値。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _len_ を _S_ の長さ。
          1. _intStart_ を ? ToIntegerOrInfinity(_start_)。
          1. _intStart_ = -∞ なら _from_ を 0。
          1. それ以外で _intStart_ &lt; 0 なら _from_ を max(_len_ + _intStart_, 0)。
          1. それ以外は _from_ を min(_intStart_, _len_)。
          1. _end_ が *undefined* なら _intEnd_ を _len_、そうでなければ ? ToIntegerOrInfinity(_end_)。
          1. _intEnd_ = -∞ なら _to_ を 0。
          1. それ以外で _intEnd_ &lt; 0 なら _to_ を max(_len_ + _intEnd_, 0)。
          1. それ以外は _to_ を min(_intEnd_, _len_)。
          1. _from_ ≥ _to_ なら空文字列。
          1. _S_ の _from_ から _to_ の部分文字列を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.split">
        <h1>String.prototype.split ( _separator_, _limit_ )</h1>
        <p>このメソッドは、このオブジェクトを String に変換した結果を左から _separator_ の出現で分割した部分文字列を配列に格納し返す。_separator_ は任意長の String または %Symbol.split% メソッドを持つオブジェクト (例: RegExp)。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _separator_ が *undefined* でも *null* でもないなら
            1. _splitter_ を ? GetMethod(_separator_, %Symbol.split%)。
            1. _splitter_ が *undefined* でなければ
              1. ? Call(_splitter_, _separator_, « _O_, _limit_ ») を返す。
          1. _S_ を ? ToString(_O_)。
          1. _limit_ が *undefined* なら _lim_ を 2<sup>32</sup> - 1、そうでなければ ℝ(? ToUint32(_limit_))。
          1. _R_ を ? ToString(_separator_)。
          1. _lim_ = 0 なら CreateArrayFromList(« »)。
          1. _separator_ が *undefined* なら CreateArrayFromList(« _S_ »)。
          1. _separatorLength_ を _R_ の長さ。
          1. _separatorLength_ = 0 なら
            1. _strLen_ を _S_ の長さ。
            1. _outLen_ を _lim_ を 0 と _strLen_ の間にクランプした結果。
            1. _head_ を _S_ の 0 から _outLen_。
            1. _codeUnits_ を _head_ のコードユニット列リスト。
            1. CreateArrayFromList(_codeUnits_) を返す。
          1. _S_ が空文字列なら CreateArrayFromList(« _S_ »)。
          1. _substrings_ を空リスト。
          1. _i_ を 0。
          1. _j_ を StringIndexOf(_S_, _R_, 0)。
          1. _j_ が ~not-found~ でない間
            1. _T_ を _S_ の _i_ から _j_。
            1. _substrings_ に _T_ を追加。
            1. _substrings_ の要素数が _lim_ なら CreateArrayFromList(_substrings_)。
            1. _i_ を _j_ + _separatorLength_。
            1. _j_ を StringIndexOf(_S_, _R_, _i_)。
          1. _T_ を _S_ の _i_ から末尾。
          1. _substrings_ に _T_ を追加。
          1. CreateArrayFromList(_substrings_) を返す。
        </emu-alg>
        <emu-note>
          <p>_separator_ が空文字列なら先頭末尾や直前マッチ末尾の空部分文字列はマッチしない。結果配列長は文字列長で各要素は1コードユニット。</p>
          <p>*this* が空文字列の場合、_separator_ が空文字列にマッチするなら結果は空、そうでなければ 1 要素（空文字列）。</p>
          <p>_separator_ が *undefined* なら結果は 1 要素で *this* の文字列表現。_limit_ が指定されればサイズ制限。</p>
        </emu-note>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.startswith">
        <h1>String.prototype.startsWith ( _searchString_ [ , _position_ ] )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _isRegExp_ を ? IsRegExp(_searchString_)。
          1. _isRegExp_ が *true* なら *TypeError*。
          1. _searchStr_ を ? ToString(_searchString_)。
          1. _len_ を _S_ の長さ。
          1. _position_ が *undefined* なら _pos_ を 0、そうでなければ ? ToIntegerOrInfinity(_position_)。
          1. _start_ を _pos_ を 0 と _len_ の間にクランプした結果。
          1. _searchLength_ を _searchStr_ の長さ。
          1. _searchLength_ = 0 なら *true*。
          1. _end_ を _start_ + _searchLength_。
          1. _end_ > _len_ なら *false*。
          1. _substring_ を _S_ の _start_ から _end_。
          1. _substring_ = _searchStr_ なら *true*。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>指定位置からの一致で *true*。</p>
        </emu-note>
        <emu-note>
          <p>RegExp の場合例外を投げる理由は将来拡張のため。</p>
        </emu-note>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.substring">
        <h1>String.prototype.substring ( _start_, _end_ )</h1>
        <p>このメソッドは、このオブジェクトを String に変換した結果のインデックス _start_ から (含まない)_end_ まで（_end_ が *undefined* なら末尾まで）の <emu-not-ref>substring</emu-not-ref> を返す。結果は String 値。</p>
        <p>どちらかの引数が *NaN* または負なら 0 に置換。長さを超えるなら長さに置換。</p>
        <p>_start_ > _end_ の場合は入れ替える。</p>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _len_ を _S_ の長さ。
          1. _intStart_ を ? ToIntegerOrInfinity(_start_)。
          1. _end_ が *undefined* なら _intEnd_ を _len_、そうでなければ ? ToIntegerOrInfinity(_end_)。
          1. _finalStart_ を _intStart_ を 0 と _len_ の間にクランプした結果。
          1. _finalEnd_ を _intEnd_ を 0 と _len_ の間にクランプした結果。
          1. _from_ を min(_finalStart_, _finalEnd_)。
          1. _to_ を max(_finalStart_, _finalEnd_)。
          1. _S_ の _from_ から _to_ の部分文字列を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocalelowercase">
        <h1>String.prototype.toLocaleLowerCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 実装時はそちらに従う。未実装時は以下。</p>
        <p>このメソッドは <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> に記載の UTF-16 コードポイント列として String を解釈する。</p>
        <p>`toLowerCase` と同様だがロケール依存（例: トルコ語など特別な場合）。</p>
        <p>オプション引数の意味は ECMA-402 に定義され、未実装時は他用途禁止。</p>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocaleuppercase">
        <h1>String.prototype.toLocaleUpperCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 実装時はその仕様に従う。未実装時は以下。</p>
        <p>String を UTF-16 コードポイント列として解釈。</p>
        <p>`toUpperCase` と同様だがロケール依存結果を意図。</p>
        <p>オプション引数の意味は ECMA-402 にのみ定義。</p>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolowercase">
        <h1>String.prototype.toLowerCase ( )</h1>
        <p>String を UTF-16 コードポイント列として解釈する (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>)。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _sText_ を StringToCodePoints(_S_)。
          1. _lowerText_ を Unicode 既定のケース変換アルゴリズムに従い toLowercase(_sText_)。
          1. _L_ を CodePointsToString(_lowerText_)。
          1. _L_ を返す。
        </emu-alg>
        <p>結果は Unicode Character Database のロケール非依存マッピング（`UnicodeData.txt` と `SpecialCasing.txt` のロケール非依存部分）に従う。</p>
        <emu-note>
          <p>一部コードポイントは複数コードポイントへ写像され長さが変わり得る。`toUpperCase` と `toLowerCase` は文脈依存で対称ではない。</p>
        </emu-note>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tostring">
        <h1>String.prototype.toString ( )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. ? ThisStringValue(*this* value) を返す。
        </emu-alg>
        <emu-note>
          <p>String オブジェクトにおいては `valueOf` と同じ結果。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.touppercase">
        <h1>String.prototype.toUpperCase ( )</h1>
        <p>String を UTF-16 コードポイント列として解釈する。</p>
        <p>`String.prototype.toLowerCase` と同様に動作するが Unicode 既定ケース変換の大文字化アルゴリズムを用いる。</p>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.towellformed">
        <h1>String.prototype.toWellFormed ( )</h1>
        <p>このオブジェクトの文字列表現から、サロゲートペアを構成しない孤立した先行・後続サロゲートを U+FFFD (REPLACEMENT CHARACTER) に置換した String を返す。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _S_ を ? ToString(_O_)。
          1. _strLen_ を _S_ の長さ。
          1. _k_ を 0。
          1. _result_ を空文字列。
          1. _k_ &lt; _strLen_ の間繰り返し
            1. _cp_ を CodePointAt(_S_, _k_)。
            1. _cp_.[[IsUnpairedSurrogate]] が *true* なら
              1. _result_ を _result_ と 0xFFFD の連結。
            1. それ以外
              1. _result_ を _result_ と UTF16EncodeCodePoint(_cp_.[[CodePoint]]) の連結。
            1. _k_ を _k_ + _cp_.[[CodeUnitCount]]。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trim">
        <h1>String.prototype.trim ( )</h1>
        <p>String を UTF-16 コードポイント列として解釈する。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _S_ を *this* の値。
          1. ? TrimString(_S_, ~start+end~) を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>

        <emu-clause id="sec-trimstring" type="abstract operation">
          <h1>
            TrimString (
              _string_: an ECMAScript language value,
              _where_: ~start~, ~end~, or ~start+end~,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_string_ を UTF-16 コードポイント列として解釈する。</dd>
          </dl>
          <emu-alg>
            1. ? RequireObjectCoercible(_string_)。
            1. _S_ を ? ToString(_string_)。
            1. _where_ が ~start~ なら
              1. _T_ を _S_ から前方空白を除去した String。
            1. それ以外で _where_ が ~end~ なら
              1. _T_ を _S_ から後方空白を除去した String。
            1. それ以外
              1. アサート: _where_ は ~start+end~。
              1. _T_ を _S_ の前後空白を除去した String。
            1. _T_ を返す。
          </emu-alg>
          <p>空白の定義は |WhiteSpace| と |LineTerminator| の和集合。Unicode 一般カテゴリ Space_Separator (“Zs”) の判定は UTF-16 として解釈する。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimend">
        <h1>String.prototype.trimEnd ( )</h1>
        <p>String を UTF-16 コードポイント列として解釈する。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _S_ を *this* の値。
          1. ? TrimString(_S_, ~end~) を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimstart">
        <h1>String.prototype.trimStart ( )</h1>
        <p>String を UTF-16 コードポイント列として解釈する。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _S_ を *this* の値。
          1. ? TrimString(_S_, ~start~) を返す。
        </emu-alg>
        <emu-note>
          <p>ジェネリック。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.valueof">
        <h1>String.prototype.valueOf ( )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. ? ThisStringValue(*this* value) を返す。
        </emu-alg>

        <emu-clause id="sec-thisstringvalue" type="abstract operation" oldids="thisstringvalue">
          <h1>
            ThisStringValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ が String なら _value_ を返す。
            1. _value_ がオブジェクトで [[StringData]] 内部スロットを持つなら
              1. _s_ を _value_.[[StringData]]。
              1. アサート: _s_ は String。
              1. _s_ を返す。
            1. *TypeError* 例外を投げる。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype-%symbol.iterator%" oldids="sec-string.prototype-@@iterator,sec-createstringiterator,sec-properties-of-string-iterator-instances,table-46,table-internal-slots-of-string-iterator-instances">
        <h1>String.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>このメソッドは String 値のコードポイントを順次 (各コードポイントを String として) 返すイテレータオブジェクトを返す。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ を *this*。
          1. ? RequireObjectCoercible(_O_)。
          1. _s_ を ? ToString(_O_)。
          1. _closure_ を _s_ を捕捉し、呼び出し時に以下を行う抽象クロージャとする:
            1. _len_ を _s_ の長さ。
            1. _position_ を 0。
            1. _position_ &lt; _len_ の間繰り返し
              1. _cp_ を CodePointAt(_s_, _position_)。
              1. _nextIndex_ を _position_ + _cp_.[[CodeUnitCount]]。
              1. _resultString_ を _s_ の _position_ から _nextIndex_。
              1. _position_ を _nextIndex_。
              1. ? GeneratorYield(CreateIteratorResultObject(_resultString_, *false*))。
            1. NormalCompletion(~unused~) を返す。
          1. CreateIteratorFromClosure(_closure_, *"%StringIteratorPrototype%"*, %StringIteratorPrototype%) を返す。
        </emu-alg>
        <p>このメソッドの *"name"* プロパティの値は *"[Symbol.iterator]"* である。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-string-instances">
      <h1>String インスタンスのプロパティ</h1>
      <p>String インスタンスは String エキゾチックオブジェクトであり、その内部メソッドを持つ。String インスタンスは String プロトタイプオブジェクトからプロパティを継承し、[[StringData]] 内部スロットを持つ。この内部スロットはその String オブジェクトが表す String 値である。</p>
      <p>String インスタンスは *"length"* プロパティと整数インデックス名を持つ列挙可能プロパティ集合を持つ。</p>

      <emu-clause id="sec-properties-of-string-instances-length">
        <h1>length</h1>
        <p>この String オブジェクトが表す String 値の要素数。</p>
        <p>一度初期化されると不変。このプロパティの属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-iterator-objects">
      <h1>String 反復子オブジェクト</h1>
      <p><dfn variants="String Iterators,String Iterator object,String Iterator objects">String Iterator</dfn> は特定の String インスタンス上の特定の反復を表すオブジェクト。名前付きコンストラクターは存在せず、String インスタンスの特定メソッド呼び出しで生成される。</p>

      <emu-clause id="sec-%stringiteratorprototype%-object">
        <h1>%StringIteratorPrototype% オブジェクト</h1>
        <p><dfn>%StringIteratorPrototype%</dfn> オブジェクト:</p>
        <ul>
          <li>全ての String Iterator オブジェクトが継承するプロパティを持つ。</li>
          <li>通常のオブジェクトである。</li>
          <li>[[Prototype]] 内部スロットの値は %Iterator.prototype% である。</li>
          <li>次のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-%stringiteratorprototype%.next">
          <h1>%StringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%StringIteratorPrototype%"*)</emu-meta> を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%stringiteratorprototype%-@@tostringtag" id="sec-%stringiteratorprototype%-%symbol.tostringtag%">
          <h1>%StringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"String Iterator"* である。</p>
          <p>属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp (正規表現) オブジェクト</h1>
    <p>RegExp オブジェクトは正規表現パターンと関連するフラグを保持する。</p>
    <emu-note>
      <p>正規表現の形式と機能は Perl 5 の正規表現機能を手本としている。</p>
    </emu-note>

    <emu-clause id="sec-patterns">
      <h1>パターン</h1>
      <p>RegExp コンストラクターは入力のパターン文字列に対して以下の文法を適用する。文字列が |Pattern| の展開として解釈できない場合、エラーが発生する。</p>
      <h2>構文</h2>
      <emu-grammar type="definition">
        Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `|` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [empty]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          `(?=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        Quantifier ::
          QuantifierPrefix
          QuantifierPrefix `?`

        QuantifierPrefix ::
          `*`
          `+`
          `?`
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          PatternCharacter
          `.`
          `\` AtomEscape[?UnicodeMode, ?NamedCaptureGroups]
          CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
          `(` GroupSpecifier[?UnicodeMode]? Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        RegularExpressionModifiers ::
          [empty]
          RegularExpressionModifiers RegularExpressionModifier

        RegularExpressionModifier :: one of
          `i` `m` `s`

        SyntaxCharacter :: one of
          `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

        PatternCharacter ::
          SourceCharacter but not SyntaxCharacter

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          DecimalEscape
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          IdentityEscape[?UnicodeMode]

        ControlEscape :: one of
          `f` `n` `r` `t` `v`

        GroupSpecifier[UnicodeMode] ::
          `?` GroupName[?UnicodeMode]

        GroupName[UnicodeMode] ::
          `&lt;` RegExpIdentifierName[?UnicodeMode] `&gt;`

        RegExpIdentifierName[UnicodeMode] ::
          RegExpIdentifierStart[?UnicodeMode]
          RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]

        RegExpIdentifierStart[UnicodeMode] ::
          IdentifierStartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpIdentifierPart[UnicodeMode] ::
          IdentifierPartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpUnicodeEscapeSequence[UnicodeMode] ::
          [+UnicodeMode] `u` HexLeadSurrogate `\u` HexTrailSurrogate
          [+UnicodeMode] `u` HexLeadSurrogate
          [+UnicodeMode] `u` HexTrailSurrogate
          [+UnicodeMode] `u` HexNonSurrogate
          [~UnicodeMode] `u` Hex4Digits
          [+UnicodeMode] `u{` CodePoint `}`

        UnicodeLeadSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+D800 to U+DBFF

        UnicodeTrailSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
      </emu-grammar>
      <p>関連付ける `\\u` |HexLeadSurrogate| の選択が曖昧である各 `\\u` |HexTrailSurrogate| は、他に対応する `\\u` |HexTrailSurrogate| を持たない最も近い `u` |HexLeadSurrogate| に関連付けられなければならない。</p>
      <emu-grammar type="definition">
        HexLeadSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xD800 to 0xDBFF]

        HexTrailSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xDC00 to 0xDFFF]

        HexNonSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is not in the inclusive interval from 0xD800 to 0xDFFF]

        IdentityEscape[UnicodeMode] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacter but not UnicodeIDContinue

        DecimalEscape ::
          NonZeroDigit DecimalDigits[~Sep]? [lookahead &notin; DecimalDigit]

        CharacterClassEscape[UnicodeMode] ::
          `d`
          `D`
          `s`
          `S`
          `w`
          `W`
          [+UnicodeMode] `p{` UnicodePropertyValueExpression `}`
          [+UnicodeMode] `P{` UnicodePropertyValueExpression `}`

        UnicodePropertyValueExpression ::
          UnicodePropertyName `=` UnicodePropertyValue
          LoneUnicodePropertyNameOrValue

        UnicodePropertyName ::
          UnicodePropertyNameCharacters

        UnicodePropertyNameCharacters ::
          UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

        UnicodePropertyValue ::
          UnicodePropertyValueCharacters

        LoneUnicodePropertyNameOrValue ::
          UnicodePropertyValueCharacters

        UnicodePropertyValueCharacters ::
          UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

        UnicodePropertyValueCharacter ::
          UnicodePropertyNameCharacter
          DecimalDigit

        UnicodePropertyNameCharacter ::
          AsciiLetter
          `_`

        CharacterClass[UnicodeMode, UnicodeSetsMode] ::
          `[` [lookahead != `^`] ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`
          `[^` ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`

        ClassContents[UnicodeMode, UnicodeSetsMode] ::
          [empty]
          [~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode]
          [+UnicodeSetsMode] ClassSetExpression

        NonemptyClassRanges[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtom[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtom[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        NonemptyClassRangesNoDash[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        ClassAtom[UnicodeMode] ::
          `-`
          ClassAtomNoDash[?UnicodeMode]

        ClassAtomNoDash[UnicodeMode] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode]

        ClassEscape[UnicodeMode] ::
          `b`
          [+UnicodeMode] `-`
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]

        ClassSetExpression ::
          ClassUnion
          ClassIntersection
          ClassSubtraction

        ClassUnion ::
          ClassSetRange ClassUnion?
          ClassSetOperand ClassUnion?

        ClassIntersection ::
          ClassSetOperand `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand
          ClassIntersection `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand

        ClassSubtraction ::
          ClassSetOperand `--` ClassSetOperand
          ClassSubtraction `--` ClassSetOperand

        ClassSetRange ::
          ClassSetCharacter `-` ClassSetCharacter

        ClassSetOperand ::
          NestedClass
          ClassStringDisjunction
          ClassSetCharacter

        NestedClass ::
          `[` [lookahead != `^`] ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `[^` ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `\` CharacterClassEscape[+UnicodeMode]
      </emu-grammar>
      <emu-note>
        <p>最初の二つの行は CharacterClass と同等である。</p>
      </emu-note>
      <emu-grammar type="definition">
        ClassStringDisjunction ::
          `\q{` ClassStringDisjunctionContents `}`

        ClassStringDisjunctionContents ::
          ClassString
          ClassString `|` ClassStringDisjunctionContents

        ClassString ::
          [empty]
          NonEmptyClassString

        NonEmptyClassString ::
          ClassSetCharacter NonEmptyClassString?

        ClassSetCharacter ::
          [lookahead &notin; ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
          `\` CharacterEscape[+UnicodeMode]
          `\` ClassSetReservedPunctuator
          `\b`

        ClassSetReservedDoublePunctuator :: one of
          `&amp;&amp;` `!!` `##`
          `$$` `%%` `**`
          `++` `,,` `..`
          `::` `;;` `&lt;&lt;`
          `==` `&gt;&gt;` `??`
          `@@` `^^` `&grave;&grave;`
          `~~`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetSyntaxCharacter :: one of
          `(` `)` `[` `]` `{` `}` `/` `-` `\` `|`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetReservedPunctuator :: one of
          `&amp;` `-` `!` `#` `%` `,`
          `:` `;` `&lt;` `=` `&gt;` `@`
          `&grave;` `~`
      </emu-grammar>
      <emu-note>
        <p>この節の複数の生成規則は <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> で別定義が与えられる。</p>
      </emu-note>

      <emu-clause id="sec-patterns-static-semantics-early-errors">
        <h1>静的セマンティクス: 早期エラー</h1>
        <emu-note>
          <p>この節は <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <ul>
          <li>
            CountLeftCapturingParensWithin(|Pattern|) ≥ 2<sup>32</sup> - 1 の場合、構文エラー。
          </li>
          <li>
            |Pattern| が互いに異なる二つの |GroupSpecifier| _x_ と _y_ を含み、それらの CapturingGroupName が等しく、かつ MightBothParticipate(_x_, _y_) が *true* の場合、構文エラー。
          </li>
        </ul>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <ul>
          <li>
            最初の |DecimalDigits| の MV が二番目の |DecimalDigits| の MV より大きい場合、構文エラー。
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            |RegularExpressionModifiers| が同一コードポイントを重複して含む場合、構文エラー。
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            最初および二番目の |RegularExpressionModifiers| がともに空なら構文エラー。
          </li>
          <li>
            最初の |RegularExpressionModifiers| が同一コードポイントを重複して含む場合、構文エラー。
          </li>
          <li>
            二番目の |RegularExpressionModifiers| が同一コードポイントを重複して含む場合、構文エラー。
          </li>
          <li>
            最初の |RegularExpressionModifiers| に含まれる任意のコードポイントが二番目にも含まれる場合、構文エラー。
          </li>
        </ul>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <ul>
          <li>
            GroupSpecifiersThatMatch(|GroupName|) が空なら構文エラー。
          </li>
        </ul>
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <ul>
          <li>
            |DecimalEscape| の CapturingGroupNumber が |AtomEscape| を含む |Pattern| 内の CountLeftCapturingParensWithin より大きい場合、構文エラー。
          </li>
        </ul>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            最初または二番目の |ClassAtom| の IsCharacterClass が *true* なら構文エラー。
          </li>
          <li>
            両方の IsCharacterClass が *false* で、かつ最初の CharacterValue > 二番目の CharacterValue の場合構文エラー。
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            |ClassAtomNoDash| または |ClassAtom| の IsCharacterClass が *true* なら構文エラー。
          </li>
          <li>
            両方の IsCharacterClass が *false* で、|ClassAtomNoDash| の CharacterValue > |ClassAtom| の CharacterValue なら構文エラー。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            |RegExpUnicodeEscapeSequence| の CharacterValue が |IdentifierStartChar| 字句文法生成規則でマッチするコードポイント値でない場合構文エラー。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            |RegExpIdentifierStart| の RegExpIdentifierCodePoint が |UnicodeIDStart| 生成規則でマッチしない場合構文エラー。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            |RegExpUnicodeEscapeSequence| の CharacterValue が |IdentifierPartChar| でマッチするコードポイント値でない場合構文エラー。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            |RegExpIdentifierPart| の RegExpIdentifierCodePoint が |UnicodeIDContinue| でマッチしない場合構文エラー。
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <ul>
          <li>
            |UnicodePropertyName| が <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> の「Property name and aliases」欄に列挙される Unicode プロパティ名またはエイリアスでなければ構文エラー。
          </li>
          <li>
            |UnicodePropertyValue| が |UnicodePropertyName| が示す Unicode プロパティの値またはエイリアス（<code>PropertyValueAliases.txt</code> 参照）でない場合構文エラー。
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <ul>
          <li>
            |LoneUnicodePropertyNameOrValue| が General_Category (gc) の値あるいは値エイリアス（<code>PropertyValueAliases.txt</code>）にも、「Property name and aliases」欄（<emu-xref href="#table-binary-unicode-properties"></emu-xref>）に列挙されるバイナリプロパティ／エイリアスにも、文字列のバイナリプロパティ（<emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> の「Property name」列）にも該当しない場合構文エラー。
          </li>
          <li>
            外側の |Pattern| に <sub>[UnicodeSetsMode]</sub> パラメータがなく、かつ |LoneUnicodePropertyNameOrValue| が文字列のバイナリプロパティ（同表）である場合構文エラー。
          </li>
        </ul>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <ul>
          <li>
            |UnicodePropertyValueExpression| の MayContainStrings が *true* なら構文エラー。
          </li>
        </ul>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            |ClassContents| の MayContainStrings が *true* なら構文エラー。
          </li>
        </ul>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            |ClassContents| の MayContainStrings が *true* なら構文エラー。
          </li>
        </ul>
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <ul>
          <li>
            最初の |ClassSetCharacter| の CharacterValue が 2 番目より大きい場合構文エラー。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparenswithin" type="abstract operation">
        <h1>
          静的セマンティクス: CountLeftCapturingParensWithin (
          _node_: a Parse Node,
          ): 非負整数
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_node_ 内の左捕捉括弧の個数を返す。<dfn variants="left-capturing parentheses">左捕捉括弧</dfn>とは <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> 生成規則の `(` 終端にマッチする任意の `(` パターン文字である。</dd>
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-alg>
          1. アサート: _node_ は <emu-xref href="#sec-patterns">RegExp パターン文法</emu-xref> の生成規則インスタンスである。
          1. _node_ に含まれる <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> の構文木ノード数を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparensbefore" type="abstract operation">
        <h1>
          静的セマンティクス: CountLeftCapturingParensBefore (
          _node_: a Parse Node,
          ): 非負整数
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>外側のパターン内で _node_ の左側に現れる左捕捉括弧の数を返す。</dd>
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-alg>
          1. アサート: _node_ は <emu-xref href="#sec-patterns">RegExp パターン文法</emu-xref> の生成規則インスタンスである。
          1. _pattern_ を _node_ を含む |Pattern| とする。
          1. _pattern_ 内で _node_ より前に出現するか、_node_ を包含する <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ノードの数を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-mightbothparticipate" type="abstract operation">
        <h1>
          静的セマンティクス: MightBothParticipate (
          _x_: a Parse Node,
          _y_: a Parse Node,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: _x_ と _y_ は同じ外側の |Pattern| を持つ。
          1. 外側の |Pattern| が <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar> ノードを含み、_x_ が |Alternative| 内に、_y_ が派生した |Disjunction| 内（または逆）に含まれる場合 *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-capturing-group-number" type="sdo">
        <h1>静的セマンティクス: CapturingGroupNumber ( ): 正の整数</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-grammar>DecimalEscape :: NonZeroDigit</emu-grammar>
        <emu-alg>
          1. |NonZeroDigit| の MV を返す。
        </emu-alg>
        <emu-grammar>DecimalEscape :: NonZeroDigit DecimalDigits</emu-grammar>
        <emu-alg>
          1. _n_ を |DecimalDigits| のコードポイント数とする。
          1. (|NonZeroDigit| の MV × 10<sup>_n_</sup> + |DecimalDigits| の MV) を返す。
        </emu-alg>
        <p>“|NonZeroDigit| の MV” と “|DecimalDigits| の MV” の定義は <emu-xref href="#sec-literals-numeric-literals"></emu-xref> にある。</p>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-is-character-class" type="sdo">
        <h1>静的セマンティクス: IsCharacterClass ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-patterns-static-semantics-is-character-class-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-grammar>
          ClassAtom ::
            `-`

          ClassAtomNoDash ::
            SourceCharacter but not one of `\` or `]` or `-`

          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>ClassEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-character-value" type="sdo">
        <h1>静的セマンティクス: CharacterValue ( ): 非負整数</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-patterns-static-semantics-character-value-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-grammar>
          ClassAtom :: `-`
        </emu-grammar>
        <emu-alg>
          1. U+002D (HYPHEN-MINUS) の数値を返す。
        </emu-alg>
        <emu-grammar>
          ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`
        </emu-grammar>
        <emu-alg>
          1. _ch_ を |SourceCharacter| にマッチしたコードポイントとする。
          1. _ch_ の数値を返す。
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `b`
        </emu-grammar>
        <emu-alg>
          1. U+0008 (BACKSPACE) の数値を返す。
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `-`
        </emu-grammar>
        <emu-alg>
          1. U+002D (HYPHEN-MINUS) の数値を返す。
        </emu-alg>
        <emu-grammar>CharacterEscape :: ControlEscape</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#table-controlescape-code-point-values"></emu-xref> に従う数値を返す。
        </emu-alg>
        <emu-table id="table-controlescape-code-point-values" caption="ControlEscape コードポイント値" oldids="table-47">
          <table>
            <thead>
              <tr>
                <th>
                  ControlEscape
                </th>
                <th>
                  数値
                </th>
                <th>
                  Code Point
                </th>
                <th>
                  Unicode 名
                </th>
                <th>
                  記号
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `t`
              </td>
              <td>
                9
              </td>
              <td>
                `U+0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `n`
              </td>
              <td>
                10
              </td>
              <td>
                `U+000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `v`
              </td>
              <td>
                11
              </td>
              <td>
                `U+000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `f`
              </td>
              <td>
                12
              </td>
              <td>
                `U+000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `r`
              </td>
              <td>
                13
              </td>
              <td>
                `U+000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-grammar>CharacterEscape :: `c` AsciiLetter</emu-grammar>
        <emu-alg>
          1. _ch_ を |AsciiLetter| にマッチしたコードポイントとする。
          1. _i_ を _ch_ の数値とする。
          1. _i_ を 32 で割った余りを返す。
        </emu-alg>
        <emu-grammar>CharacterEscape :: `0` [lookahead &notin; DecimalDigit]</emu-grammar>
        <emu-alg>
          1. U+0000 (NULL) の数値を返す。
        </emu-alg>
        <emu-note>
          <p>`\\0` は &lt;NUL> 文字を表し、その後に 10 進数字を続けることはできない。</p>
        </emu-note>
        <emu-grammar>CharacterEscape :: HexEscapeSequence</emu-grammar>
        <emu-alg>
          1. |HexEscapeSequence| の MV を返す。
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` HexLeadSurrogate `\u` HexTrailSurrogate</emu-grammar>
        <emu-alg>
          1. _lead_ を |HexLeadSurrogate| の CharacterValue とする。
          1. _trail_ を |HexTrailSurrogate| の CharacterValue とする。
          1. _cp_ を UTF16SurrogatePairToCodePoint(_lead_, _trail_) とする。
          1. _cp_ の数値を返す。
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. |Hex4Digits| の MV を返す。
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. |CodePoint| の MV を返す。
        </emu-alg>
        <emu-grammar>
          HexLeadSurrogate :: Hex4Digits

          HexTrailSurrogate :: Hex4Digits

          HexNonSurrogate :: Hex4Digits
        </emu-grammar>
        <emu-alg>
          1. |Hex4Digits| の MV を返す。
        </emu-alg>
        <emu-grammar>CharacterEscape :: IdentityEscape</emu-grammar>
        <emu-alg>
          1. _ch_ を |IdentityEscape| にマッチしたコードポイントとする。
          1. _ch_ の数値を返す。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: SourceCharacter but not ClassSetSyntaxCharacter</emu-grammar>
        <emu-alg>
          1. _ch_ を |SourceCharacter| にマッチしたコードポイントとする。
          1. _ch_ の数値を返す。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\` ClassSetReservedPunctuator</emu-grammar>
        <emu-alg>
          1. _ch_ を |ClassSetReservedPunctuator| にマッチしたコードポイントとする。
          1. _ch_ の数値を返す。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. U+0008 (BACKSPACE) の数値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-maycontainstrings" type="sdo">
        <h1>静的セマンティクス: MayContainStrings ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          CharacterClassEscape ::
            `d`
            `D`
            `s`
            `S`
            `w`
            `W`
            `P{` UnicodePropertyValueExpression `}`

          UnicodePropertyValueExpression ::
            UnicodePropertyName `=` UnicodePropertyValue

          NestedClass ::
            `[^` ClassContents `]`

          ClassContents ::
            [empty]
            NonemptyClassRanges

          ClassSetOperand ::
            ClassSetCharacter
        </emu-grammar>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. |LoneUnicodePropertyNameOrValue| が <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> の「Property name」欄にある文字列のバイナリプロパティであれば *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. |ClassUnion| が存在するならその MayContainStrings を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. |ClassSetOperand| の MayContainStrings が *true* なら *true* を返す。
          1. |ClassUnion| が存在するならその MayContainStrings を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 最初の |ClassSetOperand| の MayContainStrings が *false* なら *false*。
          1. 二番目の |ClassSetOperand| の MayContainStrings が *false* なら *false*。
          1. *true* を返す。
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. |ClassIntersection| の MayContainStrings が *false* なら *false*。
          1. |ClassSetOperand| の MayContainStrings が *false* なら *false*。
          1. *true* を返す。
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 最初の |ClassSetOperand| の MayContainStrings を返す。
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. |ClassSubtraction| の MayContainStrings を返す。
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. |ClassString| の MayContainStrings が *true* なら *true*。
          1. |ClassStringDisjunctionContents| の MayContainStrings を返す。
        </emu-alg>
        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. *true* を返す。
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. |NonEmptyClassString| の MayContainStrings を返す。
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. |NonEmptyClassString| が存在するなら *true*。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-groupspecifiersthatmatch" type="abstract operation">
        <h1>
          静的セマンティクス: GroupSpecifiersThatMatch (
          _thisGroupName_: a |GroupName| Parse Node,
          ): |GroupSpecifier| 構文ノードのリスト
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _name_ を _thisGroupName_ の CapturingGroupName とする。
          1. _pattern_ を _thisGroupName_ を含む |Pattern| とする。
          1. _result_ を新しい空リストとする。
          1. _pattern_ が含む各 |GroupSpecifier| _gs_ について
            1. _gs_ の CapturingGroupName が _name_ なら
              1. _gs_ を _result_ に追加。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-capturinggroupname" oldids="sec-regexp-identifier-names-static-semantics-stringvalue" type="sdo">
        <h1>静的セマンティクス: CapturingGroupName ( ): String</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          GroupName :: `&lt;` RegExpIdentifierName `&gt;`
        </emu-grammar>
        <emu-alg>
          1. _idTextUnescaped_ を |RegExpIdentifierName| の RegExpIdentifierCodePoints とする。
          1. CodePointsToString(_idTextUnescaped_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoints" type="sdo">
        <h1>静的セマンティクス: RegExpIdentifierCodePoints ( ): コードポイントのリスト</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierStart</emu-grammar>
        <emu-alg>
          1. _cp_ を |RegExpIdentifierStart| の RegExpIdentifierCodePoint とする。
          1. « _cp_ » を返す。
        </emu-alg>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierName RegExpIdentifierPart</emu-grammar>
        <emu-alg>
          1. _cps_ を派生した |RegExpIdentifierName| の RegExpIdentifierCodePoints とする。
          1. _cp_ を |RegExpIdentifierPart| の RegExpIdentifierCodePoint とする。
          1. _cps_ に « _cp_ » を連結したリストを返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoint" type="sdo">
        <h1>静的セマンティクス: RegExpIdentifierCodePoint ( ): コードポイント</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierStartChar| にマッチしたコードポイントを返す。
        </emu-alg>
        <emu-grammar>RegExpIdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierPartChar| にマッチしたコードポイントを返す。
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence

          RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence
        </emu-grammar>
        <emu-alg>
          1. |RegExpUnicodeEscapeSequence| の CharacterValue を数値とするコードポイントを返す。
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate

          RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
        </emu-grammar>
        <emu-alg>
          1. _lead_ を |UnicodeLeadSurrogate| にマッチしたコードポイントの数値値を数値とするコードユニットとする。
          1. _trail_ を |UnicodeTrailSurrogate| にマッチしたコードポイントの数値値を数値とするコードユニットとする。
          1. UTF16SurrogatePairToCodePoint(_lead_, _trail_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-pattern-semantics">
      <h1>パターンのセマンティクス</h1>
      <p>正規表現パターンは以下で記述される手順を用いて抽象クロージャ (Abstract Closure) に変換される。実装は、結果が同一である限り、以下に挙げるものより効率的なアルゴリズムを用いることが推奨される。この抽象クロージャは RegExp オブジェクトの [[RegExpMatcher]] 内部スロットの値として使われる。</p>
      <p>|Pattern| は、その関連フラグに `u` も `v` も含まない場合 BMP パターンである。そうでなければ Unicode パターンである。BMP パターンは、基本多言語面 (BMP) の範囲内の Unicode コードポイントから成る 16 ビット値列として解釈される String に対してマッチを行う。Unicode パターンは UTF-16 でエンコードされた Unicode コードポイント列として解釈される String に対してマッチを行う。BMP パターンの挙動を記述する文脈では「文字」は単一の 16 ビット Unicode BMP コードポイントを意味する。Unicode パターンの挙動を記述する文脈では「文字」は UTF-16 でエンコードされたコードポイント (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) を意味する。いずれの文脈でも「character value」は対応する非エンコードなコードポイントの数値を意味する。</p>
      <p>|Pattern| の構文とセマンティクスは、そのソーステキストが |SourceCharacter| 値の List であり、各 |SourceCharacter| が Unicode コードポイントに対応するとして定義される。BMP パターンが非 BMP の |SourceCharacter| を含む場合、パターン全体は UTF-16 でエンコードされ、そのエンコーディングの個々のコードユニットが List の要素として用いられる。</p>
      <emu-note>
        <p>例えば、ソーステキスト中で単一の非 BMP 文字 U+1D11E (MUSICAL SYMBOL G CLEF) で表されたパターンを考える。Unicode パターンとして解釈されると、それは単一コードポイント U+1D11E を要素とする 1 要素 (1 文字) の List となる。しかし BMP パターンとして解釈される場合、まず UTF-16 にエンコードされ、コードユニット 0xD834 と 0xDD1E から成る 2 要素の List となる。</p>
        <p>パターンは非 BMP 文字が UTF-16 エンコードされた ECMAScript の String 値として RegExp コンストラクターに渡される。例えば単一文字 MUSICAL SYMBOL G CLEF のパターンは、長さ 2 の String であり、その要素はコードユニット 0xD834 と 0xDD1E であった。したがって、2 つのパターン文字から成る BMP パターンとして処理するためにこれ以上の変換は不要である。しかし Unicode パターンとして処理するには UTF16SurrogatePairToCodePoint を用いて、その唯一の要素が単一パターン文字 (コードポイント U+1D11E) である List を生成しなければならない。</p>
        <p>実装は実際に UTF-16 との間のこのような変換を行わないかもしれないが、本仕様のセマンティクスは、パターンマッチングの結果があたかもそのような変換が行われたかのようであることを要求する。</p>
      </emu-note>

      <emu-clause id="sec-pattern-notation" oldids="sec-notation">
        <h1>表記</h1>
        <p>以下の記述では次の内部データ構造を用いる:</p>
        <ul>
          <li>
            <dfn>CharSetElement</dfn> は次の 2 種類のいずれかである:
            <ul>
              <li>
                _rer_.[[UnicodeSets]] が *false* の場合、CharSetElement は上記「パターンのセマンティクス」における意味での文字。
              </li>
              <li>
                _rer_.[[UnicodeSets]] が *true* の場合、CharSetElement は上記「パターンのセマンティクス」における意味での文字列（要素がそのような文字である列）。これには空列、1 文字列、複数文字列が含まれる。利便性のため、この種の CharSetElement を扱う際、単一文字は 1 文字列と同一視して扱う。
              </li>
            </ul>
          </li>
          <li>
            <dfn id="pattern-charset" variants="CharSets">CharSet</dfn> は CharSetElement の数学的集合。
          </li>
          <li>
            <dfn id="pattern-capturerange" variants="CaptureRanges">CaptureRange</dfn> は { [[StartIndex]], [[EndIndex]] } という Record で、キャプチャに含まれる文字の範囲を表す。[[StartIndex]] は _Input_ 内での開始インデックス (含む) を表す整数、[[EndIndex]] は _Input_ 内での終了インデックス (含まない) を表す整数である。任意の CaptureRange について、これらのインデックスは [[StartIndex]] ≤ [[EndIndex]] という不変条件を満たさなければならない。
          </li>
          <li>
            <dfn id="pattern-matchstate" variants="MatchStates" oldids="pattern-matchresult">MatchState</dfn> は { [[Input]], [[EndIndex]], [[Captures]] } という Record で、[[Input]] はマッチ対象の String を表す文字の List、[[EndIndex]] は整数、[[Captures]] はパターン中の各左捕捉括弧に対応する値の List である。MatchState は正規表現マッチングアルゴリズム中の部分的なマッチ状態を表す。[[EndIndex]] はこれまでにパターンがマッチした最後の入力文字のインデックス + 1 を表し、[[Captures]] は捕捉括弧の結果を保持する。[[Captures]] の _n_<sup>th</sup> 要素は _n_ 番目の捕捉括弧が捕捉した文字範囲を表す CaptureRange か、まだ到達していない場合 *undefined* である。バックトラッキングのため、マッチング過程の任意時点で多数の MatchState が使用され得る。
          </li>
          <li>
            <dfn id="pattern-matchercontinuation" variants="MatcherContinuations">MatcherContinuation</dfn> は 1 つの MatchState 引数を取り、MatchState または ~failure~ を返す抽象クロージャ。MatcherContinuation はパターンの残り部分（クロージャが捕捉した値で特定される）を、引数の MatchState が示す中間状態から _Input_ に対してマッチさせようとする。成功すれば最終的な MatchState を返し、失敗すれば ~failure~ を返す。
          </li>
          <li>
            <dfn id="pattern-matcher" variants="Matchers">Matcher</dfn> は 2 つの引数（MatchState と MatcherContinuation）を取り、MatchState または ~failure~ を返す抽象クロージャ。Matcher はパターンの中間サブパターン（クロージャが捕捉した値で特定される）をその MatchState の [[Input]] に対し、引数の MatchState が示す中間状態からマッチさせる。MatcherContinuation 引数は残りのパターンをマッチさせるクロージャであるべき。サブパターンをマッチさせて新しい MatchState を得た後、Matcher はその新しい MatchState に対して MatcherContinuation を呼び、残りのパターンがマッチできるか確認する。できれば Matcher は MatcherContinuation が返した MatchState を返し、できなければ選択点での別の選択を試み、成功するか全可能性が尽きるまで MatcherContinuation を繰り返し呼ぶ。
          </li>
        </ul>

        <emu-clause id="sec-regexp-records">
          <h1>RegExp レコード</h1>
          <p><dfn variants="RegExp Records">RegExp Record</dfn> は、コンパイル中および必要に応じてマッチング中に RegExp について必要となる情報を保持するために用いられる Record 値である。</p>
          <p>次のフィールドを持つ:</p>
          <emu-table id="table-regexp-record-fields" caption="RegExp Record Fields">
            <table>
              <thead>
                <tr>
                  <th>Field Name</th>
                  <th>Value</th>
                  <th>Meaning</th>
                </tr>
              </thead>
              <tr>
                <td>[[IgnoreCase]]</td>
                <td>Boolean</td>
                <td>フラグに *"i"* が現れるか</td>
              </tr>
              <tr>
                <td>[[Multiline]]</td>
                <td>Boolean</td>
                <td>フラグに *"m"* が現れるか</td>
              </tr>
              <tr>
                <td>[[DotAll]]</td>
                <td>Boolean</td>
                <td>フラグに *"s"* が現れるか</td>
              </tr>
              <tr>
                <td>[[Unicode]]</td>
                <td>Boolean</td>
                <td>フラグに *"u"* が現れるか</td>
              </tr>
              <tr>
                <td>[[UnicodeSets]]</td>
                <td>Boolean</td>
                <td>フラグに *"v"* が現れるか</td>
              </tr>
              <tr>
                <td>[[CapturingGroupsCount]]</td>
                <td>非負整数</td>
                <td>パターン内の左捕捉括弧の数</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilepattern" type="sdo" oldids="sec-pattern">
        <h1>
          実行時セマンティクス: CompilePattern (
          _rer_: a RegExp Record,
          ): 文字の List と非負整数を取り MatchState か ~failure~ を返す抽象クロージャ
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <emu-alg>
          1. _m_ を |Disjunction| の CompileSubpattern (引数 _rer_, ~forward~) とする。
          1. _rer_ と _m_ を捕捉し、(_Input_, _index_) を引数に取り呼び出し時に以下を行う新しい抽象クロージャを返す:
            1. アサート: _Input_ は文字の List。
            1. アサート: 0 ≤ _index_ ≤ _Input_ の要素数。
            1. _c_ を (_y_) を引数に取り以下を行う新しい MatcherContinuation（何も捕捉しない）とする:
              1. アサート: _y_ は MatchState。
              1. _y_ を返す。
            1. _cap_ を _rer_.[[CapturingGroupsCount]] 個の *undefined* を 1 から _rer_.[[CapturingGroupsCount]] で索引付けした List とする。
            1. _x_ を MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ } とする。
            1. _m_(_x_, _c_) を返す。
        </emu-alg>
        <emu-note>
          <p>Pattern は抽象クロージャ値へコンパイルされる。RegExpBuiltinExec はその後、この手続を文字 List とその List 内のオフセットへ適用し、そのパターンがそのオフセットで正確にマッチするか、マッチするなら捕捉括弧の値が何であるかを決定できる。<emu-xref href="#sec-pattern-semantics"></emu-xref> のアルゴリズムは、パターンのコンパイル時に *SyntaxError* 例外を投げ得るよう設計されている。一方で、一度成功裏にコンパイルされた後、得られる抽象クロージャを用いて文字 List 内でマッチを探索する際には（メモリ不足など実装定義の例外を除き）例外は投げられない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-compilesubpattern" type="sdo" oldids="sec-disjunction,sec-alternative,sec-term">
        <h1>
          実行時セマンティクス: CompileSubpattern (
          _rer_: a RegExp Record,
          _direction_: ~forward~ または ~backward~,
          ): Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-compilesubpattern-annexb"></emu-xref> で修正される。</p>
        </emu-note>

        <!-- Disjunction -->
        <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar>
        <emu-alg>
          1. _m1_ を |Alternative| の CompileSubpattern (引数 _rer_, _direction_) とする。
          1. _m2_ を |Disjunction| の CompileSubpattern (引数 _rer_, _direction_) とする。
          1. MatchTwoAlternatives(_m1_, _m2_) を返す。
        </emu-alg>
        <emu-note>
          <p>`|` 演算子は 2 つの選択肢を分離する。まず左側の |Alternative|（および正規表現の後続）へのマッチを試み、失敗したら右側の |Disjunction|（および後続）を試みる。左 |Alternative|、右 |Disjunction|、後続がいずれも選択点を持つ場合、左 |Alternative| の次の選択へ進む前に後続内の全ての選択が試される。左 |Alternative| の選択が尽きたら、左 |Alternative| の代わりに右 |Disjunction| が試される。`|` によりスキップされたパターン部分内の捕捉括弧は *undefined* を生成する。例:</p>
          <pre><code class="javascript">/a|ab/.exec("abc")</code></pre>
          <p>は結果 *"a"* を返し *"ab"* ではない。また</p>
          <pre><code class="javascript">/((a)|(ab))((c)|(bc))/.exec("abc")</code></pre>
          <p>は配列</p>
          <pre><code class="javascript">["abc", "a", "a", undefined, "bc", undefined, "bc"]</code></pre>
          <p>を返し、</p>
          <pre><code class="javascript">["abc", "ab", undefined, "ab", "c", "c", undefined]</code></pre>
          <p>ではない。2 つの選択肢を試す順序は _direction_ の値と無関係。</p>
        </emu-note>

        <!-- Alternative -->
        <emu-grammar>Alternative :: [empty]</emu-grammar>
        <emu-alg>
          1. EmptyMatcher() を返す。
        </emu-alg>
        <emu-grammar>Alternative :: Alternative Term</emu-grammar>
        <emu-alg>
          1. _m1_ を |Alternative| の CompileSubpattern (引数 _rer_, _direction_) とする。
          1. _m2_ を |Term| の CompileSubpattern (引数 _rer_, _direction_) とする。
          1. MatchSequence(_m1_, _m2_, _direction_) を返す。
        </emu-alg>
        <emu-note>
          <p>連続する |Term| は _Input_ の連続部分に同時にマッチを試みる。_direction_ が ~forward~ のとき、左 |Alternative|、右 |Term|、後続がいずれも選択点を持つ場合、右 |Term| の次の選択へ進む前に後続内の全選択が試され、左 |Alternative| の次の選択へ進む前に右 |Term| の全選択が試される。_direction_ が ~backward~ のとき、|Alternative| と |Term| の評価順序は逆転する。</p>
        </emu-note>

        <!-- Term -->
        <emu-grammar>Term :: Assertion</emu-grammar>
        <emu-alg>
          1. |Assertion| の CompileAssertion (引数 _rer_) を返す。
        </emu-alg>
        <emu-note>
          <p>得られる Matcher は _direction_ に依存しない。</p>
        </emu-note>
        <emu-grammar>Term :: Atom</emu-grammar>
        <emu-alg>
          1. |Atom| の CompileAtom (引数 _rer_, _direction_) を返す。
        </emu-alg>
        <emu-grammar>Term :: Atom Quantifier</emu-grammar>
        <emu-alg>
          1. _m_ を |Atom| の CompileAtom (引数 _rer_, _direction_) とする。
          1. _q_ を |Quantifier| の CompileQuantifier とする。
          1. アサート: _q_.[[Min]] ≤ _q_.[[Max]].
          1. _parenIndex_ を CountLeftCapturingParensBefore(|Term|) とする。
          1. _parenCount_ を CountLeftCapturingParensWithin(|Atom|) とする。
          1. (_x_, _c_) を引数に取り _m_, _q_, _parenIndex_, _parenCount_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_) を返す。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-repeatmatcher-abstract-operation" type="abstract operation">
          <h1>
            RepeatMatcher (
              _m_: a Matcher,
              _min_: 非負整数,
              _max_: 非負整数 または +&infin;,
              _greedy_: Boolean,
              _x_: MatchState,
              _c_: MatcherContinuation,
              _parenIndex_: 非負整数,
              _parenCount_: 非負整数,
            ): MatchState または ~failure~
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _max_ = 0 なら _c_(_x_) を返す。
            1. (_y_) を引数に取り _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, _parenCount_ を捕捉し以下を行う新しい MatcherContinuation _d_ を作る:
              1. アサート: _y_ は MatchState。
              1. <span id="step-repeatmatcher-done">_min_ = 0 かつ _y_.[[EndIndex]] = _x_.[[EndIndex]] なら ~failure~ を返す。</span>
              1. _min_ = 0 なら _min2_ を 0、そうでなければ _min_ - 1。
              1. _max_ = +∞ なら _max2_ を +∞、そうでなければ _max_ - 1。
              1. RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_) を返す。
            1. _cap_ を _x_.[[Captures]] のコピーとする。
            1. <span id="step-repeatmatcher-clear-captures">_parenIndex_ + 1 から _parenIndex_ + _parenCount_ までの各整数 _k_ について _cap_[_k_] に *undefined* を設定する。</span>
            1. _Input_ を _x_.[[Input]] とする。
            1. _e_ を _x_.[[EndIndex]] とする。
            1. _xr_ を MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ } とする。
            1. _min_ ≠ 0 なら _m_(_xr_, _d_) を返す。
            1. _greedy_ が *false* なら
              1. _z_ を _c_(_x_) とする。
              1. _z_ が ~failure~ でなければ _z_ を返す。
              1. _m_(_xr_, _d_) を返す。
            1. _z_ を _m_(_xr_, _d_) とする。
            1. _z_ が ~failure~ でなければ _z_ を返す。
            1. _c_(_x_) を返す。
          </emu-alg>
          <emu-note>
            <p>|Atom| に |Quantifier| が続く場合、|Quantifier| に指定された回数だけ繰り返される。|Quantifier| は非貪欲 (non-greedy) の場合、後続にマッチしつつ可能な限り少ない回数繰り返され、貪欲 (greedy) の場合、後続にマッチしつつ可能な限り多く繰り返される。繰り返されるのは入力文字列ではなく |Atom| パターンであるため、各反復で異なる入力部分文字列にマッチし得る。</p>
          </emu-note>
          <emu-note>
            <p>|Atom| と後続の正規表現がいずれも選択点を持つ場合、まず |Atom| は可能な限り多く (非貪欲なら少なく) マッチする。後続内の全選択が試されてから、|Atom| の最後の反復で次の選択へ進む。最後 (n 回目) の反復の全選択が試されてから (n - 1) 回目の反復で次の選択へ進む。その時点で |Atom| の反復回数を増減できる可能性があり（再度、少ないか多いかから開始）、それらが尽きてから (n - 1) 回目の反復で次の選択へ進む……。</p>
            <p>比較:</p>
            <pre><code class="javascript">/a[a-z]{2,4}/.exec("abcdefghi")</code></pre>
            <p>は *"abcde"* を返し、</p>
            <pre><code class="javascript">/a[a-z]{2,4}?/.exec("abcdefghi")</code></pre>
            <p>は *"abc"* を返す。</p>
            <p>さらに:</p>
            <pre><code class="javascript">/(aa|aabaac|ba|b|c)*/.exec("aabaac")</code></pre>
            <p>は選択点の順序により配列</p>
            <pre><code class="javascript">["aaba", "ba"]</code></pre>
            <p>を返し、以下ではない:</p>
            <pre><code class="javascript">
              ["aabaac", "aabaac"]
              ["aabaac", "c"]
            </code></pre>
            <p>この選択点の順序は、単項表記の 2 つの数の最大公約数 (GCD) を計算する正規表現を書くのに利用できる。以下は 10 と 15 の gcd を計算する例:</p>
            <pre><code class="javascript">"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")</code></pre>
            <p>結果は単項表記の *"aaaaa"*。</p>
          </emu-note>
          <emu-note>
            <p>RepeatMatcher のステップ <emu-xref href="#step-repeatmatcher-clear-captures"></emu-xref> は |Atom| が繰り返されるたびにその捕捉をクリアする。次の正規表現で挙動が分かる:</p>
            <pre><code class="javascript">/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")</code></pre>
            <p>これは配列</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", undefined, "c"]</code></pre>
            <p>を返し、</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</code></pre>
            <p>ではない。これは外側の `*` の各反復が量指定された |Atom| に含まれる全捕捉文字列（ここでは 2, 3, 4, 5 番）をクリアするためである。</p>
          </emu-note>
          <emu-note>
            <p>RepeatMatcher のステップ <emu-xref href="#step-repeatmatcher-done"></emu-xref> は、最小反復回数が満たされた後、空文字列にマッチする |Atom| のさらなる展開は追加反復として考慮しないと述べる。これは以下のようなパターンで無限ループに陥るのを防ぐ:</p>
            <pre><code class="javascript">/(a*)*/.exec("b")</code></pre>
            <p>またはやや複雑な:</p>
            <pre><code class="javascript">/(a*)b\1+/.exec("baaaac")</code></pre>
            <p>これは配列</p>
            <pre><code class="javascript">["b", ""]</code></pre>
            <p>を返す。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-emptymatcher" type="abstract operation">
          <h1>EmptyMatcher ( ): Matcher</h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. (_x_, _c_) を引数に取り何も捕捉せず以下を行う新しい Matcher を返す:
              1. アサート: _x_ は MatchState。
              1. アサート: _c_ は MatcherContinuation。
              1. _c_(_x_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchtwoalternatives" type="abstract operation">
          <h1>
            MatchTwoAlternatives (
              _m1_: Matcher,
              _m2_: Matcher,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. (_x_, _c_) を引数に取り _m1_, _m2_ を捕捉し以下を行う新しい Matcher を返す:
              1. アサート: _x_ は MatchState。
              1. アサート: _c_ は MatcherContinuation。
              1. _r_ を _m1_(_x_, _c_) とする。
              1. _r_ が ~failure~ でなければ _r_ を返す。
              1. _m2_(_x_, _c_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchsequence" type="abstract operation">
          <h1>
            MatchSequence (
              _m1_: Matcher,
              _m2_: Matcher,
              _direction_: ~forward~ または ~backward~,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _direction_ が ~forward~ なら
              1. (_x_, _c_) を引数に取り _m1_, _m2_ を捕捉し以下を行う新しい Matcher を返す:
                1. アサート: _x_ は MatchState。
                1. アサート: _c_ は MatcherContinuation。
                1. (_y_) を引数に取り _c_, _m2_ を捕捉し以下を行う新しい MatcherContinuation _d_ を作る:
                  1. アサート: _y_ は MatchState。
                  1. _m2_(_y_, _c_) を返す。
                1. _m1_(_x_, _d_) を返す。
            1. それ以外
              1. アサート: _direction_ は ~backward~。
              1. (_x_, _c_) を引数に取り _m1_, _m2_ を捕捉し以下を行う新しい Matcher を返す:
                1. アサート: _x_ は MatchState。
                1. アサート: _c_ は MatcherContinuation。
                1. (_y_) を引数に取り _c_, _m1_ を捕捉し以下を行う新しい MatcherContinuation _d_ を作る:
                  1. アサート: _y_ は MatchState。
                  1. _m1_(_y_, _c_) を返す。
                1. _m2_(_x_, _d_) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileassertion" type="sdo" oldids="sec-assertion">
        <h1>
          実行時セマンティクス: CompileAssertion (
          _rer_: a RegExp Record,
          ): Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-compileassertion-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-grammar>Assertion :: `^`</emu-grammar>
        <emu-alg>
          1. (_x_, _c_) を引数に取り _rer_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. _Input_ を _x_.[[Input]] とする。
            1. _e_ を _x_.[[EndIndex]] とする。
            1. _e_ = 0 または _rer_.[[Multiline]] が *true* かつ 文字 _Input_[_e_ - 1] が |LineTerminator| にマッチするなら
              1. _c_(_x_) を返す。
            1. ~failure~ を返す。
        </emu-alg>
        <emu-note>
          <p>`y` フラグがパターンに使われている場合でも、`^` は常に _Input_ の先頭、または (_rer_.[[Multiline]] が *true* の場合) 行頭にのみマッチする。</p>
        </emu-note>
        <emu-grammar>Assertion :: `$`</emu-grammar>
        <emu-alg>
          1. (_x_, _c_) を引数に取り _rer_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. _Input_ を _x_.[[Input]] とする。
            1. _e_ を _x_.[[EndIndex]] とする。
            1. _InputLength_ を _Input_ の要素数とする。
            1. _e_ = _InputLength_ または _rer_.[[Multiline]] が *true* かつ 文字 _Input_[_e_] が |LineTerminator| にマッチするなら
              1. _c_(_x_) を返す。
            1. ~failure~ を返す。
        </emu-alg>
        <emu-grammar>Assertion :: `\b`</emu-grammar>
        <emu-alg>
          1. (_x_, _c_) を引数に取り _rer_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. _Input_ を _x_.[[Input]] とする。
            1. _e_ を _x_.[[EndIndex]] とする。
            1. _a_ を IsWordChar(_rer_, _Input_, _e_ - 1) とする。
            1. _b_ を IsWordChar(_rer_, _Input_, _e_) とする。
            1. (_a_ が *true* かつ _b_ が *false*) または (_a_ が *false* かつ _b_ が *true*) なら _c_(_x_) を返す。
            1. ~failure~ を返す。
        </emu-alg>
        <emu-grammar>Assertion :: `\B`</emu-grammar>
        <emu-alg>
          1. (_x_, _c_) を引数に取り _rer_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. _Input_ を _x_.[[Input]] とする。
            1. _e_ を _x_.[[EndIndex]] とする。
            1. _a_ を IsWordChar(_rer_, _Input_, _e_ - 1) とする。
            1. _b_ を IsWordChar(_rer_, _Input_, _e_) とする。
            1. (_a_ が *true* かつ _b_ が *true*) または (_a_ が *false* かつ _b_ が *false*) なら _c_(_x_) を返す。
            1. ~failure~ を返す。
        </emu-alg>
        <emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ を |Disjunction| の CompileSubpattern (引数 _rer_, ~forward~) とする。
          1. (_x_, _c_) を引数に取り _m_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. (_y_) を引数に取り何も捕捉しない新しい MatcherContinuation _d_ を作る:
              1. アサート: _y_ は MatchState。
              1. _y_ を返す。
            1. _r_ を _m_(_x_, _d_) とする。
            1. _r_ が ~failure~ なら ~failure~ を返す。
            1. アサート: _r_ は MatchState。
            1. _cap_ を _r_.[[Captures]] とする。
            1. _Input_ を _x_.[[Input]] とする。
            1. _xe_ を _x_.[[EndIndex]] とする。
            1. _z_ を MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ } とする。
            1. _c_(_z_) を返す。
        </emu-alg>
        <emu-note>
          <p>`(?=` |Disjunction| `)` 形式はゼロ幅正の先読み。成功するには |Disjunction| 内のパターンが現在位置でマッチしなければならないが、後続をマッチする前に現在位置は進まない。|Disjunction| が現在位置で複数のマッチ方法を持つ場合、最初の 1 つのみ試す。他の演算子と異なり、`(?=` 形式内へのバックトラッキングは行われない (Perl 由来)。これは |Disjunction| が捕捉括弧を含み、パターン後続がそれらへの後方参照を含む場合のみ影響する。</p>
          <p>例:</p>
          <pre><code class="javascript">/(?=(a+))/.exec("baaabac")</code></pre>
          <p>は最初の `b` の直後で空文字列にマッチし、配列:</p>
          <pre><code class="javascript">["", "aaa"]</code></pre>
          <p>を返す。先読み内へのバックトラッキング欠如を示すため:</p>
          <pre><code class="javascript">/(?=(a+))a*b\1/.exec("baaabac")</code></pre>
          <p>は</p>
          <pre><code class="javascript">["aba", "a"]</code></pre>
          <p>を返し、</p>
          <pre><code class="javascript">["aaaba", "a"]</code></pre>
          <p>ではない。</p>
        </emu-note>
        <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ を |Disjunction| の CompileSubpattern (引数 _rer_, ~forward~) とする。
          1. (_x_, _c_) を引数に取り _m_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. (_y_) を引数に取り何も捕捉しない MatcherContinuation _d_ を作る:
              1. アサート: _y_ は MatchState。
              1. _y_ を返す。
            1. _r_ を _m_(_x_, _d_) とする。
            1. _r_ が ~failure~ でなければ ~failure~ を返す。
            1. _c_(_x_) を返す。
        </emu-alg>
        <emu-note>
          <p>`(?!` |Disjunction| `)` 形式はゼロ幅負の先読み。成功には |Disjunction| 内のパターンが現在位置でマッチに失敗する必要がある。現在位置は後続をマッチする前に進まない。|Disjunction| は捕捉括弧を含み得るが、それらへの後方参照は |Disjunction| 内部でのみ意味を持つ。この負の先読みが成功するには失敗が必要であり、負の先読み外からのその捕捉への後方参照は常に *undefined* を返す。例:</p>
          <pre><code class="javascript">/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")</code></pre>
          <p>は「a の直後に n (>0) 個の a、b、さらに n 個の a (`\\2`)、c」が続かない a を探す。2 つ目の `\\2` は負の先読みの外なので *undefined* にマッチし常に成功する。式は配列:</p>
          <pre><code class="javascript">["baaabaac", "ba", undefined, "abaac"]</code></pre>
          <p>を返す。</p>
        </emu-note>
        <emu-grammar>Assertion :: `(?&lt;=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ を |Disjunction| の CompileSubpattern (引数 _rer_, ~backward~) とする。
          1. (_x_, _c_) を引数に取り _m_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. (_y_) を引数に取り何も捕捉しない MatcherContinuation _d_ を作る:
              1. アサート: _y_ は MatchState。
              1. _y_ を返す。
            1. _r_ を _m_(_x_, _d_) とする。
            1. _r_ が ~failure~ なら ~failure~ を返す。
            1. アサート: _r_ は MatchState。
            1. _cap_ を _r_.[[Captures]] とする。
            1. _Input_ を _x_.[[Input]] とする。
            1. _xe_ を _x_.[[EndIndex]] とする。
            1. _z_ を MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ } とする。
            1. _c_(_z_) を返す。
        </emu-alg>
        <emu-grammar>Assertion :: `(?&lt;!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ を |Disjunction| の CompileSubpattern (引数 _rer_, ~backward~) とする。
          1. (_x_, _c_) を引数に取り _m_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. (_y_) を引数に取り何も捕捉しない MatcherContinuation _d_ を作る:
              1. アサート: _y_ は MatchState。
              1. _y_ を返す。
            1. _r_ を _m_(_x_, _d_) とする。
            1. _r_ が ~failure~ でなければ ~failure~ を返す。
            1. _c_(_x_) を返す。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-iswordchar-abstract-operation" type="abstract operation">
          <h1>
            IsWordChar (
              _rer_: a RegExp Record,
              _Input_: 文字の List,
              _e_: 整数,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _InputLength_ を _Input_ の要素数とする。
            1. _e_ = -1 または _e_ = _InputLength_ なら *false* を返す。
            1. _c_ を _Input_[_e_] の文字とする。
            1. WordCharacters(_rer_) に _c_ が含まれるなら *true* を返す。
            1. *false* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilequantifier" type="sdo" oldids="sec-quantifier">
        <h1>実行時セマンティクス: CompileQuantifier ( ): フィールド [[Min]] (非負整数), [[Max]] (非負整数または +∞), [[Greedy]] (Boolean) を持つ Record</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Quantifier :: QuantifierPrefix</emu-grammar>
        <emu-alg>
          1. _qp_ を |QuantifierPrefix| の CompileQuantifierPrefix とする。
          1. Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* } を返す。
        </emu-alg>
        <emu-grammar>Quantifier :: QuantifierPrefix `?`</emu-grammar>
        <emu-alg>
          1. _qp_ を |QuantifierPrefix| の CompileQuantifierPrefix とする。
          1. Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compilequantifierprefix" type="sdo">
        <h1>実行時セマンティクス: CompileQuantifierPrefix ( ): フィールド [[Min]] (非負整数), [[Max]] (非負整数または +∞) を持つ Record</h1>
        <dl class="header">
        </dl>
        <emu-grammar>QuantifierPrefix :: `*`</emu-grammar>
        <emu-alg>
          1. Record { [[Min]]: 0, [[Max]]: +∞ } を返す。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `+`</emu-grammar>
        <emu-alg>
          1. Record { [[Min]]: 1, [[Max]]: +∞ } を返す。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `?`</emu-grammar>
        <emu-alg>
          1. Record { [[Min]]: 0, [[Max]]: 1 } を返す。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. _i_ を |DecimalDigits| の MV (<emu-xref href="#sec-literals-numeric-literals"></emu-xref> 参照) とする。
          1. Record { [[Min]]: _i_, [[Max]]: _i_ } を返す。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,}`</emu-grammar>
        <emu-alg>
          1. _i_ を |DecimalDigits| の MV とする。
          1. Record { [[Min]]: _i_, [[Max]]: +∞ } を返す。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. _i_ を最初の |DecimalDigits| の MV とする。
          1. _j_ を 2 番目の |DecimalDigits| の MV とする。
          1. Record { [[Min]]: _i_, [[Max]]: _j_ } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compileatom" type="sdo" oldids="sec-atom,sec-atomescape,sec-characterescape,sec-decimalescape">
        <h1>
          実行時セマンティクス: CompileAtom (
          _rer_: a RegExp Record,
          _direction_: ~forward~ または ~backward~,
          ): Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-compileatom-annexb"></emu-xref> で修正される。</p>
        </emu-note>

        <!-- Atom -->
        <emu-grammar>Atom :: PatternCharacter</emu-grammar>
        <emu-alg>
          1. _ch_ を |PatternCharacter| にマッチした文字とする。
          1. _A_ を文字 _ch_ を含む 1 要素 CharSet とする。
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) を返す。
        </emu-alg>
        <emu-grammar>Atom :: `.`</emu-grammar>
        <emu-alg>
          1. _A_ を AllCharacters(_rer_) とする。
          1. _rer_.[[DotAll]] が *true* でなければ
            1. |LineTerminator| 生成規則右辺のコードポイントに対応する全ての文字を _A_ から除去する。
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) を返す。
        </emu-alg>
        <emu-grammar>Atom :: CharacterClass</emu-grammar>
        <emu-alg>
          1. _cc_ を |CharacterClass| の CompileCharacterClass (引数 _rer_) とする。
          1. _cs_ を _cc_.[[CharSet]] とする。
          1. _rer_.[[UnicodeSets]] が *false* または _cs_ の全 CharSetElement が単一文字（_cs_ が空の場合を含む）から成るなら CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_) を返す。
          1. アサート: _cc_.[[Invert]] は *false*。
          1. _lm_ を空の Matcher の List とする。
          1. _cs_ 内で 1 文字を超える文字列を含む各 CharSetElement _s_ について長さ降順で:
            1. _cs2_ を _s_ の最後のコードポイントを含む 1 要素 CharSet とする。
            1. _m2_ を CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_)。
            1. _s_ の 2 番目から最後の 1 つ前までの各コードポイント _c1_ を逆順で:
              1. _cs1_ を _c1_ を含む 1 要素 CharSet とする。
              1. _m1_ を CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_)。
              1. _m2_ を MatchSequence(_m1_, _m2_, _direction_) に更新。
            1. _m2_ を _lm_ に追加。
          1. _singles_ を _cs_ のうち単一文字から成る全 CharSetElement を含む CharSet とする。
          1. CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) を _lm_ に追加。
          1. _cs_ が空文字列を含むなら EmptyMatcher() を _lm_ に追加。
          1. _m2_ を _lm_ の最後の Matcher とする。
          1. _lm_ の 2 番目から最後の要素を逆順に各 Matcher _m1_ について
            1. _m2_ を MatchTwoAlternatives(_m1_, _m2_) に更新。
          1. _m2_ を返す。
        </emu-alg>
        <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ を |Disjunction| の CompileSubpattern (引数 _rer_, _direction_) とする。
          1. _parenIndex_ を CountLeftCapturingParensBefore(|Atom|) とする。
          1. (_x_, _c_) を引数に取り _direction_, _m_, _parenIndex_ を捕捉し以下を行う新しい Matcher を返す:
            1. アサート: _x_ は MatchState。
            1. アサート: _c_ は MatcherContinuation。
            1. (_y_) を引数に取り _x_, _c_, _direction_, _parenIndex_ を捕捉し以下を行う新しい MatcherContinuation _d_ を作る:
              1. アサート: _y_ は MatchState。
              1. _cap_ を _y_.[[Captures]] のコピーとする。
              1. _Input_ を _x_.[[Input]] とする。
              1. _xe_ を _x_.[[EndIndex]] とする。
              1. _ye_ を _y_.[[EndIndex]] とする。
              1. _direction_ が ~forward~ なら
                1. アサート: _xe_ ≤ _ye_。
                1. _r_ を CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ } とする。
              1. それ以外
                1. アサート: _direction_ は ~backward~。
                1. アサート: _ye_ ≤ _xe_。
                1. _r_ を CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ } とする。
              1. _cap_[_parenIndex_ + 1] に _r_ を設定。
              1. _z_ を MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ } とする。
              1. _c_(_z_) を返す。
            1. _m_(_x_, _d_) を返す。
        </emu-alg>
        <emu-note>
          <p>`(` |Disjunction| `)` 形式の括弧は |Disjunction| パターンの構成要素をグループ化し、マッチ結果を保存する。結果は後方参照（`\\` + 非ゼロ 10 進数）、置換文字列で参照、または正規表現マッチ抽象クロージャが返す配列の一部として利用できる。捕捉挙動を抑止するには `(?:` |Disjunction| `)` を用いる。</p>
        </emu-note>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _addModifiers_ を |RegularExpressionModifiers| にマッチしたソーステキストとする。
          1. _removeModifiers_ を空文字列とする。
          1. _modifiedRer_ を UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), _removeModifiers_) とする。
          1. |Disjunction| の CompileSubpattern (引数 _modifiedRer_, _direction_) を返す。
        </emu-alg>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _addModifiers_ を最初の |RegularExpressionModifiers| にマッチしたソーステキストとする。
          1. _removeModifiers_ を 2 番目の |RegularExpressionModifiers| にマッチしたソーステキストとする。
          1. _modifiedRer_ を UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), CodePointsToString(_removeModifiers_)) とする。
          1. |Disjunction| の CompileSubpattern (引数 _modifiedRer_, _direction_) を返す。
        </emu-alg>

        <!-- AtomEscape -->
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <emu-alg>
          1. _n_ を |DecimalEscape| の CapturingGroupNumber とする。
          1. アサート: _n_ ≤ _rer_.[[CapturingGroupsCount]]。
          1. BackreferenceMatcher(_rer_, « _n_ », _direction_) を返す。
        </emu-alg>
        <emu-note>
          <p>`\\` に非ゼロ 10 進数 _n_ が続くエスケープは _n_ 番目の捕捉括弧集合の結果にマッチする (<emu-xref href="#sec-pattern-notation"></emu-xref>)。正規表現内の捕捉括弧数が _n_ 未満ならエラー。_n_ 以上あるが _n_ 番目が何も捕捉せず *undefined* なら後方参照は常に成功する。</p>
        </emu-note>
        <emu-grammar>AtomEscape :: CharacterEscape</emu-grammar>
        <emu-alg>
          1. _cv_ を |CharacterEscape| の CharacterValue とする。
          1. _ch_ を character value が _cv_ の文字とする。
          1. _A_ を文字 _ch_ を含む 1 要素 CharSet とする。
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) を返す。
        </emu-alg>
        <emu-grammar>AtomEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. _cs_ を |CharacterClassEscape| の CompileToCharSet (引数 _rer_) とする。
          1. _rer_.[[UnicodeSets]] が *false* または _cs_ の全 CharSetElement が単一文字（_cs_ が空の場合含む）から成るなら CharacterSetMatcher(_rer_, _cs_, *false*, _direction_) を返す。
          1. _lm_ を空の Matcher の List とする。
          1. _cs_ 内で 1 文字を超える文字列を含む各 CharSetElement _s_ について長さ降順で:
            1. _cs2_ を _s_ の最後のコードポイントを含む 1 要素 CharSet とする。
            1. _m2_ を CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_)。
            1. _s_ の 2 番目から最後の 1 つ前までの各コードポイント _c1_ を逆順で:
              1. _cs1_ を _c1_ を含む 1 要素 CharSet。
              1. _m1_ を CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_)。
              1. _m2_ を MatchSequence(_m1_, _m2_, _direction_) に更新。
            1. _m2_ を _lm_ に追加。
          1. _singles_ を _cs_ のうち単一文字から成る全 CharSetElement を含む CharSet とする。
          1. CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) を _lm_ に追加。
          1. _cs_ が空文字列を含むなら EmptyMatcher() を _lm_ に追加。
          1. _m2_ を _lm_ の最後の Matcher に。
          1. _lm_ の 2 番目から最後の要素を逆順に各 _m1_ について
            1. _m2_ を MatchTwoAlternatives(_m1_, _m2_) に更新。
          1. _m2_ を返す。
        </emu-alg>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <emu-alg>
          1. _matchingGroupSpecifiers_ を GroupSpecifiersThatMatch(|GroupName|) とする。
          1. _parenIndices_ を新しい空 List とする。
          1. _matchingGroupSpecifiers_ の各 |GroupSpecifier| _groupSpecifier_ について
            1. _parenIndex_ を CountLeftCapturingParensBefore(_groupSpecifier_) とする。
            1. _parenIndex_ を _parenIndices_ に追加。
          1. BackreferenceMatcher(_rer_, _parenIndices_, _direction_) を返す。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-charactersetmatcher-abstract-operation" type="abstract operation">
          <h1>
            CharacterSetMatcher (
              _rer_: a RegExp Record,
              _A_: CharSet,
              _invert_: Boolean,
              _direction_: ~forward~ または ~backward~,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]] が *true* なら
              1. アサート: _invert_ は *false*。
              1. アサート: _A_ の全 CharSetElement は単一文字。
            1. (_x_, _c_) を引数に取り _rer_, _A_, _invert_, _direction_ を捕捉し以下を行う新しい Matcher を返す:
              1. アサート: _x_ は MatchState。
              1. アサート: _c_ は MatcherContinuation。
              1. _Input_ を _x_.[[Input]] とする。
              1. _e_ を _x_.[[EndIndex]] とする。
              1. _direction_ が ~forward~ なら _f_ を _e_ + 1 とし、そうでなければ _f_ を _e_ - 1。
              1. _InputLength_ を _Input_ の要素数とする。
              1. _f_ &lt; 0 または _f_ > _InputLength_ なら ~failure~。
              1. _index_ を min(_e_, _f_) とする。
              1. _ch_ を _Input_[_index_] の文字とする。
              1. _cc_ を Canonicalize(_rer_, _ch_) とする。
              1. _A_ 内に正確に 1 文字 _a_ を含む CharSetElement が存在し、Canonicalize(_rer_, _a_) が _cc_ なら _found_ を *true*、そうでなければ *false*。
              1. _invert_ が *false* かつ _found_ が *false* なら ~failure~。
              1. _invert_ が *true* かつ _found_ が *true* なら ~failure~。
              1. _cap_ を _x_.[[Captures]] とする。
              1. _y_ を MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ } とする。
              1. _c_(_y_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-backreference-matcher" type="abstract operation">
          <h1>
            BackreferenceMatcher (
              _rer_: a RegExp Record,
              _ns_: 正の整数の List,
              _direction_: ~forward~ または ~backward~,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. (_x_, _c_) を引数に取り _rer_, _ns_, _direction_ を捕捉し以下を行う新しい Matcher を返す:
              1. アサート: _x_ は MatchState。
              1. アサート: _c_ は MatcherContinuation。
              1. _Input_ を _x_.[[Input]] とする。
              1. _cap_ を _x_.[[Captures]] とする。
              1. _r_ を *undefined* とする。
              1. 各整数 _n_ ∈ _ns_ について
                1. _cap_[_n_] が *undefined* でなければ
                  1. アサート: _r_ は *undefined*。
                  1. _r_ を _cap_[_n_] に設定。
              1. _r_ が *undefined* なら _c_(_x_) を返す。
              1. _e_ を _x_.[[EndIndex]] とする。
              1. _rs_ を _r_.[[StartIndex]] とする。
              1. _re_ を _r_.[[EndIndex]] とする。
              1. _len_ を _re_ - _rs_ とする。
              1. _direction_ が ~forward~ なら _f_ を _e_ + _len_、そうでなければ _f_ を _e_ - _len_。
              1. _InputLength_ を _Input_ の要素数とする。
              1. _f_ &lt; 0 または _f_ > _InputLength_ なら ~failure~。
              1. _g_ を min(_e_, _f_) とする。
              1. 0 ≤ _i_ &lt; _len_ の整数 _i_ で Canonicalize(_rer_, _Input_[_rs_ + _i_]) ≠ Canonicalize(_rer_, _Input_[_g_ + _i_]) となるものが存在するなら ~failure~。
              1. _y_ を MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ } とする。
              1. _c_(_y_) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-canonicalize-ch" type="abstract operation">
          <h1>
            Canonicalize (
              _rer_: a RegExp Record,
              _ch_: 文字,
            ): 文字
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. HasEitherUnicodeFlag(_rer_) が *true* かつ _rer_.[[IgnoreCase]] が *true* なら
              1. Unicode Character Database の <a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a> が _ch_ に単純または共通のケースフォールディングを提供するなら、その写像結果を返す。
              1. _ch_ を返す。
            1. _rer_.[[IgnoreCase]] が *false* なら _ch_ を返す。
            1. アサート: _ch_ は UTF-16 コードユニット。
            1. _cp_ を数値が _ch_ の数値と等しいコードポイントとする。
            1. _u_ を Unicode 既定ケース変換アルゴリズムに従い toUppercase(« _cp_ ») とする。
            1. _uStr_ を CodePointsToString(_u_) とする。
            1. _uStr_ の長さ ≠ 1 なら _ch_ を返す。
            1. _cu_ を _uStr_ の単一コードユニット要素とする。
            1. _ch_ の数値 ≥ 128 かつ _cu_ の数値 &lt; 128 なら _ch_ を返す。
            1. _cu_ を返す。
          </emu-alg>
          <emu-note>
            <p>HasEitherUnicodeFlag(_rer_) が *true* の大文字小文字無視マッチでは、比較直前に全ての文字が Unicode 標準の simple case folding により暗黙にフォールディングされる。simple mapping は常に単一コードポイントへ写像するため `ß` は `ss` や `SS` には写らない。基本ラテンブロック外から内へ写像する場合がある (例: `ſ` → `s`, `K` → `k`)。これらを含む文字列は `/[a-z]/ui` などでマッチする。</p>
            <p>HasEitherUnicodeFlag(_rer_) が *false* の大文字小文字無視マッチでは toCasefold ではなく toUppercase に基づくため差異がある。例: `Ω` は toUppercase では自身、toCasefold では `ω` に写るため *"\u2126"* は `/[ω]/ui` や `/[\u03A9]/ui` にマッチするが `/[ω]/i` や `/[\u03A9]/i` にはマッチしない。また基本ラテン外から内への写像は行われないので *"\u017F ſ"*, *"\u212A K"* は `/[a-z]/i` にマッチしない。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-updatemodifiers" type="abstract operation">
          <h1>
            UpdateModifiers (
              _rer_: a RegExp Record,
              _add_: String,
              _remove_: String,
            ): RegExp Record
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. アサート: _add_ と _remove_ は共通要素を持たない。
            1. _ignoreCase_ を _rer_.[[IgnoreCase]]。
            1. _multiline_ を _rer_.[[Multiline]]。
            1. _dotAll_ を _rer_.[[DotAll]]。
            1. _unicode_ を _rer_.[[Unicode]]。
            1. _unicodeSets_ を _rer_.[[UnicodeSets]]。
            1. _capturingGroupsCount_ を _rer_.[[CapturingGroupsCount]]。
            1. _remove_ に *"i"* が含まれるなら _ignoreCase_ を *false* に。
            1. そうでなく _add_ に *"i"* が含まれるなら _ignoreCase_ を *true* に。
            1. _remove_ に *"m"* が含まれるなら _multiline_ を *false* に。
            1. そうでなく _add_ に *"m"* が含まれるなら _multiline_ を *true* に。
            1. _remove_ に *"s"* が含まれるなら _dotAll_ を *false* に。
            1. そうでなく _add_ に *"s"* が含まれるなら _dotAll_ を *true* に。
            1. RegExp Record { [[IgnoreCase]]: _ignoreCase_, [[Multiline]]: _multiline_, [[DotAll]]: _dotAll_, [[Unicode]]: _unicode_, [[UnicodeSets]]: _unicodeSets_, [[CapturingGroupsCount]]: _capturingGroupsCount_ } を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilecharacterclass" type="sdo" oldids="sec-characterclass">
        <h1>
          実行時セマンティクス: CompileCharacterClass (
          _rer_: a RegExp Record,
          ): フィールド [[CharSet]] (CharSet), [[Invert]] (Boolean) を持つ Record
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>CharacterClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassContents| の CompileToCharSet (引数 _rer_) とする。
          1. Record { [[CharSet]]: _A_, [[Invert]]: *false* } を返す。
        </emu-alg>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassContents| の CompileToCharSet (引数 _rer_) とする。
          1. _rer_.[[UnicodeSets]] が *true* なら
            1. Record { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* } を返す。
          1. Record { [[CharSet]]: _A_, [[Invert]]: *true* } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compiletocharset" type="sdo" oldids="sec-classranges,sec-nonemptyclassranges,sec-nonemptyclassrangesnodash,sec-classatom,sec-classatomnodash,sec-classescape,sec-characterclassescape">
        <h1>
          実行時セマンティクス: CompileToCharSet (
          _rer_: a RegExp Record,
          ): CharSet
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-compiletocharset-annexb"></emu-xref> で修正される。</p>
        </emu-note>

        <!-- ClassContents -->
        <emu-grammar>ClassContents :: [empty]</emu-grammar>
        <emu-alg>
          1. 空の CharSet を返す。
        </emu-alg>

        <!-- NonemptyClassRanges -->
        <emu-grammar>NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassAtom| の CompileToCharSet (引数 _rer_)。
          1. _B_ を |NonemptyClassRangesNoDash| の CompileToCharSet (引数 _rer_)。
          1. CharSet _A_ と _B_ の和集合を返す。
        </emu-alg>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ を最初の |ClassAtom| の CompileToCharSet (引数 _rer_)。
          1. _B_ を 2 番目の |ClassAtom| の CompileToCharSet (引数 _rer_)。
          1. _C_ を |ClassContents| の CompileToCharSet (引数 _rer_)。
          1. _D_ を CharacterRange(_A_, _B_)。
          1. _D_ と _C_ の和集合を返す。
        </emu-alg>

        <!-- NonemptyClassRangesNoDash -->
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassAtomNoDash| の CompileToCharSet (引数 _rer_)。
          1. _B_ を |NonemptyClassRangesNoDash| の CompileToCharSet (引数 _rer_)。
          1. CharSet _A_ と _B_ の和集合を返す。
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassAtomNoDash| の CompileToCharSet (引数 _rer_)。
          1. _B_ を |ClassAtom| の CompileToCharSet (引数 _rer_)。
          1. _C_ を |ClassContents| の CompileToCharSet (引数 _rer_)。
          1. _D_ を CharacterRange(_A_, _B_)。
          1. _D_ と _C_ の和集合を返す。
        </emu-alg>
        <emu-note>
          <p>|ClassContents| は単一の |ClassAtom|、およびダッシュで区切られた 2 つの |ClassAtom| の範囲になり得る。後者の場合、|ClassContents| には第 1 と第 2 の |ClassAtom| 間（含む）の全ての文字が含まれる。どちらかの |ClassAtom| が単一文字を表さない (例: \w) 場合、または第 1 の |ClassAtom| の character value が第 2 のそれより大きい場合はエラー。</p>
        </emu-note>
        <emu-note>
          <p>パターンが大文字小文字を無視する場合でも、範囲両端の大文字小文字は範囲に含まれる文字を決定する上で重要。例: `/[E-F]/i` は `E`, `F`, `e`, `f` のみ、`/[E-f]/i` は Unicode Basic Latin ブロックの全大文字小文字および `[`, `\\`, `]`, `^`, `_`, <code>`</code> にマッチ。</p>
        </emu-note>
        <emu-note>
          <p>`-` は文字通りにも範囲指定にも使える。|ClassContents| の先頭または末尾、範囲指定の開始/終了端、または範囲指定直後に現れる場合はリテラルとして扱われる。</p>
        </emu-note>

        <!-- ClassAtom -->
        <emu-grammar>ClassAtom :: `-`</emu-grammar>
        <emu-alg>
          1. 単一文字 `-` U+002D (HYPHEN-MINUS) を含む CharSet を返す。
        </emu-alg>

        <!-- ClassAtomNoDash -->
        <emu-grammar>ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`</emu-grammar>
        <emu-alg>
          1. |SourceCharacter| にマッチした文字を含む CharSet を返す。
        </emu-alg>

        <!-- ClassEscape -->
        <emu-grammar>
          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. _cv_ をこの |ClassEscape| の CharacterValue。
          1. _c_ を character value が _cv_ の文字。
          1. _c_ を含む 1 要素 CharSet を返す。
        </emu-alg>
        <emu-note>
          <p>|ClassAtom| 内では、`\\b`, `\\B`, 後方参照を除く正規表現中で許されるエスケープを利用できる。|CharacterClass| 内では `\\b` はバックスペース文字、`\\B` と後方参照はエラー。|ClassAtom| 内で後方参照を用いるとエラー。</p>
        </emu-note>

        <!-- CharacterClassEscape -->
        <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>
        <emu-alg>
          1. 文字 `0`〜`9` を含む 10 要素 CharSet を返す。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `D`</emu-grammar>
        <emu-alg>
          1. _S_ を <emu-grammar>CharacterClassEscape :: `d`</emu-grammar> の返す CharSet とする。
          1. CharacterComplement(_rer_, _S_) を返す。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>
        <emu-alg>
          1. |WhiteSpace| または |LineTerminator| 生成規則右辺のコードポイントに対応する全ての文字を含む CharSet を返す。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `S`</emu-grammar>
        <emu-alg>
          1. _S_ を <emu-grammar>CharacterClassEscape :: `s`</emu-grammar> の返す CharSet とする。
          1. CharacterComplement(_rer_, _S_) を返す。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>
        <emu-alg>
          1. MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_)) を返す。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `W`</emu-grammar>
        <emu-alg>
          1. _S_ を <emu-grammar>CharacterClassEscape :: `w`</emu-grammar> の返す CharSet とする。
          1. CharacterComplement(_rer_, _S_) を返す。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `p{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. |UnicodePropertyValueExpression| の CompileToCharSet (引数 _rer_) を返す。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. _S_ を |UnicodePropertyValueExpression| の CompileToCharSet (引数 _rer_) とする。
          1. アサート: _S_ は単一コードポイントのみ含む。
          1. CharacterComplement(_rer_, _S_) を返す。
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <emu-alg>
          1. _ps_ を |UnicodePropertyName| にマッチしたソーステキスト。
          1. _p_ を UnicodeMatchProperty(_rer_, _ps_)。
          1. アサート: _p_ は <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> の「Property name and aliases」に列挙される Unicode プロパティ名またはエイリアス。
          1. _vs_ を |UnicodePropertyValue| にマッチしたソーステキスト。
          1. _v_ を UnicodeMatchPropertyValue(_p_, _vs_)。
          1. _A_ をプロパティ _p_ が値 _v_ を持つ全 Unicode コードポイントを含む CharSet。
          1. MaybeSimpleCaseFolding(_rer_, _A_) を返す。
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. _s_ を |LoneUnicodePropertyNameOrValue| にマッチしたソーステキスト。
          1. UnicodeMatchPropertyValue(`General_Category`, _s_) が General_Category (gc) のプロパティ値または値エイリアス（<code>PropertyValueAliases.txt</code>）なら
            1. プロパティ “General_Category” が値 _s_ を持つ全 Unicode コードポイントを含む CharSet を返す。
          1. _p_ を UnicodeMatchProperty(_rer_, _s_)。
          1. アサート: _p_ は <emu-xref href="#table-binary-unicode-properties"></emu-xref> の「Property name and aliases」列、または <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> の「Property name」列に列挙されるバイナリ Unicode プロパティ / そのエイリアス / 文字列のバイナリプロパティ。
          1. _A_ をプロパティ _p_ が値 “True” を持つ全 CharSetElement を含む CharSet。
          1. MaybeSimpleCaseFolding(_rer_, _A_) を返す。
        </emu-alg>

        <!-- ClassUnion -->
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassSetRange| の CompileToCharSet (引数 _rer_)。
          1. |ClassUnion| が存在するなら
            1. _B_ を |ClassUnion| の CompileToCharSet (引数 _rer_)。
            1. CharSet _A_ と _B_ の和集合を返す。
          1. _A_ を返す。
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassSetOperand| の CompileToCharSet (引数 _rer_)。
          1. |ClassUnion| が存在するなら
            1. _B_ を |ClassUnion| の CompileToCharSet (引数 _rer_)。
            1. CharSet _A_ と _B_ の和集合を返す。
          1. _A_ を返す。
        </emu-alg>

        <!-- ClassIntersection -->
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. _A_ を最初の |ClassSetOperand| の CompileToCharSet (引数 _rer_)。
          1. _B_ を 2 番目の |ClassSetOperand| の CompileToCharSet (引数 _rer_)。
          1. CharSet _A_ と _B_ の共通部分を返す。
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassIntersection| の CompileToCharSet (引数 _rer_)。
          1. _B_ を |ClassSetOperand| の CompileToCharSet (引数 _rer_)。
          1. CharSet _A_ と _B_ の共通部分を返す。
        </emu-alg>

        <!-- ClassSubtraction -->
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 最初の |ClassSetOperand| の CompileToCharSet (引数 _rer_) を _A_。
          1. 2 番目の |ClassSetOperand| の CompileToCharSet (引数 _rer_) を _B_。
          1. _A_ のうち _B_ でない CharSetElement を含む CharSet を返す。
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassSubtraction| の CompileToCharSet (引数 _rer_)。
          1. _B_ を |ClassSetOperand| の CompileToCharSet (引数 _rer_)。
          1. _A_ のうち _B_ でない CharSetElement を含む CharSet を返す。
        </emu-alg>

        <!-- ClassSetRange -->
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. _A_ を最初の |ClassSetCharacter| の CompileToCharSet (引数 _rer_)。
          1. _B_ を 2 番目の |ClassSetCharacter| の CompileToCharSet (引数 _rer_)。
          1. MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_)) を返す。
        </emu-alg>
        <emu-note>
          <p>結果はしばしば 2 個以上の範囲で構成される。UnicodeSets が *true* かつ IgnoreCase が *true* のとき、MaybeSimpleCaseFolding(_rer_, [Ā-č]) はその範囲の奇数番コードポイントのみを含む。</p>
        </emu-note>

        <!-- ClassSetOperand -->
        <emu-grammar>ClassSetOperand :: ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassSetCharacter| の CompileToCharSet (引数 _rer_)。
          1. MaybeSimpleCaseFolding(_rer_, _A_) を返す。
        </emu-alg>
        <emu-grammar>ClassSetOperand :: ClassStringDisjunction</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassStringDisjunction| の CompileToCharSet (引数 _rer_)。
          1. MaybeSimpleCaseFolding(_rer_, _A_) を返す。
        </emu-alg>
        <emu-grammar>ClassSetOperand :: NestedClass</emu-grammar>
        <emu-alg>
          1. |NestedClass| の CompileToCharSet (引数 _rer_) を返す。
        </emu-alg>

        <!-- NestedClass -->
        <emu-grammar>NestedClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. |ClassContents| の CompileToCharSet (引数 _rer_) を返す。
        </emu-alg>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassContents| の CompileToCharSet (引数 _rer_)。
          1. CharacterComplement(_rer_, _A_) を返す。
        </emu-alg>
        <emu-grammar>NestedClass :: `\` CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. |CharacterClassEscape| の CompileToCharSet (引数 _rer_) を返す。
        </emu-alg>

        <!-- ClassStringDisjunction -->
        <emu-grammar>ClassStringDisjunction :: `\q{` ClassStringDisjunctionContents `}`</emu-grammar>
        <emu-alg>
          1. |ClassStringDisjunctionContents| の CompileToCharSet (引数 _rer_) を返す。
        </emu-alg>

        <!-- ClassStringDisjunctionContents -->
        <emu-grammar>ClassStringDisjunctionContents :: ClassString</emu-grammar>
        <emu-alg>
          1. _s_ を |ClassString| の CompileClassSetString (引数 _rer_)。
          1. 文字列 _s_ を 1 つだけ含む CharSet を返す。
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. _s_ を |ClassString| の CompileClassSetString (引数 _rer_)。
          1. _A_ を文字列 _s_ を 1 つ含む CharSet。
          1. _B_ を |ClassStringDisjunctionContents| の CompileToCharSet (引数 _rer_)。
          1. CharSet _A_ と _B_ の和集合を返す。
        </emu-alg>

        <!-- ClassSetCharacter -->
        <emu-grammar>
          ClassSetCharacter ::
            SourceCharacter but not ClassSetSyntaxCharacter
            `\` CharacterEscape
            `\` ClassSetReservedPunctuator
        </emu-grammar>
        <emu-alg>
          1. _cv_ をこの |ClassSetCharacter| の CharacterValue。
          1. _c_ を character value が _cv_ の文字。
          1. _c_ を含む 1 要素 CharSet を返す。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. U+0008 (BACKSPACE) を含む 1 要素 CharSet を返す。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-characterrange-abstract-operation" type="abstract operation">
          <h1>
            CharacterRange (
              _A_: CharSet,
              _B_: CharSet,
            ): CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. アサート: _A_, _B_ はそれぞれ正確に 1 文字を含む。
            1. _a_ を CharSet _A_ の唯一の文字。
            1. _b_ を CharSet _B_ の唯一の文字。
            1. _i_ を文字 _a_ の character value。
            1. _j_ を文字 _b_ の character value。
            1. アサート: _i_ ≤ _j_。
            1. _i_ から _j_ まで（含む）の character value を持つ全ての文字を含む CharSet を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-haseitherunicodeflag-abstract-operation" type="abstract operation">
          <h1>
            HasEitherUnicodeFlag (
              _rer_: a RegExp Record,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _rer_.[[Unicode]] が *true* または _rer_.[[UnicodeSets]] が *true* なら
              1. *true* を返す。
            1. *false* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-wordcharacters" type="abstract operation" oldids="sec-runtime-semantics-wordcharacters-abstract-operation">
          <h1>
            WordCharacters (
              _rer_: a RegExp Record,
            ): CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>`\\b`, `\\B`, `\\w`, `\\W` のために「word characters」と見なされる文字を含む CharSet を返す。</dd>
          </dl>
          <emu-alg>
            1. _basicWordChars_ を ASCII の word characters 全てを含む CharSet。
            1. _extraWordChars_ を、_basicWordChars_ には含まれないが Canonicalize(_rer_, _c_) が _basicWordChars_ に含まれる全ての文字 _c_ を含む CharSet。
            1. アサート: HasEitherUnicodeFlag(_rer_) が *true* かつ _rer_.[[IgnoreCase]] が *true* でない限り _extraWordChars_ は空。
            1. _basicWordChars_ と _extraWordChars_ の和集合を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allcharacters" type="abstract operation">
          <h1>
            AllCharacters (
              _rer_: a RegExp Record,
            ): CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>正規表現フラグに従う「全ての文字」の集合を返す。</dd>
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]] が *true* かつ _rer_.[[IgnoreCase]] が *true* なら
              1. [declared="c"] Simple Case Folding を持たない (scf(_c_) = _c_) 全 Unicode コードポイント _c_ を含む CharSet を返す。
            1. それ以外で HasEitherUnicodeFlag(_rer_) が *true* なら
              1. 全コードポイント値を含む CharSet を返す。
            1. それ以外
              1. 全コードユニット値を含む CharSet を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-maybesimplecasefolding" type="abstract operation">
          <h1>
            MaybeSimpleCaseFolding (
              _rer_: a RegExp Record,
              _A_: CharSet,
            ): CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_rer_.[[UnicodeSets]] が *false* または _rer_.[[IgnoreCase]] が *false* なら _A_ を返す。そうでなければ <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> (<emu-eqn id="eqn-scf" aoid="scf">scf(_cp_)</emu-eqn>) の定義 (<a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a>) を用い、_A_ の各 CharSetElement を文字ごとに正規化して得られる CharSet を返す。</dd>
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]] が *false* または _rer_.[[IgnoreCase]] が *false* なら _A_ を返す。
            1. _B_ を新しい空の CharSet。
            1. _A_ の各 CharSetElement _s_ について
              1. _t_ を空の文字列シーケンス。
              1. _s_ 内の各単一コードポイント _cp_ について
                1. scf(_cp_) を _t_ に追加。
              1. _t_ を _B_ に追加。
            1. _B_ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-charactercomplement" type="abstract operation">
          <h1>
            CharacterComplement (
              _rer_: a RegExp Record,
              _S_: CharSet,
            ): CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _A_ を AllCharacters(_rer_)。
            1. _A_ のうち _S_ に含まれない CharSetElement を含む CharSet を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchproperty-p" type="abstract operation">
          <h1>
            UnicodeMatchProperty (
              _rer_: a RegExp Record,
              _p_: ECMAScript source text,
            ): Unicode プロパティ名
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]] が *true* かつ _p_ が <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> の「Property name」列にある Unicode <emu-not-ref>property name</emu-not-ref> なら
              1. Unicode コードポイント列 _p_ の List を返す。
            1. アサート: _p_ は <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> または <emu-xref href="#table-binary-unicode-properties"></emu-xref> の「<emu-not-ref>Property name</emu-not-ref> and aliases」列に列挙される Unicode <emu-not-ref>property name</emu-not-ref> またはエイリアス。
            1. _c_ を対応行の “Canonical <emu-not-ref>property name</emu-not-ref>” 列にある正規 <emu-not-ref>property name</emu-not-ref>。
            1. Unicode コードポイント列 _c_ の List を返す。
          </emu-alg>
          <p>実装は <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>、<emu-xref href="#table-binary-unicode-properties"></emu-xref>、<emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> に列挙される Unicode プロパティ名とエイリアスをサポートしなければならない。相互運用性確保のため、それ以外をサポートしてはならない。</p>
          <emu-note>
            <p>例: `Script_Extensions` (プロパティ名) と `scx` (エイリアス) は有効だが `script_extensions` や `Scx` は無効。</p>
          </emu-note>
          <emu-note>
            <p>列挙プロパティは <a href="https://unicode.org/reports/tr18/#RL1.2">UTS18 RL1.2</a> 要求のスーパーセット。</p>
          </emu-note>
          <emu-note>
            <p>表中の綴り (大小含む) は Unicode Character Database の <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt"><code>PropertyAliases.txt</code></a> の綴りと一致し、その正確な綴りは <a href="https://www.unicode.org/policies/stability_policy.html#Alias_Stability">安定性が保証</a> されている。</p>
          </emu-note>
          <emu-import href="table-nonbinary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties-of-strings.html"></emu-import>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchpropertyvalue-p-v" type="abstract operation">
          <h1>
            UnicodeMatchPropertyValue (
              _p_: ECMAScript source text,
              _v_: ECMAScript source text,
            ): Unicode プロパティ値
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. アサート: _p_ は <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> の “Canonical property name” 列に列挙される正規・非エイリアス Unicode プロパティ名。
            1. アサート: _v_ は <code>PropertyValueAliases.txt</code> に列挙される Unicode プロパティ _p_ のプロパティ値または値エイリアス。
            1. _value_ を対応行の “Canonical property value” 列にある正規プロパティ値。
            1. Unicode コードポイント列 _value_ の List を返す。
          </emu-alg>
          <p>実装は <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> に列挙されるプロパティについて、<code>PropertyValueAliases.txt</code> に列挙される Unicode プロパティ値および値エイリアスをサポートしなければならない。相互運用性確保のため、それ以外の値・エイリアスをサポートしてはならない。</p>
          <emu-note>
            <p>例: `Xpeo` と `Old_Persian` は有効な `Script_Extensions` 値だが `xpeo` や `Old Persian` は無効。</p>
          </emu-note>
          <emu-note>
            <p>このアルゴリズムは <a href="https://unicode.org/reports/tr44/#Matching_Symbolic">UAX44 の symbolic 値マッチ規則</a> と異なり、大小・<emu-xref href="#sec-white-space">空白</emu-xref>・U+002D (HYPHEN-MINUS)・U+005F (LOW LINE) を無視せず、`Is` 接頭辞をサポートしない。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileclasssetstring" type="sdo">
        <h1>
          実行時セマンティクス: CompileClassSetString (
          _rer_: a RegExp Record,
          ): 文字列シーケンス
        </h1>
        <dl class="header">
        </dl>

        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. 空の文字列シーケンスを返す。
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. |NonEmptyClassString| の CompileClassSetString (引数 _rer_) を返す。
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. _cs_ を |ClassSetCharacter| の CompileToCharSet (引数 _rer_) とする。
          1. _s1_ を _cs_ の単一 CharSetElement である文字列シーケンスとする。
          1. |NonEmptyClassString| が存在するなら
            1. _s2_ を |NonEmptyClassString| の CompileClassSetString (引数 _rer_)。
            1. _s1_ と _s2_ の連結を返す。
          1. _s1_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-creation" oldids="sec-abstract-operations-for-the-regexp-constructor">
      <h1>RegExp 生成のための抽象操作</h1>

      <emu-clause id="sec-regexpcreate" type="abstract operation">
        <h1>
          RegExpCreate (
            _P_: ECMAScript 言語値,
            _F_: String または *undefined*,
          ): オブジェクトを含む通常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _obj_ を ! RegExpAlloc(%RegExp%) とする。
          1. ? RegExpInitialize(_obj_, _P_, _F_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpalloc" type="abstract operation">
        <h1>
          RegExpAlloc (
            _newTarget_: constructor,
          ): オブジェクトを含む通常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _obj_ を ? OrdinaryCreateFromConstructor(_newTarget_, *"%RegExp.prototype%"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] ») とする。
          1. ! DefinePropertyOrThrow(_obj_, *"lastIndex"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) を実行する。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpinitialize" type="abstract operation">
        <h1>
          RegExpInitialize (
            _obj_: オブジェクト,
            _pattern_: ECMAScript 言語値,
            _flags_: ECMAScript 言語値,
          ): オブジェクトを含む通常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _pattern_ が *undefined* なら _P_ を空文字列とする。
          1. そうでなければ _P_ を ? ToString(_pattern_) とする。
          1. _flags_ が *undefined* なら _F_ を空文字列とする。
          1. そうでなければ _F_ を ? ToString(_flags_) とする。
          1. _F_ が *"d"*, *"g"*, *"i"*, *"m"*, *"s"*, *"u"*, *"v"*, *"y"* 以外のコードユニットを含むか、あるいは同じコードユニットを複数回含むなら *SyntaxError* 例外を投げる。
          1. _F_ が *"i"* を含むなら _i_ を *true*、そうでなければ *false* とする。
          1. _F_ が *"m"* を含むなら _m_ を *true*、そうでなければ *false* とする。
          1. _F_ が *"s"* を含むなら _s_ を *true*、そうでなければ *false* とする。
          1. _F_ が *"u"* を含むなら _u_ を *true*、そうでなければ *false* とする。
          1. _F_ が *"v"* を含むなら _v_ を *true*、そうでなければ *false* とする。
          1. _u_ が *true* もしくは _v_ が *true* の場合
            1. _patternText_ を StringToCodePoints(_P_) とする。
          1. そうでなければ
            1. _patternText_ を _P_ の各 16-bit 要素を Unicode BMP コードポイントとして解釈した結果とする (UTF-16 デコードは行わない)。
          1. _parseResult_ を ParsePattern(_patternText_, _u_, _v_) とする。
          1. _parseResult_ が空でない *SyntaxError* オブジェクトの List なら *SyntaxError* 例外を投げる。
          1. アサート: _parseResult_ は |Pattern| パースノードである。
          1. _obj_.[[OriginalSource]] に _P_ を設定する。
          1. _obj_.[[OriginalFlags]] に _F_ を設定する。
          1. _capturingGroupsCount_ を CountLeftCapturingParensWithin(_parseResult_) とする。
          1. _rer_ を RegExp Record { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ } とする。
          1. _obj_.[[RegExpRecord]] に _rer_ を設定する。
          1. _obj_.[[RegExpMatcher]] に 引数 _rer_ で _parseResult_ の CompilePattern を設定する。
          1. ? <emu-meta suppress-effects="user-code">Set(_obj_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta> を実行する。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-parsepattern" type="abstract operation">
        <h1>
          静的セマンティクス: ParsePattern (
          _patternText_: Unicode コードポイント列,
          _u_: Boolean,
          _v_: Boolean,
          ): パースノードまたは空でない *SyntaxError* オブジェクト List
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>この節は <emu-xref href="#sec-parsepattern-annexb"></emu-xref> で修正される。</p>
        </emu-note>
        <emu-alg>
          1. _v_ が *true* かつ _u_ が *true* なら
            1. _parseResult_ を 1 個以上の *SyntaxError* オブジェクトを含む List とする。
          1. そうでなく _v_ が *true* なら
            1. _parseResult_ を ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|) とする。
          1. そうでなく _u_ が *true* なら
            1. _parseResult_ を ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|) とする。
          1. それ以外
            1. _parseResult_ を ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|) とする。
          1. _parseResult_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-constructor">
      <h1>RegExp コンストラクター</h1>
      <p>RegExp コンストラクター:</p>
      <ul>
        <li><dfn>%RegExp%</dfn> である。</li>
        <li>グローバルオブジェクトの *"RegExp"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼び出されたとき新しい RegExp オブジェクトを生成し初期化する。</li>
        <li>関数として呼び出された場合、新しい RegExp オブジェクトを返すか、引数が RegExp オブジェクト 1 つのみならその引数自体を返す。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された RegExp の挙動を継承するサブクラスのコンストラクターは、必要な内部スロットを持つサブクラスインスタンスを生成・初期化するため RegExp コンストラクターへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-regexp-pattern-flags">
        <h1>RegExp ( _pattern_, _flags_ )</h1>
        <p>この関数は呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _patternIsRegExp_ を ? IsRegExp(_pattern_) とする。
          1. NewTarget が *undefined* なら
            1. _newTarget_ をアクティブな関数オブジェクトとする。
            1. _patternIsRegExp_ が *true* かつ _flags_ が *undefined* なら
              1. _patternConstructor_ を ? Get(_pattern_, *"constructor"*) とする。
              1. SameValue(_newTarget_, _patternConstructor_) が *true* なら _pattern_ を返す。
          1. そうでなければ
            1. _newTarget_ を NewTarget とする。
          1. _pattern_ がオブジェクトで [[RegExpMatcher]] 内部スロットを持つなら
            1. _P_ を _pattern_.[[OriginalSource]] とする。
            1. _flags_ が *undefined* なら _F_ を _pattern_.[[OriginalFlags]] とし、そうでなければ _F_ を _flags_ とする。
          1. そうでなく _patternIsRegExp_ が *true* なら
            1. _P_ を ? Get(_pattern_, *"source"*) とする。
            1. _flags_ が *undefined* なら
              1. _F_ を ? Get(_pattern_, *"flags"*) とする。
            1. そうでなければ
              1. _F_ を _flags_ とする。
          1. それ以外
            1. _P_ を _pattern_ とする。
            1. _F_ を _flags_ とする。
          1. _O_ を ? RegExpAlloc(_newTarget_) とする。
          1. ? RegExpInitialize(_O_, _P_, _F_) を返す。
        </emu-alg>
        <emu-note>
          <p>pattern が |StringLiteral| で与えられる場合、通常のエスケープシーケンス置換が本関数で処理される前に適用される。pattern がこの関数に認識させるためにエスケープシーケンスを含む必要があるなら、|StringLiteral| 内で U+005C (REVERSE SOLIDUS) は削除されないようエスケープされなければならない。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-constructor">
      <h1>RegExp コンストラクターのプロパティ</h1>
      <p>RegExp コンストラクター:</p>
      <ul>
        <li>値 %Function.prototype% の [[Prototype]] 内部スロットを持つ。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-regexp.escape">
        <h1>RegExp.escape ( _S_ )</h1>
        <p>この関数は、正規表現 |Pattern| 内で特別な意味を持ち得る文字が等価なエスケープシーケンスに置換された _S_ のコピーを返す。</p>
        <p>呼び出し時に以下を行う:</p>

        <emu-alg>
          1. _S_ が String でなければ *TypeError* 例外を投げる。
          1. _escaped_ を空文字列とする。
          1. _cpList_ を StringToCodePoints(_S_) とする。
          1. _cpList_ の各コードポイント _cp_ について
            1. _escaped_ が空文字列でかつ _cp_ が |DecimalDigit| または |AsciiLetter| のいずれかにマッチするなら
              1. 注記: 先頭の数字をエスケープすることで、`\0` や `\1` などの |DecimalEscape| の後で文字列 _S_ をマッチさせる際、前のエスケープシーケンス拡張と解釈されるのを防ぐ。先頭の ASCII 文字も `\c` の後の文脈で同様。
              1. _numericValue_ を _cp_ の数値とする。
              1. _hex_ を Number::toString(𝔽(_numericValue_), 16) とする。
              1. アサート: _hex_ の長さは 2。
              1. _escaped_ を 0x005C (REVERSE SOLIDUS), *"x"*, _hex_ の連結に設定する。
            1. そうでなければ
              1. _escaped_ を _escaped_ と EncodeForRegExpEscape(_cp_) の連結に設定する。
          1. _escaped_ を返す。
        </emu-alg>

        <emu-note>
          <p>名前が類似していても EscapeRegExpPattern と `RegExp.escape` は異なる働きをする。前者はパターンを文字列表現へエスケープし、後者は文字列をパターン内表現のためにエスケープする。</p>
        </emu-note>

        <emu-clause id="sec-encodeforregexpescape" type="abstract operation">
          <h1>
            EncodeForRegExpEscape (
              _cp_: コードポイント,
            ): String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_cp_ をマッチする |Pattern| 表現用 String を返す。_cp_ が空白または ASCII 句読文字なら返値はエスケープシーケンス、それ以外は _cp_ 自身の String 表現。</dd>
          </dl>

          <emu-alg>
            1. _cp_ が |SyntaxCharacter| にマッチするか、_cp_ が U+002F (SOLIDUS) なら
              1. 0x005C (REVERSE SOLIDUS) と UTF16EncodeCodePoint(_cp_) の連結を返す。
            1. そうでなく _cp_ が <emu-xref href="#table-controlescape-code-point-values"></emu-xref> の “Code Point” 列に列挙されるコードポイントなら
              1. 0x005C (REVERSE SOLIDUS) と対応行の “ControlEscape” 列の文字列との連結を返す。
            1. _otherPunctuators_ を *",-=&lt;>#&amp;!%:;@~'`"* とコードユニット 0x0022 (QUOTATION MARK) の連結とする。
            1. _toEscape_ を StringToCodePoints(_otherPunctuators_) とする。
            1. _toEscape_ が _cp_ を含む、または _cp_ が |WhiteSpace| もしくは |LineTerminator| にマッチする、または _cp_ が先行サロゲートまたは後続サロゲートと同じ数値を持つなら
              1. _cpNum_ を _cp_ の数値とする。
              1. _cpNum_ ≤ 0xFF なら
                1. _hex_ を Number::toString(𝔽(_cpNum_), 16) とする。
                1. 0x005C (REVERSE SOLIDUS), *"x"*, StringPad(_hex_, 2, *"0"*, ~start~) の連結を返す。
              1. _escaped_ を空文字列とする。
              1. _codeUnits_ を UTF16EncodeCodePoint(_cp_) とする。
              1. 各コードユニット _cu_ について
                1. _escaped_ を _escaped_ と UnicodeEscape(_cu_) の連結にする。
              1. _escaped_ を返す。
            1. UTF16EncodeCodePoint(_cp_) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype">
        <h1>RegExp.prototype</h1>
        <p>`RegExp.prototype` の初期値は RegExp プロトタイプオブジェクトである。</p>
        <p>このプロパティの属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } である。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-regexp-@@species" id="sec-get-regexp-%symbol.species%">
        <h1>get RegExp [ %Symbol.species% ]</h1>
        <p>`RegExp[%Symbol.species%]` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは呼び出し時以下を行う:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティ値は *"get [Symbol.species]"* である。</p>
        <emu-note>
          <p>RegExp プロトタイプメソッドは通常 *this* 値の constructor を用いて派生オブジェクトを生成する。サブクラスの constructor は %Symbol.species% プロパティを再定義することで既定挙動を上書きできる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>RegExp プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>RegExp プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%RegExp.prototype%</dfn> である。</li>
        <li>通常のオブジェクトである。</li>
        <li>RegExp インスタンスではなく [[RegExpMatcher]] 内部スロットや他の RegExp インスタンス内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      </ul>
      <emu-note>
        <p>RegExp プロトタイプオブジェクトは自身の *"valueOf"* プロパティを持たないが、Object プロトタイプオブジェクトから継承する。</p>
      </emu-note>

      <emu-clause id="sec-regexp.prototype.constructor">
        <h1>RegExp.prototype.constructor</h1>
        <p>`RegExp.prototype.constructor` の初期値は %RegExp% である。</p>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.exec">
        <h1>RegExp.prototype.exec ( _string_ )</h1>
        <p>このメソッドは _string_ 内で正規表現パターンの出現を検索し、マッチ結果を含む Array を返す。マッチしなければ *null* を返す。</p>
        <p>呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値とする。
          1. ? RequireInternalSlot(_R_, [[RegExpMatcher]]) を実行する。
          1. _S_ を ? ToString(_string_) とする。
          1. ? RegExpBuiltinExec(_R_, _S_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.dotAll">
        <h1>get RegExp.prototype.dotAll</h1>
        <p>`RegExp.prototype.dotAll` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値とする。
          1. _cu_ をコードユニット 0x0073 (LATIN SMALL LETTER S) とする。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.flags">
        <h1>get RegExp.prototype.flags</h1>
        <p>`RegExp.prototype.flags` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値とする。
          1. _R_ がオブジェクトでなければ *TypeError* 例外を投げる。
          1. _codeUnits_ を空 List とする。
          1. _hasIndices_ を ToBoolean(? Get(_R_, *"hasIndices"*)) とする。
          1. _hasIndices_ が *true* ならコードユニット 0x0064 (LATIN SMALL LETTER D) を _codeUnits_ に追加。
          1. _global_ を ToBoolean(? Get(_R_, *"global"*)) とする。
          1. _global_ が *true* なら 0x0067 (LATIN SMALL LETTER G) を追加。
          1. _ignoreCase_ を ToBoolean(? Get(_R_, *"ignoreCase"*)) とする。
          1. _ignoreCase_ が *true* なら 0x0069 (LATIN SMALL LETTER I) を追加。
          1. _multiline_ を ToBoolean(? Get(_R_, *"multiline"*)) とする。
          1. _multiline_ が *true* なら 0x006D (LATIN SMALL LETTER M) を追加。
          1. _dotAll_ を ToBoolean(? Get(_R_, *"dotAll"*)) とする。
          1. _dotAll_ が *true* なら 0x0073 (LATIN SMALL LETTER S) を追加。
          1. _unicode_ を ToBoolean(? Get(_R_, *"unicode"*)) とする。
          1. _unicode_ が *true* なら 0x0075 (LATIN SMALL LETTER U) を追加。
          1. _unicodeSets_ を ToBoolean(? Get(_R_, *"unicodeSets"*)) とする。
          1. _unicodeSets_ が *true* なら 0x0076 (LATIN SMALL LETTER V) を追加。
          1. _sticky_ を ToBoolean(? Get(_R_, *"sticky"*)) とする。
          1. _sticky_ が *true* なら 0x0079 (LATIN SMALL LETTER Y) を追加。
          1. _codeUnits_ の要素をコードユニットとする String 値を返す。要素が無ければ空文字列を返す。
        </emu-alg>

        <emu-clause id="sec-regexphasflag" type="abstract operation">
          <h1>
            RegExpHasFlag (
              _R_: ECMAScript 言語値,
              _codeUnit_: コードユニット,
            ): Boolean または *undefined* を含む通常完了または throw 完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _R_ がオブジェクトでなければ *TypeError* 例外。
            1. _R_ が [[OriginalFlags]] 内部スロットを持たないなら
              1. SameValue(_R_, %RegExp.prototype%) が *true* なら *undefined* を返す。
              1. そうでなければ *TypeError* 例外。
            1. _flags_ を _R_.[[OriginalFlags]] とする。
            1. _flags_ が _codeUnit_ を含むなら *true* を返す。
            1. *false* を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.global">
        <h1>get RegExp.prototype.global</h1>
        <p>`RegExp.prototype.global` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _cu_ を 0x0067 (LATIN SMALL LETTER G)。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.hasIndices">
        <h1>get RegExp.prototype.hasIndices</h1>
        <p>`RegExp.prototype.hasIndices` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _cu_ を 0x0064 (LATIN SMALL LETTER D)。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.ignorecase">
        <h1>get RegExp.prototype.ignoreCase</h1>
        <p>`RegExp.prototype.ignoreCase` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _cu_ を 0x0069 (LATIN SMALL LETTER I)。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@match" id="sec-regexp.prototype-%symbol.match%">
        <h1>RegExp.prototype [ %Symbol.match% ] ( _string_ )</h1>
        <p>このメソッドは呼び出し時以下を行う:</p>
        <emu-alg>
          1. _rx_ を *this* 値とする。
          1. _rx_ がオブジェクトでなければ *TypeError* 例外。
          1. _S_ を ? ToString(_string_) とする。
          1. _flags_ を ? ToString(? Get(_rx_, *"flags"* )) とする。
          1. _flags_ が *"g"* を含まなければ
            1. ? RegExpExec(_rx_, _S_) を返す。
          1. そうでなければ
            1. _flags_ が *"u"* または *"v"* を含むなら _fullUnicode_ を *true*、そうでなければ *false* とする。
            1. ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*) を実行する。
            1. _A_ を ! ArrayCreate(0) とする。
            1. _n_ を 0 とする。
            1. 繰り返し、
              1. _result_ を ? RegExpExec(_rx_, _S_) とする。
              1. _result_ が *null* なら
                1. _n_ = 0 なら *null* を返す。
                1. _A_ を返す。
              1. そうでなければ
                1. _matchStr_ を ? ToString(? Get(_result_, *"0"* )) とする。
                1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_) を実行。
                1. _matchStr_ が空文字列なら
                  1. _thisIndex_ を ℝ(? ToLength(? Get(_rx_, *"lastIndex"*))) とする。
                  1. _nextIndex_ を AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_) とする。
                  1. ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*) を実行。
                1. _n_ を _n_ + 1 にする。
        </emu-alg>
        <p>このメソッドの *"name"* プロパティ値は *"[Symbol.match]"* である。</p>
        <emu-note>
          <p>%Symbol.match% プロパティは IsRegExp 抽象操作が正規表現基本挙動を持つオブジェクトを識別するのに用いられる。%Symbol.match% が存在しないか、その値が真へ強制されない場合、そのオブジェクトは正規表現オブジェクトとして意図されない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-regexp-prototype-matchall" id="sec-regexp-prototype-%symbol.matchall%">
        <h1>RegExp.prototype [ %Symbol.matchAll% ] ( _string_ )</h1>
        <p>このメソッドは呼び出し時以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値とする。
          1. _R_ がオブジェクトでなければ *TypeError* 例外。
          1. _S_ を ? ToString(_string_) とする。
          1. _C_ を ? SpeciesConstructor(_R_, %RegExp%) とする。
          1. _flags_ を ? ToString(? Get(_R_, *"flags"* )) とする。
          1. _matcher_ を ? Construct(_C_, « _R_, _flags_ ») とする。
          1. _lastIndex_ を ? ToLength(? Get(_R_, *"lastIndex"* )) とする。
          1. ? Set(_matcher_, *"lastIndex"*, _lastIndex_, *true*) を実行。
          1. _flags_ が *"g"* を含むなら _global_ を *true*、そうでなければ *false*。
          1. _flags_ が *"u"* または *"v"* を含むなら _fullUnicode_ を *true*、そうでなければ *false*。
          1. CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_) を返す。
        </emu-alg>
        <p>このメソッドの *"name"* プロパティ値は *"[Symbol.matchAll]"* である。</p>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.multiline">
        <h1>get RegExp.prototype.multiline</h1>
        <p>`RegExp.prototype.multiline` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _cu_ を 0x006D (LATIN SMALL LETTER M)。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@replace" id="sec-regexp.prototype-%symbol.replace%">
        <h1>RegExp.prototype [ %Symbol.replace% ] ( _string_, _replaceValue_ )</h1>
        <p>このメソッドは呼び出し時以下を行う:</p>
        <emu-alg>
          1. _rx_ を *this* 値とする。
          1. _rx_ がオブジェクトでなければ *TypeError* 例外。
          1. _S_ を ? ToString(_string_) とする。
          1. _lengthS_ を _S_ の長さとする。
          1. _functionalReplace_ を IsCallable(_replaceValue_) とする。
          1. _functionalReplace_ が *false* なら
            1. _replaceValue_ を ? ToString(_replaceValue_) とする。
          1. _flags_ を ? ToString(? Get(_rx_, *"flags"* )) とする。
          1. _flags_ が *"g"* を含むなら _global_ を *true*、そうでなければ *false*。
          1. _global_ が *true* なら
            1. ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*) を実行。
          1. _results_ を空 List とする。
          1. _done_ を *false* とする。
          1. _done_ が *false* の間繰り返し、
            1. _result_ を ? RegExpExec(_rx_, _S_) とする。
            1. _result_ が *null* なら
              1. _done_ を *true* にする。
            1. そうでなければ
              1. _result_ を _results_ に追加。
              1. _global_ が *false* なら
                1. _done_ を *true* にする。
              1. そうでなければ
                1. _matchStr_ を ? ToString(? Get(_result_, *"0"* )) とする。
                1. _matchStr_ が空文字列なら
                  1. _thisIndex_ を ℝ(? ToLength(? Get(_rx_, *"lastIndex"*))) とする。
                  1. _flags_ が *"u"* または *"v"* を含むなら _fullUnicode_ を *true*、そうでなければ *false*。
                  1. _nextIndex_ を AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_) とする。
                  1. ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*) を実行。
          1. _accumulatedResult_ を空文字列。
          1. _nextSourcePosition_ を 0。
          1. 各 _result_ ∈ _results_ について
            1. _resultLength_ を ? LengthOfArrayLike(_result_)。
            1. _nCaptures_ を max(_resultLength_ - 1, 0)。
            1. _matched_ を ? ToString(? Get(_result_, *"0"* ))。
            1. _matchLength_ を _matched_ の長さ。
            1. _position_ を ? ToIntegerOrInfinity(? Get(_result_, *"index"* ))。
            1. _position_ を 0 と _lengthS_ の間にクランプ。
            1. _captures_ を新しい空 List。
            1. _n_ を 1。
            1. _n_ ≤ _nCaptures_ の間繰り返し、
              1. _capN_ を ? Get(_result_, ! ToString(𝔽(_n_)))。
              1. _capN_ が *undefined* でなければ
                1. _capN_ を ? ToString(_capN_)。
              1. _capN_ を _captures_ に追加。
              1. 注記: _n_ = 1 のとき最初のキャプチャが _captures_[0] に入る。一般に _n_ 番目のキャプチャは _captures_[_n_ - 1]。
              1. _n_ を _n_ + 1。
            1. _namedCaptures_ を ? Get(_result_, *"groups"*)。
            1. _functionalReplace_ が *true* なら
              1. _replacerArgs_ を « _matched_ » と _captures_ と « 𝔽(_position_), _S_ » のリスト連結とする。
              1. _namedCaptures_ が *undefined* でなければ
                1. _replacerArgs_ に _namedCaptures_ を追加。
              1. _replacementValue_ を ? Call(_replaceValue_, *undefined*, _replacerArgs_)。
              1. _replacementString_ を ? ToString(_replacementValue_)。
            1. そうでなければ
              1. _namedCaptures_ が *undefined* でなければ
                1. _namedCaptures_ を ? ToObject(_namedCaptures_)。
              1. _replacementString_ を ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_)。
            1. _position_ ≥ _nextSourcePosition_ なら
              1. 注記: _position_ が後退するのは通常想定外であり、不正な RegExp サブクラス動作や副作用でフラグ等を変更した兆候である。その場合対応置換は無視される。
              1. _accumulatedResult_ を _accumulatedResult_ と _S_ の _nextSourcePosition_ から _position_ まで、および _replacementString_ の連結にする。
              1. _nextSourcePosition_ を _position_ + _matchLength_ にする。
          1. _nextSourcePosition_ ≥ _lengthS_ なら _accumulatedResult_ を返す。
          1. _accumulatedResult_ と _S_ の _nextSourcePosition_ から末尾までの部分文字列の連結を返す。
        </emu-alg>
        <p>このメソッドの *"name"* プロパティ値は *"[Symbol.replace]"* である。</p>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@search" id="sec-regexp.prototype-%symbol.search%">
        <h1>RegExp.prototype [ %Symbol.search% ] ( _string_ )</h1>
        <p>このメソッドは呼び出し時以下を行う:</p>
        <emu-alg>
          1. _rx_ を *this* 値。
          1. _rx_ がオブジェクトでなければ *TypeError* 例外。
          1. _S_ を ? ToString(_string_)。
          1. _previousLastIndex_ を ? Get(_rx_, *"lastIndex"* )。
          1. _previousLastIndex_ が *+0*<sub>𝔽</sub> でなければ
            1. ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*) を実行。
          1. _result_ を ? RegExpExec(_rx_, _S_)。
          1. _currentLastIndex_ を ? Get(_rx_, *"lastIndex"* )。
          1. SameValue(_currentLastIndex_, _previousLastIndex_) が *false* なら
            1. ? Set(_rx_, *"lastIndex"*, _previousLastIndex_, *true*) を実行。
          1. _result_ が *null* なら *-1*<sub>𝔽</sub> を返す。
          1. ? Get(_result_, *"index"*) を返す。
        </emu-alg>
        <p>このメソッドの *"name"* プロパティ値は *"[Symbol.search]"* である。</p>
        <emu-note>
          <p>検索時この RegExp オブジェクトの *"lastIndex"* と *"global"* プロパティは無視される。*"lastIndex"* は変更されない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.source">
        <h1>get RegExp.prototype.source</h1>
        <p>`RegExp.prototype.source` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _R_ がオブジェクトでなければ *TypeError* 例外。
          1. _R_ が [[OriginalSource]] 内部スロットを持たないなら
            1. SameValue(_R_, %RegExp.prototype%) が *true* なら *"(?:)"* を返す。
            1. そうでなければ *TypeError* 例外。
          1. アサート: _R_ は [[OriginalFlags]] 内部スロットを持つ。
          1. _src_ を _R_.[[OriginalSource]]。
          1. _flags_ を _R_.[[OriginalFlags]]。
          1. EscapeRegExpPattern(_src_, _flags_) を返す。
        </emu-alg>

        <emu-clause id="sec-escaperegexppattern" type="abstract operation">
          <h1>
            EscapeRegExpPattern (
              _P_: String,
              _F_: String,
            ): String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _F_ が *"v"* を含むなら
              1. _patternSymbol_ を |Pattern[+UnicodeMode, +UnicodeSetsMode]| とする。
            1. そうでなく _F_ が *"u"* を含むなら
              1. _patternSymbol_ を |Pattern[+UnicodeMode, ~UnicodeSetsMode]| とする。
            1. それ以外
              1. _patternSymbol_ を |Pattern[~UnicodeMode, ~UnicodeSetsMode]| とする。
            1. _S_ を、特定コードポイントが下記のようにエスケープされた、_P_ (UTF-16 エンコードされた Unicode コードポイントと解釈) に等価な _patternSymbol_ 形式の String とする。_S_ は _P_ と同一である場合と異なる場合があるが、_S_ を _patternSymbol_ として評価して得られる抽象クロージャは生成オブジェクトの [[RegExpMatcher]] 内部スロットの抽象クロージャと同一に振る舞わなければならない。同じ _P_, _F_ での複数回呼び出しは同一結果を生成しなければならない。
            1. パターンに現れる `/` または任意の |LineTerminator| コードポイントは、*"/*", _S_, *"/"*, _F_ の連結が (適切な字句文脈で) 同一に振る舞う |RegularExpressionLiteral| としてパース可能となるよう _S_ 内で必要に応じエスケープされる。例: _P_ が *"/"* の場合 _S_ は *"\\/"* や *"\\u002F"* 等が許されるが *"/"* は不可 ( `///` + _F_ が |SingleLineComment| と解釈されるため )。 _P_ が空文字列なら _S_ を *"(?:)"* として要件を満たせる。
            1. _S_ を返す。
          </emu-alg>

          <emu-note>
            <p>名前が類似していても `RegExp.escape` と EscapeRegExpPattern は異なる。前者は文字列をパターン内部表現用にエスケープし、後者はパターンを文字列表現用にエスケープする。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@split" id="sec-regexp.prototype-%symbol.split%">
        <h1>RegExp.prototype [ %Symbol.split% ] ( _string_, _limit_ )</h1>
        <emu-note>
          <p>このメソッドは _string_ を String に変換した結果の部分文字列を格納した配列を返す。部分文字列は *this* 値である正規表現のマッチを左から右に探索して決定され、マッチ位置自体は結果配列要素には含まれず文字列を区切る役割をする。</p>
          <p>*this* 値は空の正規表現、または空文字列にマッチする正規表現であり得る。その場合、入力文字列の先頭・末尾、前の区切りマッチ末尾における空 <emu-not-ref>substring</emu-not-ref> にはマッチしない。（例: 正規表現が空文字列にマッチするなら文字列は各コードユニット要素に分割され、結果配列長は文字列長に等しく、各 <emu-not-ref>substring</emu-not-ref> は 1 コードユニット。）あるインデックスで考慮されるマッチは最初の一つのみで、バックトラッキングにより非空マッチが得られても再考しない。（例: `/a*?/[Symbol.split]("ab")` は `["a","b"]`、`/a*/[Symbol.split]("ab")` は `["","b"]`。）</p>
          <p>_string_ が（または変換後）空文字列の場合、正規表現が空文字列にマッチ可能かどうかで結果が異なる。マッチ可能なら結果配列は空、そうでなければ空文字列 1 要素を含む。</p>
          <p>正規表現が捕捉括弧を含むとき、_separator_ がマッチする毎にその結果（*undefined* を含む）が出力配列に挿入される。例:</p>
          <pre><code class="javascript">/&lt;(\/)?([^&lt;&gt;]+)&gt;/[Symbol.split]("A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;")</code></pre>
          <p>は配列</p>
          <pre><code class="javascript">["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]</code></pre>
          <p>を生成する。</p>
          <p>_limit_ が *undefined* でなければ、出力配列は _limit_ 要素を超えないよう切り詰められる。</p>
        </emu-note>
        <p>このメソッドは呼び出し時以下を行う:</p>
        <emu-alg>
          1. _rx_ を *this* 値。
          1. _rx_ がオブジェクトでなければ *TypeError* 例外。
          1. _S_ を ? ToString(_string_)。
          1. _C_ を ? SpeciesConstructor(_rx_, %RegExp%)。
          1. _flags_ を ? ToString(? Get(_rx_, *"flags"* ))。
          1. _flags_ が *"u"* または *"v"* を含むなら _unicodeMatching_ を *true*、そうでなければ *false*。
          1. _flags_ が *"y"* を含むなら _newFlags_ を _flags_、そうでなければ _newFlags_ を _flags_ と *"y"* の連結とする。
          1. _splitter_ を ? Construct(_C_, « _rx_, _newFlags_ »)。
          1. _A_ を ! ArrayCreate(0)。
          1. _lengthA_ を 0。
          1. _limit_ が *undefined* なら _lim_ を 2<sup>32</sup> - 1、そうでなければ ℝ(? ToUint32(_limit_))。
          1. _lim_ = 0 なら _A_ を返す。
          1. _S_ が空文字列なら
            1. _z_ を ? RegExpExec(_splitter_, _S_)。
            1. _z_ が *null* でなければ _A_ を返す。
            1. ! CreateDataPropertyOrThrow(_A_, *"0"*, _S_)。
            1. _A_ を返す。
          1. _size_ を _S_ の長さ。
          1. _p_ を 0。
          1. _q_ を _p_。
          1. _q_ &lt; _size_ の間繰り返し、
            1. ? Set(_splitter_, *"lastIndex"*, 𝔽(_q_), *true*)。
            1. _z_ を ? RegExpExec(_splitter_, _S_)。
            1. _z_ が *null* なら
              1. _q_ を AdvanceStringIndex(_S_, _q_, _unicodeMatching_) とする。
            1. そうでなければ
              1. _e_ を ℝ(? ToLength(? Get(_splitter_, *"lastIndex"*)))。
              1. _e_ を min(_e_, _size_)。
              1. _e_ = _p_ なら
                1. _q_ を AdvanceStringIndex(_S_, _q_, _unicodeMatching_)。
              1. そうでなければ
                1. _T_ を _S_ の _p_ から _q_ の部分文字列。
                1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_)。
                1. _lengthA_ を _lengthA_ + 1。
                1. _lengthA_ = _lim_ なら _A_ を返す。
                1. _p_ を _e_。
                1. _numberOfCaptures_ を ? LengthOfArrayLike(_z_)。
                1. _numberOfCaptures_ を max(_numberOfCaptures_ - 1, 0)。
                1. _i_ を 1。
                1. _i_ ≤ _numberOfCaptures_ の間繰り返し、
                  1. _nextCapture_ を ? Get(_z_, ! ToString(𝔽(_i_)))。
                  1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_)。
                  1. _i_ を _i_ + 1。
                  1. _lengthA_ を _lengthA_ + 1。
                  1. _lengthA_ = _lim_ なら _A_ を返す。
                1. _q_ を _p_ に設定。
          1. _T_ を _S_ の _p_ から _size_ の部分文字列。
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_)。
          1. _A_ を返す。
        </emu-alg>
        <p>このメソッドの *"name"* プロパティ値は *"[Symbol.split]"* である。</p>
        <emu-note>
          <p>このメソッドは RegExp オブジェクトの *"global"* および *"sticky"* プロパティ値を無視する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.sticky">
        <h1>get RegExp.prototype.sticky</h1>
        <p>`RegExp.prototype.sticky` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _cu_ を 0x0079 (LATIN SMALL LETTER Y)。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.test">
        <h1>RegExp.prototype.test ( _S_ )</h1>
        <p>このメソッドは呼び出し時以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _R_ がオブジェクトでなければ *TypeError* 例外。
          1. _string_ を ? ToString(_S_)。
          1. _match_ を ? RegExpExec(_R_, _string_)。
          1. _match_ が *null* でなければ *true*、そうでなければ *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.tostring">
        <h1>RegExp.prototype.toString ( )</h1>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _R_ がオブジェクトでなければ *TypeError* 例外。
          1. _pattern_ を ? ToString(? Get(_R_, *"source"* ))。
          1. _flags_ を ? ToString(? Get(_R_, *"flags"* ))。
          1. _result_ を *"/"*, _pattern_, *"/"*, _flags_ の連結とする。
          1. _result_ を返す。
        </emu-alg>
        <emu-note>
          <p>返される String は |RegularExpressionLiteral| の形式であり、同じ挙動の別 RegExp オブジェクトを評価する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicode">
        <h1>get RegExp.prototype.unicode</h1>
        <p>`RegExp.prototype.unicode` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _cu_ を 0x0075 (LATIN SMALL LETTER U)。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicodesets">
        <h1>get RegExp.prototype.unicodeSets</h1>
        <p>`RegExp.prototype.unicodeSets` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _R_ を *this* 値。
          1. _cu_ を 0x0076 (LATIN SMALL LETTER V)。
          1. ? RegExpHasFlag(_R_, _cu_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-matching">
      <h1>RegExp マッチングのための抽象操作</h1>

      <emu-clause id="sec-regexpexec" type="abstract operation">
        <h1>
          RegExpExec (
            _R_: オブジェクト,
            _S_: String,
          ): オブジェクトまたは *null* を含む通常完了、または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _exec_ を ? Get(_R_, *"exec"*) とする。
          1. IsCallable(_exec_) が *true* なら
            1. _result_ を ? Call(_exec_, _R_, « _S_ ») とする。
            1. _result_ がオブジェクトでも *null* でもなければ *TypeError* 例外。
            1. _result_ を返す。
          1. ? RequireInternalSlot(_R_, [[RegExpMatcher]]) を実行。
          1. ? RegExpBuiltinExec(_R_, _S_) を返す。
        </emu-alg>
        <emu-note>
          <p>呼び出し可能な *"exec"* プロパティが見つからない場合、このアルゴリズムは組み込み正規表現マッチングアルゴリズムにフォールバックする。これは過去版でほとんどの組み込みアルゴリズムが *"exec"* の動的プロパティ参照を行わなかったコードとの互換性を提供する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-regexpbuiltinexec" type="abstract operation">
        <h1>
          RegExpBuiltinExec (
            _R_: 初期化済み RegExp インスタンス,
            _S_: String,
          ): Array エキゾチックオブジェクトまたは *null* を含む通常完了、または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _length_ を _S_ の長さ。
          1. _lastIndex_ を ℝ(? ToLength(! Get(_R_, *"lastIndex"* )))。
          1. _flags_ を _R_.[[OriginalFlags]]。
          1. _flags_ が *"g"* を含むなら _global_ を *true*、そうでなければ *false*。
          1. _flags_ が *"y"* を含むなら _sticky_ を *true*、そうでなければ *false*。
          1. _flags_ が *"d"* を含むなら _hasIndices_ を *true*、そうでなければ *false*。
          1. _global_ が *false* かつ _sticky_ が *false* なら _lastIndex_ を 0 に設定。
          1. _matcher_ を _R_.[[RegExpMatcher]]。
          1. _flags_ が *"u"* または *"v"* を含むなら _fullUnicode_ を *true*、そうでなければ *false*。
          1. _matchSucceeded_ を *false*。
          1. _fullUnicode_ が *true* なら _input_ を StringToCodePoints(_S_)、そうでなければ _input_ を _S_ のコードユニット列 List とする。
          1. 注記: _input_ の各要素は文字と見なす。
          1. _matchSucceeded_ が *false* の間繰り返し、
            1. _lastIndex_ > _length_ なら
              1. _global_ または _sticky_ が *true* なら
                1. ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta> を実行。
              1. *null* を返す。
            1. _inputIndex_ を _S_ の _lastIndex_ 番目要素から得た文字の _input_ 内インデックスとする。
            1. _r_ を _matcher_(_input_, _inputIndex_) とする。
            1. _r_ が ~failure~ なら
              1. _sticky_ が *true* なら
                1. ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>。
                1. *null* を返す。
              1. _lastIndex_ を AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_) に設定。
            1. そうでなければ
              1. アサート: _r_ は MatchState。
              1. _matchSucceeded_ を *true* にする。
          1. _e_ を _r_.[[EndIndex]]。
          1. _fullUnicode_ が *true* なら _e_ を GetStringIndex(_S_, _e_) に設定。
          1. _global_ または _sticky_ が *true* なら
            1. ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, 𝔽(_e_), *true*)</emu-meta>。
          1. _n_ を _r_.[[Captures]] の要素数。
          1. アサート: _n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]]。
          1. アサート: _n_ &lt; 2<sup>32</sup> - 1。
          1. _A_ を ! ArrayCreate(_n_ + 1)。
          1. アサート: _A_.*"length"* の数学的値は _n_ + 1。
          1. ! CreateDataPropertyOrThrow(_A_, *"index"*, 𝔽(_lastIndex_))。
          1. ! CreateDataPropertyOrThrow(_A_, *"input"*, _S_)。
          1. _match_ を Match Record { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }。
          1. _indices_ を空 List。
          1. _groupNames_ を空 List。
          1. _indices_ に _match_ を追加。
          1. _matchedSubstr_ を GetMatchString(_S_, _match_)。
          1. ! CreateDataPropertyOrThrow(_A_, *"0"*, _matchedSubstr_)。
          1. _R_ が |GroupName| を含むなら
            1. _groups_ を OrdinaryObjectCreate(*null*)。
            1. _hasGroups_ を *true*。
          1. そうでなければ
            1. _groups_ を *undefined*。
            1. _hasGroups_ を *false*。
          1. ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_)。
          1. _matchedGroupNames_ を空 List。
          1. 1 ≤ _i_ ≤ _n_ を昇順で各 _i_ について
            1. _captureI_ を _r_.[[Captures]] の _i_ 番目要素。
            1. _captureI_ が *undefined* なら
              1. _capturedValue_ を *undefined*。
              1. _indices_ に *undefined* を追加。
            1. そうでなければ
              1. _captureStart_ を _captureI_.[[StartIndex]]。
              1. _captureEnd_ を _captureI_.[[EndIndex]]。
              1. _fullUnicode_ が *true* なら
                1. _captureStart_ を GetStringIndex(_S_, _captureStart_)。
                1. _captureEnd_ を GetStringIndex(_S_, _captureEnd_)。
              1. _capture_ を Match Record { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }。
              1. _capturedValue_ を GetMatchString(_S_, _capture_)。
              1. _indices_ に _capture_ を追加。
            1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_)。
            1. _i_ 番目のキャプチャが |GroupName| で定義されているなら
              1. _s_ をその |GroupName| の CapturingGroupName とする。
              1. _matchedGroupNames_ が _s_ を含むなら
                1. アサート: _capturedValue_ は *undefined*。
                1. _groupNames_ に *undefined* を追加。
              1. そうでなければ
                1. _capturedValue_ が *undefined* でなければ _s_ を _matchedGroupNames_ に追加。
                1. 注記: 同名グループが複数ある場合 _groups_ に既に _s_ プロパティが存在することがあるが、すべて可書きデータプロパティなので CreateDataPropertyOrThrow は成功する。
                1. ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_)。
                1. _groupNames_ に _s_ を追加。
            1. そうでなければ
              1. _groupNames_ に *undefined* を追加。
          1. _hasIndices_ が *true* なら
            1. _indicesArray_ を MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_) とする。
            1. ! CreateDataPropertyOrThrow(_A_, *"indices"*, _indicesArray_)。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-advancestringindex" type="abstract operation">
        <h1>
          AdvanceStringIndex (
            _S_: String,
            _index_: 非負整数,
            _unicode_: Boolean,
          ): 整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: _index_ ≤ 2<sup>53</sup> - 1。
          1. _unicode_ が *false* なら _index_ + 1 を返す。
          1. _length_ を _S_ の長さ。
          1. _index_ + 1 ≥ _length_ なら _index_ + 1 を返す。
          1. _cp_ を CodePointAt(_S_, _index_)。
          1. _index_ + _cp_.[[CodeUnitCount]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getstringindex" type="abstract operation">
        <h1>
          GetStringIndex (
            _S_: String,
            _codePointIndex_: 非負整数,
          ): 非負整数
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_S_ を UTF-16 エンコードされたコードポイント列として解釈し (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>)、_codePointIndex_ に対応するコードユニットインデックスが存在すればそれを返し、存在しなければ _S_ の長さを返す。</dd>
        </dl>
        <emu-alg>
          1. _S_ が空文字列なら 0 を返す。
          1. _len_ を _S_ の長さ。
          1. _codeUnitCount_ を 0。
          1. _codePointCount_ を 0。
          1. _codeUnitCount_ &lt; _len_ の間繰り返し、
            1. _codePointCount_ = _codePointIndex_ なら _codeUnitCount_ を返す。
            1. _cp_ を CodePointAt(_S_, _codeUnitCount_)。
            1. _codeUnitCount_ を _codeUnitCount_ + _cp_.[[CodeUnitCount]] に。
            1. _codePointCount_ を _codePointCount_ + 1 に。
          1. _len_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-match-records">
        <h1>Match レコード</h1>
        <p><dfn variants="Match Records">Match Record</dfn> は正規表現のマッチまたはキャプチャの開始・終了インデックスを保持する Record 値である。</p>
        <p>Match Record は <emu-xref href="#table-match-record"></emu-xref> に列挙するフィールドを持つ。</p>
        <emu-table id="table-match-record" caption="Match Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[StartIndex]]</td>
              <td>非負整数</td>
              <td>マッチ開始位置 (含む) までのコードユニット数。</td>
            </tr>
            <tr>
              <td>[[EndIndex]]</td>
              <td>[[StartIndex]] 以上の整数</td>
              <td>マッチ終了位置 (含まない) までのコードユニット数。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getmatchstring" type="abstract operation">
        <h1>
          GetMatchString (
            _S_: String,
            _match_: Match Record,
          ): String
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ _S_ の長さ。
          1. _S_ の _match_.[[StartIndex]] から _match_.[[EndIndex]] までの部分文字列を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmatchindexpair" type="abstract operation">
        <h1>
          GetMatchIndexPair (
            _S_: String,
            _match_: Match Record,
          ): Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ _S_ の長さ。
          1. CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) ») を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makematchindicesindexpairarray" type="abstract operation">
        <h1>
          MakeMatchIndicesIndexPairArray (
            _S_: String,
            _indices_: Match Record または *undefined* の List,
            _groupNames_: String または *undefined* の List,
            _hasGroups_: Boolean,
          ): Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _n_ を _indices_ の要素数。
          1. アサート: _n_ &lt; 2<sup>32</sup> - 1。
          1. アサート: _groupNames_ は _n_ - 1 要素を持つ。
          1. 注記: _groupNames_ の要素は _indices_[1] から整列。
          1. _A_ を ! ArrayCreate(_n_)。
          1. _hasGroups_ が *true* なら
            1. _groups_ を OrdinaryObjectCreate(*null*)。
          1. そうでなければ
            1. _groups_ を *undefined*。
          1. ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_)。
          1. 0 ≤ _i_ &lt; _n_ を昇順で各 _i_ について
            1. _matchIndices_ を _indices_[_i_]。
            1. _matchIndices_ が *undefined* でなければ
              1. _matchIndexPair_ を GetMatchIndexPair(_S_, _matchIndices_)。
            1. そうでなければ
              1. _matchIndexPair_ を *undefined*。
            1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_)。
            1. _i_ > 0 なら
              1. _s_ を _groupNames_[_i_ - 1]。
              1. _s_ が *undefined* でなければ
                1. アサート: _groups_ は *undefined* でない。
                1. 注記: 同名グループが複数ある場合でも _groups_ は通常オブジェクトなので再作成は成功する。
                1. ! CreateDataPropertyOrThrow(_groups_, _s_, _matchIndexPair_)。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-regexp-instances">
      <h1>RegExp インスタンスのプロパティ</h1>
      <p>RegExp インスタンスは RegExp プロトタイプオブジェクトからプロパティを継承する通常オブジェクトである。RegExp インスタンスは内部スロット [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] を持つ。[[RegExpMatcher]] 内部スロットの値は RegExp オブジェクトの |Pattern| の抽象クロージャ表現である。</p>
      <emu-note>
        <p>ECMAScript 2015 以前は RegExp インスタンスは独自データプロパティ *"source"*, *"global"*, *"ignoreCase"*, *"multiline"* を持つと規定されていた。これらは現在 `RegExp.prototype` のアクセサプロパティとして規定される。</p>
      </emu-note>
      <p>RegExp インスタンスは次のプロパティも持つ:</p>

      <emu-clause id="sec-lastindex">
        <h1>lastIndex</h1>
        <p>*"lastIndex"* プロパティの値は次のマッチを開始する String インデックスを指定する。使用時に整数 Number へ強制される (<emu-xref href="#sec-regexpbuiltinexec"></emu-xref> 参照)。属性は { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } とする。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-string-iterator-objects">
      <h1>RegExp 文字列イテレータオブジェクト</h1>
      <p><dfn variants="RegExp String Iterators,RegExp String Iterator object,RegExp String Iterator objects">RegExp String Iterator</dfn> は、特定の RegExp インスタンスオブジェクトに対して、特定の String インスタンスオブジェクト上の反復処理を表すオブジェクトである。RegExp String Iterator オブジェクトに対する名前付きコンストラクターは存在しない。代わりに、RegExp インスタンスオブジェクトの特定メソッド呼び出しによって生成される。</p>

      <emu-clause id="sec-createregexpstringiterator" type="abstract operation">
        <h1>
          CreateRegExpStringIterator (
            _R_: オブジェクト,
            _S_: String,
            _global_: Boolean,
            _fullUnicode_: Boolean,
          ): オブジェクト
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _iterator_ を OrdinaryObjectCreate(%RegExpStringIteratorPrototype%, « [[IteratingRegExp]], [[IteratedString]], [[Global]], [[Unicode]], [[Done]] ») とする。
          1. _iterator_.[[IteratingRegExp]] に _R_ を設定する。
          1. _iterator_.[[IteratedString]] に _S_ を設定する。
          1. _iterator_.[[Global]] に _global_ を設定する。
          1. _iterator_.[[Unicode]] に _fullUnicode_ を設定する。
          1. _iterator_.[[Done]] に *false* を設定する。
          1. _iterator_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%regexpstringiteratorprototype%-object">
        <h1>%RegExpStringIteratorPrototype% オブジェクト</h1>
        <p><dfn>%RegExpStringIteratorPrototype%</dfn> オブジェクト:</p>
        <ul>
          <li>全ての RegExp String Iterator オブジェクトに継承されるプロパティを持つ。</li>
          <li>通常のオブジェクトである。</li>
          <li>[[Prototype]] 内部スロットの値は %Iterator.prototype% である。</li>
          <li>以下のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-%regexpstringiteratorprototype%.next">
          <h1>%RegExpStringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. _O_ を *this* 値とする。
            1. _O_ がオブジェクトでなければ *TypeError* 例外を投げる。
            1. _O_ が RegExp String Iterator Object Instance の全内部スロット（<emu-xref href="#sec-properties-of-regexp-string-iterator-instances"></emu-xref> 参照）を持たなければ *TypeError* 例外を投げる。
            1. _O_.[[Done]] が *true* なら
              1. CreateIteratorResultObject(*undefined*, *true*) を返す。
            1. _R_ を _O_.[[IteratingRegExp]] とする。
            1. _S_ を _O_.[[IteratedString]] とする。
            1. _global_ を _O_.[[Global]] とする。
            1. _fullUnicode_ を _O_.[[Unicode]] とする。
            1. _match_ を ? RegExpExec(_R_, _S_) とする。
            1. _match_ が *null* なら
              1. _O_.[[Done]] に *true* を設定する。
              1. CreateIteratorResultObject(*undefined*, *true*) を返す。
            1. _global_ が *false* なら
              1. _O_.[[Done]] に *true* を設定する。
              1. CreateIteratorResultObject(_match_, *false*) を返す。
            1. _matchStr_ を ? ToString(? Get(_match_, *"0"* )) とする。
            1. _matchStr_ が空文字列なら
              1. _thisIndex_ を ℝ(? ToLength(? Get(_R_, *"lastIndex"*))) とする。
              1. _nextIndex_ を AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_) とする。
              1. ? Set(_R_, *"lastIndex"*, 𝔽(_nextIndex_), *true*) を実行する。
            1. CreateIteratorResultObject(_match_, *false*) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%regexpstringiteratorprototype%-@@tostringtag" id="sec-%regexpstringiteratorprototype%-%symbol.tostringtag%">
          <h1>%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"RegExp String Iterator"* である。</p>
          <p>このプロパティの属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } である。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-regexp-string-iterator-instances">
        <h1>RegExp String Iterator インスタンスのプロパティ</h1>
        <p>RegExp String Iterator インスタンスは %RegExpStringIteratorPrototype% 組込みオブジェクトからプロパティを継承する通常オブジェクトである。RegExp String Iterator インスタンスは初期化時に <emu-xref href="#table-regexp-string-iterator-instance-slots"></emu-xref> に列挙された内部スロットを持つ。</p>
        <emu-table id="table-regexp-string-iterator-instance-slots" caption="RegExp String Iterator インスタンスの内部スロット">
          <table>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>[[IteratingRegExp]]</td>
              <td>an Object</td>
              <td>反復に使用される正規表現。IsRegExp([[IteratingRegExp]]) は初期状態で *true*。</td>
            </tr>
            <tr>
              <td>[[IteratedString]]</td>
              <td>a String</td>
              <td>反復対象となる String 値。</td>
            </tr>
            <tr>
              <td>[[Global]]</td>
              <td>a Boolean</td>
              <td>[[IteratingRegExp]] が global かどうかを示す。</td>
            </tr>
            <tr>
              <td>[[Unicode]]</td>
              <td>a Boolean</td>
              <td>[[IteratingRegExp]] が Unicode モードかどうかを示す。</td>
            </tr>
            <tr>
              <td>[[Done]]</td>
              <td>a Boolean</td>
              <td>反復処理が完了しているかどうかを示す。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>インデックス付きコレクション</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array オブジェクト</h1>
    <p>配列 (Array) は特定種類のプロパティ名に特別な扱いを与えるエキゾチックオブジェクトである。この特別扱いの定義については <emu-xref href="#sec-array-exotic-objects"></emu-xref> を参照。</p>

    <emu-clause id="sec-array-constructor">
      <h1>Array コンストラクター</h1>
      <p>Array コンストラクター:</p>
      <ul>
        <li><dfn>%Array%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Array"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼び出されたとき新しい Array を生成し初期化する。</li>
        <li>関数として（コンストラクターではなく）呼び出された場合も新しい Array を生成し初期化する。従って関数呼び出し `Array(…)` は、同じ引数のオブジェクト生成式 `new Array(…)` と等価である。</li>
        <li>その振る舞いが引数の個数と型に依存して変化する関数である。</li>
        <li>クラス定義の `extends` 句の値として利用できる。エキゾチック Array の挙動を継承することを意図したサブクラスコンストラクターは、サブクラスインスタンス（Array エキゾチックオブジェクト）を初期化するために Array コンストラクターへの `super` 呼び出しを含めなければならない。ただし、`Array.prototype` のメソッドの多くは *this* 値が Array エキゾチックオブジェクトであることに依存しない汎用メソッドである。</li>
      </ul>

      <emu-clause id="sec-array" oldids="sec-array-constructor-array,sec-array-len,sec-array-items">
        <h1>Array ( ..._values_ )</h1>
        <p>この関数は呼び出し時に以下の手順を実行する:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら _newTarget_ をアクティブな関数オブジェクトとし；そうでなければ _newTarget_ を NewTarget とする。
          1. _proto_ を ? GetPrototypeFromConstructor(_newTarget_, *"%Array.prototype%"*) とする。
          1. _numberOfArgs_ を _values_ の要素数とする。
          1. _numberOfArgs_ = 0 なら
            1. ! ArrayCreate(0, _proto_) を返す。
          1. そうでなく _numberOfArgs_ = 1 なら
            1. _len_ を _values_[0] とする。
            1. _array_ を ! ArrayCreate(0, _proto_) とする。
            1. _len_ が Number でなければ
              1. ! CreateDataPropertyOrThrow(_array_, *"0"*, _len_) を実行。
              1. _intLen_ を *1*<sub>𝔽</sub> とする。
            1. そうでなければ
              1. _intLen_ を ! ToUint32(_len_) とする。
              1. SameValueZero(_intLen_, _len_) が *false* なら *RangeError* 例外を投げる。
            1. ! Set(_array_, *"length"*, _intLen_, *true*) を実行。
            1. _array_ を返す。
          1. それ以外の場合
            1. アサート: _numberOfArgs_ ≥ 2.
            1. _array_ を ? ArrayCreate(_numberOfArgs_, _proto_) とする。
            1. _k_ を 0 とする。
            1. _k_ &lt; _numberOfArgs_ の間繰り返し、
              1. _Pk_ を ! ToString(𝔽(_k_)) とする。
              1. _itemK_ を _values_[_k_] とする。
              1. ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_) を実行。
              1. _k_ を _k_ + 1 にする。
            1. アサート: _array_ の *"length"* プロパティの数学的値は _numberOfArgs_ である。
            1. _array_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Array コンストラクターのプロパティ</h1>
      <p>Array コンストラクター:</p>
      <ul>
        <li>値 %Function.prototype% を持つ [[Prototype]] 内部スロットを有する。</li>
        <li>値 *1*<sub>𝔽</sub> の *"length"* プロパティを持つ。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-array.from">
        <h1>Array.from ( _items_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>このメソッドは呼び出し時に以下を実行する:</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. _mapper_ が *undefined* なら
            1. _mapping_ を *false* とする。
          1. そうでなければ
            1. IsCallable(_mapper_) が *false* なら *TypeError* 例外を投げる。
            1. _mapping_ を *true* とする。
          1. _usingIterator_ を ? GetMethod(_items_, %Symbol.iterator%) とする。
          1. _usingIterator_ が *undefined* でなければ
            1. IsConstructor(_C_) が *true* なら
              1. _A_ を ? Construct(_C_) とする。
            1. そうでなければ
              1. _A_ を ! ArrayCreate(0) とする。
            1. _iteratorRecord_ を ? GetIteratorFromMethod(_items_, _usingIterator_) とする。
            1. _k_ を 0 とする。
            1. 繰り返し、
              1. _k_ ≥ 2<sup>53</sup> - 1 なら
                1. _error_ を ThrowCompletion(新規 *TypeError* オブジェクト) とする。
                1. ? IteratorClose(_iteratorRecord_, _error_) を返す。
              1. _Pk_ を ! ToString(𝔽(_k_)) とする。
              1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
              1. _next_ が ~done~ なら
                1. ? Set(_A_, *"length"*, 𝔽(_k_), *true*) を実行。
                1. _A_ を返す。
              1. _mapping_ が *true* なら
                1. _mappedValue_ を Completion(Call(_mapper_, _thisArg_, « _next_, 𝔽(_k_) »)) とする。
                1. IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_)。
              1. そうでなければ
                1. _mappedValue_ を _next_ とする。
              1. _defineStatus_ を Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)) とする。
              1. IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_)。
              1. _k_ を _k_ + 1 にする。
          1. 注記: _items_ は iterable ではないので配列ライクオブジェクトとみなす。
          1. _arrayLike_ を ! ToObject(_items_) とする。
          1. _len_ を ? LengthOfArrayLike(_arrayLike_) とする。
          1. IsConstructor(_C_) が *true* なら
            1. _A_ を ? Construct(_C_, « 𝔽(_len_) ») とする。
          1. そうでなければ
            1. _A_ を ? ArrayCreate(_len_) とする。
          1. _k_ を 0 にする。
          1. _k_ &lt; _len_ の間繰り返し、
            1. _Pk_ を ! ToString(𝔽(_k_)) とする。
            1. _kValue_ を ? Get(_arrayLike_, _Pk_) とする。
            1. _mapping_ が *true* なら
              1. _mappedValue_ を ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) ») とする。
            1. そうでなければ
              1. _mappedValue_ を _kValue_ とする。
            1. ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_) を実行。
            1. _k_ を _k_ + 1 にする。
          1. ? Set(_A_, *"length"*, 𝔽(_len_), *true*) を実行。
          1. _A_ を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的に汎用のファクトリメソッドであり、*this* 値が Array コンストラクターであることを要求しない。そのため単一の数値引数で呼び出され得る他のコンストラクターに転用または継承できる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.isarray">
        <h1>Array.isArray ( _arg_ )</h1>
        <p>この関数は呼び出し時に以下を実行する:</p>
        <emu-alg>
          1. ? IsArray(_arg_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.of">
        <h1>Array.of ( ..._items_ )</h1>
        <p>このメソッドは呼び出し時に以下を実行する:</p>
        <emu-alg>
          1. _len_ を _items_ の要素数とする。
          1. _lenNumber_ を 𝔽(_len_) とする。
          1. _C_ を *this* 値とする。
          1. IsConstructor(_C_) が *true* なら
            1. _A_ を ? Construct(_C_, « _lenNumber_ ») とする。
          1. そうでなければ
            1. _A_ を ? ArrayCreate(_len_) とする。
          1. _k_ を 0。
          1. _k_ &lt; _len_ の間繰り返し、
            1. _kValue_ を _items_[_k_] とする。
            1. _Pk_ を ! ToString(𝔽(_k_)) とする。
            1. ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_) を実行。
            1. _k_ を _k_ + 1。
          1. ? Set(_A_, *"length"*, _lenNumber_, *true*) を実行。
          1. _A_ を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的に汎用のファクトリメソッドであり、*this* 値が Array コンストラクターであることを要求しない。そのため単一の数値引数で呼び出され得る他のコンストラクターへ転用または継承できる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype">
        <h1>Array.prototype</h1>
        <p>`Array.prototype` の値は Array プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-array-@@species" id="sec-get-array-%symbol.species%">
        <h1>get Array [ %Symbol.species% ]</h1>
        <p>`Array[%Symbol.species%]` は set アクセサ関数が *undefined* のアクセサプロパティであり、その get アクセサは以下を行う:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティの値は *"get [Symbol.species]"* である。</p>
        <emu-note>
          <p>Array プロトタイプメソッドは通常、その *this* 値の constructor を使って派生オブジェクトを生成する。しかしサブクラスコンストラクターは %Symbol.species% プロパティを再定義することで既定の挙動を上書きできる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-prototype-object">
      <h1>Array プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Array プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Array.prototype%</dfn> である。</li>
        <li>Array エキゾチックオブジェクトであり、そのようなオブジェクトに規定された内部メソッドを持つ。</li>
        <li>初期値 *+0*<sub>𝔽</sub> の *"length"* プロパティを持ち、その属性は { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } である。</li>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      </ul>
      <emu-note>
        <p>Array プロトタイプオブジェクトを Array エキゾチックオブジェクトとして規定するのは ECMAScript 2015 以前に作成されたコードとの互換性を確保するためである。</p>
      </emu-note>

      <emu-clause id="sec-array.prototype.at">
        <h1>Array.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value) とする。
          1. _len_ を ? LengthOfArrayLike(_O_) とする。
          1. _relativeIndex_ を ? ToIntegerOrInfinity(_index_) とする。
          1. _relativeIndex_ ≥ 0 なら
            1. _k_ を _relativeIndex_ とする。
          1. そうでなければ
            1. _k_ を _len_ + _relativeIndex_ とする。
          1. _k_ &lt; 0 または _k_ ≥ _len_ なら *undefined* を返す。
          1. ? Get(_O_, ! ToString(𝔽(_k_))) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.concat">
        <h1>Array.prototype.concat ( ..._items_ )</h1>
        <p>このメソッドは対象オブジェクトの配列要素に続いて各引数の配列要素を順に含む配列を返す。</p>
        <p>呼び出し時に以下を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value) とする。
          1. _A_ を ? ArraySpeciesCreate(_O_, 0) とする。
          1. _n_ を 0。
          1. _items_ の先頭に _O_ を挿入する。
          1. 各要素 _E_ ∈ _items_ について:
            1. _spreadable_ を ? IsConcatSpreadable(_E_) とする。
            1. _spreadable_ が *true* なら
              1. _len_ を ? LengthOfArrayLike(_E_) とする。
              1. _n_ + _len_ > 2<sup>53</sup> - 1 なら *TypeError* 例外。
              1. _k_ を 0。
              1. _k_ &lt; _len_ の間:
                1. _Pk_ を ! ToString(𝔽(_k_)) とする。
                1. _exists_ を ? HasProperty(_E_, _Pk_) とする。
                1. _exists_ が *true* なら
                  1. _subElement_ を ? Get(_E_, _Pk_) とする。
                  1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_) を実行。
                1. _n_ を _n_ + 1。
                1. _k_ を _k_ + 1。
            1. そうでなければ
              1. 注記: _E_ は展開されず単一要素として追加される。
              1. _n_ ≥ 2<sup>53</sup> - 1 なら *TypeError* 例外。
              1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_) を実行。
              1. _n_ を _n_ + 1。
          1. <span id="step-array-proto-concat-set-length">? Set(_A_, *"length"*, 𝔽(_n_), *true*) を実行。</span>
          1. _A_ を返す。
        </emu-alg>
        <p>このメソッドの *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
        <emu-note>
          <p>ステップ <emu-xref href="#step-array-proto-concat-set-length"></emu-xref> で *"length"* を明示的に設定するのは、_items_ の最後の非空要素に後続の hole がある場合や _A_ が組込み Array でない場合の正しい長さを保証するためである。</p>
        </emu-note>
        <emu-note>
          <p>このメソッドは意図的に汎用であり、*this* 値が Array であることを要求しない。そのため他の種類のオブジェクトへメソッドとして転用可能である。</p>
        </emu-note>

        <emu-clause id="sec-isconcatspreadable" type="abstract operation">
          <h1>
            IsConcatSpreadable (
              _O_: ECMAScript 言語値,
            ): Boolean を含む通常完了または throw 完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _O_ がオブジェクトでなければ *false* を返す。
            1. _spreadable_ を ? Get(_O_, %Symbol.isConcatSpreadable%) とする。
            1. _spreadable_ が *undefined* でなければ ToBoolean(_spreadable_) を返す。
            1. ? IsArray(_O_) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.constructor">
        <h1>Array.prototype.constructor</h1>
        <p>`Array.prototype.constructor` の初期値は %Array% である。</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.copywithin">
        <h1>Array.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <emu-note>
          <p>_end_ 引数は省略可。指定されない場合 *this* 値の長さが使われる。</p>
        </emu-note>
        <emu-note>
          <p>_target_ が負なら配列長を _length_ として <emu-eqn>_length_ + _target_</emu-eqn> と扱う。_start_ が負なら <emu-eqn>_length_ + _start_</emu-eqn>。_end_ が負なら <emu-eqn>_length_ + _end_</emu-eqn> と扱う。</p>
        </emu-note>
        <p>このメソッドは呼び出し時に以下を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _relativeTarget_ を ? ToIntegerOrInfinity(_target_)。
          1. _relativeTarget_ = -∞ なら _to_ = 0。
          1. そうでなく _relativeTarget_ &lt; 0 なら _to_ = max(_len_ + _relativeTarget_, 0)。
          1. それ以外は _to_ = min(_relativeTarget_, _len_)。
          1. _relativeStart_ を ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _from_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _from_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _from_ = min(_relativeStart_, _len_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _len_；そうでなければ _relativeEnd_ を ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _final_ = 0。
          1. そうでなく _relativeEnd_ &lt; 0 なら _final_ = max(_len_ + _relativeEnd_, 0)。
          1. それ以外は _final_ = min(_relativeEnd_, _len_)。
          1. _count_ を min(_final_ - _from_, _len_ - _to_)。
          1. _from_ &lt; _to_ かつ _to_ &lt; _from_ + _count_ なら
            1. _direction_ = -1。
            1. _from_ = _from_ + _count_ - 1。
            1. _to_ = _to_ + _count_ - 1。
          1. そうでなければ
            1. _direction_ = 1。
          1. _count_ > 0 の間繰り返し、
            1. _fromKey_ を ! ToString(𝔽(_from_))。
            1. _toKey_ を ! ToString(𝔽(_to_))。
            1. _fromPresent_ を ? HasProperty(_O_, _fromKey_)。
            1. _fromPresent_ が *true* なら
              1. _fromValue_ を ? Get(_O_, _fromKey_)。
              1. ? Set(_O_, _toKey_, _fromValue_, *true*)。
            1. そうでなければ
              1. アサート: _fromPresent_ は *false*。
              1. ? DeletePropertyOrThrow(_O_, _toKey_)。
            1. _from_ += _direction_。
            1. _to_ += _direction_。
            1. _count_ -= 1。
          1. _O_ を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的に汎用であり、*this* 値が Array である必要はない。他オブジェクトへ転用できる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.entries">
        <h1>Array.prototype.entries ( )</h1>
        <p>このメソッドは呼び出し時以下を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. CreateArrayIterator(_O_, ~key+value~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.every">
        <h1>Array.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ は 3 引数を受け取り Boolean へ強制可能な値を返す関数であるべき。`every` は昇順で各要素に対し _callback_ を 1 回ずつ呼び、_callback_ が *false* を返す要素を見つけた時点で直ちに *false* を返す。見つからなければ *true* を返す。_callback_ は実際に存在する要素に対してのみ呼ばれ、欠落要素には呼ばれない。</p>
          <p>_thisArg_ が指定されれば各呼び出しの *this* 値として使用され、指定がなければ *undefined* が用いられる。</p>
          <p>_callback_ は (要素値, 要素インデックス, 走査対象オブジェクト) を受け取る。</p>
          <p>`every` 自体は直接対象オブジェクトをミューテートしないが、_callback_ の呼び出しにより変更され得る。</p>
          <p>処理される要素の範囲は最初の _callback_ 呼び出し前に固定される。`every` 開始後に追加された要素は訪問されない。既存要素が変更された場合、その時点の値が渡される；開始後に削除された要素は訪問されない。空配列に対しては *true* を返し、数学の「全て」量化に相当する。</p>
        </emu-note>
        <p>このメソッドは呼び出し時以下を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. IsCallable(_callback_) が *false* なら *TypeError* 例外。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間繰り返し、
            1. _Pk_ を ! ToString(𝔽(_k_))。
            1. _kPresent_ を ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ を ? Get(_O_, _Pk_)。
              1. _testResult_ を ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
              1. _testResult_ が *false* なら *false* を返す。
            1. _k_ を _k_ + 1。
          1. *true* を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的に汎用であり、*this* 値が Array であることを要求しない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.fill">
        <h1>Array.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <emu-note>
          <p>_start_ は省略可。省略時 *+0*<sub>𝔽</sub> を使用。</p>
          <p>_end_ は省略可。省略時 *this* 値の長さを使用。</p>
        </emu-note>
        <emu-note>
          <p>_start_ が負なら <emu-eqn>_length_ + _start_</emu-eqn>、_end_ が負なら <emu-eqn>_length_ + _end_</emu-eqn> と扱う。</p>
        </emu-note>
        <p>このメソッドは呼び出し時以下を実行:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ を ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _k_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _k_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _k_ = min(_relativeStart_, _len_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _len_；そうでなければ _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _final_ = 0。
          1. そうでなく _relativeEnd_ &lt; 0 なら _final_ = max(_len_ + _relativeEnd_, 0)。
          1. それ以外は _final_ = min(_relativeEnd_, _len_)。
          1. _k_ &lt; _final_ の間繰り返し、
            1. _Pk_ を ! ToString(𝔽(_k_))。
            1. ? Set(_O_, _Pk_, _value_, *true*)。
            1. _k_++。
          1. _O_ を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的に汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.filter">
        <h1>Array.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ は 3 引数を受け Boolean へ強制可能な値を返す関数であるべき。`filter` は昇順で各要素に対し _callback_ を呼び、*true* を返した値を集め新しい配列を構成する。欠落要素には呼ばれない。</p>
          <p>_thisArg_ が提供されれば *this* として使われ、なければ *undefined*。</p>
          <p>_callback_ は (値, インデックス, 走査対象) を受け取る。</p>
          <p>`filter` 自体は直接オブジェクトを変更しないが _callback_ により変更され得る。</p>
          <p>処理範囲は開始前に固定。開始後に追加された要素は訪問されず、変更された既存要素は訪問時点の値、開始後に削除された要素は訪問されない。</p>
        </emu-note>
        <p>このメソッドは呼び出し時以下を実行:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _A_ を ? ArraySpeciesCreate(_O_, 0)。
          1. _k_ = 0。
          1. _to_ = 0。
          1. _k_ &lt; _len_ の間繰り返し、
            1. _Pk_ を ! ToString(𝔽(_k_))。
            1. _kPresent_ を ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ を ? Get(_O_, _Pk_)。
              1. _selected_ を ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
              1. _selected_ が *true* なら
                1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_)。
                1. _to_++。
            1. _k_++。
          1. _A_ を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.find">
        <h1>Array.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>このメソッドは昇順インデックスで各要素に対し _predicate_ を呼び、*true* に強制される値を返した最初の要素値を返す。存在しなければ *undefined*。</p>
          <p>追加情報は FindViaPredicate を参照。</p>
        </emu-note>
        <p>呼び出し時の手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _findRec_ を ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Value]] を返す。
        </emu-alg>
        <emu-note>
          <p>汎用メソッド。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findindex">
        <h1>Array.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>昇順で _predicate_ を呼び、*true* に強制される値を返した最初の要素のインデックスを返す。なければ -1。</p>
          <p>追加情報は FindViaPredicate 参照。</p>
        </emu-note>
        <p>呼び出し時手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _findRec_ を ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Index]] を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlast">
        <h1>Array.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>降順で _predicate_ を呼び、*true* に強制される値を返した最初の要素値を返す。なければ *undefined*。</p>
          <p>追加情報は FindViaPredicate 参照。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _findRec_ を ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Value]] を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlastindex">
        <h1>Array.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>降順で _predicate_ を呼び、*true* に強制される値を返した最初の要素のインデックスを返す。なければ -1。</p>
          <p>追加情報は FindViaPredicate 参照。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _findRec_ を ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Index]] を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>

        <emu-clause id="sec-findviapredicate" type="abstract operation">
          <h1>
            FindViaPredicate (
              _O_: オブジェクト,
              _len_: 非負整数,
              _direction_: ~ascending~ または ~descending~,
              _predicate_: ECMAScript 言語値,
              _thisArg_: ECMAScript 言語値,
            ): フィールド [[Index]] (整数 Number) と [[Value]] (ECMAScript 言語値) を持つ Record を含む通常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              <p>_O_ は配列ライクまたは TypedArray であるべき。この操作は指定方向で各要素に _predicate_ を 1 回ずつ呼び、*true* に強制される値を返した時点でそのインデックスと値を含む Record を返す。該当要素がない場合、インデックス *-1*<sub>𝔽</sub> と値 *undefined* の Record を返す。</p>
              <p>_predicate_ は関数であるべき。呼び出し時 (要素値, インデックス, 対象オブジェクト) が渡され、戻り値は Boolean へ強制される。</p>
              <p>_thisArg_ は各呼び出しの *this* として用いられる。</p>
              <p>この操作自体は直接オブジェクトを変更しないが _predicate_ により変更され得る。</p>
              <p>処理範囲は走査開始直前に固定される。以降に追加された要素は訪問されない。既存要素が変更された場合はその訪問時の値が渡される。走査開始後に削除された要素は依然訪問され、存在しなければ *undefined* またはプロトタイプから取得される。</p>
            </dd>
          </dl>
          <emu-alg>
            1. IsCallable(_predicate_) が *false* なら *TypeError* 例外。
            1. _direction_ が ~ascending~ なら
              1. _indices_ を 0 以上 _len_ 未満の整数の昇順 List とする。
            1. そうでなければ
              1. _indices_ を 0 以上 _len_ 未満の整数の降順 List とする。
            1. 各整数 _k_ ∈ _indices_ について
              1. _Pk_ を ! ToString(𝔽(_k_))。
              1. 注記: _O_ が TypedArray の場合、次の Get 呼び出しは正常完了を返す。
              1. _kValue_ を ? Get(_O_, _Pk_)。
              1. _testResult_ を ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
              1. ToBoolean(_testResult_) が *true* なら Record { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ } を返す。
            1. Record { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* } を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flat">
        <h1>Array.prototype.flat ( [ _depth_ ] )</h1>
        <p>このメソッドは呼び出し時以下を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _sourceLen_ を ? LengthOfArrayLike(_O_)。
          1. _depthNum_ = 1。
          1. _depth_ が *undefined* でなければ
            1. _depthNum_ を ? ToIntegerOrInfinity(_depth_) に設定。
            1. _depthNum_ &lt; 0 なら _depthNum_ = 0。
          1. _A_ を ? ArraySpeciesCreate(_O_, 0)。
          1. ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_) を実行。
          1. _A_ を返す。
        </emu-alg>

        <emu-clause id="sec-flattenintoarray" type="abstract operation">
          <h1>
            FlattenIntoArray (
              _target_: オブジェクト,
              _source_: オブジェクト,
              _sourceLen_: 非負整数,
              _start_: 非負整数,
              _depth_: 非負整数または +&infin;,
              optional _mapperFunction_: 関数オブジェクト,
              optional _thisArg_: ECMAScript 言語値,
            ): 非負整数を含む通常完了または throw 完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. アサート: _mapperFunction_ が存在するなら IsCallable(_mapperFunction_) は *true* であり、_thisArg_ が存在し、かつ _depth_ は 1。
            1. _targetIndex_ を _start_。
            1. _sourceIndex_ を *+0*<sub>𝔽</sub>。
            1. ℝ(_sourceIndex_) &lt; _sourceLen_ の間繰り返し、
              1. _P_ を ! ToString(_sourceIndex_)。
              1. _exists_ を ? HasProperty(_source_, _P_)。
              1. _exists_ が *true* なら
                1. _element_ を ? Get(_source_, _P_)。
                1. _mapperFunction_ が存在するなら
                  1. _element_ を ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ ») に設定。
                1. _shouldFlatten_ を *false*。
                1. _depth_ > 0 なら
                  1. _shouldFlatten_ を ? IsArray(_element_) に設定。
                1. _shouldFlatten_ が *true* なら
                  1. _depth_ = +∞ なら _newDepth_ = +∞。
                  1. そうでなければ _newDepth_ = _depth_ - 1。
                  1. _elementLen_ を ? LengthOfArrayLike(_element_)。
                  1. _targetIndex_ を ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_) に設定。
                1. そうでなければ
                  1. _targetIndex_ ≥ 2<sup>53</sup> - 1 なら *TypeError* 例外。
                  1. ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_)。
                  1. _targetIndex_++。
              1. _sourceIndex_ を _sourceIndex_ + *1*<sub>𝔽</sub>。
            1. _targetIndex_ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flatmap">
        <h1>Array.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>このメソッドは呼び出し時以下を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _sourceLen_ を ? LengthOfArrayLike(_O_)。
            1. IsCallable(_mapperFunction_) が *false* なら *TypeError* 例外。
          1. _A_ を ? ArraySpeciesCreate(_O_, 0)。
          1. ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_) を実行。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.foreach">
        <h1>Array.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ は 3 引数を受け取る関数であるべき。`forEach` は昇順で存在する各要素に対し _callback_ を 1 回呼ぶ。欠落要素には呼ばれない。</p>
          <p>_thisArg_ があれば *this* 値、なければ *undefined*。</p>
          <p>_callback_ の引数は (値, インデックス, 対象オブジェクト)。</p>
          <p>`forEach` 自体は直接オブジェクトを変更しないが _callback_ により変更され得る。</p>
          <p>処理範囲は開始前に決定。開始後に追加された要素は訪問されず、変更された要素は訪問時の値、開始後に削除されたものは訪問されない。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ を ! ToString(𝔽(_k_))。
            1. _kPresent_ を ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ を ? Get(_O_, _Pk_)。
              1. ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_++。
          1. *undefined* を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.includes">
        <h1>Array.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>このメソッドは SameValueZero アルゴリズムで昇順に _searchElement_ と各要素を比較し、いずれかで一致したら *true*、なければ *false* を返す。</p>
          <p>第 2 引数 _fromIndex_ の既定値は *+0*<sub>𝔽</sub>（全検索）。配列長以上なら *false*。 *-0*<sub>𝔽</sub> 未満なら末尾からのオフセットとして扱い、計算結果が *+0*<sub>𝔽</sub> 以下なら全検索。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _len_ = 0 なら *false*。
          1. _n_ を ? ToIntegerOrInfinity(_fromIndex_)。
          1. アサート: _fromIndex_ が *undefined* なら _n_ = 0。
          1. _n_ = +∞ なら *false*。
          1. そうでなく _n_ = -∞ なら _n_ = 0。
          1. _n_ ≥ 0 なら
            1. _k_ = _n_。
          1. そうでなければ
            1. _k_ = _len_ + _n_。
            1. _k_ &lt; 0 なら _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _elementK_ を ? Get(_O_, ! ToString(𝔽(_k_)))。
            1. SameValueZero(_searchElement_, _elementK_) が *true* なら *true*。
            1. _k_++。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
        <emu-note>
          <p>このメソッドは `indexOf` と異なり、SameValueZero を使うため *NaN* を検出でき、欠落要素をスキップせず *undefined* として扱う。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.indexof">
        <h1>Array.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>昇順で IsStrictlyEqual アルゴリズムにより比較し、マッチする最小インデックスを返し、なければ *-1*<sub>𝔽</sub> を返す。</p>
        <emu-note>
          <p>第 2 引数 _fromIndex_ の既定値は *+0*<sub>𝔽</sub>。配列長以上なら検索せず *-1*<sub>𝔽</sub>。*-0*<sub>𝔽</sub> 未満なら末尾からのオフセットとして扱い、結果が *+0*<sub>𝔽</sub> 以下なら全検索。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _len_ = 0 なら *-1*<sub>𝔽</sub>。
          1. _n_ を ? ToIntegerOrInfinity(_fromIndex_)。
          1. アサート: _fromIndex_ が *undefined* なら _n_ = 0。
          1. _n_ = +∞ なら *-1*<sub>𝔽</sub>。
          1. そうでなく _n_ = -∞ なら _n_ = 0。
          1. _n_ ≥ 0 なら
            1. _k_ = _n_。
          1. そうでなければ
            1. _k_ = _len_ + _n_。
            1. _k_ &lt; 0 なら _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ を ! ToString(𝔽(_k_))。
            1. _kPresent_ を ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _elementK_ を ? Get(_O_, _Pk_)。
              1. IsStrictlyEqual(_searchElement_, _elementK_) が *true* なら 𝔽(_k_)。
            1. _k_++。
          1. *-1*<sub>𝔽</sub> を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.join">
        <h1>Array.prototype.join ( _separator_ )</h1>
        <p>配列要素を String に変換し _separator_ を挟んで連結した結果を返す。_separator_ 未指定ならカンマ。</p>
        <p>呼び出し時手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _separator_ が *undefined* なら _sep_ = *","*；そうでなければ _sep_ = ? ToString(_separator_)。
          1. _R_ を空文字列。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _k_ > 0 なら _R_ を _R_ と _sep_ の連結に更新。
            1. _element_ を ? Get(_O_, ! ToString(𝔽(_k_)))。
            1. _element_ が *undefined* でも *null* でもなければ
              1. _S_ を ? ToString(_element_)。
              1. _R_ を _R_ と _S_ の連結に。
            1. _k_++。
          1. _R_ を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.keys">
        <h1>Array.prototype.keys ( )</h1>
        <p>このメソッドは呼び出し時以下を実行する:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. CreateArrayIterator(_O_, ~key~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.lastindexof">
        <h1>Array.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>降順で IsStrictlyEqual により比較し、一致した最大インデックスを返し、なければ *-1*<sub>𝔽</sub>。</p>
          <p>第2引数 _fromIndex_ の既定は長さ−1。長さ以上なら全検索。*-0*<sub>𝔽</sub> 未満なら末尾からのオフセット。計算結果が *+0*<sub>𝔽</sub> 以下なら *-1*<sub>𝔽</sub>。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _len_ = 0 なら *-1*<sub>𝔽</sub>。
          1. _fromIndex_ が存在すれば _n_ = ? ToIntegerOrInfinity(_fromIndex_)；そうでなければ _n_ = _len_ - 1。
          1. _n_ = -∞ なら *-1*<sub>𝔽</sub>。
          1. _n_ ≥ 0 なら
            1. _k_ = min(_n_, _len_ - 1)。
          1. そうでなければ
            1. _k_ = _len_ + _n_。
          1. _k_ ≥ 0 の間、
            1. _Pk_ を ! ToString(𝔽(_k_))。
            1. _kPresent_ を ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _elementK_ を ? Get(_O_, _Pk_)。
              1. IsStrictlyEqual(_searchElement_, _elementK_) が *true* なら 𝔽(_k_)。
            1. _k_--。
          1. *-1*<sub>𝔽</sub> を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.map">
        <h1>Array.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ は 3 引数を受ける関数であるべき。`map` は昇順に各要素に対し _callback_ を呼び、その結果から新しい配列を作成。欠落要素には呼ばない。</p>
          <p>_thisArg_ があれば *this*、なければ *undefined*。</p>
          <p>_callback_ の引数: (値, インデックス, 対象)。</p>
          <p>`map` 自体は直接ミューテーションしないが _callback_ による変更はあり得る。</p>
          <p>処理範囲は開始前に固定。開始後追加要素は無視、変更要素は訪問時点の値、開始後削除された要素は訪問されない。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _A_ を ? ArraySpeciesCreate(_O_, _len_)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ を ! ToString(𝔽(_k_))。
            1. _kPresent_ を ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ を ? Get(_O_, _Pk_)。
              1. _mappedValue_ を ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
              1. ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)。
            1. _k_++。
          1. _A_ を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.pop">
        <h1>Array.prototype.pop ( )</h1>
        <emu-note>
          <p>最後の要素を削除して返す。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _len_ = 0 なら
            1. ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*)。
            1. *undefined* を返す。
          1. それ以外
            1. アサート: _len_ > 0。
            1. _newLen_ = 𝔽(_len_ - 1)。
            1. _index_ = ! ToString(_newLen_)。
            1. _element_ を ? Get(_O_, _index_)。
            1. ? DeletePropertyOrThrow(_O_, _index_)。
            1. ? Set(_O_, *"length"*, _newLen_, *true*)。
            1. _element_ を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.push">
        <h1>Array.prototype.push ( ..._items_ )</h1>
        <emu-note>
          <p>引数を末尾に順に追加し新しい長さを返す。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _argCount_ を _items_ の要素数。
          1. _len_ + _argCount_ > 2<sup>53</sup> - 1 なら *TypeError*。
          1. 各 _E_ ∈ _items_ について
            1. ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*)。
            1. _len_++。
          1. ? Set(_O_, *"length"*, 𝔽(_len_), *true*)。
          1. 𝔽(_len_) を返す。
        </emu-alg>
        <p>このメソッドの *"length"* は *1*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduce">
        <h1>Array.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callback_ は 4 引数を受け取るべき。`reduce` は最初の（もしくは初期値を与えた場合その次の）要素以降に対して昇順で 1 回ずつ呼ぶ。</p>
          <p>_callback_ の引数: _previousValue_, _currentValue_, _currentIndex_, 走査対象オブジェクト。最初の呼び出し時の _previousValue_ と _currentValue_ は初期値有無で変化。空配列かつ初期値なしは *TypeError*。</p>
          <p>`reduce` 自体は直接ミューテートしない。</p>
          <p>処理範囲は開始前固定。追加要素は無視。変更要素は訪問時の値。開始後削除された要素は訪問されない。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _len_ = 0 かつ _initialValue_ が無ければ *TypeError*。
          1. _k_ = 0。
          1. _accumulator_ = *undefined*。
          1. _initialValue_ が存在すれば
            1. _accumulator_ = _initialValue_。
          1. そうでなければ
            1. _kPresent_ = *false*。
            1. _kPresent_ が *false* かつ _k_ &lt; _len_ の間、
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
              1. _kPresent_ が *true* なら
                1. _accumulator_ = ? Get(_O_, _Pk_)。
              1. _k_++。
            1. _kPresent_ が *false* なら *TypeError*。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_++。
          1. _accumulator_ を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduceright">
        <h1>Array.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>説明は reduce の逆方向版。空配列で初期値なしは *TypeError*。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_, _len_ を前節同様に取得。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _len_ = 0 かつ _initialValue_ 無しなら *TypeError*。
          1. _k_ = _len_ - 1。
          1. _accumulator_ = *undefined*。
          1. _initialValue_ が存在すれば
            1. _accumulator_ = _initialValue_。
          1. そうでなければ
            1. _kPresent_ = *false*。
            1. _kPresent_ が *false* かつ _k_ ≥ 0 の間、
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
              1. _kPresent_ が *true* なら
                1. _accumulator_ = ? Get(_O_, _Pk_)。
              1. _k_--。
            1. _kPresent_ が *false* なら *TypeError*。
          1. _k_ ≥ 0 の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_--。
          1. _accumulator_ を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reverse">
        <h1>Array.prototype.reverse ( )</h1>
        <emu-note>
          <p>要素順序を反転し配列を返す。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _middle_ = floor(_len_ / 2)。
          1. _lower_ = 0。
          1. _lower_ ≠ _middle_ の間、
            1. _upper_ = _len_ - _lower_ - 1。
            1. _upperP_ = ! ToString(𝔽(_upper_))。
            1. _lowerP_ = ! ToString(𝔽(_lower_))。
            1. _lowerExists_ = ? HasProperty(_O_, _lowerP_)。
            1. _lowerExists_ が *true* なら _lowerValue_ = ? Get(_O_, _lowerP_)。
            1. _upperExists_ = ? HasProperty(_O_, _upperP_)。
            1. _upperExists_ が *true* なら _upperValue_ = ? Get(_O_, _upperP_)。
            1. 両方 *true* なら
              1. ? Set(_O_, _lowerP_, _upperValue_, *true*)。
              1. ? Set(_O_, _upperP_, _lowerValue_, *true*)。
            1. そうでなく _lowerExists_ *false* かつ _upperExists_ *true* なら
              1. ? Set(_O_, _lowerP_, _upperValue_, *true*)。
              1. ? DeletePropertyOrThrow(_O_, _upperP_)。
            1. そうでなく _lowerExists_ *true* かつ _upperExists_ *false* なら
              1. ? DeletePropertyOrThrow(_O_, _lowerP_)。
              1. ? Set(_O_, _upperP_, _lowerValue_, *true*)。
            1. そうでなければ（両方 *false*）何もしない。
            1. _lower_++。
          1. _O_ を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.shift">
        <h1>Array.prototype.shift ( )</h1>
        <p>最初の要素を削除して返す。</p>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _len_ = 0 なら
            1. ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*)。
            1. *undefined* を返す。
          1. _first_ を ? Get(_O_, *"0"*)。
          1. _k_ = 1。
          1. _k_ &lt; _len_ の間、
            1. _from_ = ! ToString(𝔽(_k_))。
            1. _to_ = ! ToString(𝔽(_k_ - 1))。
            1. _fromPresent_ = ? HasProperty(_O_, _from_)。
            1. _fromPresent_ が *true* なら
              1. _fromValue_ = ? Get(_O_, _from_)。
              1. ? Set(_O_, _to_, _fromValue_, *true*)。
            1. そうでなければ
              1. ? DeletePropertyOrThrow(_O_, _to_)。
            1. _k_++。
          1. ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1)))。
          1. ? Set(_O_, *"length"*, 𝔽(_len_ - 1), *true*)。
          1. _first_ を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.slice">
        <h1>Array.prototype.slice ( _start_, _end_ )</h1>
        <p>_start_ から（_end_ が *undefined* なら末尾まで、そうでなければ _end_ 非含む）要素を含む新しい配列を返す。負値は長さを _length_ として <emu-eqn>_length_ + _start_</emu-eqn>, <emu-eqn>_length_ + _end_</emu-eqn>。</p>
        <p>手順:</p>
        <emu-alg>
          1. _O_ を ? ToObject(*this* value)。
          1. _len_ を ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ を ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _k_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _k_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _k_ = min(_relativeStart_, _len_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _len_；そうでなければ _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _final_ = 0。
          1. そうでなく _relativeEnd_ &lt; 0 なら _final_ = max(_len_ + _relativeEnd_, 0)。
          1. それ以外は _final_ = min(_relativeEnd_, _len_)。
          1. _count_ = max(_final_ - _k_, 0)。
          1. _A_ を ? ArraySpeciesCreate(_O_, _count_)。
          1. _n_ = 0。
          1. _k_ &lt; _final_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_)。
            1. _k_++。
            1. _n_++。
          1. <span id="step-array-proto-slice-set-length">? Set(_A_, *"length"*, 𝔽(_n_), *true*) を実行。</span>
          1. _A_ を返す。
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-array-proto-slice-set-length"></emu-xref> で明示的に長さを設定するのは _A_ が組込み Array でない場合でも正しい長さを保証するため。</p>
        </emu-note>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.some">
        <h1>Array.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ は 3 引数を受け Boolean へ強制可能な値を返す関数であるべき。`some` は *true* を返す最初の要素を見つけるまで昇順で呼び、見つかれば *true*、なければ *false*。欠落要素は無視。</p>
          <p>_thisArg_ があれば *this*、なければ *undefined*。</p>
          <p>引数: (値, インデックス, 対象)。</p>
          <p>オブジェクトは直接ミューテートしないが _callback_ により変更され得る。</p>
          <p>範囲は開始前に固定。追加要素は無視。変更要素は訪問時の値。削除要素は訪問されない。空配列では *false*（数学の「存在」量化）。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
              1. _testResult_ が *true* なら *true*。
            1. _k_++。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.sort" oldids="sec-sortcompare">
        <h1>Array.prototype.sort ( _comparator_ )</h1>
        <p>配列要素をソートする。_comparator_ が *undefined* でなければ 2 引数 (_x_, _y_) を受け負数 / 正数 / 0 を返す関数であるべき。</p>
        <p>手順:</p>
        <emu-alg>
          1. <span id="step-array-sort-comparefn">_comparator_ が *undefined* でなく IsCallable(_comparator_) が *false* なら *TypeError*。</span>
          1. _obj_ = ? ToObject(*this* value)。
          1. <span id="step-array-sort-len">_len_ = ? LengthOfArrayLike(_obj_)</span>。
          1. _SortCompare_ を (_x_, _y_) を引数に _comparator_ を捕捉し呼出時 CompareArrayElements を返す新しい抽象クロージャとする。
          1. <span id="step-array-sortindexedproperties">_sortedList_ = ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~)</span>。
          1. _itemCount_ を _sortedList_ の要素数。
          1. _j_ = 0。
          1. _j_ &lt; _itemCount_ の間、
            1. ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*)。
            1. _j_++。
          1. 注記: ステップ <emu-xref href="#step-array-sortindexedproperties"></emu-xref> の呼出は ~skip-holes~ を用いる。残りのインデックスは hole 数を保持するため削除する。
          1. _j_ &lt; _len_ の間、
            1. ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_)))。
            1. _j_++。
          1. _obj_ を返す。
        </emu-alg>
        <emu-note>
          <p>存在しないプロパティ値は常に *undefined* より後方、かつ *undefined* は他の任意値より後方に並ぶため（CompareArrayElements 参照）、*undefined* が末尾、その後に非存在要素が続く。</p>
        </emu-note>
        <emu-note>
          <p>手順 <emu-xref href="#step-sortcompare-tostring-x"></emu-xref>, <emu-xref href="#step-sortcompare-tostring-y"></emu-xref> の ToString によるメソッド呼出は _SortCompare_ を一貫した比較器にしない可能性がある。</p>
        </emu-note>
        <emu-note>
          <p>汎用。</p>
        </emu-note>

        <emu-clause id="sec-sortindexedproperties" type="abstract operation">
          <h1>
            SortIndexedProperties (
              _obj_: オブジェクト,
              _len_: 非負整数,
              _SortCompare_: 2 パラメータ抽象クロージャ,
              _holes_: ~skip-holes~ または ~read-through-holes~,
            ): ECMAScript 言語値の List を含む通常完了または throw 完了
          </h1>
          <dl class="header"></dl>
          <emu-alg>
            1. _items_ を空 List。
            1. _k_ = 0。
            1. _k_ &lt; _len_ の間、
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _holes_ が ~skip-holes~ なら
                1. _kRead_ = ? HasProperty(_obj_, _Pk_)。
              1. そうでなければ（~read-through-holes~）
                1. _kRead_ = *true*。
              1. _kRead_ が *true* なら
                1. _kValue_ = ? Get(_obj_, _Pk_)。
                1. _items_ に _kValue_ を追加。
              1. _k_++。
            1. <span id="step-array-sort">実装定義の <emu-meta effects="user-code">_SortCompare_ 呼出列</emu-meta> を用いて _items_ をソート。いずれかの呼出が異常完了したらそれ以上呼び出さずその Completion Record を返す。</span>
            1. _items_ を返す。
          </emu-alg>
          <p><dfn id="sort-order">ソート順</dfn> は上記アルゴリズムのステップ <emu-xref href="#step-array-sort"></emu-xref> 後の _items_ の順序。_SortCompare_ が一貫した比較器でない場合は実装定義。Array.prototype.sort または Array.prototype.toSorted により呼び出された場合で _comparator_ が *undefined* かつ特定値への全ての ToString 適用結果が同じでない場合も実装定義。</p>
          <p>実装定義でない場合、次を満たすこと:</p>
          <ul>
            <li>非負整数 <emu-eqn>_itemCount_</emu-eqn> 未満の整数についてある置換 π が存在し、各 _j_ (<emu-eqn>0 ≤ _j_ &lt; _itemCount_</emu-eqn>) で <emu-eqn>old[_j_]</emu-eqn> が <emu-eqn>new[π(_j_)]</emu-eqn> と同一。</li>
            <li>すべての _j_, _k_ について <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) &lt; 0</emu-eqn> なら <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>。</li>
            <li>_j_ &lt; _k_ &lt; _itemCount_ かつ <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) = 0</emu-eqn> なら <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>（安定ソート）。</li>
          </ul>
          <p><emu-eqn>old[_j_]</emu-eqn> はステップ <emu-xref href="#step-array-sort"></emu-xref> 前の <emu-eqn>_items_[_j_]</emu-eqn>、<emu-eqn>new[_j_]</emu-eqn> は後の値。</p>
          <p>抽象クロージャまたは関数 _comparator_ が集合 _S_ の <dfn id="consistent-comparator">一貫した比較器</dfn> であるとは、任意の _a_, _b_, _c_ ∈ _S_ について以下を満たすこと。記法 <emu-eqn>_a_ &lt;<sub>C</sub> _b_</emu-eqn> は <emu-eqn>ℝ(_comparator_(_a_, _b_)) &lt; 0</emu-eqn> を、=<sub>C</sub>, ><sub>C</sub> も同様。</p>
          <ul>
            <li>同一ペア (_a_, _b_) への呼出は常に同じ Number _v_（*NaN* でない）を返し、三つの関係のいずれかのみ成り立つ。</li>
            <li>_comparator_ 呼出は _obj_ またはそのプロトタイプチェーン上のオブジェクトを変更しない。</li>
            <li>反射律: _a_ =<sub>C</sub> _a_。</li>
            <li>対称律: _a_ =<sub>C</sub> _b_ ⇒ _b_ =<sub>C</sub> _a_。</li>
            <li>推移律 (=): _a_ =<sub>C</sub> _b_, _b_ =<sub>C</sub> _c_ ⇒ _a_ =<sub>C</sub> _c_。</li>
            <li>推移律 (&lt;): _a_ &lt;<sub>C</sub> _b_, _b_ &lt;<sub>C</sub> _c_ ⇒ _a_ &lt;<sub>C</sub> _c_。</li>
            <li>推移律 (>): _a_ ><sub>C</sub> _b_, _b_ ><sub>C</sub> _c_ ⇒ _a_ ><sub>C</sub> _c_。</li>
          </ul>
          <emu-note>
            <p>これら条件は _comparator_ が _S_ を同値類に分割し、それらが全順序付けされるために必要十分。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-comparearrayelements" type="abstract operation">
          <h1>
            CompareArrayElements (
              _x_: ECMAScript 言語値,
              _y_: ECMAScript 言語値,
              _comparator_: 関数オブジェクトまたは *undefined*,
            ): Number を含む通常完了または異常完了
          </h1>
          <dl class="header"></dl>
          <emu-alg>
            1. _x_ と _y_ が共に *undefined* なら *+0*<sub>𝔽</sub>。
            1. _x_ が *undefined* なら *1*<sub>𝔽</sub>。
            1. _y_ が *undefined* なら *-1*<sub>𝔽</sub>。
            1. _comparator_ が *undefined* でなければ
              1. _v_ を ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »))。
              1. _v_ が *NaN* なら *+0*<sub>𝔽</sub> を返す。
              1. _v_ を返す。
            1. <span id="step-sortcompare-tostring-x">_xString_ = ? ToString(_x_)</span>。
            1. <span id="step-sortcompare-tostring-y">_yString_ = ? ToString(_y_)</span>。
            1. _xSmaller_ = ! IsLessThan(_xString_, _yString_, *true*)。
            1. _xSmaller_ が *true* なら *-1*<sub>𝔽</sub>。
            1. _ySmaller_ = ! IsLessThan(_yString_, _xString_, *true*)。
            1. _ySmaller_ が *true* なら *1*<sub>𝔽</sub>。
            1. *+0*<sub>𝔽</sub> を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.splice">
        <h1>Array.prototype.splice ( _start_, _deleteCount_, ..._items_ )</h1>
        <emu-note>
          <p>_start_ 位置から _deleteCount_ 個を削除し、_items_ を挿入する。削除要素の配列を返す。</p>
        </emu-note>
        <p>手順:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _actualStart_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _actualStart_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _actualStart_ = min(_relativeStart_, _len_)。
          1. _itemCount_ を _items_ の要素数。
          1. _start_ が存在しなければ _actualDeleteCount_ = 0。
          1. そうでなく _deleteCount_ が存在しなければ _actualDeleteCount_ = _len_ - _actualStart_。
          1. それ以外
            1. _dc_ = ? ToIntegerOrInfinity(_deleteCount_)。
            1. _actualDeleteCount_ = clamp(_dc_, 0, _len_ - _actualStart_)。
          1. _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1 なら *TypeError*。
          1. _A_ = ? ArraySpeciesCreate(_O_, _actualDeleteCount_)。
          1. _k_ = 0。
          1. _k_ &lt; _actualDeleteCount_ の間、
            1. _from_ = ! ToString(𝔽(_actualStart_ + _k_))。
            1. ? HasProperty(_O_, _from_) が *true* なら
              1. _fromValue_ = ? Get(_O_, _from_)。
              1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_)。
            1. _k_++。
          1. <span id="step-array-proto-splice-set-length">? Set(_A_, *"length"*, 𝔽(_actualDeleteCount_), *true*) を実行。</span>
          1. _itemCount_ &lt; _actualDeleteCount_ の場合
            1. _k_ = _actualStart_。
            1. _k_ &lt; (_len_ - _actualDeleteCount_) の間、
              1. _from_ = ! ToString(𝔽(_k_ + _actualDeleteCount_))。
              1. _to_ = ! ToString(𝔽(_k_ + _itemCount_))。
              1. ? HasProperty(_O_, _from_) が *true* なら
                1. _fromValue_ = ? Get(_O_, _from_)。
                1. ? Set(_O_, _to_, _fromValue_, *true*)。
              1. そうでなければ ? DeletePropertyOrThrow(_O_, _to_)。
              1. _k_++。
            1. _k_ = _len_。
            1. _k_ > (_len_ - _actualDeleteCount_ + _itemCount_) の間、
              1. ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1)))。
              1. _k_--。
          1. そうでなく _itemCount_ > _actualDeleteCount_ の場合
            1. _k_ = (_len_ - _actualDeleteCount_)。
            1. _k_ > _actualStart_ の間、
              1. _from_ = ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1))。
              1. _to_ = ! ToString(𝔽(_k_ + _itemCount_ - 1))。
              1. ? HasProperty(_O_, _from_) が *true* なら
                1. _fromValue_ = ? Get(_O_, _from_)。
                1. ? Set(_O_, _to_, _fromValue_, *true*)。
              1. そうでなければ ? DeletePropertyOrThrow(_O_, _to_)。
              1. _k_--。
          1. _k_ = _actualStart_。
          1. 各 _E_ ∈ _items_ について
            1. ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*)。
            1. _k_++。
          1. <span id="step-array-proto-splice-set-length-2">? Set(_O_, *"length"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*) を実行。</span>
          1. _A_ を返す。
        </emu-alg>
        <emu-note>
          <p>ステップ <emu-xref href="#step-array-proto-splice-set-length"></emu-xref>, <emu-xref href="#step-array-proto-splice-set-length-2"></emu-xref> で明示的に長さを設定するのは組込み配列でない場合でも正しい長さを保証するため。</p>
        </emu-note>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tolocalestring">
        <h1>Array.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 国際化 API を含む実装は ECMA-402 仕様に従って実装しなければならない。含まない場合は以下の仕様を用いる。</p>
        <emu-note>
          <p>ECMA-402 第 1 版はこのメソッドの代替仕様を含まなかった。</p>
        </emu-note>
        <p>オプション引数の意味は ECMA-402 に定義され、未サポート実装は他目的に利用してはならない。</p>
        <p>手順:</p>
        <emu-alg>
          1. _array_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_array_)。
          1. _separator_ をホストロケールに適切な実装定義リスト区切り文字列（例 *", "*）とする。
          1. _R_ を空文字列。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _k_ > 0 なら _R_ = _R_ + _separator_。
            1. _element_ = ? Get(_array_, ! ToString(𝔽(_k_)))。
            1. _element_ が *undefined* でも *null* でもなければ
              1. _S_ = ? ToString(? Invoke(_element_, *"toLocaleString"*))。
              1. _R_ = _R_ + _S_。
            1. _k_++。
          1. _R_ を返す。
        </emu-alg>
        <emu-note>
          <p>各要素の `toLocaleString` 結果をロケール依存区切りで連結。`toString` のロケール感知版。</p>
        </emu-note>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.toreversed">
        <h1>Array.prototype.toReversed ( )</h1>
        <p>このメソッドは呼び出し時以下を実行する:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _A_ = ? ArrayCreate(_len_)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _from_ = ! ToString(𝔽(_len_ - _k_ - 1))。
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _fromValue_ = ? Get(_O_, _from_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_)。
            1. _k_++。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tosorted">
        <h1>Array.prototype.toSorted ( _comparator_ )</h1>
        <p>呼び出し時手順:</p>
        <emu-alg>
          1. _comparator_ が *undefined* でなく IsCallable(_comparator_) が *false* なら *TypeError*。
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _A_ = ? ArrayCreate(_len_)。
          1. _SortCompare_ を (_x_, _y_) を引数に _comparator_ を捕捉し CompareArrayElements を呼ぶ抽象クロージャとする。
          1. _sortedList_ = ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~)。
          1. _j_ = 0。
          1. _j_ &lt; _len_ の間、
            1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_])。
            1. _j_++。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tospliced">
        <h1>Array.prototype.toSpliced ( _start_, _skipCount_, ..._items_ )</h1>
        <p>呼び出し時手順:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _actualStart_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _actualStart_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _actualStart_ = min(_relativeStart_, _len_)。
          1. _insertCount_ を _items_ 要素数。
          1. _start_ が存在しなければ _actualSkipCount_ = 0。
          1. そうでなく _skipCount_ が存在しなければ _actualSkipCount_ = _len_ - _actualStart_。
          1. それ以外
            1. _sc_ = ? ToIntegerOrInfinity(_skipCount_)。
            1. _actualSkipCount_ = clamp(_sc_, 0, _len_ - _actualStart_)。
          1. _newLen_ = _len_ + _insertCount_ - _actualSkipCount_。
          1. _newLen_ > 2<sup>53</sup> - 1 なら *TypeError*。
          1. _A_ = ? ArrayCreate(_newLen_)。
          1. _i_ = 0。
          1. _r_ = _actualStart_ + _actualSkipCount_。
          1. _i_ &lt; _actualStart_ の間、
            1. _Pi_ = ! ToString(𝔽(_i_))。
            1. _iValue_ = ? Get(_O_, _Pi_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_)。
            1. _i_++。
          1. 各 _E_ ∈ _items_ について
            1. _Pi_ = ! ToString(𝔽(_i_))。
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_)。
            1. _i_++。
          1. _i_ &lt; _newLen_ の間、
            1. _Pi_ = ! ToString(𝔽(_i_))。
            1. _from_ = ! ToString(𝔽(_r_))。
            1. _fromValue_ = ? Get(_O_, _from_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_)。
            1. _i_++。
            1. _r_++。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tostring">
        <h1>Array.prototype.toString ( )</h1>
        <p>呼び出し時手順:</p>
        <emu-alg>
          1. _array_ = ? ToObject(*this* value)。
          1. _func_ = ? Get(_array_, *"join"*)。
          1. IsCallable(_func_) が *false* なら _func_ を %Object.prototype.toString% に設定。
          1. ? Call(_func_, _array_) を返す。
        </emu-alg>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.unshift">
        <h1>Array.prototype.unshift ( ..._items_ )</h1>
        <p>引数を配列先頭に順序を保って挿入する。</p>
        <p>手順:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _argCount_ = _items_ の要素数。
          1. _argCount_ > 0 なら
            1. _len_ + _argCount_ > 2<sup>53</sup> - 1 なら *TypeError*。
            1. _k_ = _len_。
            1. _k_ > 0 の間、
              1. _from_ = ! ToString(𝔽(_k_ - 1))。
              1. _to_ = ! ToString(𝔽(_k_ + _argCount_ - 1))。
              1. _fromPresent_ = ? HasProperty(_O_, _from_)。
              1. _fromPresent_ が *true* なら
                1. _fromValue_ = ? Get(_O_, _from_)。
                1. ? Set(_O_, _to_, _fromValue_, *true*)。
              1. そうでなければ ? DeletePropertyOrThrow(_O_, _to_)。
              1. _k_--。
            1. _j_ = *+0*<sub>𝔽</sub>。
            1. 各 _E_ ∈ _items_ について
              1. ? Set(_O_, ! ToString(_j_), _E_, *true*)。
              1. _j_ += *1*<sub>𝔽</sub>。
          1. ? Set(_O_, *"length"*, 𝔽(_len_ + _argCount_), *true*)。
          1. 𝔽(_len_ + _argCount_) を返す。
        </emu-alg>
        <p>このメソッドの *"length"* は *1*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>汎用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.values">
        <h1>Array.prototype.values ( )</h1>
        <p>呼び出し時手順:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. CreateArrayIterator(_O_, ~value~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.with">
        <h1>Array.prototype.with ( _index_, _value_ )</h1>
        <p>呼び出し時手順:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_)。
          1. _relativeIndex_ ≥ 0 なら _actualIndex_ = _relativeIndex_；そうでなければ _actualIndex_ = _len_ + _relativeIndex_。
          1. _actualIndex_ ≥ _len_ または _actualIndex_ &lt; 0 なら *RangeError*。
          1. _A_ = ? ArrayCreate(_len_)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _k_ = _actualIndex_ なら _fromValue_ = _value_；そうでなければ _fromValue_ = ? Get(_O_, _Pk_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_)。
            1. _k_++。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@iterator" id="sec-array.prototype-%symbol.iterator%">
        <h1>Array.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% プロパティの初期値は <emu-xref href="#sec-array.prototype.values"></emu-xref> で定義される %Array.prototype.values% である。</p>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@unscopables" id="sec-array.prototype-%symbol.unscopables%">
        <h1>Array.prototype [ %Symbol.unscopables% ]</h1>
        <p>%Symbol.unscopables% データプロパティの初期値は以下で生成されるオブジェクト:</p>
        <emu-alg>
          1. _unscopableList_ = OrdinaryObjectCreate(*null*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"at"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"copyWithin"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"entries"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"fill"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"find"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findIndex"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findLast"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findLastIndex"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"flat"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"flatMap"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"includes"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"keys"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toReversed"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toSorted"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toSpliced"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"values"*, *true*)。
          1. _unscopableList_ を返す。
        </emu-alg>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 属性を持つ。</p>
        <emu-note>
          <p>このオブジェクトの own プロパティ名は ECMAScript 2015 以前に `Array.prototype` の標準プロパティでなかった名前であり、`with` 文でシャドウされる既存コードの挙動を守るため無視される。</p>
          <p>*"with"* が含まれないのは既に <emu-xref href="#sec-keywords-and-reserved-words">予約語</emu-xref> であるため。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-array-instances">
      <h1>Array インスタンスのプロパティ</h1>
      <p>Array インスタンスは Array エキゾチックオブジェクトであり、その内部メソッドを持つ。Array プロトタイプオブジェクトからプロパティを継承する。</p>
      <p>Array インスタンスは *"length"* プロパティと配列インデックス名を持つ列挙可能プロパティ集合を有する。</p>

      <emu-clause id="sec-properties-of-array-instances-length">
        <h1>length</h1>
        <p>Array インスタンスの *"length"* プロパティは、配列インデックス名を持つ全ての configurable な自プロパティ名より常に数値的に大きい値を持つデータプロパティである。</p>
        <p>初期属性は { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>*"length"* の値を減少させると旧値と新値の間のインデックスを持つ自要素が削除される（ただし非設定可能は削除不可）。非設定可能な <emu-xref href="#array-index">array-indexed</emu-xref> プロパティの最大値以上に *"length"* を減らそうとすると、その最大値 + 1 に設定される。<emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref> 参照。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-iterator-objects">
      <h1>Array イテレータオブジェクト</h1>
      <p><dfn variants="Array Iterators,Array Iterator object,Array Iterator objects">Array Iterator</dfn> は特定の Array インスタンス上の反復を表すオブジェクトである。名前付きコンストラクターは存在せず、Array インスタンスの特定メソッド呼出により生成される。</p>

      <emu-clause id="sec-createarrayiterator" type="abstract operation">
        <h1>
          CreateArrayIterator (
            _array_: オブジェクト,
            _kind_: ~key+value~, ~key~, または ~value~,
          ): オブジェクト
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>Array メソッドが返すイテレータオブジェクトを生成するために用いる。</dd>
        </dl>
        <emu-alg>
          1. _iterator_ を OrdinaryObjectCreate(%ArrayIteratorPrototype%, « [[IteratedArrayLike]], [[ArrayLikeNextIndex]], [[ArrayLikeIterationKind]] ») とする。
          1. _iterator_.[[IteratedArrayLike]] = _array_。
          1. _iterator_.[[ArrayLikeNextIndex]] = 0。
          1. _iterator_.[[ArrayLikeIterationKind]] = _kind_。
          1. _iterator_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%arrayiteratorprototype%-object">
        <h1>%ArrayIteratorPrototype% オブジェクト</h1>
        <p><dfn>%ArrayIteratorPrototype%</dfn> オブジェクト:</p>
        <ul>
          <li>全 Array Iterator オブジェクトが継承するプロパティを持つ。</li>
          <li>通常のオブジェクト。</li>
          <li>[[Prototype]] 内部スロット値は %Iterator.prototype%。</li>
          <li>以下のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-%arrayiteratorprototype%.next">
          <h1>%ArrayIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. _O_ を *this* 値。
            1. _O_ がオブジェクトでなければ *TypeError*。
            1. _O_ が Array Iterator Instance の全内部スロットを持たなければ *TypeError*。
            1. _array_ = _O_.[[IteratedArrayLike]]。
            1. _array_ が *undefined* なら CreateIteratorResultObject(*undefined*, *true*)。
            1. _index_ = _O_.[[ArrayLikeNextIndex]]。
            1. _kind_ = _O_.[[ArrayLikeIterationKind]]。
            1. _array_ が [[TypedArrayName]] 内部スロットを持つなら
              1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~)。
              1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *TypeError*。
              1. _len_ = TypedArrayLength(_taRecord_)。
            1. そうでなければ
              1. _len_ = ? LengthOfArrayLike(_array_)。
            1. _index_ ≥ _len_ なら
              1. _O_.[[IteratedArrayLike]] = *undefined*。
              1. CreateIteratorResultObject(*undefined*, *true*) を返す。
            1. _O_.[[ArrayLikeNextIndex]] = _index_ + 1。
            1. _indexNumber_ = 𝔽(_index_)。
            1. _kind_ = ~key~ なら
              1. _result_ = _indexNumber_。
            1. そうでなければ
              1. _elementKey_ = ! ToString(_indexNumber_)。
              1. _elementValue_ = ? Get(_array_, _elementKey_)。
              1. _kind_ = ~value~ なら
                1. _result_ = _elementValue_。
              1. そうでなければ（~key+value~）
                1. _result_ = CreateArrayFromList(« _indexNumber_, _elementValue_ »)。
            1. CreateIteratorResultObject(_result_, *false*) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%arrayiteratorprototype%-@@tostringtag" id="sec-%arrayiteratorprototype%-%symbol.tostringtag%">
          <h1>%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"Array Iterator"*。</p>
          <p>属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-array-iterator-instances">
        <h1>Array Iterator インスタンスのプロパティ</h1>
        <p>Array Iterator インスタンスは %ArrayIteratorPrototype% から継承する通常オブジェクトで、初期化時に <emu-xref href="#table-internal-slots-of-array-iterator-instances"></emu-xref> の内部スロットを持つ。</p>
        <emu-table id="table-internal-slots-of-array-iterator-instances" caption="Array Iterator インスタンスの内部スロット" oldids="table-48">
          <table>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[IteratedArrayLike]]
              </td>
              <td>
                an Object or *undefined*
              </td>
              <td>
                反復対象となる配列ライクオブジェクト。
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeNextIndex]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                次に調べる要素の整数インデックス。
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeIterationKind]]
              </td>
              <td>
                ~key+value~, ~key~, or ~value~
              </td>
              <td>
                各反復で返す内容を識別する値。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray オブジェクト</h1>
    <p>_TypedArray_ は基礎となるバイナリデータバッファ (<emu-xref href="#sec-arraybuffer-objects"></emu-xref>) に対する配列ライクなビューを提供する。<dfn variants="TypedArray element types">TypedArray 要素型</dfn> は _TypedArray_ インスタンスのすべての要素が持つ基礎バイナリのスカラーデータ型である。サポートされる各要素型ごとに <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に列挙される別個の _TypedArray_ コンストラクターが存在する。<emu-xref href="#table-the-typedarray-constructors"></emu-xref> 内の各コンストラクターはそれぞれ固有のプロトタイプオブジェクトを持つ。</p>
    <emu-table id="table-the-typedarray-constructors" caption="TypedArray コンストラクター" oldids="table-49">
      <table>
        <thead>
          <tr>
            <th>
              コンストラクター名と組込み
            </th>
            <th>
              要素型
            </th>
            <th>
              要素サイズ
            </th>
            <th>
              変換操作
            </th>
            <th>
              説明
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Int8Array<br>
            <dfn>%Int8Array%</dfn>
          </td>
          <td>
            ~int8~
          </td>
          <td>
            1
          </td>
          <td>
            ToInt8
          </td>
          <td>
            8 ビット 2 の補数符号付き整数
          </td>
        </tr>
        <tr>
          <td>
            Uint8Array<br>
            <dfn>%Uint8Array%</dfn>
          </td>
          <td>
            ~uint8~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8
          </td>
          <td>
            8 ビット符号なし整数
          </td>
        </tr>
        <tr>
          <td>
            Uint8ClampedArray<br>
            <dfn>%Uint8ClampedArray%</dfn>
          </td>
          <td>
            ~uint8clamped~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8Clamp
          </td>
          <td>
            8 ビット符号なし整数 (クランプ変換)
          </td>
        </tr>
        <tr>
          <td>
            Int16Array<br>
            <dfn>%Int16Array%</dfn>
          </td>
          <td>
            ~int16~
          </td>
          <td>
            2
          </td>
          <td>
            ToInt16
          </td>
          <td>
            16 ビット 2 の補数符号付き整数
          </td>
        </tr>
        <tr>
          <td>
            Uint16Array<br>
            <dfn>%Uint16Array%</dfn>
          </td>
          <td>
            ~uint16~
          </td>
          <td>
            2
          </td>
          <td>
            ToUint16
          </td>
          <td>
            16 ビット符号なし整数
          </td>
        </tr>
        <tr>
          <td>
            Int32Array<br>
            <dfn>%Int32Array%</dfn>
          </td>
          <td>
            ~int32~
          </td>
          <td>
            4
          </td>
          <td>
            ToInt32
          </td>
          <td>
            32 ビット 2 の補数符号付き整数
          </td>
        </tr>
        <tr>
          <td>
            Uint32Array<br>
            <dfn>%Uint32Array%</dfn>
          </td>
          <td>
            ~uint32~
          </td>
          <td>
            4
          </td>
          <td>
            ToUint32
          </td>
          <td>
            32 ビット符号なし整数
          </td>
        </tr>
        <tr>
          <td>
            BigInt64Array<br>
            <dfn>%BigInt64Array%</dfn>
          </td>
          <td>
            ~bigint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigInt64
          </td>
          <td>
            64 ビット 2 の補数符号付き整数
          </td>
        </tr>
        <tr>
          <td>
            BigUint64Array<br>
            <dfn>%BigUint64Array%</dfn>
          </td>
          <td>
            ~biguint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigUint64
          </td>
          <td>
            64 ビット符号なし整数
          </td>
        </tr>
        <tr>
          <td>
            Float16Array<br>
            <dfn>%Float16Array%</dfn>
          </td>
          <td>
            ~float16~
          </td>
          <td>
            2
          </td>
          <td>
          </td>
          <td>
            16 ビット IEEE 浮動小数点
          </td>
        </tr>
        <tr>
          <td>
            Float32Array<br>
            <dfn>%Float32Array%</dfn>
          </td>
          <td>
            ~float32~
          </td>
          <td>
            4
          </td>
          <td>
          </td>
          <td>
            32 ビット IEEE 浮動小数点
          </td>
        </tr>
        <tr>
          <td>
            Float64Array<br>
            <dfn>%Float64Array%</dfn>
          </td>
          <td>
            ~float64~
          </td>
          <td>
            8
          </td>
          <td>
          </td>
          <td>
            64 ビット IEEE 浮動小数点
          </td>
        </tr>
      </table>
    </emu-table>
    <p>以下の定義では _TypedArray_ への参照は上表から適切なコンストラクター名に置き換えるものとする。</p>

    <emu-clause id="sec-%typedarray%-intrinsic-object">
      <h1>%TypedArray% 組込みオブジェクト</h1>
      <p><dfn>%TypedArray%</dfn> 組込みオブジェクト:</p>
      <ul>
        <li>すべての _TypedArray_ コンストラクターオブジェクトが継承するコンストラクター関数オブジェクトである。</li>
        <li>対応するプロトタイプオブジェクトと共に、全 _TypedArray_ コンストラクターおよびそのインスタンスが継承する共通プロパティを提供する。</li>
        <li>グローバル名を持たず、グローバルオブジェクトのプロパティとして現れない。</li>
        <li>様々な _TypedArray_ コンストラクターの抽象的スーパークラスとして振る舞う。</li>
        <li>抽象クラスコンストラクターであるため呼び出されるとエラーを投げる。_TypedArray_ コンストラクターはこれへ `super` 呼び出しを行わない。</li>
      </ul>

      <emu-clause id="sec-%typedarray%">
        <h1>%TypedArray% ( )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. *TypeError* 例外を投げる。
        </emu-alg>
        <p>この関数の *"length"* プロパティは *+0*<sub>𝔽</sub> である。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarray%-intrinsic-object">
      <h1>%TypedArray% 組込みオブジェクトのプロパティ</h1>
      <p>%TypedArray% 組込みオブジェクト:</p>
      <ul>
        <li>値 %Function.prototype% の [[Prototype]] 内部スロットを持つ。</li>
        <li>*"name"* プロパティ値は *"TypedArray"*。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-%typedarray%.from">
        <h1>%TypedArray%.from ( _source_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. IsConstructor(_C_) が *false* なら *TypeError* 例外。
          1. _mapper_ が *undefined* なら
            1. _mapping_ を *false* とする。
          1. そうでなければ
            1. IsCallable(_mapper_) が *false* なら *TypeError* 例外。
            1. _mapping_ を *true* とする。
          1. _usingIterator_ を ? GetMethod(_source_, %Symbol.iterator%) とする。
          1. _usingIterator_ が *undefined* でなければ
            1. _values_ を ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_)) とする。
            1. _len_ を _values_ の要素数とする。
            1. _targetObj_ を ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) ») とする。
            1. _k_ = 0。
            1. _k_ &lt; _len_ の間繰り返し、
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _kValue_ を _values_ の先頭要素とする。
              1. _values_ から先頭要素を除去。
              1. _mapping_ が *true* なら
                1. _mappedValue_ = ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »)。
              1. そうでなければ
                1. _mappedValue_ = _kValue_。
              1. ? Set(_targetObj_, _Pk_, _mappedValue_, *true*)。
              1. _k_ を _k_ + 1 に。
            1. アサート: _values_ は空 List。
            1. _targetObj_ を返す。
          1. 注: _source_ は iterable でないので配列ライクであるとみなす。
          1. _arrayLike_ = ! ToObject(_source_)。
          1. _len_ = ? LengthOfArrayLike(_arrayLike_)。
          1. _targetObj_ = ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ? Get(_arrayLike_, _Pk_)。
            1. _mapping_ が *true* なら
              1. _mappedValue_ = ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »)。
            1. そうでなければ
              1. _mappedValue_ = _kValue_。
            1. ? Set(_targetObj_, _Pk_, _mappedValue_, *true*)。
            1. _k_++。
          1. _targetObj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.of">
        <h1>%TypedArray%.of ( ..._items_ )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _len_ を _items_ の要素数とする。
          1. _C_ を *this* 値とする。
          1. IsConstructor(_C_) が *false* なら *TypeError* 例外。
          1. _newObj_ = ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _kValue_ = _items_[_k_]。
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. ? Set(_newObj_, _Pk_, _kValue_, *true*)。
            1. _k_++。
          1. _newObj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype">
        <h1>%TypedArray%.prototype</h1>
        <p>%TypedArray%`.prototype` の初期値は %TypedArray% プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%-@@species" id="sec-get-%typedarray%-%symbol.species%">
        <h1>get %TypedArray% [ %Symbol.species% ]</h1>
        <p>%TypedArray%`[%Symbol.species%]` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティ値は *"get [Symbol.species]"*。</p>
        <emu-note>
          <p>%TypedArray.prototype% の各メソッドは通常 *this* 値のコンストラクターを用いて派生オブジェクトを生成する。サブクラスコンストラクターは %Symbol.species% を再定義して既定挙動を上書きできる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
      <h1>%TypedArray% プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>%TypedArray% プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値は %Object.prototype%。</li>
        <li><dfn>%TypedArray.prototype%</dfn> である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[ViewedArrayBuffer]] など _TypedArray_ インスタンス特有の内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-%typedarray%.prototype.at">
        <h1>%TypedArray%.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_)。
          1. _relativeIndex_ ≥ 0 なら
            1. _k_ = _relativeIndex_。
          1. そうでなければ
            1. _k_ = _len_ + _relativeIndex_。
          1. _k_ &lt; 0 または _k_ ≥ _len_ なら *undefined* を返す。
          1. ! Get(_O_, ! ToString(𝔽(_k_))) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.buffer">
        <h1>get %TypedArray%.prototype.buffer</h1>
        <p>%TypedArray%`.prototype.buffer` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _buffer_ = _O_.[[ViewedArrayBuffer]]。
          1. _buffer_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
        <h1>get %TypedArray%.prototype.byteLength</h1>
        <p>%TypedArray%`.prototype.byteLength` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. _size_ = TypedArrayByteLength(_taRecord_)。
          1. 𝔽(_size_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
        <h1>get %TypedArray%.prototype.byteOffset</h1>
        <p>%TypedArray%`.prototype.byteOffset` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *+0*<sub>𝔽</sub> を返す。
          1. _offset_ = _O_.[[ByteOffset]]。
          1. 𝔽(_offset_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.constructor">
        <h1>%TypedArray%.prototype.constructor</h1>
        <p>%TypedArray%`.prototype.constructor` の初期値は %TypedArray% である。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.copywithin">
        <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.copywithin"></emu-xref> に定義された `Array.prototype.copyWithin` と同じ。</p>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _relativeTarget_ = ? ToIntegerOrInfinity(_target_)。
          1. _relativeTarget_ = -∞ なら _targetIndex_ = 0。
          1. そうでなく _relativeTarget_ &lt; 0 なら _targetIndex_ = max(_len_ + _relativeTarget_, 0)。
          1. それ以外は _targetIndex_ = min(_relativeTarget_, _len_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _startIndex_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _startIndex_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _startIndex_ = min(_relativeStart_, _len_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _len_; そうでなければ _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _endIndex_ = 0。
          1. そうでなく _relativeEnd_ &lt; 0 なら _endIndex_ = max(_len_ + _relativeEnd_, 0)。
          1. それ以外は _endIndex_ = min(_relativeEnd_, _len_)。
          1. _count_ = min(_endIndex_ - _startIndex_, _len_ - _targetIndex_)。
          1. _count_ > 0 なら
            1. 注: コピーはソースのビットレベルエンコーディングを保持する方法で行わねばならない。
            1. _buffer_ = _O_.[[ViewedArrayBuffer]]。
            1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
            1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *TypeError*。
            1. _len_ = TypedArrayLength(_taRecord_)。
            1. _elementSize_ = TypedArrayElementSize(_O_)。
            1. _byteOffset_ = _O_.[[ByteOffset]]。
            1. _bufferByteLimit_ = (_len_ × _elementSize_) + _byteOffset_。
            1. _toByteIndex_ = (_targetIndex_ × _elementSize_) + _byteOffset_。
            1. _fromByteIndex_ = (_startIndex_ × _elementSize_) + _byteOffset_。
            1. _countBytes_ = _count_ × _elementSize_。
            1. もし _fromByteIndex_ &lt; _toByteIndex_ かつ _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_ なら
              1. _direction_ = -1。
              1. _fromByteIndex_ = _fromByteIndex_ + _countBytes_ - 1。
              1. _toByteIndex_ = _toByteIndex_ + _countBytes_ - 1。
            1. そうでなければ
              1. _direction_ = 1。
            1. _countBytes_ > 0 の間繰り返し、
              1. もし _fromByteIndex_ &lt; _bufferByteLimit_ かつ _toByteIndex_ &lt; _bufferByteLimit_ なら
                1. _value_ = GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~)。
                1. SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~) を実行。
                1. _fromByteIndex_ += _direction_。
                1. _toByteIndex_ += _direction_。
                1. _countBytes_ = _countBytes_ - 1。
              1. そうでなければ
                1. _countBytes_ = 0。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.entries">
        <h1>%TypedArray%.prototype.entries ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. CreateArrayIterator(_O_, ~key+value~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.every">
        <h1>%TypedArray%.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.every"></emu-xref> の `Array.prototype.every` と同じ。</p>
        <p>このメソッドは呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ! Get(_O_, _Pk_)。
            1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
            1. _testResult_ が *false* なら *false*。
            1. _k_++。
          1. *true* を返す。
        </emu-alg>
        <p>このメソッドは汎用ではない。*this* 値は [[TypedArrayName]] 内部スロットを持つオブジェクトでなければならない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.fill">
        <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.fill"></emu-xref> の `Array.prototype.fill` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _O_.[[ContentType]] が ~bigint~ なら _value_ = ? ToBigInt(_value_)。そうでなければ _value_ = ? ToNumber(_value_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _startIndex_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _startIndex_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _startIndex_ = min(_relativeStart_, _len_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _len_; そうでなければ _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _endIndex_ = 0。
          1. そうでなく _relativeEnd_ &lt; 0 なら _endIndex_ = max(_len_ + _relativeEnd_, 0)。
          1. それ以外は _endIndex_ = min(_relativeEnd_, _len_)。
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *TypeError*。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _endIndex_ = min(_endIndex_, _len_)。
          1. _k_ = _startIndex_。
          1. _k_ &lt; _endIndex_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. ! Set(_O_, _Pk_, _value_, *true*)。
            1. _k_++。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.filter">
        <h1>%TypedArray%.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.filter"></emu-xref> の `Array.prototype.filter` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _kept_ = 新しい空 List。
          1. _captured_ = 0。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ! Get(_O_, _Pk_)。
            1. _selected_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
            1. _selected_ が *true* なら
              1. _kValue_ を _kept_ に追加。
              1. _captured_ = _captured_ + 1。
            1. _k_++。
          1. _A_ = ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »)。
          1. _n_ = 0。
          1. 各 _e_ ∈ _kept_ について
            1. ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*)。
            1. _n_++。
          1. _A_ を返す。
        </emu-alg>
        <p>このメソッドは汎用ではない。*this* 値は [[TypedArrayName]] 内部スロットを持つ必要がある。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.find">
        <h1>%TypedArray%.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.find"></emu-xref> の `Array.prototype.find` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Value]] を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findindex">
        <h1>%TypedArray%.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.findindex"></emu-xref> の `Array.prototype.findIndex` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Index]] を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlast">
        <h1>%TypedArray%.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.findlast"></emu-xref> の `Array.prototype.findLast` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Value]] を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlastindex">
        <h1>%TypedArray%.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.findlastindex"></emu-xref> の `Array.prototype.findLastIndex` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. _findRec_.[[Index]] を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.foreach">
        <h1>%TypedArray%.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.foreach"></emu-xref> の `Array.prototype.forEach` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ! Get(_O_, _Pk_)。
            1. ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_++。
          1. *undefined* を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.includes">
        <h1>%TypedArray%.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.includes"></emu-xref> の `Array.prototype.includes` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _len_ = 0 なら *false*。
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_)。
          1. アサート: _fromIndex_ が *undefined* なら _n_ = 0。
          1. _n_ = +∞ なら *false*。
          1. そうでなく _n_ = -∞ なら _n_ = 0。
          1. _n_ ≥ 0 なら
            1. _k_ = _n_。
          1. そうでなければ
            1. _k_ = _len_ + _n_。
            1. _k_ &lt; 0 なら _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _elementK_ = ! Get(_O_, ! ToString(𝔽(_k_)))。
            1. SameValueZero(_searchElement_, _elementK_) が *true* なら *true*。
            1. _k_++。
          1. *false* を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.indexof">
        <h1>%TypedArray%.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.indexof"></emu-xref> の `Array.prototype.indexOf` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _len_ = 0 なら *-1*<sub>𝔽</sub>。
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_)。
          1. アサート: _fromIndex_ *undefined* → _n_ = 0。
          1. _n_ = +∞ なら *-1*<sub>𝔽</sub>。
          1. そうでなく _n_ = -∞ なら _n_ = 0。
          1. _n_ ≥ 0 なら
            1. _k_ = _n_。
          1. そうでなければ
            1. _k_ = _len_ + _n_。
            1. _k_ &lt; 0 なら _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ! HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _elementK_ = ! Get(_O_, _Pk_)。
              1. IsStrictlyEqual(_searchElement_, _elementK_) が *true* なら 𝔽(_k_)。
            1. _k_++。
          1. *-1*<sub>𝔽</sub> を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.join">
        <h1>%TypedArray%.prototype.join ( _separator_ )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.join"></emu-xref> の `Array.prototype.join` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _separator_ が *undefined* なら _sep_ = *","*；そうでなければ _sep_ = ? ToString(_separator_)。
          1. _R_ = 空文字列。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _k_ > 0 なら _R_ = _R_ と _sep_ の連結。
            1. _element_ = ! Get(_O_, ! ToString(𝔽(_k_)))。
            1. _element_ が *undefined* でないなら
              1. _S_ = ! ToString(_element_)。
              1. _R_ = _R_ + _S_。
            1. _k_++。
          1. _R_ を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.keys">
        <h1>%TypedArray%.prototype.keys ( )</h1>
        <p>このメソッドは呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. CreateArrayIterator(_O_, ~key~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.lastindexof">
        <h1>%TypedArray%.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref> の `Array.prototype.lastIndexOf` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _len_ = 0 なら *-1*<sub>𝔽</sub>。
          1. _fromIndex_ が存在するなら _n_ = ? ToIntegerOrInfinity(_fromIndex_); そうでなければ _n_ = _len_ - 1。
          1. _n_ = -∞ なら *-1*<sub>𝔽</sub>。
          1. _n_ ≥ 0 なら
            1. _k_ = min(_n_, _len_ - 1)。
          1. そうでなければ
            1. _k_ = _len_ + _n_。
          1. _k_ ≥ 0 の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ! HasProperty(_O_, _Pk_)。
            1. _kPresent_ が *true* なら
              1. _elementK_ = ! Get(_O_, _Pk_)。
              1. IsStrictlyEqual(_searchElement_, _elementK_) が *true* なら 𝔽(_k_)。
            1. _k_--。
          1. *-1*<sub>𝔽</sub> を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.length">
        <h1>get %TypedArray%.prototype.length</h1>
        <p>%TypedArray%`.prototype.length` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] と [[ArrayLength]] を持つ。
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *+0*<sub>𝔽</sub>。
          1. _length_ = TypedArrayLength(_taRecord_)。
          1. 𝔽(_length_) を返す。
        </emu-alg>
        <p>この関数は汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.map">
        <h1>%TypedArray%.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.map"></emu-xref> の `Array.prototype.map` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _A_ = ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ! Get(_O_, _Pk_)。
            1. _mappedValue_ = ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
            1. ? Set(_A_, _Pk_, _mappedValue_, *true*)。
            1. _k_++。
          1. _A_ を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduce">
        <h1>%TypedArray%.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.reduce"></emu-xref> の `Array.prototype.reduce` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _len_ = 0 かつ _initialValue_ 非存在なら *TypeError*。
          1. _k_ = 0。
          1. _accumulator_ = *undefined*。
          1. _initialValue_ 存在なら
            1. _accumulator_ = _initialValue_。
          1. そうでなければ
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _accumulator_ = ! Get(_O_, _Pk_)。
            1. _k_++。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ! Get(_O_, _Pk_)。
            1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_++。
          1. _accumulator_ を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduceright">
        <h1>%TypedArray%.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.reduceright"></emu-xref> の `Array.prototype.reduceRight` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _len_ = 0 かつ _initialValue_ 無しなら *TypeError*。
          1. _k_ = _len_ - 1。
          1. _accumulator_ = *undefined*。
          1. _initialValue_ 存在なら
            1. _accumulator_ = _initialValue_。
          1. そうでなければ
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _accumulator_ = ! Get(_O_, _Pk_)。
            1. _k_--。
          1. _k_ ≥ 0 の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ! Get(_O_, _Pk_)。
            1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_--。
          1. _accumulator_ を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reverse">
        <h1>%TypedArray%.prototype.reverse ( )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.reverse"></emu-xref> の `Array.prototype.reverse` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _middle_ = floor(_len_ / 2)。
          1. _lower_ = 0。
          1. _lower_ ≠ _middle_ の間、
            1. _upper_ = _len_ - _lower_ - 1。
            1. _upperP_ = ! ToString(𝔽(_upper_))。
            1. _lowerP_ = ! ToString(𝔽(_lower_))。
            1. _lowerValue_ = ! Get(_O_, _lowerP_)。
            1. _upperValue_ = ! Get(_O_, _upperP_)。
            1. ! Set(_O_, _lowerP_, _upperValue_, *true*)。
            1. ! Set(_O_, _upperP_, _lowerValue_, *true*)。
            1. _lower_++。
          1. _O_ を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.set" oldids="sec-%typedarray%.prototype.set-overloaded-offset">
        <h1>%TypedArray%.prototype.set ( _source_ [ , _offset_ ] )</h1>
        <p>このメソッドは _source_ から値を読み取り複数の値をこの _TypedArray_ に設定する。詳細は _source_ の型に依存する。任意の _offset_ は書き込み開始位置の要素インデックスを示し、省略時 0。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _target_ = *this* 値。
          1. ? RequireInternalSlot(_target_, [[TypedArrayName]])。
          1. アサート: _target_ は [[ViewedArrayBuffer]] を持つ。
          1. _targetOffset_ = ? ToIntegerOrInfinity(_offset_)。
          1. _targetOffset_ &lt; 0 なら *RangeError*。
          1. もし _source_ が [[TypedArrayName]] を持つオブジェクトなら
            1. ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_)。
          1. そうでなければ
            1. ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_)。
          1. *undefined* を返す。
        </emu-alg>
        <p>汎用ではない。</p>

        <emu-clause id="sec-settypedarrayfromarraylike" type="abstract operation" oldids="sec-%typedarray%.prototype.set-array-offset">
          <h1>
            SetTypedArrayFromArrayLike (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: an ECMAScript language value, but not a TypedArray,
            ): ~unused~ を含む通常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_target_ の _targetOffset_ から _source_ の値を複数設定する。</dd>
          </dl>
          <emu-alg>
            1. _targetRecord_ = MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~)。
            1. IsTypedArrayOutOfBounds(_targetRecord_) が *true* なら *TypeError*。
            1. _targetLength_ = TypedArrayLength(_targetRecord_)。
            1. _src_ = ? ToObject(_source_)。
            1. _srcLength_ = ? LengthOfArrayLike(_src_)。
            1. _targetOffset_ = +∞ なら *RangeError*。
            1. _srcLength_ + _targetOffset_ > _targetLength_ なら *RangeError*。
            1. _k_ = 0。
            1. _k_ &lt; _srcLength_ の間、
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _value_ = ? Get(_src_, _Pk_)。
              1. _targetIndex_ = 𝔽(_targetOffset_ + _k_)。
              1. ? TypedArraySetElement(_target_, _targetIndex_, _value_)。
              1. _k_++。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
          <h1>
            SetTypedArrayFromTypedArray (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: a TypedArray,
            ): ~unused~ を含む通常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_target_ の _targetOffset_ から _source_ の値を複数設定する。</dd>
          </dl>
          <emu-alg>
            1. _targetBuffer_ = _target_.[[ViewedArrayBuffer]]。
            1. _targetRecord_ = MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~)。
            1. IsTypedArrayOutOfBounds(_targetRecord_) が *true* なら *TypeError*。
            1. _targetLength_ = TypedArrayLength(_targetRecord_)。
            1. _srcBuffer_ = _source_.[[ViewedArrayBuffer]]。
            1. _srcRecord_ = MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~)。
            1. IsTypedArrayOutOfBounds(_srcRecord_) が *true* なら *TypeError*。
            1. _srcLength_ = TypedArrayLength(_srcRecord_)。
            1. _targetType_ = TypedArrayElementType(_target_)。
            1. _targetElementSize_ = TypedArrayElementSize(_target_)。
            1. _targetByteOffset_ = _target_.[[ByteOffset]]。
            1. _srcType_ = TypedArrayElementType(_source_)。
            1. _srcElementSize_ = TypedArrayElementSize(_source_)。
            1. _srcByteOffset_ = _source_.[[ByteOffset]]。
            1. _targetOffset_ = +∞ なら *RangeError*。
            1. _srcLength_ + _targetOffset_ > _targetLength_ なら *RangeError*。
            1. _target_.[[ContentType]] ≠ _source_.[[ContentType]] なら *TypeError*。
            1. IsSharedArrayBuffer(_srcBuffer_) かつ IsSharedArrayBuffer(_targetBuffer_) かつ _srcBuffer_.[[ArrayBufferData]] = _targetBuffer_.[[ArrayBufferData]] なら _sameSharedArrayBuffer_ = *true*、そうでなければ *false*。
            1. SameValue(_srcBuffer_, _targetBuffer_) または _sameSharedArrayBuffer_ が *true* なら
              1. _srcByteLength_ = TypedArrayByteLength(_srcRecord_)。
              1. _srcBuffer_ = ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_)。
              1. _srcByteIndex_ = 0。
            1. そうでなければ
              1. _srcByteIndex_ = _srcByteOffset_。
            1. _targetByteIndex_ = (_targetOffset_ × _targetElementSize_) + _targetByteOffset_。
            1. _limit_ = _targetByteIndex_ + (_targetElementSize_ × _srcLength_)。
            1. _srcType_ = _targetType_ なら
              1. 注: 転送はビットレベルエンコーディングを保持する形で行う。
              1. _targetByteIndex_ &lt; _limit_ の間、
                1. _value_ = GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~)。
                1. SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~)。
                1. _srcByteIndex_++。
                1. _targetByteIndex_++。
            1. そうでなければ
              1. _targetByteIndex_ &lt; _limit_ の間、
                1. _value_ = GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~)。
                1. SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~)。
                1. _srcByteIndex_ += _srcElementSize_。
                1. _targetByteIndex_ += _targetElementSize_。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.slice">
        <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.slice"></emu-xref> の `Array.prototype.slice` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _srcArrayLength_ = TypedArrayLength(_taRecord_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _startIndex_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _startIndex_ = max(_srcArrayLength_ + _relativeStart_, 0)。
          1. それ以外 _startIndex_ = min(_relativeStart_, _srcArrayLength_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _srcArrayLength_; そうでなければ _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _endIndex_ = 0。
          1. そうでなく _relativeEnd_ &lt; 0 なら _endIndex_ = max(_srcArrayLength_ + _relativeEnd_, 0)。
          1. それ以外 _endIndex_ = min(_relativeEnd_, _srcArrayLength_)。
          1. _countBytes_ = max(_endIndex_ - _startIndex_, 0)。
          1. _A_ = ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »)。
          1. _countBytes_ > 0 なら
            1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
            1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *TypeError*。
            1. _endIndex_ = min(_endIndex_, TypedArrayLength(_taRecord_))。
            1. _countBytes_ = max(_endIndex_ - _startIndex_, 0)。
            1. _srcType_ = TypedArrayElementType(_O_)。
            1. _targetType_ = TypedArrayElementType(_A_)。
            1. もし _srcType_ = _targetType_ なら
              1. 注: 転送はビットエンコーディング保持で行う。
              1. _srcBuffer_ = _O_.[[ViewedArrayBuffer]]。
              1. _targetBuffer_ = _A_.[[ViewedArrayBuffer]]。
              1. _elementSize_ = TypedArrayElementSize(_O_)。
              1. _srcByteOffset_ = _O_.[[ByteOffset]]。
              1. _srcByteIndex_ = (_startIndex_ × _elementSize_) + _srcByteOffset_。
              1. _targetByteIndex_ = _A_.[[ByteOffset]]。
              1. _endByteIndex_ = _targetByteIndex_ + (_countBytes_ × _elementSize_)。
              1. _targetByteIndex_ &lt; _endByteIndex_ の間、
                1. _value_ = GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~)。
                1. SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~)。
                1. _srcByteIndex_++。
                1. _targetByteIndex_++。
            1. そうでなければ
              1. _n_ = 0。
              1. _k_ = _startIndex_。
              1. _k_ &lt; _endIndex_ の間、
                1. _Pk_ = ! ToString(𝔽(_k_))。
                1. _kValue_ = ! Get(_O_, _Pk_)。
                1. ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*)。
                1. _k_++。
                1. _n_++。
          1. _A_ を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.some">
        <h1>%TypedArray%.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <p>引数の意味と使用法は <emu-xref href="#sec-array.prototype.some"></emu-xref> の `Array.prototype.some` と同じ。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kValue_ = ! Get(_O_, _Pk_)。
            1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
            1. _testResult_ が *true* なら *true*。
            1. _k_++。
          1. *false* を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.sort" oldids="sec-typedarraysortcompare">
        <h1>%TypedArray%.prototype.sort ( _comparator_ )</h1>
        <p>これは独立したメソッドであり、以下に述べる点を除き <emu-xref href="#sec-array.prototype.sort"></emu-xref> の `Array.prototype.sort` と同じ要件を実装する。実装は *this* 値が固定長で疎でない整数インデックス付きプロパティを持つことを利用して最適化できる。</p>
        <p>汎用ではない。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _comparator_ が *undefined* でなく IsCallable(_comparator_) が *false* なら *TypeError*。
          1. _obj_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_obj_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. 注: 以下のクロージャは文字列比較ではなく数値比較を行う。
          1. _SortCompare_ を (_x_, _y_) を取り _comparator_ を捕捉し CompareTypedArrayElements を呼ぶ抽象クロージャとする。
          1. _sortedList_ = ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~)。
          1. _j_ = 0。
          1. _j_ &lt; _len_ の間、
            1. ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*)。
            1. _j_++。
          1. _obj_ を返す。
        </emu-alg>
        <emu-note>
          <p>*NaN* は他の任意値より常に大きく比較されるため (CompareTypedArrayElements 参照)、_comparator_ 未指定時は *NaN* 値は末尾に並ぶ。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.subarray">
        <h1>%TypedArray%.prototype.subarray ( _start_, _end_ )</h1>
        <p>このメソッドは元の _TypedArray_ と同じ要素型・同じ ArrayBuffer を参照し、_start_ (含む) から _end_ (含まない) までの要素を参照する新しい _TypedArray_ を返す。_start_ または _end_ が負なら配列末尾からのインデックスを示す。</p>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] を持つ。
            1. _buffer_ = _O_.[[ViewedArrayBuffer]]。
          1. _srcRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. IsTypedArrayOutOfBounds(_srcRecord_) が *true* なら
            1. _srcLength_ = 0。
          1. そうでなければ
            1. _srcLength_ = TypedArrayLength(_srcRecord_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. _relativeStart_ = -∞ なら _startIndex_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _startIndex_ = max(_srcLength_ + _relativeStart_, 0)。
          1. それ以外 _startIndex_ = min(_relativeStart_, _srcLength_)。
          1. _elementSize_ = TypedArrayElementSize(_O_)。
          1. _srcByteOffset_ = _O_.[[ByteOffset]]。
          1. _beginByteOffset_ = _srcByteOffset_ + (_startIndex_ × _elementSize_)。
          1. もし _O_.[[ArrayLength]] が ~auto~ かつ _end_ が *undefined* なら
            1. _argumentsList_ = « _buffer_, 𝔽(_beginByteOffset_) »。
          1. そうでなければ
            1. _end_ が *undefined* なら _relativeEnd_ = _srcLength_; そうでなければ _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
            1. _relativeEnd_ = -∞ なら _endIndex_ = 0。
            1. そうでなく _relativeEnd_ &lt; 0 なら _endIndex_ = max(_srcLength_ + _relativeEnd_, 0)。
            1. それ以外 _endIndex_ = min(_relativeEnd_, _srcLength_)。
            1. _newLength_ = max(_endIndex_ - _startIndex_, 0)。
            1. _argumentsList_ = « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) »。
          1. ? TypedArraySpeciesCreate(_O_, _argumentsList_) を返す。
        </emu-alg>
        <p>汎用ではない。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tolocalestring">
        <h1>%TypedArray%.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>これは <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref> の `Array.prototype.toLocaleString` と同アルゴリズムを実装するが、*"length"* の [[Get]] の代わりに TypedArrayLength を呼ぶ点が異なる。基礎バッファがリサイズ不可で固定長かつ疎でないことを利用した最適化は許されるが、観測可能な仕様上の挙動を変えてはならない。</p>
        <p>汎用ではない。アルゴリズム実行前に ValidateTypedArray が *this* 値と ~seq-cst~ で呼ばれ、その結果が異常完了ならアルゴリズムを実行せず例外を投げる。</p>
        <emu-note>
          <p>実装が ECMA-402 国際化 API を含む場合、このメソッドは ECMA-402 における `Array.prototype.toLocaleString` アルゴリズムに基づく。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.toreversed">
        <h1>%TypedArray%.prototype.toReversed ( )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _A_ = ? TypedArrayCreateSameType(_O_, _len_)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _from_ = ! ToString(𝔽(_len_ - _k_ - 1))。
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _fromValue_ = ! Get(_O_, _from_)。
            1. ! Set(_A_, _Pk_, _fromValue_, *true*)。
            1. _k_++。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tosorted">
        <h1>%TypedArray%.prototype.toSorted ( _comparator_ )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _comparator_ が *undefined* でなく IsCallable(_comparator_) が *false* なら *TypeError*。
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _A_ = ? TypedArrayCreateSameType(_O_, _len_)。
          1. 注: 以下のクロージャは文字列比較でなく数値比較。
          1. _SortCompare_ を (_x_, _y_) を取り _comparator_ を捕捉し CompareTypedArrayElements を呼ぶ抽象クロージャとする。
          1. _sortedList_ = ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~)。
          1. _j_ = 0。
          1. _j_ &lt; _len_ の間、
            1. ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*)。
            1. _j_++。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tostring">
        <h1>%TypedArray%.prototype.toString ( )</h1>
        <p>*"toString"* プロパティの初期値は <emu-xref href="#sec-array.prototype.tostring"></emu-xref> で定義される %Array.prototype.toString% である。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.values">
        <h1>%TypedArray%.prototype.values ( )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. CreateArrayIterator(_O_, ~value~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.with">
        <h1>%TypedArray%.prototype.with ( _index_, _value_ )</h1>
        <p>呼び出し時:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. _len_ = TypedArrayLength(_taRecord_)。
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_)。
          1. _relativeIndex_ ≥ 0 なら _actualIndex_ = _relativeIndex_; そうでなければ _actualIndex_ = _len_ + _relativeIndex_。
          1. _O_.[[ContentType]] が ~bigint~ なら _numericValue_ = ? ToBigInt(_value_); そうでなければ _numericValue_ = ? ToNumber(_value_)。
          1. IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) が *false* なら *RangeError*。
          1. _A_ = ? TypedArrayCreateSameType(_O_, _len_)。
          1. _k_ = 0。
          1. _k_ &lt; _len_ の間、
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _k_ = _actualIndex_ なら _fromValue_ = _numericValue_; そうでなければ _fromValue_ = ! Get(_O_, _Pk_)。
            1. ! Set(_A_, _Pk_, _fromValue_, *true*)。
            1. _k_++。
          1. _A_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%typedarray%.prototype-@@iterator" id="sec-%typedarray%.prototype-%symbol.iterator%">
        <h1>%TypedArray%.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% プロパティの初期値は <emu-xref href="#sec-%typedarray%.prototype.values"></emu-xref> で定義される %TypedArray.prototype.values% である。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%.prototype-@@tostringtag" id="sec-get-%typedarray%.prototype-%symbol.tostringtag%">
        <h1>get %TypedArray%.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%TypedArray%`.prototype[%Symbol.toStringTag%]` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ = *this* 値。
          1. _O_ がオブジェクトでなければ *undefined*。
          1. _O_ が [[TypedArrayName]] を持たなければ *undefined*。
          1. _name_ = _O_.[[TypedArrayName]]。
          1. アサート: _name_ は String。
          1. _name_ を返す。
        </emu-alg>
        <p>このプロパティは { [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
        <p>この関数の *"name"* プロパティ初期値は *"get [Symbol.toStringTag]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-typedarray-objects">
      <h1>TypedArray オブジェクト用抽象操作</h1>

      <emu-clause id="sec-typedarraycreatefromconstructor" oldids="typedarray-create" type="abstract operation">
        <h1>
          TypedArrayCreateFromConstructor (
            _constructor_: a constructor,
            _argumentList_: a List of ECMAScript language values,
          ): TypedArray を含む通常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>コンストラクター関数を用いた新規 TypedArray の作成を規定する。</dd>
        </dl>
        <emu-alg>
          1. _newTypedArray_ = ? Construct(_constructor_, _argumentList_)。
          1. _taRecord_ = ? ValidateTypedArray(_newTypedArray_, ~seq-cst~)。
          1. アサート: _newTypedArray_ は <emu-xref href="#sec-properties-of-typedarray-instances" title></emu-xref> 記載の内部スロットを全て持つ。
          1. _argumentList_ の要素数が 1 で _argumentList_[0] が Number なら
            1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *TypeError*。
            1. _length_ = TypedArrayLength(_taRecord_)。
            1. _length_ &lt; ℝ(_argumentList_[0]) なら *TypeError*。
          1. _newTypedArray_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-create-same-type" type="abstract operation">
        <h1>
          TypedArrayCreateSameType (
            _exemplar_: a TypedArray,
            _length_: a non-negative integer,
          ): TypedArray を含む通常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_exemplar_ から派生したコンストラクターと _length_ を用いて新しい TypedArray を生成する。TypedArraySpeciesCreate が %Symbol.species% によりカスタムサブクラスを構築できるのに対し常に組込み TypedArray コンストラクターを用いる。</dd>
        </dl>
        <emu-alg>
          1. _constructor_ を _exemplar_.[[TypedArrayName]] に対応する <emu-xref href="#table-the-typedarray-constructors"></emu-xref> の組込みオブジェクトとする。
          1. _result_ = ? <emu-meta suppress-effects="user-code">TypedArrayCreateFromConstructor(_constructor_, « 𝔽(_length_) »)</emu-meta>。
          1. アサート: _result_ は [[TypedArrayName]] と [[ContentType]] を持つ。
          1. アサート: _result_.[[ContentType]] は _exemplar_.[[ContentType]]。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="typedarray-species-create" type="abstract operation">
        <h1>
          TypedArraySpeciesCreate (
            _exemplar_: a TypedArray,
            _argumentList_: a List of ECMAScript language values,
          ): TypedArray を含む通常完了または throw 完了
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_exemplar_ から派生したコンストラクターを用いて新しい TypedArray を作成する。ArraySpeciesCreate と異なり常に実際の TypedArray を生成することを強制する。</dd>
        </dl>
        <emu-alg>
          1. _defaultConstructor_ を _exemplar_.[[TypedArrayName]] に対応する組込みオブジェクトとする。
          1. _constructor_ = ? SpeciesConstructor(_exemplar_, _defaultConstructor_)。
          1. _result_ = ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_)。
          1. _result_.[[ContentType]] ≠ _exemplar_.[[ContentType]] なら *TypeError*。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validatetypedarray" type="abstract operation">
        <h1>
          ValidateTypedArray (
            _O_: an ECMAScript language value,
            _order_: ~seq-cst~ or ~unordered~,
          ): TypedArray With Buffer Witness Record を含む通常完了または throw 完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] を持つ。
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, _order_)。
          1. IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *TypeError*。
          1. _taRecord_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementsize" type="abstract operation">
        <h1>
          TypedArrayElementSize (
            _O_: a TypedArray,
          ): 非負整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[TypedArrayName]] に対し <emu-xref href="#table-the-typedarray-constructors"></emu-xref> で規定された要素サイズ値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementtype" type="abstract operation">
        <h1>
          TypedArrayElementType (
            _O_: a TypedArray,
          ): TypedArray 要素型
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[TypedArrayName]] に対し <emu-xref href="#table-the-typedarray-constructors"></emu-xref> で規定された要素型値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-comparetypedarrayelements" type="abstract operation">
        <h1>
          CompareTypedArrayElements (
            _x_: a Number or a BigInt,
            _y_: a Number or a BigInt,
            _comparator_: a function object or *undefined*,
          ): Number を含む通常完了または異常完了
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: _x_ と _y_ は両方 Number か両方 BigInt。
          1. _comparator_ が *undefined* でないなら
            1. _v_ = ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »))。
            1. _v_ が *NaN* なら *+0*<sub>𝔽</sub>。
            1. _v_ を返す。
          1. _x_ と _y_ が両方 *NaN* なら *+0*<sub>𝔽</sub>。
          1. _x_ が *NaN* なら *1*<sub>𝔽</sub>。
          1. _y_ が *NaN* なら *-1*<sub>𝔽</sub>。
          1. _x_ &lt; _y_ なら *-1*<sub>𝔽</sub>。
          1. _x_ > _y_ なら *1*<sub>𝔽</sub>。
          1. _x_ が *-0*<sub>𝔽</sub> かつ _y_ が *+0*<sub>𝔽</sub> なら *-1*<sub>𝔽</sub>。
          1. _x_ が *+0*<sub>𝔽</sub> かつ _y_ が *-0*<sub>𝔽</sub> なら *1*<sub>𝔽</sub>。
          1. *+0*<sub>𝔽</sub> を返す。
        </emu-alg>
        <emu-note>
          これは <emu-xref href="#sec-comparearrayelements"></emu-xref> の文字列比較ではなく数値比較を行う。
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-constructors">
      <h1>_TypedArray_ コンストラクター</h1>
      <p>各 _TypedArray_ コンストラクターは:</p>
      <ul>
        <li><emu-xref href="#table-the-typedarray-constructors"></emu-xref> にて _TypedArray_ の代わりに用いられる名称が異なるだけで、以下に記述する構造を持つ組込みオブジェクトである。</li>
        <li>引数の数と型により挙動が変わる関数であり、呼び出し時の実際の挙動は渡された引数の数と種類に依存する。</li>
        <li>関数として呼び出すことを意図しておらず、その形で呼べば例外を投げる。</li>
        <li>クラス定義の `extends` 句に利用できる。指定された _TypedArray_ の挙動を継承するサブクラスコンストラクターは、%TypedArray%`.prototype` 組込みメソッドを支える内部状態でインスタンスを初期化するため _TypedArray_ コンストラクターへの `super` 呼び出しを含めねばならない。</li>
      </ul>

      <emu-clause id="sec-typedarray" oldids="sec-typedarray-length,sec-typedarray-object">
        <h1>_TypedArray_ ( ..._args_ )</h1>
        <p>各 _TypedArray_ コンストラクターは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError*。
          1. _constructorName_ をこの <var>TypedArray</var> コンストラクターに対応する <emu-xref href="#table-the-typedarray-constructors"></emu-xref> の Constructor Name の String 値とする。
          1. _proto_ = <code>"%<var>TypedArray</var>.prototype%"</code>。
          1. _numberOfArgs_ = _args_ の要素数。
          1. _numberOfArgs_ = 0 なら
            1. ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0) を返す。
          1. それ以外
            1. _firstArgument_ = _args_[0]。
            1. _firstArgument_ がオブジェクトなら
              1. _O_ = ? AllocateTypedArray(_constructorName_, NewTarget, _proto_)。
              1. _firstArgument_ が [[TypedArrayName]] を持つなら
                1. ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_)。
              1. そうでなく [[ArrayBufferData]] を持つなら
                1. _numberOfArgs_ > 1 なら _byteOffset_ = _args_[1]; そうでなければ *undefined*。
                1. _numberOfArgs_ > 2 なら _length_ = _args_[2]; そうでなければ *undefined*。
                1. ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_)。
              1. それ以外
                1. アサート: _firstArgument_ はオブジェクトで [[TypedArrayName]] も [[ArrayBufferData]] も持たない。
                1. _usingIterator_ = ? GetMethod(_firstArgument_, %Symbol.iterator%)。
                1. _usingIterator_ が *undefined* でなければ
                  1. _values_ = ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_))。
                  1. ? InitializeTypedArrayFromList(_O_, _values_)。
                1. そうでなければ
                  1. 注: _firstArgument_ は iterable でないので配列ライクと仮定。
                  1. ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_)。
              1. _O_ を返す。
            1. そうでなければ
              1. アサート: _firstArgument_ はオブジェクトでない。
              1. _elementLength_ = ? ToIndex(_firstArgument_)。
              1. ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_) を返す。
        </emu-alg>

        <emu-clause id="sec-allocatetypedarray" type="abstract operation">
          <h1>
            AllocateTypedArray (
              _constructorName_: <emu-xref href="#table-the-typedarray-constructors"></emu-xref> にある TypedArray コンストラクター名 String,
              _newTarget_: a constructor,
              _defaultProto_: a String,
              optional _length_: 非負整数,
            ): TypedArray を含む通常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>TypedArray コンストラクターインスタンスを検証・生成する。_length_ が渡されればその長さの ArrayBuffer も割当て関連付ける。_TypedArray_ が用いる共通セマンティクスを提供。</dd>
          </dl>
          <emu-alg>
            1. _proto_ = ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_)。
            1. _obj_ = TypedArrayCreate(_proto_)。
            1. アサート: _obj_.[[ViewedArrayBuffer]] は *undefined*。
            1. _obj_.[[TypedArrayName]] = _constructorName_。
            1. _constructorName_ が *"BigInt64Array"* または *"BigUint64Array"* なら _obj_.[[ContentType]] = ~bigint~。
            1. それ以外は _obj_.[[ContentType]] = ~number~。
            1. _length_ 非存在なら
              1. _obj_.[[ByteLength]] = 0。
              1. _obj_.[[ByteOffset]] = 0。
              1. _obj_.[[ArrayLength]] = 0。
            1. そうでなければ
              1. ? AllocateTypedArrayBuffer(_obj_, _length_)。
            1. _obj_ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray">
          <h1>
            InitializeTypedArrayFromTypedArray (
              _O_: a TypedArray,
              _srcArray_: a TypedArray,
            ): ~unused~ を含む通常完了または throw 完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _srcData_ = _srcArray_.[[ViewedArrayBuffer]]。
            1. _elementType_ = TypedArrayElementType(_O_)。
            1. _elementSize_ = TypedArrayElementSize(_O_)。
            1. _srcType_ = TypedArrayElementType(_srcArray_)。
            1. _srcElementSize_ = TypedArrayElementSize(_srcArray_)。
            1. _srcByteOffset_ = _srcArray_.[[ByteOffset]]。
            1. _srcRecord_ = MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~)。
            1. IsTypedArrayOutOfBounds(_srcRecord_) が *true* なら *TypeError*。
            1. _elementLength_ = TypedArrayLength(_srcRecord_)。
            1. _byteLength_ = _elementSize_ × _elementLength_。
            1. _elementType_ = _srcType_ なら
              1. _data_ = ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_)。
            1. そうでなければ
              1. _data_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>。
              1. _srcArray_.[[ContentType]] ≠ _O_.[[ContentType]] なら *TypeError*。
              1. _srcByteIndex_ = _srcByteOffset_。
              1. _targetByteIndex_ = 0。
              1. _count_ = _elementLength_。
              1. _count_ > 0 の間、
                1. _value_ = GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~)。
                1. SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~)。
                1. _srcByteIndex_ += _srcElementSize_。
                1. _targetByteIndex_ += _elementSize_。
                1. _count_--。
            1. _O_.[[ViewedArrayBuffer]] = _data_。
            1. _O_.[[ByteLength]] = _byteLength_。
            1. _O_.[[ByteOffset]] = 0。
            1. _O_.[[ArrayLength]] = _elementLength_。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length">
          <h1>
            InitializeTypedArrayFromArrayBuffer (
              _O_: a TypedArray,
              _buffer_: an ArrayBuffer or a SharedArrayBuffer,
              _byteOffset_: an ECMAScript language value,
              _length_: an ECMAScript language value,
            ): ~unused~ を含む通常完了または throw 完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _elementSize_ = TypedArrayElementSize(_O_)。
            1. _offset_ = ? ToIndex(_byteOffset_)。
            1. _offset_ mod _elementSize_ ≠ 0 なら *RangeError*。
            1. _bufferIsFixedLength_ = IsFixedLengthArrayBuffer(_buffer_)。
            1. _length_ が *undefined* でなければ
              1. _newLength_ = ? ToIndex(_length_)。
            1. IsDetachedBuffer(_buffer_) が *true* なら *TypeError*。
            1. _bufferByteLength_ = ArrayBufferByteLength(_buffer_, ~seq-cst~)。
            1. _length_ が *undefined* かつ _bufferIsFixedLength_ が *false* なら
              1. _offset_ > _bufferByteLength_ なら *RangeError*。
              1. _O_.[[ByteLength]] = ~auto~。
              1. _O_.[[ArrayLength]] = ~auto~。
            1. そうでなければ
              1. もし _length_ が *undefined* なら
                1. _bufferByteLength_ mod _elementSize_ ≠ 0 なら *RangeError*。
                1. _newByteLength_ = _bufferByteLength_ - _offset_。
                1. _newByteLength_ &lt; 0 なら *RangeError*。
              1. そうでなければ
                1. _newByteLength_ = _newLength_ × _elementSize_。
                1. _offset_ + _newByteLength_ > _bufferByteLength_ なら *RangeError*。
              1. _O_.[[ByteLength]] = _newByteLength_。
              1. _O_.[[ArrayLength]] = _newByteLength_ / _elementSize_。
            1. _O_.[[ViewedArrayBuffer]] = _buffer_。
            1. _O_.[[ByteOffset]] = _offset_。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromlist" type="abstract operation">
          <h1>
            InitializeTypedArrayFromList (
              _O_: a TypedArray,
              _values_: a List of ECMAScript language values,
            ): ~unused~ を含む通常完了または throw 完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _len_ = _values_ の要素数。
            1. ? AllocateTypedArrayBuffer(_O_, _len_)。
            1. _k_ = 0。
            1. _k_ &lt; _len_ の間、
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _kValue_ = _values_ の先頭要素。
              1. _values_ から先頭を除去。
              1. ? Set(_O_, _Pk_, _kValue_, *true*)。
              1. _k_++。
            1. アサート: _values_ は空。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraylike" type="abstract operation">
          <h1>
            InitializeTypedArrayFromArrayLike (
              _O_: a TypedArray,
              _arrayLike_: an Object, but not a TypedArray or an ArrayBuffer,
            ): ~unused~ を含む通常完了または throw 完了
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _len_ = ? LengthOfArrayLike(_arrayLike_)。
            1. ? AllocateTypedArrayBuffer(_O_, _len_)。
            1. _k_ = 0。
            1. _k_ &lt; _len_ の間、
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _kValue_ = ? Get(_arrayLike_, _Pk_)。
              1. ? Set(_O_, _Pk_, _kValue_, *true*)。
              1. _k_++。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allocatetypedarraybuffer" type="abstract operation">
          <h1>
            AllocateTypedArrayBuffer (
              _O_: a TypedArray,
              _length_: a non-negative integer,
            ): ~unused~ を含む通常完了または throw 完了
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_O_ に ArrayBuffer を割当て関連付ける。</dd>
          </dl>
          <emu-alg>
            1. アサート: _O_.[[ViewedArrayBuffer]] は *undefined*。
            1. _elementSize_ = TypedArrayElementSize(_O_)。
            1. _byteLength_ = _elementSize_ × _length_。
            1. _data_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>。
            1. _O_.[[ViewedArrayBuffer]] = _data_。
            1. _O_.[[ByteLength]] = _byteLength_。
            1. _O_.[[ByteOffset]] = 0。
            1. _O_.[[ArrayLength]] = _length_。
            1. ~unused~ を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-typedarray-constructors">
      <h1>_TypedArray_ コンストラクターのプロパティ</h1>
      <p>各 _TypedArray_ コンストラクターは:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値が %TypedArray%。</li>
        <li>*"length"* プロパティ値は *3*<sub>𝔽</sub>。</li>
        <li>*"name"* プロパティ値は <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に規定されたコンストラクター名の String 値。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-typedarray.bytes_per_element">
        <h1>_TypedArray_.BYTES_PER_ELEMENT</h1>
        <p>_TypedArray_`.BYTES_PER_ELEMENT` の値は <emu-xref href="#table-the-typedarray-constructors"></emu-xref> における _TypedArray_ の要素サイズ値。</p>
        <p>属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype">
        <h1>_TypedArray_.prototype</h1>
        <p>_TypedArray_`.prototype` の初期値は対応する _TypedArray_ プロトタイプ組込みオブジェクト (<emu-xref href="#sec-properties-of-typedarray-prototype-objects"></emu-xref>) である。</p>
        <p>属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-prototype-objects">
      <h1>_TypedArray_ プロトタイプオブジェクトのプロパティ</h1>
      <p>各 _TypedArray_ プロトタイプオブジェクトは:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値が %TypedArray.prototype%。</li>
        <li>通常のオブジェクト。</li>
        <li>[[ViewedArrayBuffer]] など _TypedArray_ インスタンス固有内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-typedarray.prototype.bytes_per_element">
        <h1>_TypedArray_.prototype.BYTES_PER_ELEMENT</h1>
        <p>_TypedArray_`.prototype.BYTES_PER_ELEMENT` の値は <emu-xref href="#table-the-typedarray-constructors"></emu-xref> における _TypedArray_ の要素サイズ値。</p>
        <p>属性は { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype.constructor">
        <h1>_TypedArray_.prototype.constructor</h1>
        <p>与えられた _TypedArray_ コンストラクターのプロトタイプにおける *"constructor"* プロパティ初期値はそのコンストラクター自身である。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-instances">
      <h1>_TypedArray_ インスタンスのプロパティ</h1>
      <p>_TypedArray_ インスタンスは TypedArray である。各 _TypedArray_ インスタンスは対応する _TypedArray_ プロトタイプオブジェクトからプロパティを継承し、[[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] の内部スロットを持つ。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>キー付きコレクション</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map オブジェクト</h1>
    <p>Map はキー/値ペアのコレクションであり、キーと値の両方に任意の ECMAScript 言語値を使用できる。Map のコレクション内では、同一のキー値はただ 1 つのキー/値ペアにしか現れない。異なるキー値の判別には SameValueZero 比較アルゴリズムの意味論が用いられる。</p>
    <p>Map はハッシュテーブルまたはコレクション内要素数に対して平均で亜線形のアクセス時間を提供する他の機構を用いて実装されなければならない。本仕様で用いるデータ構造は Map の必要な観測可能セマンティクスを記述するためだけのものであり、実際に成立する実装モデルであることを意図しない。</p>

    <emu-clause id="sec-map-constructor">
      <h1>Map コンストラクター</h1>
      <p>Map コンストラクター:</p>
      <ul>
        <li><dfn>%Map%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Map"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼ばれたとき新しい Map を生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、その形で呼び出されると例外を投げる。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された Map の挙動を継承することを意図するサブクラスコンストラクターは、`Map.prototype` 組込みメソッドをサポートするために必要な内部状態でサブクラスインスタンスを生成・初期化するため、Map コンストラクターへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-map-iterable">
        <h1>Map ( [ _iterable_ ] )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError* 例外を投げる。
          1. _map_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%Map.prototype%"*, « [[MapData]] ») とする。
          1. _map_.[[MapData]] を新しい空 List に設定する。
          1. _iterable_ が *undefined* または *null* なら _map_ を返す。
          1. _adder_ を ? Get(_map_, *"set"*) とする。
          1. IsCallable(_adder_) が *false* なら *TypeError* 例外。
          1. ? AddEntriesFromIterable(_map_, _iterable_, _adder_) を返す。
        </emu-alg>
        <emu-note>
          <p>引数 _iterable_ が与えられる場合、それは %Symbol.iterator% メソッドを実装し、最初の要素が Map のキーとして用いられる値、2 番目の要素がそのキーに関連付ける値である 2 要素の配列ライクオブジェクトを生成するイテレータオブジェクトを返すオブジェクトであることが期待される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-add-entries-from-iterable" type="abstract operation">
        <h1>
          AddEntriesFromIterable (
            _target_: an Object,
            _iterable_: an ECMAScript language value, but not *undefined* or *null*,
            _adder_: a function object,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_adder_ は _target_ をレシーバとして呼び出される。</dd>
        </dl>
        <emu-alg>
          1. _iteratorRecord_ を ? GetIterator(_iterable_, ~sync~) とする。
          1. 繰り返し、
            1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
            1. _next_ が ~done~ なら _target_ を返す。
            1. _next_ がオブジェクトでないなら
              1. _error_ を ThrowCompletion(新規 *TypeError* オブジェクト) とする。
              1. ? IteratorClose(_iteratorRecord_, _error_) を返す。
            1. _k_ を Completion(Get(_next_, *"0"* )) とする。
            1. IfAbruptCloseIterator(_k_, _iteratorRecord_)。
            1. _v_ を Completion(Get(_next_, *"1"* )) とする。
            1. IfAbruptCloseIterator(_v_, _iteratorRecord_)。
            1. _status_ を Completion(Call(_adder_, _target_, « _k_, _v_ »)) とする。
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_)。
        </emu-alg>
        <emu-note>
          <p>引数 _iterable_ は %Symbol.iterator% メソッドを実装し、最初の要素が Map のキー、2 番目の要素がそのキーに対応する値である 2 要素配列ライクを生成するイテレータオブジェクトを返すオブジェクトであることが期待される。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-constructor">
      <h1>Map コンストラクターのプロパティ</h1>
      <p>Map コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値が %Function.prototype% である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-map.groupby">
        <h1>Map.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ は 2 つの引数を受け取る関数であるべき。`groupBy` は _items_ の各要素に対し昇順で _callback_ を 1 度ずつ呼び、新しい Map を構築する。_callback_ が返した各値は Map のキーとして用いられる。そのキーごとに、結果 Map はそのキーをキーとし、_callback_ がそのキーを返した全要素を含む配列を値とするエントリを持つ。</p>
          <p>_callback_ は 2 つの引数 (要素の値、要素のインデックス) で呼ばれる。</p>
          <p>`groupBy` の戻り値は Map である。</p>
        </emu-note>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. _groups_ を ? GroupBy(_items_, _callback_, ~collection~) とする。
          1. _map_ を ! Construct(%Map%) とする。
          1. 各 Record { [[Key]], [[Elements]] } _g_ ∈ _groups_ について
            1. _elements_ を CreateArrayFromList(_g_.[[Elements]]) とする。
            1. _entry_ を { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ } という Record とする。
            1. _entry_ を _map_.[[MapData]] に追加する。
          1. _map_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype">
        <h1>Map.prototype</h1>
        <p>`Map.prototype` の初期値は Map プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } の属性を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-map-@@species" id="sec-get-map-%symbol.species%">
        <h1>get Map [ %Symbol.species% ]</h1>
        <p>`Map[%Symbol.species%]` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティの値は *"get [Symbol.species]"* である。</p>
        <emu-note>
          <p>派生コレクションオブジェクトを生成するメソッドは %Symbol.species% を呼び出して派生オブジェクトを生成するためのコンストラクターを決定すべき。サブクラスコンストラクターは %Symbol.species% を再定義して既定のコンストラクター割り当てを変更できる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-prototype-object">
      <h1>Map プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Map プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Map.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロットの値が %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[MapData]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-map.prototype.clear">
        <h1>Map.prototype.clear ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値とする。
          1. ? RequireInternalSlot(_M_, [[MapData]]) を実行。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[MapData]] について
            1. _p_.[[Key]] を ~empty~ に設定。
            1. _p_.[[Value]] を ~empty~ に設定。
          1. *undefined* を返す。
        </emu-alg>
        <emu-note>
          <p>既存の [[MapData]] List は保持される。これはその List 上の反復途中で一時停止している Map Iterator オブジェクトが存在する可能性があるためである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.constructor">
        <h1>Map.prototype.constructor</h1>
        <p>`Map.prototype.constructor` の初期値は %Map% である。</p>
      </emu-clause>

      <emu-clause id="sec-map.prototype.delete">
        <h1>Map.prototype.delete ( _key_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値とする。
          1. ? RequireInternalSlot(_M_, [[MapData]])。
          1. _key_ を CanonicalizeKeyedCollectionKey(_key_) に設定。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[MapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら
              1. _p_.[[Key]] を ~empty~ に。
              1. _p_.[[Value]] を ~empty~ に。
              1. *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>~empty~ はエントリが削除されたことを示す仕様上の装置として用いられる。実装は内部データ構造から物理的にエントリを除去するなど別の手段を取ってもよい。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.entries">
        <h1>Map.prototype.entries ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値とする。
          1. ? CreateMapIterator(_M_, ~key+value~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.foreach">
        <h1>Map.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[MapData]])。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _entries_ を _M_.[[MapData]]。
          1. _numEntries_ を _entries_ の要素数。
          1. _index_ = 0。
          1. _index_ &lt; _numEntries_ の間繰り返し、
            1. _e_ = _entries_[_index_]。
            1. _index_ を _index_ + 1 に。
            1. _e_.[[Key]] が ~empty~ でなければ
              1. ? Call(_callback_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »)。
              1. 注: _callback_ の実行中に _entries_ の要素数が増加した可能性がある。
              1. _numEntries_ を _entries_ の要素数に設定。
          1. *undefined* を返す。
        </emu-alg>
        <emu-note>
          <p>_callback_ は 3 引数を受け取る関数であるべき。`forEach` は Map に存在する各キー/値ペアについてキー挿入順に 1 度ずつ _callback_ を呼ぶ。削除済みキーについては呼ばれない。</p>
          <p>_thisArg_ が与えられれば各呼出しの *this* 値として用いられ、無ければ *undefined*。</p>
          <p>_callback_ は (値, キー, 走査対象 Map) で呼ばれる。</p>
          <p>`forEach` 自体は直接オブジェクトをミューテートしないが _callback_ により変更され得る。Map の [[MapData]] の各エントリは 1 度だけ訪問される。`forEach` 開始後に追加された新しいキーは訪問される。訪問後に削除され再追加されたキーは再訪問され得る。開始後に削除され訪問前のキーは再追加されない限り訪問されない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.get">
        <h1>Map.prototype.get ( _key_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[MapData]])。
          1. _key_ を CanonicalizeKeyedCollectionKey(_key_) に設定。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[MapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら _p_.[[Value]] を返す。
          1. *undefined* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.has">
        <h1>Map.prototype.has ( _key_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[MapData]])。
          1. _key_ を CanonicalizeKeyedCollectionKey(_key_) に設定。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[MapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.keys">
        <h1>Map.prototype.keys ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? CreateMapIterator(_M_, ~key~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.set">
        <h1>Map.prototype.set ( _key_, _value_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[MapData]])。
          1. _key_ を CanonicalizeKeyedCollectionKey(_key_) に設定。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[MapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら
              1. _p_.[[Value]] を _value_ に設定。
              1. _M_ を返す。
          1. _p_ を { [[Key]]: _key_, [[Value]]: _value_ } とする Record とする。
          1. _p_ を _M_.[[MapData]] に追加。
          1. _M_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-map.prototype.size">
        <h1>get Map.prototype.size</h1>
        <p>`Map.prototype.size` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[MapData]])。
          1. _count_ を 0 とする。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[MapData]] について
            1. _p_.[[Key]] が ~empty~ でなければ _count_ を _count_ + 1 に設定。
          1. 𝔽(_count_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.values">
        <h1>Map.prototype.values ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? CreateMapIterator(_M_, ~value~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@iterator" id="sec-map.prototype-%symbol.iterator%">
        <h1>Map.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% プロパティの初期値は <emu-xref href="#sec-map.prototype.entries"></emu-xref> で定義される %Map.prototype.entries% である。</p>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@tostringtag" id="sec-map.prototype-%symbol.tostringtag%">
        <h1>Map.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"Map"* である。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } の属性を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-map-instances">
      <h1>Map インスタンスのプロパティ</h1>
      <p>Map インスタンスは通常のオブジェクトであり、Map プロトタイプオブジェクトからプロパティを継承する。Map インスタンスは [[MapData]] 内部スロットも持つ。</p>
    </emu-clause>

    <emu-clause id="sec-map-iterator-objects">
      <h1>Map イテレータオブジェクト</h1>
      <p><dfn variants="Map Iterators,Map Iterator object,Map Iterator objects">Map Iterator</dfn> は特定の Map インスタンスオブジェクト上の特定の反復を表すオブジェクトである。Map Iterator オブジェクトには名前付きコンストラクターは存在しない。代わりに、Map インスタンスオブジェクトの特定メソッド呼出により生成される。</p>

      <emu-clause id="sec-createmapiterator" type="abstract operation" oldids="sec-properties-of-map-iterator-instances,table-50,table-internal-slots-of-map-iterator-instances">
        <h1>
          CreateMapIterator (
            _map_: an ECMAScript language value,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): either a normal completion containing a Generator or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>Map メソッドのうち、そのようなイテレータを返すもののためのイテレータオブジェクトを生成するために用いられる。</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_map_, [[MapData]]) を実行。
          1. 引数なしで _map_ と _kind_ を捕捉し呼び出し時に以下を行う新しい抽象クロージャ _closure_ を作成:
            1. _entries_ を _map_.[[MapData]]。
            1. _index_ = 0。
            1. _numEntries_ を _entries_ の要素数。
            1. _index_ &lt; _numEntries_ の間繰り返し、
              1. _e_ = _entries_[_index_]。
              1. _index_ を _index_ + 1。
              1. _e_.[[Key]] が ~empty~ でなければ
                1. _kind_ が ~key~ なら
                  1. _result_ = _e_.[[Key]]。
                1. そうでなく _kind_ が ~value~ なら
                  1. _result_ = _e_.[[Value]]。
                1. それ以外
                  1. アサート: _kind_ は ~key+value~。
                  1. _result_ = CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »)。
                1. ? GeneratorYield(CreateIteratorResultObject(_result_, *false*)) を実行。
                1. 注: GeneratorYield による一時停止中に _entries_ の要素数が増加した可能性がある。
                1. _numEntries_ を _entries_ の要素数に設定。
            1. NormalCompletion(~unused~) を返す。
          1. CreateIteratorFromClosure(_closure_, *"%MapIteratorPrototype%"*, %MapIteratorPrototype%) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%mapiteratorprototype%-object">
        <h1>%MapIteratorPrototype% オブジェクト</h1>
        <p><dfn>%MapIteratorPrototype%</dfn> オブジェクト:</p>
        <ul>
          <li>全 Map Iterator オブジェクトが継承するプロパティを持つ。</li>
          <li>通常のオブジェクトである。</li>
          <li>[[Prototype]] 内部スロットの値は %Iterator.prototype%。</li>
          <li>以下のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-%mapiteratorprototype%.next">
          <h1>%MapIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%MapIteratorPrototype%"*)</emu-meta> を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%mapiteratorprototype%-@@tostringtag" id="sec-%mapiteratorprototype%-%symbol.tostringtag%">
          <h1>%MapIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"Map Iterator"* である。</p>
          <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } の属性を持つ。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set オブジェクト</h1>
    <p>Set オブジェクトは ECMAScript 言語値のコレクションである。異なる値は Set のコレクション内で 1 度だけ要素として現れる。異なる値の判別には SameValueZero 比較アルゴリズムの意味論が用いられる。</p>
    <p>Set オブジェクトはハッシュテーブルまたはコレクション内要素数に対し平均で亜線形アクセス時間を提供する他の機構を用いて実装されなければならない。本仕様で用いるデータ構造は Set オブジェクトの必要な観測可能セマンティクスを記述するためのみのものであり、実装モデルとなることを意図しない。</p>

    <emu-clause id="sec-abstract-operations-for-set-objects">
      <h1>Set オブジェクトに関する抽象操作</h1>

      <emu-clause id="sec-set-records">
        <h1>Set Record</h1>
        <p><dfn variants="Set Records">Set Record</dfn> は Set または類似オブジェクトのインターフェースをカプセル化するために用いられる Record 値である。</p>
        <p>Set Record は <emu-xref href="#table-set-record-fields"></emu-xref> に列挙したフィールドを持つ。</p>
        <emu-table id="table-set-record-fields" caption="Set Record のフィールド">
          <table>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
            <tr>
              <td>
                [[SetObject]]
              </td>
              <td>
                an Object
              </td>
              <td>
                Set または類似オブジェクト。
              </td>
            </tr>
            <tr>
              <td>
                [[Size]]
              </td>
              <td>
                a non-negative integer or +∞
              </td>
              <td>
                オブジェクトの報告サイズ。
              </td>
            </tr>
            <tr>
              <td>
                [[Has]]
              </td>
              <td>
                a function object
              </td>
              <td>
                オブジェクトの `has` メソッド。
              </td>
            </tr>
            <tr>
              <td>
                [[Keys]]
              </td>
              <td>
                a function object
              </td>
              <td>
                オブジェクトの `keys` メソッド。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getsetrecord" type="abstract operation">
        <h1>
          GetSetRecord (
            _obj_: an ECMAScript language value,
          ): either a normal completion containing a Set Record or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _obj_ がオブジェクトでなければ *TypeError* 例外。
          1. _rawSize_ を ? Get(_obj_, *"size"*) とする。
          1. _numSize_ を ? ToNumber(_rawSize_) とする。
          1. 注: _rawSize_ が *undefined* の場合 _numSize_ は *NaN* になる。
          1. _numSize_ が *NaN* なら *TypeError* 例外。
          1. _intSize_ を ! ToIntegerOrInfinity(_numSize_) とする。
          1. _intSize_ &lt; 0 なら *RangeError* 例外。
          1. _has_ を ? Get(_obj_, *"has"*)。
          1. IsCallable(_has_) が *false* なら *TypeError* 例外。
          1. _keys_ を ? Get(_obj_, *"keys"*)。
          1. IsCallable(_keys_) が *false* なら *TypeError* 例外。
          1. 新しい Set Record { [[SetObject]]: _obj_, [[Size]]: _intSize_, [[Has]]: _has_, [[Keys]]: _keys_ } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatahas" type="abstract operation">
        <h1>
          SetDataHas (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. SetDataIndex(_setData_, _value_) が ~not-found~ なら *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdataindex" type="abstract operation">
        <h1>
          SetDataIndex (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): a non-negative integer or ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _value_ を CanonicalizeKeyedCollectionKey(_value_) に設定。
          1. _size_ を _setData_ の要素数とする。
          1. _index_ = 0。
          1. _index_ &lt; _size_ の間、
            1. _e_ = _setData_[_index_]。
            1. _e_ が ~empty~ でなく _e_ が _value_ なら
              1. _index_ を返す。
            1. _index_ = _index_ + 1。
          1. ~not-found~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatasize" type="abstract operation">
        <h1>
          SetDataSize (
            _setData_: a List of either ECMAScript language values or ~empty~,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _count_ = 0。
          1. 各要素 _e_ ∈ _setData_ について
            1. _e_ が ~empty~ でなければ _count_ = _count_ + 1。
          1. _count_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-set-constructor">
      <h1>Set コンストラクター</h1>
      <p>Set コンストラクター:</p>
      <ul>
        <li><dfn>%Set%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Set"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼ばれたとき新しい Set オブジェクトを生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、その形で呼ばれると例外を投げる。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された Set の挙動を継承するサブクラスコンストラクターは、`Set.prototype` 組込みメソッドをサポートするための内部状態でサブクラスインスタンスを生成・初期化するため、Set コンストラクターへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-set-iterable">
        <h1>Set ( [ _iterable_ ] )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError* 例外。
          1. _set_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%Set.prototype%"*, « [[SetData]] ») とする。
          1. _set_.[[SetData]] を新しい空 List に設定。
          1. _iterable_ が *undefined* または *null* なら _set_ を返す。
          1. _adder_ を ? Get(_set_, *"add"*) とする。
          1. IsCallable(_adder_) が *false* なら *TypeError* 例外。
          1. _iteratorRecord_ を ? GetIterator(_iterable_, ~sync~) とする。
          1. 繰り返し、
            1. _next_ = ? IteratorStepValue(_iteratorRecord_)。
            1. _next_ が ~done~ なら _set_ を返す。
            1. _status_ を Completion(Call(_adder_, _set_, « _next_ »)) とする。
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-constructor">
      <h1>Set コンストラクターのプロパティ</h1>
      <p>Set コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値が %Function.prototype% である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-set.prototype">
        <h1>Set.prototype</h1>
        <p>`Set.prototype` の初期値は Set プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } の属性を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-set-@@species" id="sec-get-set-%symbol.species%">
        <h1>get Set [ %Symbol.species% ]</h1>
        <p>`Set[%Symbol.species%]` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティの値は *"get [Symbol.species]"* である。</p>
        <emu-note>
          <p>派生コレクションオブジェクトを生成するメソッドは %Symbol.species% を呼び出して派生オブジェクトを生成するのに使用するコンストラクターを決定すべき。サブクラスコンストラクターは %Symbol.species% を再定義して既定のコンストラクター割り当てを変更できる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-prototype-object">
      <h1>Set プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Set プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Set.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロットの値が %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[SetData]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-set.prototype.add">
        <h1>Set.prototype.add ( _value_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[SetData]])。
          1. _value_ を CanonicalizeKeyedCollectionKey(_value_) に設定。
          1. 各要素 _e_ ∈ _S_.[[SetData]] について
            1. _e_ が ~empty~ でなく SameValue(_e_, _value_) が *true* なら
              1. _S_ を返す。
          1. _value_ を _S_.[[SetData]] に追加。
          1. _S_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.clear">
        <h1>Set.prototype.clear ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[SetData]])。
          1. 各要素 _e_ ∈ _S_.[[SetData]] について
            1. 値が _e_ の要素を値が ~empty~ の要素で置き換える。
          1. *undefined* を返す。
        </emu-alg>
        <emu-note>
          <p>既存の [[SetData]] List は保持される。これはその List 上の反復途中で一時停止している Set Iterator オブジェクトが存在する可能性があるためである。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.constructor">
        <h1>Set.prototype.constructor</h1>
        <p>`Set.prototype.constructor` の初期値は %Set% である。</p>
      </emu-clause>

      <emu-clause id="sec-set.prototype.delete">
        <h1>Set.prototype.delete ( _value_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[SetData]])。
          1. _value_ を CanonicalizeKeyedCollectionKey(_value_) に設定。
          1. 各要素 _e_ ∈ _S_.[[SetData]] について
            1. _e_ が ~empty~ でなく SameValue(_e_, _value_) が *true* なら
              1. 値が _e_ の要素を値が ~empty~ の要素で置き換える。
              1. *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>~empty~ は削除済みエントリを示す仕様上の装置。実装は内部構造から実際に除去するなど他の手段を取ってよい。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.difference">
        <h1>Set.prototype.difference ( _other_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[SetData]])。
          1. _otherRec_ を ? GetSetRecord(_other_) とする。
          1. _resultSetData_ を _O_.[[SetData]] のコピーとする。
          1. もし SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]] なら
            1. _thisSize_ を _O_.[[SetData]] の要素数とする。
            1. _index_ = 0。
            1. _index_ &lt; _thisSize_ の間、
              1. _e_ = _resultSetData_[_index_]。
              1. _e_ が ~empty~ でなければ
                1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
                1. _inOther_ が *true* なら
                  1. _resultSetData_[_index_] = ~empty~。
              1. _index_ = _index_ + 1。
          1. それ以外
            1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
            1. _next_ = ~not-started~。
            1. _next_ が ~done~ でない間、
              1. _next_ = ? IteratorStepValue(_keysIter_)。
              1. _next_ が ~done~ でなければ
                1. _next_ = CanonicalizeKeyedCollectionKey(_next_)。
                1. _valueIndex_ = SetDataIndex(_resultSetData_, _next_)。
                1. _valueIndex_ が ~not-found~ でなければ
                  1. _resultSetData_[_valueIndex_] = ~empty~。
          1. _result_ を OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] ») とする。
          1. _result_.[[SetData]] = _resultSetData_。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.entries">
        <h1>Set.prototype.entries ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? CreateSetIterator(_S_, ~key+value~) を返す。
        </emu-alg>
        <emu-note>
          <p>反復目的では、Set は各エントリのキーと値が同一である Map に似て見える。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.foreach">
        <h1>Set.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[SetData]])。
          1. IsCallable(_callback_) が *false* なら *TypeError*。
          1. _entries_ = _S_.[[SetData]]。
          1. _numEntries_ = _entries_ の要素数。
          1. _index_ = 0。
          1. _index_ &lt; _numEntries_ の間、
            1. _e_ = _entries_[_index_]。
            1. _index_ = _index_ + 1。
            1. _e_ が ~empty~ でなければ
              1. ? Call(_callback_, _thisArg_, « _e_, _e_, _S_ »)。
              1. 注: _callback_ 実行中に _entries_ の要素数が増加した可能性がある。
              1. _numEntries_ を _entries_ の要素数に設定。
          1. *undefined* を返す。
        </emu-alg>
        <emu-note>
          <p>_callback_ は 3 引数を受け取る関数であるべき。`forEach` は Set オブジェクト内の各値に対して値挿入順で _callback_ を 1 度呼ぶ。削除済みの値については呼ばれない。</p>
          <p>_thisArg_ が与えられれば各呼出しの *this* 値として使用し、無ければ *undefined*。</p>
          <p>_callback_ は 3 引数で呼ばれる: 最初の 2 引数は Set に含まれる値で同一の値、3 番目は走査対象の Set。</p>
          <p>_callback_ が 3 引数で呼ばれるのは Map や Array の `forEach` のコールバックと整合性を保つため。Set では各項目値がキーと値の双方であるとみなされる。</p>
          <p>`forEach` 自体は直接オブジェクトを変更しないが、_callback_ により変更され得る。</p>
          <p>各値は通常 1 度だけ訪問されるが、訪問後削除され完了前に再追加された場合は再訪問される。開始後に削除され訪問前であった値は完了前に再追加されない限り訪問されない。開始後に追加された新しい値は訪問される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.has">
        <h1>Set.prototype.has ( _value_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[SetData]])。
          1. _value_ を CanonicalizeKeyedCollectionKey(_value_) に設定。
          1. 各要素 _e_ ∈ _S_.[[SetData]] について
            1. _e_ が ~empty~ でなく SameValue(_e_, _value_) が *true* なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.intersection">
        <h1>Set.prototype.intersection ( _other_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[SetData]])。
          1. _otherRec_ を ? GetSetRecord(_other_) とする。
          1. _resultSetData_ を新しい空 List とする。
          1. もし SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]] なら
            1. _thisSize_ を _O_.[[SetData]] の要素数。
            1. _index_ = 0。
            1. _index_ &lt; _thisSize_ の間、
              1. _e_ = _O_.[[SetData]][_index_]。
              1. _index_ = _index_ + 1。
              1. _e_ が ~empty~ でなければ
                1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
                1. _inOther_ が *true* なら
                  1. 注: 以前の _otherRec_.[[Has]] 呼出しが _O_.[[SetData]] の要素を削除再追加し、この反復で同じ要素が 2 度訪問され得る。
                  1. SetDataHas(_resultSetData_, _e_) が *false* なら _resultSetData_ に _e_ を追加。
                1. 注: _otherRec_.[[Has]] 実行中に _O_.[[SetData]] の要素数が増えた可能性。
                1. _thisSize_ を _O_.[[SetData]] の要素数に設定。
          1. それ以外
            1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
            1. _next_ = ~not-started~。
            1. _next_ が ~done~ でない間、
              1. _next_ = ? IteratorStepValue(_keysIter_)。
              1. _next_ が ~done~ でなければ
                1. _next_ = CanonicalizeKeyedCollectionKey(_next_)。
                1. _inThis_ = SetDataHas(_O_.[[SetData]], _next_)。
                1. _inThis_ が *true* なら
                  1. 注: _other_ は任意のオブジェクトであるためその *"keys"* イテレータが同じ値を複数回生成し得る。
                  1. SetDataHas(_resultSetData_, _next_) が *false* なら _resultSetData_ に _next_ を追加。
          1. _result_ = OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
          1. _result_.[[SetData]] = _resultSetData_。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.isdisjointfrom">
        <h1>Set.prototype.isDisjointFrom ( _other_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[SetData]])。
          1. _otherRec_ を ? GetSetRecord(_other_) とする。
          1. もし SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]] なら
            1. _thisSize_ を _O_.[[SetData]] の要素数。
            1. _index_ = 0。
            1. _index_ &lt; _thisSize_ の間、
              1. _e_ = _O_.[[SetData]][_index_]。
              1. _index_ = _index_ + 1。
              1. _e_ が ~empty~ でなければ
                1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
                1. _inOther_ が *true* なら *false* を返す。
                1. 注: _otherRec_.[[Has]] 実行中に _O_.[[SetData]] の要素数が増加した可能性。
                1. _thisSize_ を _O_.[[SetData]] の要素数に設定。
          1. それ以外
            1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
            1. _next_ = ~not-started~。
            1. _next_ が ~done~ でない間、
              1. _next_ = ? IteratorStepValue(_keysIter_)。
              1. _next_ が ~done~ でなければ
                1. SetDataHas(_O_.[[SetData]], _next_) が *true* なら
                  1. ? IteratorClose(_keysIter_, NormalCompletion(~unused~)) を実行。
                  1. *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issubsetof">
        <h1>Set.prototype.isSubsetOf ( _other_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[SetData]])。
          1. _otherRec_ を ? GetSetRecord(_other_) とする。
          1. SetDataSize(_O_.[[SetData]]) > _otherRec_.[[Size]] なら *false* を返す。
          1. _thisSize_ を _O_.[[SetData]] の要素数。
          1. _index_ = 0。
          1. _index_ &lt; _thisSize_ の間、
            1. _e_ = _O_.[[SetData]][_index_]。
            1. _index_ = _index_ + 1。
            1. _e_ が ~empty~ でなければ
              1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
              1. _inOther_ が *false* なら *false* を返す。
              1. 注: _otherRec_.[[Has]] 実行中に _O_.[[SetData]] の要素数が増加した可能性。
              1. _thisSize_ を _O_.[[SetData]] の要素数に設定。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issupersetof">
        <h1>Set.prototype.isSupersetOf ( _other_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[SetData]])。
          1. _otherRec_ を ? GetSetRecord(_other_) とする。
          1. SetDataSize(_O_.[[SetData]]) &lt; _otherRec_.[[Size]] なら *false* を返す。
          1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
          1. _next_ = ~not-started~。
          1. _next_ が ~done~ でない間、
            1. _next_ = ? IteratorStepValue(_keysIter_)。
            1. _next_ が ~done~ でなければ
              1. SetDataHas(_O_.[[SetData]], _next_) が *false* なら
                1. ? IteratorClose(_keysIter_, NormalCompletion(~unused~))。
                1. *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.keys">
        <h1>Set.prototype.keys ( )</h1>
        <p>*"keys"* プロパティの初期値は <emu-xref href="#sec-set.prototype.values"></emu-xref> で定義される %Set.prototype.values% である。</p>
        <emu-note>
          <p>反復目的では、Set は各エントリのキーと値が同一の Map のように見える。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-set.prototype.size">
        <h1>get Set.prototype.size</h1>
        <p>`Set.prototype.size` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[SetData]])。
          1. _size_ = SetDataSize(_S_.[[SetData]])。
          1. 𝔽(_size_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.symmetricdifference">
        <h1>Set.prototype.symmetricDifference ( _other_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[SetData]])。
          1. _otherRec_ を ? GetSetRecord(_other_) とする。
          1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
          1. _resultSetData_ を _O_.[[SetData]] のコピーとする。
          1. _next_ = ~not-started~。
          1. _next_ が ~done~ でない間、
            1. _next_ = ? IteratorStepValue(_keysIter_)。
            1. _next_ が ~done~ でなければ
              1. _next_ = CanonicalizeKeyedCollectionKey(_next_)。
              1. _resultIndex_ = SetDataIndex(_resultSetData_, _next_)。
              1. _resultIndex_ が ~not-found~ なら _alreadyInResult_ = *false*、そうでなければ *true*。
              1. SetDataHas(_O_.[[SetData]], _next_) が *true* なら
                1. _alreadyInResult_ が *true* なら _resultSetData_[_resultIndex_] = ~empty~。
              1. そうでなければ
                1. _alreadyInResult_ が *false* なら _resultSetData_ に _next_ を追加。
          1. _result_ = OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
          1. _result_.[[SetData]] = _resultSetData_。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.union">
        <h1>Set.prototype.union ( _other_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[SetData]])。
          1. _otherRec_ を ? GetSetRecord(_other_) とする。
          1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
          1. _resultSetData_ を _O_.[[SetData]] のコピーとする。
          1. _next_ = ~not-started~。
          1. _next_ が ~done~ でない間、
            1. _next_ = ? IteratorStepValue(_keysIter_)。
            1. _next_ が ~done~ でなければ
              1. _next_ = CanonicalizeKeyedCollectionKey(_next_)。
              1. SetDataHas(_resultSetData_, _next_) が *false* なら
                1. _resultSetData_ に _next_ を追加。
          1. _result_ = OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
          1. _result_.[[SetData]] = _resultSetData_。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.values">
        <h1>Set.prototype.values ( )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? CreateSetIterator(_S_, ~value~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@iterator" id="sec-set.prototype-%symbol.iterator%">
        <h1>Set.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% プロパティの初期値は <emu-xref href="#sec-set.prototype.values"></emu-xref> で定義される %Set.prototype.values% である。</p>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@tostringtag" id="sec-set.prototype-%symbol.tostringtag%">
        <h1>Set.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"Set"* である。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } の属性を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-set-instances">
      <h1>Set インスタンスのプロパティ</h1>
      <p>Set インスタンスは通常のオブジェクトであり、Set プロトタイプオブジェクトからプロパティを継承する。Set インスタンスは [[SetData]] 内部スロットも持つ。</p>
    </emu-clause>

    <emu-clause id="sec-set-iterator-objects">
      <h1>Set イテレータオブジェクト</h1>
      <p><dfn variants="Set Iterators,Set Iterator object,Set Iterator objects">Set Iterator</dfn> は以下で定義される構造を持つ通常のオブジェクトであり、特定の Set インスタンスオブジェクト上の特定の反復を表す。Set Iterator オブジェクトには名前付きコンストラクターは存在しない。代わりに Set インスタンスオブジェクトの特定メソッド呼出によって生成される。</p>

      <emu-clause id="sec-createsetiterator" type="abstract operation" oldids="sec-properties-of-set-iterator-instances,table-51,table-internal-slots-of-set-iterator-instances">
        <h1>
          CreateSetIterator (
            _set_: an ECMAScript language value,
            _kind_: ~key+value~ or ~value~,
          ): either a normal completion containing a Generator or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>Set メソッドのうちイテレータを返すもののためのイテレータオブジェクトを生成するために用いられる。</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_set_, [[SetData]]) を実行。
          1. 引数なしで _set_ と _kind_ を捕捉し呼び出し時に以下を行う新しい抽象クロージャ _closure_ を作成:
            1. _index_ = 0。
            1. _entries_ = _set_.[[SetData]]。
            1. _numEntries_ = _entries_ の要素数。
            1. _index_ &lt; _numEntries_ の間、
              1. _e_ = _entries_[_index_]。
              1. _index_ = _index_ + 1。
              1. _e_ が ~empty~ でなければ
                1. _kind_ が ~key+value~ なら
                  1. _result_ = CreateArrayFromList(« _e_, _e_ »)。
                  1. ? GeneratorYield(CreateIteratorResultObject(_result_, *false*))。
                1. そうでなければ
                  1. アサート: _kind_ は ~value~。
                  1. ? GeneratorYield(CreateIteratorResultObject(_e_, *false*))。
                1. 注: GeneratorYield による一時停止中に _entries_ の要素数が増加した可能性。
                1. _numEntries_ を _entries_ の要素数に設定。
            1. NormalCompletion(~unused~) を返す。
          1. CreateIteratorFromClosure(_closure_, *"%SetIteratorPrototype%"*, %SetIteratorPrototype%) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%setiteratorprototype%-object">
        <h1>%SetIteratorPrototype% オブジェクト</h1>
        <p><dfn>%SetIteratorPrototype%</dfn> オブジェクト:</p>
        <ul>
          <li>すべての Set Iterator オブジェクトが継承するプロパティを持つ。</li>
          <li>通常のオブジェクトである。</li>
          <li>[[Prototype]] 内部スロットの値は %Iterator.prototype%。</li>
          <li>以下のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-%setiteratorprototype%.next">
          <h1>%SetIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%SetIteratorPrototype%"*)</emu-meta> を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%setiteratorprototype%-@@tostringtag" id="sec-%setiteratorprototype%-%symbol.tostringtag%">
          <h1>%SetIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"Set Iterator"* である。</p>
          <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } の属性を持つ。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap オブジェクト</h1>
    <p>WeakMap はキーがオブジェクトおよび/またはシンボルであり、値が任意の ECMAScript 言語値であるキー/値ペアのコレクションである。WeakMap は特定のキーを持つキー/値ペアを含むかを問い合わせできるが、保持する値をキーとして列挙する仕組みは提供されない。特定の状況では、<emu-xref href="#sec-weakref-execution"></emu-xref> に記述されるように、存活していない値は WeakMap のキーとして除去される。</p>
    <p>実装は、WeakMap のキー/値ペアが到達不能になってから WeakMap から除去されるまでの間に任意に決定される遅延を課すことができる。もしこの遅延が ECMAScript プログラムから観測可能であれば、プログラム実行に影響する不確定性の原因となり得る。そのため ECMAScript 実装は、観測者が観測対象のキーを提示することなく WeakMap のキーを観測する手段を提供してはならない。</p>
    <p>WeakMap はハッシュテーブルまたはコレクション内キー/値ペア数に対し平均で亜線形のアクセス時間を提供する他の機構を用いて実装されなければならない。本仕様で用いられるデータ構造は WeakMap の必要な観測可能セマンティクスを記述するためだけのもので、実装モデルとなることを意図しない。</p>
    <emu-note>
      <p>WeakMap と WeakSet は、WeakMap や WeakSet インスタンスが存在しなかった場合にそのオブジェクトまたはシンボルが到達不能となり実装のガーベジコレクション機構によるリソース回収対象となる状況で、メモリ資源を “リーク” しない形で動的に状態を関連付ける機構を提供することを意図している。この特性は WeakMap または WeakSet インスタンスからキーへの逆方向 per-object/symbol マッピングを用いることで達成できる。あるいは各 WeakMap または WeakSet インスタンスが内部にキーと値データを保持してもよいが、この方法は WeakMap/WeakSet 実装とガーベジコレクタ間の協調を要する。以下の参考文献は WeakMap および WeakSet の実装に有用となり得る機構を記述している:</p>
      <p>Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In <i>Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97)</i>, A. Michael Berman (Ed.). ACM, New York, NY, USA, 176-183, <a href="http://doi.acm.org/10.1145/263698.263733">http://doi.acm.org/10.1145/263698.263733</a>.</p>
      <p>Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008, <a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak">http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak</a></p>
    </emu-note>

    <emu-clause id="sec-weakmap-constructor">
      <h1>WeakMap コンストラクター</h1>
      <p>WeakMap コンストラクター:</p>
      <ul>
        <li><dfn>%WeakMap%</dfn> である。</li>
        <li>グローバルオブジェクトの *"WeakMap"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼ばれたとき新しい WeakMap を生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、その形で呼ばれると例外を投げる。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された WeakMap の挙動を継承するサブクラスコンストラクターは、`WeakMap.prototype` 組込みメソッドをサポートするために必要な内部状態でサブクラスインスタンスを生成・初期化するため、WeakMap コンストラクターへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-weakmap-iterable">
        <h1>WeakMap ( [ _iterable_ ] )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError* 例外。
          1. _map_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakMap.prototype%"*, « [[WeakMapData]] ») とする。
          1. _map_.[[WeakMapData]] を新しい空 List に設定。
          1. _iterable_ が *undefined* または *null* なら _map_ を返す。
          1. _adder_ を ? Get(_map_, *"set"*) とする。
          1. IsCallable(_adder_) が *false* なら *TypeError* 例外。
          1. ? AddEntriesFromIterable(_map_, _iterable_, _adder_) を返す。
        </emu-alg>
        <emu-note>
          <p>引数 _iterable_ が与えられる場合、それは %Symbol.iterator% メソッドを実装し、最初の要素が WeakMap のキー、2 番目の要素がそのキーに関連付ける値である 2 要素配列ライクを生成するイテレータオブジェクトを返すオブジェクトであることが期待される。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-constructor">
      <h1>WeakMap コンストラクターのプロパティ</h1>
      <p>WeakMap コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値が %Function.prototype% である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype">
        <h1>WeakMap.prototype</h1>
        <p>`WeakMap.prototype` の初期値は WeakMap プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } の属性を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-prototype-object">
      <h1>WeakMap プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>WeakMap プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%WeakMap.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロットの値が %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[WeakMapData]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype.constructor">
        <h1>WeakMap.prototype.constructor</h1>
        <p>`WeakMap.prototype.constructor` の初期値は %WeakMap% である。</p>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.delete">
        <h1>WeakMap.prototype.delete ( _key_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. CanBeHeldWeakly(_key_) が *false* なら *false* を返す。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[WeakMapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら
              1. _p_.[[Key]] を ~empty~ に。
              1. _p_.[[Value]] を ~empty~ に。
              1. *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>~empty~ は削除を示す仕様上の装置。実装は内部データ構造から物理的に削除するなど別の手段を取ってもよい。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.get">
        <h1>WeakMap.prototype.get ( _key_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. CanBeHeldWeakly(_key_) が *false* なら *undefined* を返す。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[WeakMapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら _p_.[[Value]] を返す。
          1. *undefined* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.has">
        <h1>WeakMap.prototype.has ( _key_ )</h1>
        <p>このメソッドは呼び出し時:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. CanBeHeldWeakly(_key_) が *false* なら *false* を返す。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[WeakMapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.set">
        <h1>WeakMap.prototype.set ( _key_, _value_ )</h1>
        <p>このメソッドは呼び出し時:</p>
        <emu-alg>
          1. _M_ を *this* 値。
          1. ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. CanBeHeldWeakly(_key_) が *false* なら *TypeError* 例外。
          1. 各 Record { [[Key]], [[Value]] } _p_ ∈ _M_.[[WeakMapData]] について
            1. _p_.[[Key]] が ~empty~ でなく SameValue(_p_.[[Key]], _key_) が *true* なら
              1. _p_.[[Value]] を _value_ に設定。
              1. _M_ を返す。
          1. _p_ を { [[Key]]: _key_, [[Value]]: _value_ } という Record とする。
          1. _p_ を _M_.[[WeakMapData]] に追加。
          1. _M_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakmap.prototype-@@tostringtag" id="sec-weakmap.prototype-%symbol.tostringtag%">
        <h1>WeakMap.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"WeakMap"* である。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } の属性を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakmap-instances">
      <h1>WeakMap インスタンスのプロパティ</h1>
      <p>WeakMap インスタンスは通常のオブジェクトであり、WeakMap プロトタイプオブジェクトからプロパティを継承する。WeakMap インスタンスは [[WeakMapData]] 内部スロットも持つ。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet オブジェクト</h1>
    <p>WeakSet はオブジェクトおよび/またはシンボルのコレクションである。区別されるオブジェクトまたはシンボルは WeakSet のコレクション内で 1 度だけ要素として現れる。WeakSet は特定の値を含むかを問い合わせできるが、保持する値を列挙する仕組みは提供されない。特定の状況では、<emu-xref href="#sec-weakref-execution"></emu-xref> に記述されるように、存活していない値は WeakSet の要素として除去される。</p>
    <p>実装は WeakSet に含まれる値が到達不能になってから WeakSet から除去されるまでの間に任意の遅延を課すことができる。もしこの遅延が ECMAScript プログラムから観測可能であれば、不確定性の原因となり得る。そのため ECMAScript 実装は、観測者が観測対象値を提示することなく WeakSet が特定値を含むか決定する手段を提供してはならない。</p>
    <p>WeakSet はハッシュテーブルまたはコレクション内要素数に対し平均で亜線形アクセス時間を提供する他の機構を用いて実装されなければならない。本仕様のデータ構造は WeakSet の必要な観測可能セマンティクスを記述するためだけのもので、実装モデルとなることを意図しない。</p>
    <emu-note>
      <p><emu-xref href="#sec-weakmap-objects"></emu-xref> の注を参照。</p>
    </emu-note>

    <emu-clause id="sec-weakset-constructor">
      <h1>WeakSet コンストラクター</h1>
      <p>WeakSet コンストラクター:</p>
      <ul>
        <li><dfn>%WeakSet%</dfn> である。</li>
        <li>グローバルオブジェクトの *"WeakSet"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼ばれたとき新しい WeakSet を生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、その形で呼ばれると例外を投げる。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された WeakSet の挙動を継承するサブクラスコンストラクターは、`WeakSet.prototype` 組込みメソッドをサポートするために必要な内部状態でサブクラスインスタンスを生成・初期化するため、WeakSet コンストラクターへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-weakset-iterable">
        <h1>WeakSet ( [ _iterable_ ] )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError* 例外。
          1. _set_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakSet.prototype%"*, « [[WeakSetData]] ») とする。
          1. _set_.[[WeakSetData]] を新しい空 List に設定。
          1. _iterable_ が *undefined* または *null* なら _set_ を返す。
          1. _adder_ を ? Get(_set_, *"add"*) とする。
          1. IsCallable(_adder_) が *false* なら *TypeError* 例外。
          1. _iteratorRecord_ を ? GetIterator(_iterable_, ~sync~) とする。
          1. 繰り返し、
            1. _next_ = ? IteratorStepValue(_iteratorRecord_)。
            1. _next_ が ~done~ なら _set_ を返す。
            1. _status_ を Completion(Call(_adder_, _set_, « _next_ »)) とする。
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-constructor">
      <h1>WeakSet コンストラクターのプロパティ</h1>
      <p>WeakSet コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値が %Function.prototype% である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-weakset.prototype">
        <h1>WeakSet.prototype</h1>
        <p>`WeakSet.prototype` の初期値は WeakSet プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } の属性を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-prototype-object">
      <h1>WeakSet プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>WeakSet プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%WeakSet.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロットの値が %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[WeakSetData]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-weakset.prototype.add">
        <h1>WeakSet.prototype.add ( _value_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[WeakSetData]])。
          1. CanBeHeldWeakly(_value_) が *false* なら *TypeError* 例外。
          1. 各要素 _e_ ∈ _S_.[[WeakSetData]] について
            1. _e_ が ~empty~ でなく SameValue(_e_, _value_) が *true* なら
              1. _S_ を返す。
          1. _value_ を _S_.[[WeakSetData]] に追加。
          1. _S_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.constructor">
        <h1>WeakSet.prototype.constructor</h1>
        <p>`WeakSet.prototype.constructor` の初期値は %WeakSet% である。</p>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.delete">
        <h1>WeakSet.prototype.delete ( _value_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[WeakSetData]])。
          1. CanBeHeldWeakly(_value_) が *false* なら *false* を返す。
          1. 各要素 _e_ ∈ _S_.[[WeakSetData]] について
            1. _e_ が ~empty~ でなく SameValue(_e_, _value_) が *true* なら
              1. 値が _e_ の要素を値が ~empty~ の要素で置き換える。
              1. *true* を返す。
          1. *false* を返す。
        </emu-alg>
        <emu-note>
          <p>~empty~ は削除を示す仕様上の装置。実装は内部構造から物理的に除去するなど別手段を取ってよい。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.has">
        <h1>WeakSet.prototype.has ( _value_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値。
          1. ? RequireInternalSlot(_S_, [[WeakSetData]])。
          1. CanBeHeldWeakly(_value_) が *false* なら *false*。
          1. 各要素 _e_ ∈ _S_.[[WeakSetData]] について
            1. _e_ が ~empty~ でなく SameValue(_e_, _value_) が *true* なら *true*。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakset.prototype-@@tostringtag" id="sec-weakset.prototype-%symbol.tostringtag%">
        <h1>WeakSet.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"WeakSet"* である。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } の属性を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakset-instances">
      <h1>WeakSet インスタンスのプロパティ</h1>
      <p>WeakSet インスタンスは通常のオブジェクトであり、WeakSet プロトタイプオブジェクトからプロパティを継承する。WeakSet インスタンスは [[WeakSetData]] 内部スロットも持つ。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-keyed-collections">
    <h1>キー付きコレクションに関する抽象操作</h1>

    <emu-clause id="sec-canonicalizekeyedcollectionkey" type="abstract operation">
      <h1>
        CanonicalizeKeyedCollectionKey (
          _key_: an ECMAScript language value,
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _key_ が *-0*<sub>𝔽</sub> なら *+0*<sub>𝔽</sub> を返す。
        1. _key_ を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>構造化データ</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer オブジェクト</h1>

    <emu-clause id="sec-arraybuffer-notation">
      <h1>記法</h1>
      <p>本節、および <emu-xref href="#sec-atomics-object"></emu-xref>、<emu-xref href="#sec-memory-model"></emu-xref> における以下の記述は、read-modify-write 変更関数 (modification function) の内部データ構造を用いる。</p>
      <p><dfn variants="read-modify-write modification functions">read-modify-write 変更関数</dfn> とは、2 つのバイト値 List を引数に取り、バイト値の List を返す抽象クロージャとして表現される数学的関数である。これらの抽象クロージャは以下のすべての性質を満たす:</p>
      <ul>
        <li>アルゴリズムの全ステップをアトミックに実行する。</li>
        <li>個々のアルゴリズムステップは観測不可能である。</li>
      </ul>
      <emu-note>
        <p>read-modify-write 変更関数のアルゴリズムステップが純粋な数学的関数を成していることの検証を助けるため、次の編集上の慣例を推奨する:</p>
        <ul>
          <li>直接または呼び出される抽象操作・抽象クロージャを経由して、そのパラメータと捕捉した値以外の言語値や仕様上の値へアクセスしない。</li>
          <li>直接または遷移的に Completion Record を返す抽象操作や抽象クロージャを呼び出さない。</li>
          <li>Completion Record を返さない。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-fixed-length-and-resizable-arraybuffer-objects">
      <h1>固定長およびリサイズ可能 ArrayBuffer オブジェクト</h1>
      <p><dfn>固定長 ArrayBuffer</dfn> とは、生成後にバイト長が変化しない ArrayBuffer である。</p>
      <p><dfn>リサイズ可能 ArrayBuffer</dfn> とは、<emu-xref href="#sec-arraybuffer.prototype.resize" title></emu-xref> の呼び出しによって生成後にバイト長を変更し得る ArrayBuffer である。</p>
      <p>生成される ArrayBuffer オブジェクトの種類は、<emu-xref href="#sec-arraybuffer-length" title></emu-xref> に渡された引数に依存する。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-arraybuffer-objects">
      <h1>ArrayBuffer オブジェクトに関する抽象操作</h1>

      <emu-clause id="sec-allocatearraybuffer" type="abstract operation">
        <h1>
          AllocateArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ArrayBuffer を生成するために使用される。</dd>
        </dl>
        <emu-alg>
          1. _slots_ を « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] » とする。
          1. _maxByteLength_ が存在し ~empty~ でないなら _allocatingResizableBuffer_ を *true*、そうでなければ *false* とする。
          1. _allocatingResizableBuffer_ が *true* なら
            1. _byteLength_ > _maxByteLength_ なら *RangeError* 例外を投げる。
            1. &#8288;[[ArrayBufferMaxByteLength]] を _slots_ に追加する。
          1. _obj_ を ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, _slots_) とする。
          1. _block_ を ? CreateByteDataBlock(_byteLength_) とする。
          1. _obj_.[[ArrayBufferData]] に _block_ を設定する。
          1. _obj_.[[ArrayBufferByteLength]] に _byteLength_ を設定する。
          1. _allocatingResizableBuffer_ が *true* なら
            1. _maxByteLength_ バイトから成る Data Block _block_ を生成できない場合 *RangeError* 例外を投げる。
            1. 注: リサイズ可能 ArrayBuffer はインプレース成長で実装可能となるよう設計されている。実装は例えば仮想メモリを事前確保できない場合に投げてもよい。
            1. _obj_.[[ArrayBufferMaxByteLength]] に _maxByteLength_ を設定する。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybufferbytelength" type="abstract operation">
        <h1>
          ArrayBufferByteLength (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _order_: ~seq-cst~ or ~unordered~,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsSharedArrayBuffer(_arrayBuffer_) が *true* かつ _arrayBuffer_ が [[ArrayBufferByteLengthData]] 内部スロットを持つなら
            1. _bufferByteLengthBlock_ を _arrayBuffer_.[[ArrayBufferByteLengthData]] とする。
            1. _rawLength_ を GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_) とする。
            1. _isLittleEndian_ を周囲のエージェントの Agent Record の [[LittleEndian]] フィールドの値とする。
            1. ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_)) を返す。
          1. アサート: IsDetachedBuffer(_arrayBuffer_) は *false*。
          1. _arrayBuffer_.[[ArrayBufferByteLength]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffercopyanddetach" type="abstract operation">
        <h1>
          ArrayBufferCopyAndDetach (
            _arrayBuffer_: an ECMAScript language value,
            _newLength_: an ECMAScript language value,
            _preserveResizability_: ~preserve-resizability~ or ~fixed-length~,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]]) を実行。
          1. IsSharedArrayBuffer(_arrayBuffer_) が *true* なら *TypeError* 例外。
          1. _newLength_ が *undefined* なら
            1. _newByteLength_ を _arrayBuffer_.[[ArrayBufferByteLength]] とする。
          1. そうでなければ
            1. _newByteLength_ を ? ToIndex(_newLength_) とする。
          1. IsDetachedBuffer(_arrayBuffer_) が *true* なら *TypeError* 例外。
          1. _preserveResizability_ が ~preserve-resizability~ かつ IsFixedLengthArrayBuffer(_arrayBuffer_) が *false* なら
            1. _newMaxByteLength_ を _arrayBuffer_.[[ArrayBufferMaxByteLength]] とする。
          1. そうでなければ
            1. _newMaxByteLength_ を ~empty~ とする。
          1. _arrayBuffer_.[[ArrayBufferDetachKey]] が *undefined* でなければ *TypeError* 例外。
          1. _newBuffer_ を ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_)</emu-meta> とする。
          1. _copyLength_ を min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]]) とする。
          1. _fromBlock_ を _arrayBuffer_.[[ArrayBufferData]] とする。
          1. _toBlock_ を _newBuffer_.[[ArrayBufferData]] とする。
          1. CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_) を実行。
          1. 注: 新しい Data Block の生成および旧 Data Block からのコピーは観測不可能。実装はゼロコピー移動や `realloc` として実装してよい。
          1. ! DetachArrayBuffer(_arrayBuffer_) を実行。
          1. _newBuffer_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdetachedbuffer" type="abstract operation">
        <h1>
          IsDetachedBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _arrayBuffer_.[[ArrayBufferData]] が *null* なら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-detacharraybuffer" type="abstract operation">
        <h1>
          DetachArrayBuffer (
            _arrayBuffer_: an ArrayBuffer,
            optional _key_: anything,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
          <dt>skip global checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. アサート: IsSharedArrayBuffer(_arrayBuffer_) は *false*。
          1. _key_ が存在しなければ _key_ を *undefined* に設定。
          1. _arrayBuffer_.[[ArrayBufferDetachKey]] が _key_ でなければ *TypeError* 例外。
          1. _arrayBuffer_.[[ArrayBufferData]] を *null* に設定。
          1. _arrayBuffer_.[[ArrayBufferByteLength]] を 0 に設定。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-note>
          <p>ArrayBuffer インスタンスをデタッチすることは、裏付けとして使用される Data Block をそのインスタンスから切り離し、バイト長を 0 に設定する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-clonearraybuffer" type="abstract operation">
        <h1>
          CloneArrayBuffer (
            _srcBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _srcByteOffset_: a non-negative integer,
            _srcLength_: a non-negative integer,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_srcByteOffset_ で開始し _srcLength_ バイト継続する範囲の _srcBuffer_ のデータをコピーした新しい ArrayBuffer を作成する。</dd>
        </dl>
        <emu-alg>
          1. アサート: IsDetachedBuffer(_srcBuffer_) は *false*。
          1. _targetBuffer_ を ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _srcLength_)</emu-meta> とする。
          1. _srcBlock_ を _srcBuffer_.[[ArrayBufferData]] とする。
          1. _targetBlock_ を _targetBuffer_.[[ArrayBufferData]] とする。
          1. CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_) を実行。
          1. _targetBuffer_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation">
        <h1>
          GetArrayBufferMaxByteLengthOption (
            _options_: an ECMAScript language value,
          ): either a normal completion containing either a non-negative integer or ~empty~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _options_ がオブジェクトでなければ ~empty~ を返す。
          1. _maxByteLength_ を ? Get(_options_, *"maxByteLength"*) とする。
          1. _maxByteLength_ が *undefined* なら ~empty~ を返す。
          1. ? ToIndex(_maxByteLength_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation">
        <h1>
          HostResizeArrayBuffer (
            _buffer_: an ArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ホストが _buffer_ の実装定義のリサイズを行う機会を提供する。ホストがリサイズを扱わない場合、既定動作のため ~unhandled~ を返してよい。</dd>
        </dl>

        <p>HostResizeArrayBuffer の実装は以下に従わなければならない:</p>
        <ul>
          <li>抽象操作は _buffer_ をデタッチしない。</li>
          <li>抽象操作が ~handled~ で正常完了した場合、_buffer_.[[ArrayBufferByteLength]] は _newByteLength_ である。</li>
        </ul>

        <p>HostResizeArrayBuffer の既定実装は NormalCompletion(~unhandled~) を返すことである。</p>
      </emu-clause>

      <emu-clause id="sec-isfixedlengtharraybuffer" type="abstract operation">
        <h1>
          IsFixedLengthArrayBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _arrayBuffer_ が [[ArrayBufferMaxByteLength]] 内部スロットを持つなら *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunsignedelementtype" type="abstract operation">
        <h1>
          IsUnsignedElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>引数 _type_ が符号なし TypedArray 要素型か検証する。</dd>
        </dl>
        <emu-alg>
          1. _type_ が ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, ~biguint64~ のいずれかなら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunclampedintegerelementtype" type="abstract operation">
        <h1>
          IsUnclampedIntegerElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>引数 _type_ が ~uint8clamped~ を除く整数 TypedArray 要素型か検証する。</dd>
        </dl>
        <emu-alg>
          1. _type_ が ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, ~uint32~ のいずれかなら *true*。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isbigintelementtype" type="abstract operation">
        <h1>
          IsBigIntElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>引数 _type_ が BigInt TypedArray 要素型か検証する。</dd>
        </dl>
        <emu-alg>
          1. _type_ が ~biguint64~ または ~bigint64~ のいずれかなら *true*。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isnotearconfiguration" type="abstract operation">
        <h1>
          IsNoTearConfiguration (
            _type_: a TypedArray element type,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsUnclampedIntegerElementType(_type_) が *true* なら *true* を返す。
          1. IsBigIntElementType(_type_) が *true* かつ _order_ が ~init~ でも ~unordered~ でもないなら *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rawbytestonumeric" type="abstract operation" oldids="sec-rawbytestonumber">
        <h1>
          RawBytesToNumeric (
            _type_: a TypedArray element type,
            _rawBytes_: a List of byte values,
            _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _elementSize_ を要素型 _type_ について <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に指定された要素サイズ値とする。
          1. _isLittleEndian_ が *false* なら _rawBytes_ の要素順を反転する。
          1. _type_ が ~float16~ なら
            1. _value_ を _rawBytes_ のバイト要素を連結し IEEE 754-2019 binary16 値のリトルエンディアンビット列エンコーディングとして解釈したものとする。
            1. _value_ が NaN なら *NaN* を返す。
            1. _value_ に対応する Number 値を返す。
          1. _type_ が ~float32~ なら
            1. _value_ を _rawBytes_ のバイト要素を連結し IEEE 754-2019 binary32 値のリトルエンディアンビット列エンコーディングとして解釈したものとする。
            1. _value_ が NaN なら *NaN*。
            1. 対応する Number 値を返す。
          1. _type_ が ~float64~ なら
            1. _value_ を _rawBytes_ のバイト要素を連結し IEEE 754-2019 binary64 値のリトルエンディアンビット列エンコーディングとして解釈したものとする。
            1. _value_ が NaN なら *NaN*。
            1. 対応する Number 値を返す。
          1. IsUnsignedElementType(_type_) が *true* なら
            1. _intValue_ を _rawBytes_ のバイト要素を連結し符号なしリトルエンディアン 2 進数のビット列エンコーディングとして解釈したものとする。
          1. そうでなければ
            1. _intValue_ を _rawBytes_ のバイト要素を連結しビット長 _elementSize_ × 8 のリトルエンディアン 2 の補数表現として解釈したものとする。
          1. IsBigIntElementType(_type_) が *true* なら _intValue_ に対応する BigInt 値を返す。
          1. そうでなければ _intValue_ に対応する Number 値を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getrawbytesfromsharedblock" type="abstract operation">
        <h1>
          GetRawBytesFromSharedBlock (
            _block_: a Shared Data Block,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _elementSize_ を要素型 _type_ について <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に指定された要素サイズ値とする。
          1. _execution_ を周囲のエージェントの Agent Record の [[CandidateExecution]] フィールドとする。
          1. _eventsRecord_ を _execution_.[[EventsRecords]] のうち [[AgentSignifier]] が AgentSignifier() である Agent Events Record とする。
          1. _isTypedArray_ が *true* かつ IsNoTearConfiguration(_type_, _order_) が *true* なら _noTear_ = *true*、そうでなければ *false*。
          1. _rawValue_ を長さ _elementSize_ の List で、その要素が非決定的に選ばれたバイト値とする。
          1. 注: 実装では _rawValue_ は基盤ハードウェア上の非アトミックまたはアトミック read 命令の結果。非決定性は弱い一貫性ハードウェアの観測可能動作を記述するメモリモデル上の意味的規定。
          1. _readEvent_ を ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ } とする。
          1. _readEvent_ を _eventsRecord_.[[EventList]] に追加。
          1. Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } を _execution_.[[ChosenValues]] に追加。
          1. _rawValue_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvaluefrombuffer" type="abstract operation">
        <h1>
          GetValueFromBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
            optional _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: IsDetachedBuffer(_arrayBuffer_) は *false*。
          1. アサート: _arrayBuffer_ の _byteIndex_ から _type_ の値を表現するのに十分なバイトが存在する。
          1. _block_ を _arrayBuffer_.[[ArrayBufferData]] とする。
          1. _elementSize_ を要素型 _type_ について <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に指定された要素サイズ値とする。
          1. IsSharedArrayBuffer(_arrayBuffer_) が *true* なら
            1. アサート: _block_ は Shared Data Block。
            1. _rawValue_ を GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_) とする。
          1. そうでなければ
            1. _rawValue_ を、_byteIndex_ (含む) から _byteIndex_ + _elementSize_ (含まない) のインデックスにある _block_ のバイトからなる List とする。
          1. アサート: _rawValue_ の要素数は _elementSize_。
          1. _isLittleEndian_ が存在しなければ、周囲のエージェントの Agent Record の [[LittleEndian]] フィールドの値を設定。
          1. RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numerictorawbytes" type="abstract operation" oldids="sec-numbertorawbytes">
        <h1>
          NumericToRawBytes (
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isLittleEndian_: a Boolean,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _type_ が ~float16~ なら
            1. _rawBytes_ を、_value_ を roundTiesToEven モードで IEEE 754-2019 binary16 形式に変換した結果の 2 バイトを要素とする List とする。バイトはリトルエンディアン順。_value_ が *NaN* の場合、_rawBytes_ は実装が選ぶ任意の IEEE 754-2019 binary16 NaN エンコーディングとなり得る。実装は区別可能な各 *NaN* 値に常に同じエンコーディングを選択しなければならない。
          1. Else if _type_ が ~float32~ なら
            1. 同様に 4 バイト (binary32)。
          1. Else if _type_ が ~float64~ なら
            1. 同様に 8 バイト (binary64)。
          1. Else
            1. _n_ を要素型 _type_ について <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に指定された要素サイズ値とする。
            1. _conversionOperation_ を <emu-xref href="#table-the-typedarray-constructors"></emu-xref> の変換操作列に _type_ について示された抽象操作とする。
            1. _intValue_ を ℝ(! _conversionOperation_(_value_)) とする。
            1. _intValue_ ≥ 0 なら
              1. _rawBytes_ を _intValue_ の _n_ バイト 2 進エンコーディング (リトルエンディアン) を要素とする List とする。
            1. そうでなければ
              1. _rawBytes_ を _intValue_ の _n_ バイト 2 の補数エンコーディング (リトルエンディアン) を要素とする List とする。
          1. _isLittleEndian_ が *false* なら _rawBytes_ の順序を反転。
          1. _rawBytes_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setvalueinbuffer" type="abstract operation">
        <h1>
          SetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
            optional _isLittleEndian_: a Boolean,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: IsDetachedBuffer(_arrayBuffer_) は *false*。
          1. アサート: _byteIndex_ から始まり _type_ の値を表す十分なバイトが存在する。
          1. アサート: IsBigIntElementType(_type_) が *true* なら _value_ は BigInt、そうでなければ Number。
          1. _block_ を _arrayBuffer_.[[ArrayBufferData]] とする。
          1. _elementSize_ を要素型 _type_ について <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に指定された要素サイズ値。
          1. _isLittleEndian_ が存在しなければ周囲のエージェントの Agent Record の [[LittleEndian]] フィールド値を設定。
          1. _rawBytes_ を NumericToRawBytes(_type_, _value_, _isLittleEndian_) とする。
          1. IsSharedArrayBuffer(_arrayBuffer_) が *true* なら
            1. _execution_ を周囲のエージェントの Agent Record の [[CandidateExecution]] フィールド。
            1. _eventsRecord_ を _execution_.[[EventsRecords]] 内で [[AgentSignifier]] が AgentSignifier() の Agent Events Record。
            1. _isTypedArray_ が *true* かつ IsNoTearConfiguration(_type_, _order_) が *true* なら _noTear_ = *true*、そうでなければ *false*。
            1. WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } を _eventsRecord_.[[EventList]] に追加。
          1. そうでなければ
            1. _rawBytes_ の各バイトを _block_[_byteIndex_] から順に格納。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmodifysetvalueinbuffer" type="abstract operation">
        <h1>
          GetModifySetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _op_: a read-modify-write modification function,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: IsDetachedBuffer(_arrayBuffer_) は *false*。
          1. アサート: _byteIndex_ から _type_ の値を表す十分なバイトが存在する。
          1. アサート: IsBigIntElementType(_type_) が *true* なら _value_ は BigInt、そうでなければ Number。
          1. _block_ を _arrayBuffer_.[[ArrayBufferData]] とする。
          1. _elementSize_ を要素型 _type_ について <emu-xref href="#table-the-typedarray-constructors"></emu-xref> に指定された要素サイズ値。
          1. _isLittleEndian_ を周囲のエージェントの Agent Record の [[LittleEndian]] フィールド値とする。
          1. _rawBytes_ を NumericToRawBytes(_type_, _value_, _isLittleEndian_) とする。
          1. IsSharedArrayBuffer(_arrayBuffer_) が *true* なら
            1. _execution_ を周囲のエージェントの Agent Record の [[CandidateExecution]]。
            1. _eventsRecord_ を _execution_.[[EventsRecords]] 内で [[AgentSignifier]] が AgentSignifier() の Agent Events Record。
            1. _rawBytesRead_ を長さ _elementSize_ の List（非決定的に選ばれたバイト値）。
            1. 注: _rawBytesRead_ は基盤ハードウェア上の read-modify-write 命令、load-link、load-exclusive などのオペランド結果。非決定性は弱い一貫性ハードウェアの観測可能動作を記述。
            1. _rmwEvent_ を ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ } とする。
            1. _rmwEvent_ を _eventsRecord_.[[EventList]] に追加。
            1. Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } を _execution_.[[ChosenValues]] に追加。
          1. そうでなければ
            1. _rawBytesRead_ を長さ _elementSize_ の List で、_block_[_byteIndex_] からの _elementSize_ バイト列。
            1. _rawBytesModified_ を _op_(_rawBytesRead_, _rawBytes_) とする。
            1. _rawBytesModified_ の各バイトを _block_[_byteIndex_] から格納。
          1. RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arraybuffer-constructor">
      <h1>ArrayBuffer コンストラクター</h1>
      <p>ArrayBuffer コンストラクター:</p>
      <ul>
        <li><dfn>%ArrayBuffer%</dfn> である。</li>
        <li>グローバルオブジェクトの *"ArrayBuffer"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼び出された際、新しい ArrayBuffer を生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、その形で呼び出されると例外を投げる。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された ArrayBuffer の挙動を継承するサブクラスコンストラクターは、`ArrayBuffer.prototype` 組込みメソッドをサポートするために必要な内部状態でサブクラスインスタンスを生成・初期化するため、ArrayBuffer コンストラクターへの `super` 呼び出しを含める必要がある。</li>
      </ul>

      <emu-clause id="sec-arraybuffer-length">
        <h1>ArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError* 例外。
          1. _byteLength_ を ? ToIndex(_length_) とする。
          1. _requestedMaxByteLength_ を ? GetArrayBufferMaxByteLengthOption(_options_) とする。
          1. ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor">
      <h1>ArrayBuffer コンストラクターのプロパティ</h1>
      <p>ArrayBuffer コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値が %Function.prototype% である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-arraybuffer.isview">
        <h1>ArrayBuffer.isView ( _arg_ )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. _arg_ がオブジェクトでなければ *false* を返す。
          1. _arg_ が [[ViewedArrayBuffer]] 内部スロットを持てば *true* を返す。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype">
        <h1>ArrayBuffer.prototype</h1>
        <p>`ArrayBuffer.prototype` の初期値は ArrayBuffer プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } の属性を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-arraybuffer-@@species" id="sec-get-arraybuffer-%symbol.species%">
        <h1>get ArrayBuffer [ %Symbol.species% ]</h1>
        <p>`ArrayBuffer[%Symbol.species%]` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティ値は *"get [Symbol.species]"* である。</p>
        <emu-note>
          <p><emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> は通常、派生オブジェクトを生成するために *this* 値のコンストラクターを用いる。しかしサブクラスコンストラクターは %Symbol.species% プロパティを再定義することで <emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> メソッドの既定挙動を上書きできる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>ArrayBuffer プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>ArrayBuffer プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%ArrayBuffer.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロットの値が %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[ArrayBufferData]] および [[ArrayBufferByteLength]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength</h1>
        <p>`ArrayBuffer.prototype.byteLength` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) を実行。
          1. IsSharedArrayBuffer(_O_) が *true* なら *TypeError* 例外。
          1. IsDetachedBuffer(_O_) が *true* なら *+0*<sub>𝔽</sub> を返す。
          1. _length_ を _O_.[[ArrayBufferByteLength]] とする。
          1. 𝔽(_length_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.constructor">
        <h1>ArrayBuffer.prototype.constructor</h1>
        <p>`ArrayBuffer.prototype.constructor` の初期値は %ArrayBuffer% である。</p>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.detached">
        <h1>get ArrayBuffer.prototype.detached</h1>
        <p>`ArrayBuffer.prototype.detached` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *true* なら *TypeError* 例外。
          1. IsDetachedBuffer(_O_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
        <h1>get ArrayBuffer.prototype.maxByteLength</h1>
        <p>`ArrayBuffer.prototype.maxByteLength` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *true* なら *TypeError* 例外。
          1. IsDetachedBuffer(_O_) が *true* なら *+0*<sub>𝔽</sub> を返す。
          1. IsFixedLengthArrayBuffer(_O_) が *true* なら
            1. _length_ を _O_.[[ArrayBufferByteLength]] とする。
          1. そうでなければ
            1. _length_ を _O_.[[ArrayBufferMaxByteLength]] とする。
          1. 𝔽(_length_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.resizable">
        <h1>get ArrayBuffer.prototype.resizable</h1>
        <p>`ArrayBuffer.prototype.resizable` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *true* なら *TypeError* 例外。
          1. IsFixedLengthArrayBuffer(_O_) が *false* なら *true* を返し、そうでなければ *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.resize">
        <h1>ArrayBuffer.prototype.resize ( _newLength_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]])。
          1. IsSharedArrayBuffer(_O_) が *true* なら *TypeError* 例外。
          1. _newByteLength_ を ? ToIndex(_newLength_) とする。
          1. IsDetachedBuffer(_O_) が *true* なら *TypeError* 例外。
          1. _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]] なら *RangeError* 例外。
          1. _hostHandled_ を ? HostResizeArrayBuffer(_O_, _newByteLength_) とする。
          1. _hostHandled_ が ~handled~ なら *undefined* を返す。
          1. _oldBlock_ を _O_.[[ArrayBufferData]] とする。
          1. _newBlock_ を ? CreateByteDataBlock(_newByteLength_) とする。
          1. _copyLength_ を min(_newByteLength_, _O_.[[ArrayBufferByteLength]]) とする。
          1. CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_) を実行。
          1. 注: 新旧 Data Block の生成・コピーは観測不可能。実装はインプレース成長・縮小として実装してもよい。
          1. _O_.[[ArrayBufferData]] を _newBlock_ に設定。
          1. _O_.[[ArrayBufferByteLength]] を _newByteLength_ に設定。
          1. *undefined* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *true* なら *TypeError* 例外。
          1. IsDetachedBuffer(_O_) が *true* なら *TypeError* 例外。
          1. _len_ を _O_.[[ArrayBufferByteLength]] とする。
          1. _relativeStart_ を ? ToIntegerOrInfinity(_start_) とする。
          1. _relativeStart_ = -∞ なら _first_ = 0。
          1. Else if _relativeStart_ &lt; 0 なら _first_ = max(_len_ + _relativeStart_, 0)。
          1. Else _first_ = min(_relativeStart_, _len_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _len_、そうでなければ ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _final_ = 0。
          1. Else if _relativeEnd_ &lt; 0 なら _final_ = max(_len_ + _relativeEnd_, 0)。
          1. Else _final_ = min(_relativeEnd_, _len_)。
          1. _newLen_ を max(_final_ - _first_, 0) とする。
          1. _ctor_ を ? SpeciesConstructor(_O_, %ArrayBuffer%) とする。
          1. _new_ を ? Construct(_ctor_, « 𝔽(_newLen_) ») とする。
          1. ? RequireInternalSlot(_new_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_new_) が *true* なら *TypeError*。
          1. IsDetachedBuffer(_new_) が *true* なら *TypeError*。
          1. SameValue(_new_, _O_) が *true* なら *TypeError*。
          1. _new_.[[ArrayBufferByteLength]] &lt; _newLen_ なら *TypeError*。
          1. 注: 以上の副作用で _O_ がデタッチまたはリサイズされた可能性。
          1. IsDetachedBuffer(_O_) が *true* なら *TypeError*。
          1. _fromBuf_ を _O_.[[ArrayBufferData]]。
          1. _toBuf_ を _new_.[[ArrayBufferData]]。
          1. _currentLen_ を _O_.[[ArrayBufferByteLength]]。
          1. _first_ &lt; _currentLen_ なら
            1. _count_ を min(_newLen_, _currentLen_ - _first_)。
            1. CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_) を実行。
          1. _new_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfer">
        <h1>ArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfertofixedlength">
        <h1>ArrayBuffer.prototype.transferToFixedLength ( [ _newLength_ ] )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-arraybuffer.prototype-@@tostringtag" id="sec-arraybuffer.prototype-%symbol.tostringtag%">
        <h1>ArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"ArrayBuffer"* である。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } の属性を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-instances">
      <h1>ArrayBuffer インスタンスのプロパティ</h1>
      <p>ArrayBuffer インスタンスは ArrayBuffer プロトタイプオブジェクトからプロパティを継承する。各 ArrayBuffer インスタンスは [[ArrayBufferData]] 内部スロット、[[ArrayBufferByteLength]] 内部スロット、[[ArrayBufferDetachKey]] 内部スロットを持つ。リサイズ可能な ArrayBuffer インスタンスはさらに [[ArrayBufferMaxByteLength]] 内部スロットを持つ。</p>
      <p>[[ArrayBufferData]] が *null* の ArrayBuffer インスタンスはデタッチされていると見なされ、当該インスタンスに含まれるデータへアクセスまたは変更を試みる演算子はすべて失敗する。</p>
      <p>[[ArrayBufferDetachKey]] が *undefined* 以外に設定されている ArrayBuffer インスタンスでは、その同じ「デタッチキー」を引数として渡す DetachArrayBuffer 呼び出しのみが必要であり、そうでなければ TypeError になる。この内部スロットは特定の埋め込み環境によってのみ設定され、本仕様のアルゴリズムでは設定されない。</p>
    </emu-clause>

    <emu-clause id="sec-resizable-arraybuffer-guidelines">
      <h1>リサイズ可能 ArrayBuffer ガイドライン</h1>
      <emu-note>
        <p>以下はリサイズ可能 ArrayBuffer を扱う ECMAScript プログラマー向けガイドラインである。</p>
        <p>可能であれば展開環境でプログラムをテストすることを推奨する。利用可能な物理メモリ量はハードウェアデバイス間で大きく異なる。同様に仮想メモリサブシステムもデバイスや OS により大きく異なる。64 ビットデスクトップ Web ブラウザでメモリ不足を起こさないアプリケーションが 32 ビットモバイル Web ブラウザではメモリ不足になる可能性がある。</p>
        <p>リサイズ可能 ArrayBuffer の *"maxByteLength"* オプション値を選ぶ際、アプリケーションにとって可能な限り小さいサイズを選ぶことを推奨する。*"maxByteLength"* は 1,073,741,824 (2<sup>30</sup> バイト, 1GiB) を超えないことを推奨する。</p>
        <p>特定の最大サイズでリサイズ可能 ArrayBuffer を生成できても、将来のリサイズが成功する保証はない点に留意されたい。</p>
      </emu-note>

      <emu-note>
        <p>以下はリサイズ可能 ArrayBuffer を実装する ECMAScript 実装者向けガイドラインである。</p>
        <p>リサイズ可能 ArrayBuffer は、リサイズ時コピー、仮想メモリを事前確保したインプレース成長、またはコンストラクターの *"maxByteLength"* オプション値に応じた両者の組み合わせとして実装できる。</p>
        <p>ホストが (多数の ECMAScript アプリケーションを同時に実行する) マルチテナントであり、インプレース成長を仮想メモリ予約で実装する場合、32 ビット/64 ビット実装ともに *"maxByteLength"* ≥ 1GiB〜1.5GiB の値に対して例外を投げることを推奨する。これは単一アプリケーションによる仮想アドレス空間の枯渇可能性と相互運用性リスクを低減するためである。</p>
        <p>ホストに仮想メモリが無い (MMU 無し組込みデバイスなど) 場合、またはコピーによるリサイズのみを実装する場合、*"maxByteLength"* オプションに任意の <emu-not-ref>Number value for</emu-not-ref> を受け入れてもよい。ただし要求サイズのメモリブロックを決して割り当てられない場合は *RangeError* を投げることを推奨する。例えば要求サイズがデバイスで利用可能な最大メモリ量を超える場合など。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer オブジェクト</h1>

    <emu-clause id="sec-fixed-length-and-growable-sharedarraybuffer-objects">
      <h1>固定長および成長可能 (growable) SharedArrayBuffer オブジェクト</h1>
      <p><dfn>固定長 SharedArrayBuffer</dfn> とは、生成後にそのバイト長が変更できない SharedArrayBuffer である。</p>
      <p><dfn>成長可能 SharedArrayBuffer</dfn> とは、<emu-xref href="#sec-sharedarraybuffer.prototype.grow" title></emu-xref> の呼び出しによって生成後にバイト長を増やすことができる SharedArrayBuffer である。</p>
      <p>生成される SharedArrayBuffer オブジェクトの種別は、<emu-xref href="#sec-sharedarraybuffer-length" title></emu-xref> に渡された引数に依存する。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects">
      <h1>SharedArrayBuffer オブジェクト用抽象操作</h1>

      <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation">
        <h1>
          AllocateSharedArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): either a normal completion containing a SharedArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>SharedArrayBuffer を生成するために用いられる。</dd>
        </dl>
        <emu-alg>
          1. _slots_ を « [[ArrayBufferData]] » とする。
          1. _maxByteLength_ が存在しかつ ~empty~ でないなら _allocatingGrowableBuffer_ = *true*、そうでなければ *false* とする。
          1. _allocatingGrowableBuffer_ が *true* なら
            1. _byteLength_ > _maxByteLength_ なら *RangeError* 例外を投げる。
            1. &#8288;[[ArrayBufferByteLengthData]] と [[ArrayBufferMaxByteLength]] を _slots_ に追加する。
          1. そうでなければ
            1. &#8288;[[ArrayBufferByteLength]] を _slots_ に追加する。
          1. _obj_ を ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, _slots_) とする。
          1. _allocatingGrowableBuffer_ が *true* なら _allocLength_ = _maxByteLength_、そうでなければ _allocLength_ = _byteLength_。
          1. _block_ を ? CreateSharedByteDataBlock(_allocLength_) とする。
          1. _obj_.[[ArrayBufferData]] に _block_ を設定する。
          1. _allocatingGrowableBuffer_ が *true* なら
            1. アサート: _byteLength_ ≤ _maxByteLength_。
            1. _byteLengthBlock_ を ? CreateSharedByteDataBlock(8) とする。
            1. SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~) を実行。
            1. _obj_.[[ArrayBufferByteLengthData]] に _byteLengthBlock_ を設定。
            1. _obj_.[[ArrayBufferMaxByteLength]] に _maxByteLength_ を設定。
          1. そうでなければ
            1. _obj_.[[ArrayBufferByteLength]] に _byteLength_ を設定。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issharedarraybuffer" type="abstract operation">
        <h1>
          IsSharedArrayBuffer (
            _obj_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>オブジェクトが ArrayBuffer / SharedArrayBuffer あるいはそのサブタイプかどうかを判定する。</dd>
        </dl>
        <emu-alg>
          1. _bufferData_ を _obj_.[[ArrayBufferData]] とする。
          1. _bufferData_ が *null* なら *false* を返す。
          1. _bufferData_ が Data Block なら *false* を返す。
          1. アサート: _bufferData_ は Shared Data Block である。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation">
        <h1>
          HostGrowSharedArrayBuffer (
            _buffer_: a SharedArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ホストに _buffer_ の実装定義の成長処理を行う機会を与える。ホストが処理しない場合は既定動作として ~unhandled~ を返してよい。</dd>
        </dl>
        <p>HostGrowSharedArrayBuffer の実装は以下の要件に従わなければならない:</p>
        <ul>
          <li>抽象操作が ~unhandled~ で正常完了しない（= それ以外で正常完了する）場合で、_newByteLength_ が _buffer_ の現在のバイト長より小さい、または _newByteLength_ > _buffer_.[[ArrayBufferMaxByteLength]] のいずれかなら *RangeError* 例外を投げる。</li>
          <li>_isLittleEndian_ を周囲のエージェントの Agent Record の [[LittleEndian]] フィールド値とする。抽象操作が ~handled~ で正常完了した場合、[[Order]] が ~seq-cst~、[[Payload]] が NumericToRawBytes(~biguint64~, _newByteLength_, _isLittleEndian_)、[[Block]] が _buffer_.[[ArrayBufferByteLengthData]]、[[ByteIndex]] が 0、[[ElementSize]] が 8 の WriteSharedMemory または ReadModifyWriteSharedMemory イベントを周囲のエージェントの候補実行 (candidate execution) に追加し、`SharedArrayBuffer.prototype.grow` への競合する呼び出しが「失われない」（沈黙して何もしないことがない）ようにする。</li>
        </ul>

        <emu-note>
          <p>上記 2 つ目の要件は、_buffer_ の現在バイト長をどのよう/いつ読み取るかについて意図的に曖昧にしている。基盤ハードウェア上でバイト長をアトミック read-modify-write で更新する必要があるため、load-link/store-conditional や load-exclusive/store-exclusive 命令対を用いるアーキテクチャでは命令ペアを命令ストリーム内で近接させたい場合がある。そのため SharedArrayBuffer.prototype.grow 自体は HostGrowSharedArrayBuffer を呼ぶ前に _newByteLength_ の境界チェックを行わず、また現在のバイト長をいつ読むかを規定しない。</p>
          <p>これは HostResizeArrayBuffer と対照的であり、後者では _newByteLength_ が 0 以上かつ _buffer_.[[ArrayBufferMaxByteLength]] 以下であることが保証される。</p>
        </emu-note>

        <p>HostGrowSharedArrayBuffer の既定実装は NormalCompletion(~unhandled~) を返す。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer-constructor">
      <h1>SharedArrayBuffer コンストラクター</h1>
      <p>SharedArrayBuffer コンストラクター:</p>
      <ul>
        <li><dfn>%SharedArrayBuffer%</dfn> である。</li>
        <li>（ホストがそれを提供する場合）グローバルオブジェクトの *"SharedArrayBuffer"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼ばれたとき新しい SharedArrayBuffer を生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、その形で呼び出されると例外を投げる。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された SharedArrayBuffer の挙動を継承するサブクラスコンストラクターは `SharedArrayBuffer.prototype` の組込みメソッドを支える内部状態でサブクラスインスタンスを生成・初期化するため `super` 呼び出しを含めねばならない。</li>
      </ul>

      <p>ホストが SharedArrayBuffer への並行アクセスを提供しない場合、グローバルオブジェクトの *"SharedArrayBuffer"* プロパティを省略してよい。</p>

      <emu-note>
        <p>`ArrayBuffer` と異なり、`SharedArrayBuffer` はデタッチされず、その内部 [[ArrayBufferData]] スロットが *null* になることはない。</p>
      </emu-note>

      <emu-clause id="sec-sharedarraybuffer-length">
        <h1>SharedArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError* 例外。
          1. _byteLength_ を ? ToIndex(_length_) とする。
          1. _requestedMaxByteLength_ を ? GetArrayBufferMaxByteLengthOption(_options_) とする。
          1. ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor">
      <h1>SharedArrayBuffer コンストラクターのプロパティ</h1>
      <p>SharedArrayBuffer コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値が %Function.prototype% である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-sharedarraybuffer.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>`SharedArrayBuffer.prototype` の初期値は SharedArrayBuffer プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer-@@species" id="sec-sharedarraybuffer-%symbol.species%">
        <h1>get SharedArrayBuffer [ %Symbol.species% ]</h1>
        <p>`SharedArrayBuffer[%Symbol.species%]` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサの挙動は次の通り:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティ値は *"get [Symbol.species]"* である。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object">
      <h1>SharedArrayBuffer プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>SharedArrayBuffer プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%SharedArrayBuffer.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロット値は %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[ArrayBufferData]] や [[ArrayBufferByteLength]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>
        <p>`SharedArrayBuffer.prototype.byteLength` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *false* なら *TypeError* 例外。
          1. _length_ を ArrayBufferByteLength(_O_, ~seq-cst~) とする。
          1. 𝔽(_length_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>`SharedArrayBuffer.prototype.constructor` の初期値は %SharedArrayBuffer% である。</p>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.grow">
        <h1>SharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]])。
          1. IsSharedArrayBuffer(_O_) が *false* なら *TypeError* 例外。
          1. _newByteLength_ を ? ToIndex(_newLength_) とする。
          1. _hostHandled_ を ? HostGrowSharedArrayBuffer(_O_, _newByteLength_) とする。
          1. _hostHandled_ が ~handled~ なら *undefined* を返す。
          1. _isLittleEndian_ を周囲のエージェントの Agent Record の [[LittleEndian]] フィールド値とする。
          1. _byteLengthBlock_ を _O_.[[ArrayBufferByteLengthData]] とする。
          1. _currentByteLengthRawBytes_ を GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~) とする。
          1. _newByteLengthRawBytes_ を NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_) とする。
          1. 繰り返し、
            1. 注: 競合する grow を全順序化し、失われたり沈黙して無視されたりしないようにするための compare-and-exchange ループ。
            1. _currentByteLength_ を ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_)) とする。
            1. _newByteLength_ = _currentByteLength_ なら *undefined* を返す。
            1. _newByteLength_ &lt; _currentByteLength_ または _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]] なら *RangeError* 例外。
            1. _byteLengthDelta_ を _newByteLength_ - _currentByteLength_ とする。
            1. _byteLengthDelta_ バイトから成る新しい Shared Data Block 値を作成できないなら *RangeError* 例外。
            1. 注: ここで新しい Shared Data Block を作って差し替えるわけではない。最大サイズの Shared Data Block を事前確保する仕様上のモデルであり、メモリ不足なら *RangeError* を投げることを要求するための手順。
            1. _readByteLengthRawBytes_ を AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_) とする。
            1. ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) が *true* なら *undefined* を返す。
            1. _currentByteLengthRawBytes_ を _readByteLengthRawBytes_ に設定。
        </emu-alg>
        <emu-note>
          <p>長さ更新の compare-exchange の擬似的失敗は許されない。新しい長さの境界チェックが通り、実装がメモリ不足でない場合、候補実行には常に ReadModifyWriteSharedMemory イベント（成功した compare-exchange）が追加される。</p>
          <p>SharedArrayBuffer.prototype.grow への並列呼び出しは全順序化される。例: `sab.grow(10)` と `sab.grow(20)` が競合する場合、必ずどちらかが勝つ。`sab.grow(10)` が `sab.grow(20)` の後でも `sab` を縮めることはなく、その場合は *RangeError* を投げる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
        <h1>get SharedArrayBuffer.prototype.growable</h1>
        <p>`SharedArrayBuffer.prototype.growable` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *false* なら *TypeError* 例外。
          1. IsFixedLengthArrayBuffer(_O_) が *false* なら *true*、そうでなければ *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
        <h1>get SharedArrayBuffer.prototype.maxByteLength</h1>
        <p>`SharedArrayBuffer.prototype.maxByteLength` は set アクセサが *undefined* のアクセサプロパティであり、get アクセサは次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *false* なら *TypeError* 例外。
          1. IsFixedLengthArrayBuffer(_O_) が *true* なら
            1. _length_ を _O_.[[ArrayBufferByteLength]] とする。
          1. そうでなければ
            1. _length_ を _O_.[[ArrayBufferMaxByteLength]] とする。
          1. 𝔽(_length_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_O_) が *false* なら *TypeError* 例外。
          1. _len_ を ArrayBufferByteLength(_O_, ~seq-cst~) とする。
          1. _relativeStart_ を ? ToIntegerOrInfinity(_start_) とする。
          1. _relativeStart_ = -∞ なら _first_ = 0。
          1. そうでなく _relativeStart_ &lt; 0 なら _first_ = max(_len_ + _relativeStart_, 0)。
          1. それ以外は _first_ = min(_relativeStart_, _len_)。
          1. _end_ が *undefined* なら _relativeEnd_ = _len_; そうでなければ ? ToIntegerOrInfinity(_end_)。
          1. _relativeEnd_ = -∞ なら _final_ = 0。
          1. そうでなく _relativeEnd_ &lt; 0 なら _final_ = max(_len_ + _relativeEnd_, 0)。
          1. それ以外は _final_ = min(_relativeEnd_, _len_)。
          1. _newLen_ = max(_final_ - _first_, 0)。
          1. _ctor_ = ? SpeciesConstructor(_O_, %SharedArrayBuffer%)。
          1. _new_ = ? Construct(_ctor_, « 𝔽(_newLen_) »)。
          1. ? RequireInternalSlot(_new_, [[ArrayBufferData]])。
          1. IsSharedArrayBuffer(_new_) が *false* なら *TypeError*。
          1. _new_.[[ArrayBufferData]] が _O_.[[ArrayBufferData]] と同一なら *TypeError*。
          1. ArrayBufferByteLength(_new_, ~seq-cst~) &lt; _newLen_ なら *TypeError*。
          1. _fromBuf_ = _O_.[[ArrayBufferData]]。
          1. _toBuf_ = _new_.[[ArrayBufferData]]。
          1. CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_) を実行。
          1. _new_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer.prototype.toString,sec-sharedarraybuffer.prototype-@@tostringtag" id="sec-sharedarraybuffer.prototype-%symbol.tostringtag%">
        <h1>SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列 *"SharedArrayBuffer"* である。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-instances">
      <h1>SharedArrayBuffer インスタンスのプロパティ</h1>
      <p>SharedArrayBuffer インスタンスは SharedArrayBuffer プロトタイプオブジェクトからプロパティを継承する。各インスタンスは [[ArrayBufferData]] 内部スロットを持つ。成長不可のインスタンスは [[ArrayBufferByteLength]] 内部スロットを持つ。成長可能インスタンスは [[ArrayBufferByteLengthData]] および [[ArrayBufferMaxByteLength]] 内部スロットを持つ。</p>

      <emu-note>
        <p>ArrayBuffer と異なり、SharedArrayBuffer インスタンスは決してデタッチされない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-growable-sharedarraybuffer-guidelines">
      <h1>成長可能 SharedArrayBuffer ガイドライン</h1>
      <emu-note>
        <p>以下は成長可能 SharedArrayBuffer を扱う ECMAScript プログラマー向けガイドラインである。</p>
        <p>可能な限り実際のデプロイ環境でテストすることを推奨する。利用可能な物理メモリ量はハードウェア間で大きく異なる。同様に仮想メモリサブシステムもハードウェアや OS により大きく異なる。64 ビットデスクトップブラウザで正常なアプリが 32 ビットモバイルブラウザではメモリ不足になる可能性がある。</p>
        <p>成長可能 SharedArrayBuffer の *"maxByteLength"* オプション値はアプリで必要な最小限の値を選ぶことを推奨し、1,073,741,824 (1GiB) を超えないことを推奨する。</p>
        <p>特定の最大サイズで成長可能 SharedArrayBuffer を生成できても、将来の grow が成功する保証はない。</p>
        <p>成長可能 SharedArrayBuffer の長さ読み出しの全てが同期的 (~seq-cst~) 読みとは限らない。`u8[idx]` のような整数インデックス付きプロパティアクセスの境界チェックに用いる長さの読み出しは同期化されない。一般に明示的同期が無い場合、あるアクセスがインバウンドでも同じエージェント内の後続アクセスもインバウンドとは限らない。対照的に SharedArrayBuffer の `length` / `byteLength` ゲッター、%TypedArray%.prototype、DataView.prototype を介した明示的読み出しは同期化される。TypedArray が完全に out-of-bounds かを確認するための組込みメソッドによる長さの読み出しも同期化される。</p>
      </emu-note>

      <emu-note>
        <p>以下は成長可能 SharedArrayBuffer を実装する実装者向けガイドラインである。</p>
        <p>成長可能 SharedArrayBuffer は仮想メモリ事前予約によるインプレース成長で実装することを推奨する。</p>
        <p>grow 操作は基盤メモリアクセスと並行し得るため、メモリモデル上の制約として非順序 (unordered) アクセスでも「ティア」(値の一部が混ざる) を起こしてはならない。実際には基盤データブロックをコピーで拡張する（世界停止を伴う）手法では実装しづらい。世界停止は直列化ポイントを導入し遅いため推奨しない。</p>
        <p>追加されたメモリは作成直後（競合アクセスに対しても）ゼロ化されているように見えねばならない。ゼロ初期化オンデマンドの仮想メモリページ、または手動ゼロ化時の慎重な同期で実現できる。</p>
        <p>成長可能 SharedArrayBuffer 上の TypedArray ビューの整数インデックス付きプロパティアクセスは、基礎バッファ長へのアクセスが同期化されない（前述）ため、非成長 SharedArrayBuffer 上の場合と同様に最適化可能なことを意図している。例えば境界チェックをループ外へホイストできる。</p>
        <p>仮想メモリを持たない（MMU の無い組込み等）ホストでコピー方式による実装は困難である。そうしたホストにおけるメモリ使用は仮想メモリを持つホストと大きく異なる可能性があるため、メモリ使用の期待値を明確に伝えるべきである。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView オブジェクト</h1>

    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1>DataView オブジェクト用抽象操作</h1>

      <emu-clause id="sec-dataview-with-buffer-witness-records">
        <h1>DataView With Buffer Witness Record</h1>
        <p><dfn variants="DataView With Buffer Witness Records">DataView With Buffer Witness Record</dfn> は、DataView と、その参照バッファのキャッシュされたバイト長をカプセル化するための Record 値である。これは、参照バッファが成長可能 SharedArrayBuffer である場合にバイト長データブロックに対する単一の共有メモリ読み出しイベントを保証する助けとして用いられる。</p>
        <p>DataView With Buffer Witness Record は <emu-xref href="#table-dataview-with-buffer-witness-record-fields"></emu-xref> に示すフィールドを持つ。</p>
        <emu-table id="table-dataview-with-buffer-witness-record-fields" caption="DataView With Buffer Witness Record のフィールド">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a DataView
              </td>
              <td>
                バッファのバイト長が読み込まれる DataView オブジェクト。
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                Record 作成時点のオブジェクトの [[ViewedArrayBuffer]] のバイト長。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-makedataviewwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeDataViewWithBufferWitnessRecord (
            _obj_: a DataView,
            _order_: ~seq-cst~ or ~unordered~,
          ): a DataView With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _buffer_ を _obj_.[[ViewedArrayBuffer]] とする。
          1. IsDetachedBuffer(_buffer_) が *true* なら
            1. _byteLength_ = ~detached~。
          1. そうでなければ
            1. _byteLength_ = ArrayBufferByteLength(_buffer_, _order_)。
          1. DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewbytelength" type="abstract operation">
        <h1>
          GetViewByteLength (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. アサート: IsViewOutOfBounds(_viewRecord_) は *false*。
          1. _view_ を _viewRecord_.[[Object]] とする。
          1. _view_.[[ByteLength]] が ~auto~ でないなら _view_.[[ByteLength]] を返す。
          1. アサート: IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) は *false*。
          1. _byteOffset_ = _view_.[[ByteOffset]]。
          1. _byteLength_ = _viewRecord_.[[CachedBufferByteLength]]。
          1. アサート: _byteLength_ は ~detached~ ではない。
          1. _byteLength_ - _byteOffset_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isviewoutofbounds" type="abstract operation">
        <h1>
          IsViewOutOfBounds (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _view_ を _viewRecord_.[[Object]] とする。
          1. _bufferByteLength_ を _viewRecord_.[[CachedBufferByteLength]] とする。
          1. アサート: IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) が *true* であることと _bufferByteLength_ が ~detached~ であることは同値。
          1. _bufferByteLength_ が ~detached~ なら *true* を返す。
          1. _byteOffsetStart_ = _view_.[[ByteOffset]]。
          1. _view_.[[ByteLength]] が ~auto~ なら
            1. _byteOffsetEnd_ = _bufferByteLength_。
          1. そうでなければ
            1. _byteOffsetEnd_ = _byteOffsetStart_ + _view_.[[ByteLength]]。
          1. _byteOffsetStart_ > _bufferByteLength_ または _byteOffsetEnd_ > _bufferByteLength_ なら *true*。
          1. 注: 長さ 0 の DataView は out-of-bounds とみなさない。
          1. *false* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewvalue" type="abstract operation">
        <h1>
          GetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
          ): either a normal completion containing either a Number or a BigInt, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>DataView インスタンス上の関数からビューのバッファから値を取得する際に使用される。</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_view_, [[DataView]])。
          1. アサート: _view_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _getIndex_ = ? ToIndex(_requestIndex_)。
          1. _isLittleEndian_ = ToBoolean(_isLittleEndian_)。
          1. _viewOffset_ = _view_.[[ByteOffset]]。
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~)。
          1. 注: _view_ のバッファが成長可能 SharedArrayBuffer の場合、境界チェックは同期化されない操作。
          1. IsViewOutOfBounds(_viewRecord_) が *true* なら *TypeError* 例外。
          1. _viewSize_ = GetViewByteLength(_viewRecord_)。
          1. _elementSize_ を <emu-xref href="#table-the-typedarray-constructors"></emu-xref> における要素型 _type_ の要素サイズ値とする。
          1. _getIndex_ + _elementSize_ > _viewSize_ なら *RangeError* 例外。
          1. _bufferIndex_ = _getIndex_ + _viewOffset_。
          1. GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setviewvalue" type="abstract operation">
        <h1>
          SetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
            _value_: an ECMAScript language value,
          ): either a normal completion containing *undefined* or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>DataView インスタンス上の関数からビューのバッファへ値を書き込むために使用される。</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_view_, [[DataView]])。
          1. アサート: _view_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _getIndex_ = ? ToIndex(_requestIndex_)。
          1. IsBigIntElementType(_type_) が *true* なら _numberValue_ = ? ToBigInt(_value_)。
          1. そうでなければ _numberValue_ = ? ToNumber(_value_)。
          1. _isLittleEndian_ = ToBoolean(_isLittleEndian_)。
          1. _viewOffset_ = _view_.[[ByteOffset]]。
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~)。
          1. 注: _view_ のバッファが成長可能 SharedArrayBuffer の場合、境界チェックは同期化されない。
          1. IsViewOutOfBounds(_viewRecord_) が *true* なら *TypeError* 例外。
          1. _viewSize_ = GetViewByteLength(_viewRecord_)。
          1. _elementSize_ を <emu-xref href="#table-the-typedarray-constructors"></emu-xref> の _type_ の要素サイズ値とする。
          1. _getIndex_ + _elementSize_ > _viewSize_ なら *RangeError* 例外。
          1. _bufferIndex_ = _getIndex_ + _viewOffset_。
          1. SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_) を実行。
          1. *undefined* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-dataview-constructor">
      <h1>DataView コンストラクター</h1>
      <p>DataView コンストラクター:</p>
      <ul>
        <li><dfn>%DataView%</dfn> である。</li>
        <li>グローバルオブジェクトの *"DataView"* プロパティの初期値である。</li>
        <li>コンストラクターとして呼ばれた際に新しい DataView を生成し初期化する。</li>
        <li>関数として呼び出すことは意図されず、その形で呼ぶと例外を投げる。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された DataView の挙動を継承するサブクラスコンストラクターは `DataView.prototype` の組込みメソッドを支える内部状態でインスタンスを初期化するため `super` 呼び出しを含めねばならない。</li>
      </ul>

      <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
        <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
        <p>この関数は呼び出し時に次を行う:</p>
        <emu-alg>
          1. NewTarget が *undefined* なら *TypeError* 例外。
          1. ? RequireInternalSlot(_buffer_, [[ArrayBufferData]])。
          1. _offset_ = ? ToIndex(_byteOffset_)。
          1. IsDetachedBuffer(_buffer_) が *true* なら *TypeError* 例外。
          1. _bufferByteLength_ = ArrayBufferByteLength(_buffer_, ~seq-cst~)。
          1. _offset_ > _bufferByteLength_ なら *RangeError* 例外。
          1. _bufferIsFixedLength_ = IsFixedLengthArrayBuffer(_buffer_)。
          1. _byteLength_ が *undefined* なら
            1. _bufferIsFixedLength_ が *true* なら
              1. _viewByteLength_ = _bufferByteLength_ - _offset_。
            1. そうでなければ
              1. _viewByteLength_ = ~auto~。
          1. そうでなければ
            1. _viewByteLength_ = ? ToIndex(_byteLength_)。
            1. _offset_ + _viewByteLength_ > _bufferByteLength_ なら *RangeError* 例外。
          1. _O_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »)。
          1. IsDetachedBuffer(_buffer_) が *true* なら *TypeError* 例外。
          1. _bufferByteLength_ = ArrayBufferByteLength(_buffer_, ~seq-cst~) に再設定。
          1. _offset_ > _bufferByteLength_ なら *RangeError* 例外。
          1. _byteLength_ が *undefined* でないなら
            1. _offset_ + _viewByteLength_ > _bufferByteLength_ なら *RangeError* 例外。
          1. _O_.[[ViewedArrayBuffer]] = _buffer_。
          1. _O_.[[ByteLength]] = _viewByteLength_。
          1. _O_.[[ByteOffset]] = _offset_。
          1. _O_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-constructor">
      <h1>DataView コンストラクターのプロパティ</h1>
      <p>DataView コンストラクター:</p>
      <ul>
        <li>[[Prototype]] 内部スロット値が %Function.prototype% である。</li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-dataview.prototype">
        <h1>DataView.prototype</h1>
        <p>`DataView.prototype` の初期値は DataView プロトタイプオブジェクトである。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-prototype-object">
      <h1>DataView プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>DataView プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%DataView.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロット値は %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-get-dataview.prototype.buffer">
        <h1>get DataView.prototype.buffer</h1>
        <p>`DataView.prototype.buffer` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[DataView]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _buffer_ = _O_.[[ViewedArrayBuffer]]。
          1. _buffer_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.bytelength">
        <h1>get DataView.prototype.byteLength</h1>
        <p>`DataView.prototype.byteLength` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[DataView]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. IsViewOutOfBounds(_viewRecord_) が *true* なら *TypeError* 例外。
          1. _size_ = GetViewByteLength(_viewRecord_)。
          1. 𝔽(_size_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.byteoffset">
        <h1>get DataView.prototype.byteOffset</h1>
        <p>`DataView.prototype.byteOffset` は set アクセサが *undefined* のアクセサプロパティであり、その get アクセサは以下を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値。
          1. ? RequireInternalSlot(_O_, [[DataView]])。
          1. アサート: _O_ は [[ViewedArrayBuffer]] 内部スロットを持つ。
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. IsViewOutOfBounds(_viewRecord_) が *true* なら *TypeError* 例外。
          1. _offset_ = _O_.[[ByteOffset]]。
          1. 𝔽(_offset_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.constructor">
        <h1>DataView.prototype.constructor</h1>
        <p>`DataView.prototype.constructor` の初期値は %DataView% である。</p>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbigint64">
        <h1>DataView.prototype.getBigInt64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbiguint64">
        <h1>DataView.prototype.getBigUint64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat16">
        <h1>DataView.prototype.getFloat16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat32">
        <h1>DataView.prototype.getFloat32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat64">
        <h1>DataView.prototype.getFloat64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint8">
        <h1>DataView.prototype.getInt8 ( _byteOffset_ )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? GetViewValue(_view_, _byteOffset_, *true*, ~int8~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint16">
        <h1>DataView.prototype.getInt16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint32">
        <h1>DataView.prototype.getInt32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint8">
        <h1>DataView.prototype.getUint8 ( _byteOffset_ )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? GetViewValue(_view_, _byteOffset_, *true*, ~uint8~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint16">
        <h1>DataView.prototype.getUint16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint32">
        <h1>DataView.prototype.getUint32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbigint64">
        <h1>DataView.prototype.setBigInt64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbiguint64">
        <h1>DataView.prototype.setBigUint64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat16">
        <h1>DataView.prototype.setFloat16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat32">
        <h1>DataView.prototype.setFloat32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat64">
        <h1>DataView.prototype.setFloat64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint8">
        <h1>DataView.prototype.setInt8 ( _byteOffset_, _value_ )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? SetViewValue(_view_, _byteOffset_, *true*, ~int8~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint16">
        <h1>DataView.prototype.setInt16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint32">
        <h1>DataView.prototype.setInt32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint8">
        <h1>DataView.prototype.setUint8 ( _byteOffset_, _value_ )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. ? SetViewValue(_view_, _byteOffset_, *true*, ~uint8~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint16">
        <h1>DataView.prototype.setUint16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint32">
        <h1>DataView.prototype.setUint32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>このメソッドは呼び出し時に以下を行う:</p>
        <emu-alg>
          1. _view_ を *this* 値。
          1. _littleEndian_ が存在しなければ _littleEndian_ = *false*。
          1. ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~, _value_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-dataview.prototype-@@tostringtag" id="sec-dataview.prototype-%symbol.tostringtag%">
        <h1>DataView.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティ初期値は文字列 *"DataView"* である。</p>
        <p>このプロパティは { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-dataview-instances">
      <h1>DataView インスタンスのプロパティ</h1>
      <p>DataView インスタンスは DataView プロトタイプオブジェクトからプロパティを継承する。各インスタンスは [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] 内部スロットを持つ。</p>
      <emu-note>
        <p>[[DataView]] 内部スロットの値自体は仕様内では使用されない。その内部スロットが存在すること自体で DataView コンストラクターにより生成されたオブジェクトであることを識別する。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-atomics-object">
    <h1>Atomics オブジェクト</h1>
    <p>Atomics オブジェクトは次の通りである:</p>
    <ul>
      <li><dfn>%Atomics%</dfn> である。</li>
      <li>グローバルオブジェクトの *"Atomics"* プロパティの初期値である。</li>
      <li>通常のオブジェクトである。</li>
      <li>その [[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      <li>[[Construct]] 内部メソッドを持たない；`new` 演算子でコンストラクタとして使用できない。</li>
      <li>[[Call]] 内部メソッドを持たない；関数として呼び出せない。</li>
    </ul>
    <p>Atomics オブジェクトは共有メモリ配列セルに対して不可分（アトミック）に動作する関数、およびエージェントがプリミティブなイベントを待機・送出するための関数を提供する。規律を守って用いることで、共有メモリを介して通信するマルチエージェントプログラムは、並列 CPU 上であっても理解可能な順序で実行される。共有メモリ通信を支配する規則は後述のメモリモデルで定義される。</p>
    <emu-note>
      <p>ECMAScript での共有メモリのプログラミングおよび実装に関する参考指針については、メモリモデル節末尾の注記を参照のこと。</p>
    </emu-note>

    <emu-clause id="sec-waiter-record">
      <h1>Waiter Record</h1>
      <p><dfn variants="Waiter Records">Waiter Record</dfn> は `Atomics.wait` または `Atomics.waitAsync` への特定の呼び出しを表すために用いられる Record 値である。</p>
      <p>Waiter Record は <emu-xref href="#table-waiterrecord"></emu-xref> に挙げるフィールドを持つ。</p>
      <emu-table id="table-waiterrecord" caption="Waiter Record のフィールド">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[AgentSignifier]]
            </td>
            <td>
              エージェント識別子
            </td>
            <td>
              `Atomics.wait` または `Atomics.waitAsync` を呼び出したエージェント。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseCapability]]
            </td>
            <td>
              PromiseCapability Record または ~blocking~
            </td>
            <td>
              `Atomics.waitAsync` の呼び出しを表す場合はその結果の Promise、それ以外は ~blocking~。
            </td>
          </tr>
          <tr>
            <td>
              [[TimeoutTime]]
            </td>
            <td>
              非負の拡張数学的値
            </td>
            <td>
              タイムアウトが発火し得る最も早い時刻；時間値を用いて計算される。
            </td>
          </tr>
          <tr>
            <td>
              [[Result]]
            </td>
            <td>
              *"ok"* または *"timed-out"*
            </td>
            <td>
              呼び出しの戻り値。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-waiterlist-records" oldids="sec-waiterlist-objects">
      <h1>WaiterList Records</h1>
      <p><dfn variants="WaiterList Records">WaiterList Record</dfn> は `Atomics.wait`, `Atomics.waitAsync`, `Atomics.notify` を通じたエージェントの待機と通知を説明するために用いられる。</p>
      <p>WaiterList Record は <emu-xref href="#table-waiterlistrecord"></emu-xref> に挙げるフィールドを持つ。</p>
      <emu-table id="table-waiterlistrecord" caption="WaiterList Record のフィールド">
        <table>
          <thead>
            <tr>
              <th>
                フィールド名
              </th>
              <th>
                値
              </th>
              <th>
                意味
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Waiters]]
            </td>
            <td>
              Waiter Record の List
            </td>
            <td>
              この WaiterList が関連付けられているロケーションで待機している `Atomics.wait` または `Atomics.waitAsync` への呼び出し。
            </td>
          </tr>
          <tr>
            <td>
              [[MostRecentLeaveEvent]]
            </td>
            <td>
              Synchronize event または ~empty~
            </td>
            <td>
              直近にそのクリティカルセクションを離れたイベント。未入場なら ~empty~。
            </td>
          </tr>
        </table>
      </emu-table>
      <p>同一のエージェント識別子を持つ複数の Waiter Record が 1 つの WaiterList に存在し得る。</p>
      <p>エージェントクラスタは WaiterList Record の保管領域を持ち、そのインデックスは (_block_, _i_) であり、_block_ は Shared Data Block、_i_ はそのメモリ内のバイトオフセットである。WaiterList Record はエージェント非依存であり、(_block_, _i_) による WaiterList Record の参照はクラスタ内どのエージェントからも同一の WaiterList Record を得る。</p>
      <p>各 WaiterList Record はその評価中の排他的アクセスを制御する <dfn variants="critical sections">クリティカルセクション</dfn> を持つ。同時に入場できるのは 1 つのエージェントのみである。クリティカルセクションへの入退場は抽象操作 EnterCriticalSection と LeaveCriticalSection により制御される。待機エージェントの追加/削除、リスト走査、リスト上のエージェントのサスペンドおよび通知、Synchronize event の設定/取得といった WaiterList Record 上の操作は、クリティカルセクションへ入場したエージェントのみが実行できる。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-atomics">
      <h1>Atomics のための抽象操作</h1>

      <emu-clause id="sec-validateintegertypedarray" type="abstract operation" oldids="sec-validatesharedintegertypedarray">
        <h1>
          ValidateIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _waitable_: a Boolean,
          ): 正常完了で TypedArray With Buffer Witness Record を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _taRecord_ を ? ValidateTypedArray(_typedArray_, ~unordered~) の結果とする。
          1. 注: _typedArray_ の裏付けバッファが拡張可能な SharedArrayBuffer のとき、境界チェックは同期化操作ではない。
          1. もし _waitable_ が *true* なら、
            1. もし _typedArray_.[[TypedArrayName]] が *"Int32Array"* でも *"BigInt64Array"* でもないなら *TypeError* 例外を投げる。
          1. それ以外なら、
            1. _type_ を TypedArrayElementType(_typedArray_) とする。
            1. IsUnclampedIntegerElementType(_type_) が *false* かつ IsBigIntElementType(_type_) が *false* なら *TypeError* 例外を投げる。
          1. _taRecord_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccess" type="abstract operation">
        <h1>
          ValidateAtomicAccess (
            _taRecord_: a TypedArray With Buffer Witness Record,
            _requestIndex_: an ECMAScript language value,
          ): 正常完了で整数を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _length_ を TypedArrayLength(_taRecord_) とする。
          1. _accessIndex_ を ? ToIndex(_requestIndex_) とする。
          1. 事前条件: _accessIndex_ ≥ 0.
          1. もし _accessIndex_ ≥ _length_ なら *RangeError* 例外を投げる。
          1. _typedArray_ を _taRecord_.[[Object]] とする。
          1. _elementSize_ を TypedArrayElementSize(_typedArray_) とする。
          1. _offset_ を _typedArray_.[[ByteOffset]] とする。
          1. (_accessIndex_ × _elementSize_) + _offset_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccessonintegertypedarray" type="abstract operation">
        <h1>
          ValidateAtomicAccessOnIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
          ): 正常完了で整数を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _taRecord_ を ? ValidateIntegerTypedArray(_typedArray_, *false*) とする。
          1. ? ValidateAtomicAccess(_taRecord_, _requestIndex_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-revalidateatomicaccess" type="abstract operation">
        <h1>
          RevalidateAtomicAccess (
            _typedArray_: a TypedArray,
            _byteIndexInBuffer_: an integer,
          ): 正常完了で ~unused~ を含むか、または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>この操作は Atomics メソッド内で全ての引数強制が行われた後（それらには任意の副作用があり得て、バッファを out of bounds にし得る）、アトミック操作のための裏付けバッファ内のインデックスを再検証する。_typedArray_ の裏付けバッファが SharedArrayBuffer の場合、この操作は例外を投げない。</dd>
        </dl>
        <emu-alg>
          1. _taRecord_ を MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~) とする。
          1. 注: _typedArray_ の裏付けバッファが拡張可能な SharedArrayBuffer のとき、境界チェックは同期化操作ではない。
          1. もし IsTypedArrayOutOfBounds(_taRecord_) が *true* なら *TypeError* 例外を投げる。
          1. 事前条件: _byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]].
          1. もし _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]] なら *RangeError* 例外を投げる。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getwaiterlist" type="abstract operation">
        <h1>
          GetWaiterList (
            _block_: a Shared Data Block,
            _i_: 4 で割り切れる非負整数,
          ): WaiterList Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _i_ および _i_ + 3 は _block_ のメモリ内の有効なバイトオフセットである。
          1. 組 (_block_, _i_) により参照される WaiterList Record を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-entercriticalsection" type="abstract operation">
        <h1>
          EnterCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: 周囲のエージェントはいかなる WaiterList Record のクリティカルセクションにも入っていない。
          1. いずれのエージェントも _WL_ のクリティカルセクションにいないまで待ち、次に（他のエージェントを入れずに）_WL_ のクリティカルセクションへ入る。
          1. もし _WL_.[[MostRecentLeaveEvent]] が ~empty~ でないなら、
            1. 注: _WL_ のクリティカルセクションが少なくとも一度入場された場合、LeaveCriticalSection により Synchronize event が設定されている。
            1. _execution_ を周囲エージェントの Agent Record の [[CandidateExecution]] フィールドとする。
            1. _eventsRecord_ を _execution_.[[EventsRecords]] のうち [[AgentSignifier]] が AgentSignifier() である Agent Events Record とする。
            1. _enterEvent_ を新たな Synchronize event とする。
            1. _enterEvent_ を _eventsRecord_.[[EventList]] に追加する。
            1. (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) を _eventsRecord_.[[AgentSynchronizesWith]] に追加する。
          1. ~unused~ を返す。
        </emu-alg>
        <p>EnterCriticalSection は、クリティカルセクションへ入ろうとするエージェントが他のエージェントの退出を待たねばならないとき <dfn>競合 (contention)</dfn> を持つ。競合がないとき、EnterCriticalSection 呼び出しの FIFO 順序は観測可能である。競合があるとき、実装は任意の順序を選択できるが、エージェントを無期限に待たせてはならない。</p>
      </emu-clause>

      <emu-clause id="sec-leavecriticalsection" type="abstract operation">
        <h1>
          LeaveCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: 周囲のエージェントは _WL_ のクリティカルセクション内にいる。
          1. _execution_ を周囲エージェントの Agent Record の [[CandidateExecution]] フィールドとする。
          1. _eventsRecord_ を _execution_.[[EventsRecords]] のうち [[AgentSignifier]] が AgentSignifier() の Agent Events Record とする。
          1. _leaveEvent_ を新たな Synchronize event とする。
          1. _leaveEvent_ を _eventsRecord_.[[EventList]] に追加する。
          1. _WL_.[[MostRecentLeaveEvent]] を _leaveEvent_ に設定する。
          1. _WL_ のクリティカルセクションを離れる。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-addwaiter" type="abstract operation">
        <h1>
          AddWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: 周囲のエージェントは _WL_ のクリティカルセクション内にいる。
          1. 事前条件: _WL_.[[Waiters]] に [[PromiseCapability]] フィールドが _waiterRecord_.[[PromiseCapability]] かつ [[AgentSignifier]] フィールドが _waiterRecord_.[[AgentSignifier]] である Waiter Record は存在しない。
          1. _waiterRecord_ を _WL_.[[Waiters]] に追加する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiter" type="abstract operation">
        <h1>
          RemoveWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: 周囲のエージェントは _WL_ のクリティカルセクション内にいる。
          1. 事前条件: _WL_.[[Waiters]] は _waiterRecord_ を含む。
          1. _waiterRecord_ を _WL_.[[Waiters]] から除去する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiters" type="abstract operation">
        <h1>
          RemoveWaiters (
            _WL_: a WaiterList Record,
            _c_: 非負整数または +&infin;,
          ): Waiter Record の List
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: 周囲のエージェントは _WL_ のクリティカルセクション内にいる。
          1. _len_ を _WL_.[[Waiters]] の要素数とする。
          1. _n_ を min(_c_, _len_) とする。
          1. _L_ を _WL_.[[Waiters]] の最初の _n_ 要素からなる List とする。
          1. _WL_.[[Waiters]] の最初の _n_ 要素を除去する。
          1. _L_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-suspendthisagent" type="abstract operation" oldids="sec-suspend,sec-suspendagent">
        <h1>
          SuspendThisAgent (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: 周囲のエージェントは _WL_ のクリティカルセクション内にいる。
          1. 事前条件: _WL_.[[Waiters]] は _waiterRecord_ を含む。
          1. _thisAgent_ を AgentSignifier() とする。
          1. 事前条件: _waiterRecord_.[[AgentSignifier]] は _thisAgent_ である。
          1. 事前条件: _waiterRecord_.[[PromiseCapability]] は ~blocking~ である。
          1. 事前条件: AgentCanSuspend() は *true* である。
          1. LeaveCriticalSection(_WL_) を行い、サスペンドが有効になる前に通知が到着しても失われない方法で、周囲のエージェントを _waiterRecord_.[[TimeoutTime]] の時刻までサスペンドし、その後周囲のエージェントはサスペンド解除される。サスペンド解除はタイムアウト、または他のエージェントが NotifyWaiter を _WL_, _thisAgent_ で呼び出した（つまり `Atomics.notify` 呼び出し経由）場合のみ起こる。
          1. EnterCriticalSection(_WL_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-notifywaiter" type="abstract operation">
        <h1>
          NotifyWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: 周囲のエージェントは _WL_ のクリティカルセクション内にいる。
          1. もし _waiterRecord_.[[PromiseCapability]] が ~blocking~ なら、
            1. 識別子が _waiterRecord_.[[AgentSignifier]] であるエージェントをサスペンドから起こす。
            1. 注: これによりエージェントは SuspendThisAgent 内の実行を再開する。
          1. そうでなく AgentSignifier() が _waiterRecord_.[[AgentSignifier]] なら、
            1. _promiseCapability_ を _waiterRecord_.[[PromiseCapability]] とする。
            1. ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] ») を実行する。
          1. その他の場合、
            1. EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]]) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
        <emu-note>
          <p>エージェントは、ホストへ渡す以外の形で他エージェントの promise capability にアクセスしてはならない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueresolveinagentjob" type="abstract operation">
        <h1>
          EnqueueResolveInAgentJob (
            _agentSignifier_: an agent signifier,
            _promiseCapability_: a PromiseCapability Record,
            _resolution_: *"ok"* or *"timed-out"*,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _resolveJob_ を、引数なしで _agentSignifier_, _promiseCapability_, _resolution_ を捕捉し、呼び出されたとき次を行う新たな Job Abstract Closure とする:
            1. 事前条件: AgentSignifier() は _agentSignifier_ である。
            1. ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ ») を実行する。
            1. ~unused~ を返す。
          1. _realmInTargetAgent_ を ! GetFunctionRealm(_promiseCapability_.[[Resolve]]) とする。
          1. 事前条件: _agentSignifier_ は _realmInTargetAgent_.[[AgentSignifier]] である。
          1. HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dowait" type="abstract operation">
        <h1>
          DoWait (
            _mode_: ~sync~ or ~async~,
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _timeout_: an ECMAScript language value,
          ): 正常完了で Object, *"not-equal"*, *"timed-out"*, *"ok"* のいずれか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _taRecord_ を ? ValidateIntegerTypedArray(_typedArray_, *true*) とする。
          1. _buffer_ を _taRecord_.[[Object]].[[ViewedArrayBuffer]] とする。
          1. もし IsSharedArrayBuffer(_buffer_) が *false* なら *TypeError* 例外を投げる。
          1. _i_ を ? ValidateAtomicAccess(_taRecord_, _index_) とする。
          1. _arrayTypeName_ を _typedArray_.[[TypedArrayName]] とする。
          1. もし _arrayTypeName_ が *"BigInt64Array"* なら _v_ を ? ToBigInt64(_value_) とする。
          1. そうでなければ _v_ を ? ToInt32(_value_) とする。
          1. _q_ を ? ToNumber(_timeout_) とする。
          1. もし _q_ が *NaN* 又は *+∞*<sub>𝔽</sub> なら _t_ を +∞ とする；_q_ が *-∞*<sub>𝔽</sub> なら _t_ を 0；それ以外は _t_ を max(ℝ(_q_), 0) とする。
          1. もし _mode_ が ~sync~ かつ AgentCanSuspend() が *false* なら *TypeError* 例外を投げる。
          1. _block_ を _buffer_.[[ArrayBufferData]] とする。
          1. _offset_ を _typedArray_.[[ByteOffset]] とする。
          1. _byteIndexInBuffer_ を (_i_ × 4) + _offset_ とする。
          1. _WL_ を GetWaiterList(_block_, _byteIndexInBuffer_) とする。
          1. もし _mode_ が ~sync~ なら
            1. _promiseCapability_ を ~blocking~ とする。
            1. _resultObject_ を *undefined* とする。
          1. それ以外なら
            1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
            1. _resultObject_ を OrdinaryObjectCreate(%Object.prototype%) とする。
          1. EnterCriticalSection(_WL_) を実行する。
          1. _elementType_ を TypedArrayElementType(_typedArray_) とする。
          1. _w_ を GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~) とする。
          1. もし _v_ ≠ _w_ なら
            1. LeaveCriticalSection(_WL_) を実行する。
            1. もし _mode_ が ~sync~ なら *"not-equal"* を返す。
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*) を実行。
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"not-equal"*) を実行。
            1. _resultObject_ を返す。
          1. もし _t_ = 0 かつ _mode_ が ~async~ なら
            1. 注: 同期即時タイムアウトには特別扱いはない。非同期即時タイムアウトは失敗を速め、不要な Promise ジョブを避ける特別扱いを持つ。
            1. LeaveCriticalSection(_WL_) を実行する。
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*) を実行。
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"timed-out"*) を実行。
            1. _resultObject_ を返す。
          1. _thisAgent_ を AgentSignifier() とする。
          1. _now_ を現在時刻 (UTC) を示す time value とする。
          1. _additionalTimeout_ を実装定義の非負数学的値とする。
          1. _timeoutTime_ を ℝ(_now_) + _t_ + _additionalTimeout_ とする。
          1. 注: _t_ が +∞ のとき _timeoutTime_ も +∞。
          1. _waiterRecord_ を新たな Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *"ok"* } とする。
          1. AddWaiter(_WL_, _waiterRecord_) を実行する。
          1. もし _mode_ が ~sync~ なら
            1. SuspendThisAgent(_WL_, _waiterRecord_) を実行する。
          1. それ以外で _timeoutTime_ が有限なら
            1. EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_) を実行する。
          1. LeaveCriticalSection(_WL_) を実行する。
          1. もし _mode_ が ~sync~ なら _waiterRecord_.[[Result]] を返す。
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *true*) を実行。
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, _promiseCapability_.[[Promise]]) を実行。
          1. _resultObject_ を返す。
        </emu-alg>
        <emu-note>
          <p>_additionalTimeout_ は、電力消費削減やタイミング攻撃緩和のためのタイマー分解能粗化など、実装が必要に応じてタイムアウトにパディングを追加することを許容する。値は DoWait の呼び出しごとに異なり得る。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueatomicswaitasynctimeoutjob" type="abstract operation">
        <h1>
          EnqueueAtomicsWaitAsyncTimeoutJob (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _timeoutJob_ を、引数なしで _WL_ と _waiterRecord_ を捕捉し、呼び出されたとき以下を行う新たな Job Abstract Closure とする:
            1. EnterCriticalSection(_WL_) を実行する。
            1. もし _WL_.[[Waiters]] が _waiterRecord_ を含むなら
              1. _timeOfJobExecution_ を現在時刻 (UTC) を示す time value とする。
              1. 事前条件: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] （時間値の非単調性は無視）。
              1. _waiterRecord_.[[Result]] を *"timed-out"* に設定する。
              1. RemoveWaiter(_WL_, _waiterRecord_) を実行する。
              1. NotifyWaiter(_WL_, _waiterRecord_) を実行する。
            1. LeaveCriticalSection(_WL_) を実行する。
            1. ~unused~ を返す。
          1. _now_ を現在時刻 (UTC) を示す time value とする。
          1. _currentRealm_ を現在の Realm Record とする。
          1. HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomiccompareexchangeinsharedblock" type="abstract operation">
        <h1>
          AtomicCompareExchangeInSharedBlock (
            _block_: a Shared Data Block,
            _byteIndexInBuffer_: an integer,
            _elementSize_: a non-negative integer,
            _expectedBytes_: a List of byte values,
            _replacementBytes_: a List of byte values,
          ): byte 値の List
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _execution_ を周囲エージェントの Agent Record の [[CandidateExecution]] フィールドとする。
          1. _eventsRecord_ を _execution_.[[EventsRecords]] のうち [[AgentSignifier]] が AgentSignifier() の Agent Events Record とする。
          1. _rawBytesRead_ を長さ _elementSize_ の List とし、要素は非決定的に選ばれるバイト値とする。
          1. 注: 実装では _rawBytesRead_ は基盤ハードウェア上のロードリンク、ロード排他、または read-modify-write 命令のオペランドの結果である。この非決定性は弱い一貫性を持つハードウェアの観測可能な振る舞いを記述するための意味的規定。
          1. 注: 期待値と読み取った値の比較は read-modify-write 変更関数の外で行い、期待値不一致の場合に不必要な強い同期化を避ける。
          1. もし ByteListEqual(_rawBytesRead_, _expectedBytes_) が *true* なら
            1. _second_ を (_oldBytes_, _newBytes_) を引数に取り何も捕捉せず呼ばれるとアトミックに次を行う新たな read-modify-write 変更関数とし、_newBytes_ を返す。
            1. _event_ を ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ } とする。
          1. それ以外なら
            1. _event_ を ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ } とする。
          1. _event_ を _eventsRecord_.[[EventList]] に追加する。
          1. Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } を _execution_.[[ChosenValues]] に追加する。
          1. _rawBytesRead_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomicreadmodifywrite" type="abstract operation">
        <h1>
          AtomicReadModifyWrite (
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _op_: a read-modify-write modification function,
          ): 正常完了で Number または BigInt を含むか、または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_op_ は2つの byte 値 List を引数に取り、byte 値 List を返す。この操作は値をアトミックに読み込み、別の値と結合し、その結合を格納し、読み込んだ値を返す。</dd>
        </dl>
        <emu-alg>
          1. _byteIndexInBuffer_ を ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_) とする。
          1. もし _typedArray_.[[ContentType]] が ~bigint~ なら _v_ を ? ToBigInt(_value_) とする。
          1. それ以外は _v_ を 𝔽(? ToIntegerOrInfinity(_value_)) とする。
          1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) を実行する。
          1. _buffer_ を _typedArray_.[[ViewedArrayBuffer]] とする。
          1. _elementType_ を TypedArrayElementType(_typedArray_) とする。
          1. GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistbitwiseop" type="abstract operation">
        <h1>
          ByteListBitwiseOp (
            _op_: `&amp;`, `^`, または `|`,
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): byte 値の List
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>この操作は引数の全てのバイト値に対してビット単位演算をアトミックに行い、byte 値の List を返す。</dd>
        </dl>
        <emu-alg>
          1. 事前条件: _xBytes_ と _yBytes_ は同じ要素数を持つ。
          1. _result_ を新たな空 List とする。
          1. _i_ を 0 とする。
          1. 各要素 _xByte_ について
            1. _yByte_ を _yBytes_[_i_] とする。
            1. もし _op_ が `&amp;` なら
              1. _resultByte_ を _xByte_ と _yByte_ のビット単位 AND の結果とする。
            1. そうでなく _op_ が `^` なら
              1. _resultByte_ を _xByte_ と _yByte_ のビット単位 XOR の結果とする。
            1. それ以外
              1. 事前条件: _op_ は `|`。
              1. _resultByte_ を _xByte_ と _yByte_ のビット単位 OR の結果とする。
            1. _i_ を _i_ + 1 にする。
            1. _resultByte_ を _result_ に追加する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistequal" type="abstract operation">
        <h1>
          ByteListEqual (
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. もし _xBytes_ と _yBytes_ が同じ要素数でなければ *false* を返す。
          1. _i_ を 0 とする。
          1. 各要素 _xByte_ について
            1. _yByte_ を _yBytes_[_i_] とする。
            1. もし _xByte_ ≠ _yByte_ なら *false* を返す。
            1. _i_ を _i_ + 1 にする。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-atomics.add">
      <h1>Atomics.add ( _typedArray_, _index_, _value_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _add_ を (_xBytes_, _yBytes_) を引数に取り _typedArray_ を捕捉し、呼ばれるとアトミックに以下を行う新たな read-modify-write 変更関数とする:
          1. _type_ を TypedArrayElementType(_typedArray_) とする。
          1. _isLittleEndian_ を周囲エージェントの Agent Record の [[LittleEndian]] フィールドの値とする。
          1. _x_ を RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_) とする。
          1. _y_ を RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_) とする。
          1. もし _x_ が Number なら
            1. _sum_ を Number::add(_x_, _y_) とする。
          1. それ以外
            1. 事前条件: _x_ は BigInt。
            1. _sum_ を BigInt::add(_x_, _y_) とする。
          1. _sumBytes_ を NumericToRawBytes(_type_, _sum_, _isLittleEndian_) とする。
          1. 事前条件: _sumBytes_, _xBytes_, _yBytes_ は同じ要素数。
          1. _sumBytes_ を返す。
        1. ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.and">
      <h1>Atomics.and ( _typedArray_, _index_, _value_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _and_ を (_xBytes_, _yBytes_) を引数に取り何も捕捉せず、呼ばれるとアトミックに次を行う新たな read-modify-write 変更関数とし、ByteListBitwiseOp(`&amp;`, _xBytes_, _yBytes_) を返す。
        1. ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.compareexchange">
      <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _byteIndexInBuffer_ を ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_) とする。
        1. _buffer_ を _typedArray_.[[ViewedArrayBuffer]] とする。
        1. _block_ を _buffer_.[[ArrayBufferData]] とする。
        1. もし _typedArray_.[[ContentType]] が ~bigint~ なら
          1. _expected_ を ? ToBigInt(_expectedValue_) とする。
          1. _replacement_ を ? ToBigInt(_replacementValue_) とする。
        1. それ以外
          1. _expected_ を 𝔽(? ToIntegerOrInfinity(_expectedValue_)) とする。
          1. _replacement_ を 𝔽(? ToIntegerOrInfinity(_replacementValue_)) とする。
        1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) を実行する。
        1. _elementType_ を TypedArrayElementType(_typedArray_) とする。
        1. _elementSize_ を TypedArrayElementSize(_typedArray_) とする。
        1. _isLittleEndian_ を周囲エージェントの Agent Record の [[LittleEndian]] フィールド値とする。
        1. _expectedBytes_ を NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_) とする。
        1. _replacementBytes_ を NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_) とする。
        1. もし IsSharedArrayBuffer(_buffer_) が *true* なら
          1. _rawBytesRead_ を AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_) とする。
        1. それ以外
          1. _rawBytesRead_ を長さ _elementSize_ の List とし、_block_[_byteIndexInBuffer_] から始まる _elementSize_ バイト列とする。
          1. もし ByteListEqual(_rawBytesRead_, _expectedBytes_) が *true* なら
            1. _replacementBytes_ の各バイトを _block_ の _block_[_byteIndexInBuffer_] から書き込む。
        1. RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.exchange">
      <h1>Atomics.exchange ( _typedArray_, _index_, _value_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _second_ を (_oldBytes_, _newBytes_) を引数に取り何も捕捉せず、呼ばれるとアトミックに _newBytes_ を返す read-modify-write 変更関数とする。
        1. ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.islockfree">
      <h1>Atomics.isLockFree ( _size_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _n_ を ? ToIntegerOrInfinity(_size_) とする。
        1. _AR_ を周囲エージェントの Agent Record とする。
        1. もし _n_ = 1 なら _AR_.[[IsLockFree1]] を返す。
        1. もし _n_ = 2 なら _AR_.[[IsLockFree2]] を返す。
        1. もし _n_ = 4 なら *true* を返す。
        1. もし _n_ = 8 なら _AR_.[[IsLockFree8]] を返す。
        1. *false* を返す。
      </emu-alg>
      <emu-note>
        <p>この関数は最適化プリミティブである。直感的には、サイズ _n_ バイトのデータに対するアトミックプリミティブ（`compareExchange`, `load`, `store`, `add`, `sub`, `and`, `or`, `xor`, `exchange`）のアトミックステップが、そのデータ _n_ バイト外のロックを取得せずに実行されるなら `Atomics.isLockFree`(_n_) は *true* を返す。高性能アルゴリズムはこの関数を用いてクリティカルセクションでロックを使うかアトミック操作を使うかを決定する。アトミックプリミティブがロックフリーでない場合、アルゴリズムが独自のロックを提供する方がしばしば効率的である。</p>
        <p>`Atomics.isLockFree`(4) は常に *true* を返し、これは全ての関連ハードウェアでサポート可能である。これを前提できることでプログラムは一般に単純化する。</p>
        <p>この関数が返す値に関わらず、全てのアトミック操作はアトミックであることが保証される。例えば、操作の途中で可視な操作が発生（いわゆる「tearing」）することは決してない。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-atomics.load" oldids="sec-atomicload">
      <h1>Atomics.load ( _typedArray_, _index_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _byteIndexInBuffer_ を ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_) とする。
        1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) を実行する。
        1. _buffer_ を _typedArray_.[[ViewedArrayBuffer]] とする。
        1. _elementType_ を TypedArrayElementType(_typedArray_) とする。
        1. GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.or">
      <h1>Atomics.or ( _typedArray_, _index_, _value_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _or_ を (_xBytes_, _yBytes_) を引数に取り何も捕捉せず、呼ばれるとアトミックに ByteListBitwiseOp(`|`, _xBytes_, _yBytes_) を返す read-modify-write 変更関数とする。
        1. ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _byteIndexInBuffer_ を ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_) とする。
        1. もし _typedArray_.[[ContentType]] が ~bigint~ なら _v_ を ? ToBigInt(_value_) とする。
        1. それ以外は _v_ を 𝔽(? ToIntegerOrInfinity(_value_)) とする。
        1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) を実行する。
        1. _buffer_ を _typedArray_.[[ViewedArrayBuffer]] とする。
        1. _elementType_ を TypedArrayElementType(_typedArray_) とする。
        1. SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~) を実行する。
        1. _v_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.sub">
      <h1>Atomics.sub ( _typedArray_, _index_, _value_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _subtract_ を (_xBytes_, _yBytes_) を引数に取り _typedArray_ を捕捉し、呼ばれるとアトミックに以下を行う新たな read-modify-write 変更関数とする:
          1. _type_ を TypedArrayElementType(_typedArray_) とする。
          1. _isLittleEndian_ を周囲エージェントの Agent Record の [[LittleEndian]] フィールド値とする。
          1. _x_ を RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_) とする。
          1. _y_ を RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_) とする。
          1. もし _x_ が Number なら
            1. _difference_ を Number::subtract(_x_, _y_) とする。
          1. それ以外
            1. 事前条件: _x_ は BigInt。
            1. _difference_ を BigInt::subtract(_x_, _y_) とする。
          1. _differenceBytes_ を NumericToRawBytes(_type_, _difference_, _isLittleEndian_) とする。
          1. 事前条件: _differenceBytes_, _xBytes_, _yBytes_ は同じ要素数。
          1. _differenceBytes_ を返す。
        1. ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.wait">
      <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>この関数は周囲のエージェントを待機キューに入れ、通知またはタイムアウトまでサスペンドし、それらを区別する文字列を返す。</p>
      <p>呼び出されたとき次を行う:</p>
      <emu-alg>
        1. ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.waitasync">
      <h1>Atomics.waitAsync ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>この関数は、呼び出しエージェントが通知されるかタイムアウトに達したとき解決される Promise を返す。</p>
      <p>呼び出されたとき次を行う:</p>
      <emu-alg>
        1. ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.notify">
      <h1>Atomics.notify ( _typedArray_, _index_, _count_ )</h1>
      <p>この関数は待機キューでスリープしている一部のエージェントに通知する。</p>
      <p>呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _taRecord_ を ? ValidateIntegerTypedArray(_typedArray_, *true*) とする。
        1. _byteIndexInBuffer_ を ? ValidateAtomicAccess(_taRecord_, _index_) とする。
        1. もし _count_ が *undefined* なら
          1. _c_ を +∞ とする。
        1. それ以外
          1. _intCount_ を ? ToIntegerOrInfinity(_count_) とする。
          1. _c_ を max(_intCount_, 0) とする。
        1. _buffer_ を _typedArray_.[[ViewedArrayBuffer]] とする。
        1. _block_ を _buffer_.[[ArrayBufferData]] とする。
        1. もし IsSharedArrayBuffer(_buffer_) が *false* なら *+0*<sub>𝔽</sub> を返す。
        1. _WL_ を GetWaiterList(_block_, _byteIndexInBuffer_) とする。
        1. EnterCriticalSection(_WL_) を実行する。
        1. _S_ を RemoveWaiters(_WL_, _c_) とする。
        1. 各 _S_ の要素 _W_ について
          1. NotifyWaiter(_WL_, _W_) を実行する。
        1. LeaveCriticalSection(_WL_) を実行する。
        1. _n_ を _S_ の要素数とする。
        1. 𝔽(_n_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.xor">
      <h1>Atomics.xor ( _typedArray_, _index_, _value_ )</h1>
      <p>この関数は呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _xor_ を (_xBytes_, _yBytes_) を引数に取り何も捕捉せず、呼ばれるとアトミックに ByteListBitwiseOp(`^`, _xBytes_, _yBytes_) を返す read-modify-write 変更関数とする。
        1. ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-atomics-@@tostringtag" id="sec-atomics-%symbol.tostringtag%">
      <h1>Atomics [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"Atomics"* である。</p>
      <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-json-object">
    <h1>JSON オブジェクト</h1>
    <p>JSON オブジェクトは次の通りである:</p>
    <ul>
      <li><dfn>%JSON%</dfn> である。</li>
      <li>グローバルオブジェクトの *"JSON"* プロパティの初期値である。</li>
      <li>通常のオブジェクトである。</li>
      <li>`parse` と `stringify` の 2 つの関数を含み、JSON テキストの構文解析と構築に使用される。</li>
      <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      <li>[[Construct]] 内部メソッドを持たず、`new` 演算子でコンストラクタとして使用できない。</li>
      <li>[[Call]] 内部メソッドを持たず、関数として呼び出せない。</li>
    </ul>
    <p>JSON データ交換形式は ECMA-404 に定義される。本仕様で使用される JSON 交換形式は ECMA-404 に記述されるものと正確に同一である。`JSON.parse` および `JSON.stringify` の適合実装は ECMA-404 仕様に記述された交換形式を、削除や拡張なしにサポートしなければならない。</p>

    <emu-clause id="sec-json.parse">
      <h1>JSON.parse ( _text_ [ , _reviver_ ] )</h1>
      <p>この関数は JSON テキスト（JSON 形式の文字列）を構文解析し、ECMAScript 言語値を生成する。JSON 形式はリテラル、配列、オブジェクトを ECMAScript のリテラル、配列初期化子、オブジェクト初期化子に類似した構文で表現する。構文解析後、JSON オブジェクトは ECMAScript オブジェクトとして実体化され、JSON 配列は ECMAScript の Array インスタンスとして実体化される。JSON の文字列、数値、真偽値、および null はそれぞれ ECMAScript の String, Number, Boolean, *null* として実体化される。</p>
      <p>任意の _reviver_ パラメータは 2 つのパラメータ _key_, _value_ を取る関数であり、結果をフィルタおよび変換できる。構文解析で生成された各 _key_/_value_ ペアで呼び出され、その戻り値が元の値の代わりに使用される。受け取ったものをそのまま返した場合、構造は変更されない。*undefined* を返した場合、そのプロパティは結果から削除される。</p>
      <emu-alg>
        1. _jsonString_ を ? ToString(_text_) とする。
        1. _unfiltered_ を ? ParseJSON(_jsonString_) とする。
        1. もし IsCallable(_reviver_) が *true* なら
          1. _root_ を OrdinaryObjectCreate(%Object.prototype%) とする。
          1. _rootName_ を空文字列とする。
          1. ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_) を実行する。
          1. ? InternalizeJSONProperty(_root_, _rootName_, _reviver_) を返す。
        1. それ以外
          1. _unfiltered_ を返す。
      </emu-alg>
      <p>この関数の *"length"* プロパティは *2*<sub>𝔽</sub> である。</p>

      <emu-clause id="sec-ParseJSON" type="abstract operation">
        <h1>
          ParseJSON (
            _text_: a String,
          ): 正常完了で ECMAScript 言語値を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. [id="step-json-parse-validate"] もし StringToCodePoints(_text_) が ECMA-404 で規定された有効な JSON テキストでないなら *SyntaxError* 例外を投げる。
          1. _scriptString_ を *"("*, _text_, *");"* の文字列連結とする。
          1. [id="step-json-parse-parse"] _script_ を ParseText(_scriptString_, |Script|) とする。
          1. 注: <emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref> で定義される早期エラールールは上記 ParseText 呼び出しに特別な扱いを持つ。
          1. 事前条件: _script_ は Parse Node。
          1. [id="step-json-parse-eval"] _result_ を ! <emu-meta suppress-effects="user-code">_script_ の評価</emu-meta> とする。
          1. 注: <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> で定義される PropertyDefinitionEvaluation の意味論は ParseJSON 中特別な扱いを持つ。
          1. [id="step-json-parse-assert-type"] 事前条件: _result_ は String, Number, Boolean, |ArrayLiteral| か |ObjectLiteral| により定義される Object, または *null* のいずれかである。
          1. _result_ を返す。
        </emu-alg>
        <p>適合実装が `JSON.parse` の JSON 文法を拡張することは許されない。修正または拡張された JSON 交換形式をサポートしたい実装は別の parse 関数を定義しなければならない。</p>
        <emu-note>
          <p>有効な JSON テキストは ECMAScript |PrimaryExpression| 構文の部分集合である。ステップ <emu-xref href="#step-json-parse-validate"></emu-xref> は _jsonString_ がその部分集合に従うことを検証し、ステップ <emu-xref href="#step-json-parse-assert-type"></emu-xref> は評価が適切な型の値を返すことを保証する。</p>
          <p>しかし、<emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> が ParseJSON 中で異なる振る舞いをするため、同一のソーステキストを |PrimaryExpression| として評価した場合と JSON として評価した場合で異なる結果を生むことがある。さらにオブジェクトリテラル内の重複 *"__proto__"* プロパティの Early Error（ParseJSON 中は適用されない）により、文法に合致していても ParseJSON が受理するすべてのテキストが |PrimaryExpression| として有効とは限らない。</p>
        </emu-note>
        <emu-note>
          <p>オブジェクト内に重複する name String が存在する場合、字句的に先行する同一キーの値は上書きされる。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-internalizejsonproperty" type="abstract operation">
        <h1>
          InternalizeJSONProperty (
            _holder_: an Object,
            _name_: a String,
            _reviver_: a function object,
          ): 正常完了で ECMAScript 言語値を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>このアルゴリズムは [[Delete]] または CreateDataProperty が *false* を返しても例外を投げないことを意図している。</p>
        </emu-note>
        <p>呼び出されたとき次を行う:</p>
        <emu-alg>
          1. _val_ を ? Get(_holder_, _name_) とする。
          1. もし _val_ が Object なら
            1. _isArray_ を ? IsArray(_val_) とする。
            1. もし _isArray_ が *true* なら
              1. _len_ を ? LengthOfArrayLike(_val_) とする。
              1. _I_ を 0 とする。
              1. _I_ &lt; _len_ の間繰り返す:
                1. _prop_ を ! ToString(𝔽(_I_)) とする。
                1. _newElement_ を ? InternalizeJSONProperty(_val_, _prop_, _reviver_) とする。
                1. もし _newElement_ が *undefined* なら
                  1. ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_prop_) を実行。
                1. それ以外
                  1. ? CreateDataProperty(_val_, _prop_, _newElement_) を実行。
                1. _I_ を _I_ + 1 にする。
            1. それ以外
              1. _keys_ を ? EnumerableOwnProperties(_val_, ~key~) とする。
              1. 各 String _P_ について
                1. _newElement_ を ? InternalizeJSONProperty(_val_, _P_, _reviver_) とする。
                1. もし _newElement_ が *undefined* なら
                  1. ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_P_) を実行。
                1. それ以外
                  1. ? CreateDataProperty(_val_, _P_, _newElement_) を実行。
          1. ? Call(_reviver_, _holder_, « _name_, _val_ ») を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-json.stringify">
      <h1>JSON.stringify ( _value_ [ , _replacer_ [ , _space_ ] ] )</h1>
      <p>この関数は _value_ を UTF-16 エンコードされた JSON 形式の文字列か *undefined* で表現して返す。3 つのパラメータを取る。_value_ は通常オブジェクトまたは配列であるが、String, Boolean, Number, *null* も指定可能。任意の _replacer_ はオブジェクトや配列の文字列化方法を変更する関数、または文字列と数値の配列であり、文字列化に含めるプロパティを選択する包含リストとして振る舞う。任意の _space_ は String または Number で、人間可読性向上のため結果に空白を挿入できる。</p>
      <p>呼び出されたとき次を行う:</p>
      <emu-alg>
        1. _stack_ を新たな空 List とする。
        1. _indent_ を空文字列とする。
        1. _PropertyList_ を *undefined* とする。
        1. _ReplacerFunction_ を *undefined* とする。
        1. もし _replacer_ が Object なら
          1. もし IsCallable(_replacer_) が *true* なら
            1. _ReplacerFunction_ を _replacer_ に設定する。
          1. それ以外
            1. _isArray_ を ? IsArray(_replacer_) とする。
            1. もし _isArray_ が *true* なら
              1. _PropertyList_ を新たな空 List とする。
              1. _len_ を ? LengthOfArrayLike(_replacer_) とする。
              1. _k_ を 0 とする。
              1. _k_ &lt; _len_ の間繰り返す:
                1. _prop_ を ! ToString(𝔽(_k_)) とする。
                1. _v_ を ? Get(_replacer_, _prop_) とする。
                1. _item_ を *undefined* とする。
                1. もし _v_ が String なら
                  1. _item_ を _v_ とする。
                1. それ以外で _v_ が Number なら
                  1. _item_ を ! ToString(_v_) とする。
                1. それ以外で _v_ が Object なら
                  1. もし _v_ が [[StringData]] または [[NumberData]] 内部スロットを持つなら _item_ を ? ToString(_v_) とする。
                1. もし _item_ が *undefined* でなく かつ _PropertyList_ に含まれていなければ _item_ を _PropertyList_ に追加する。
                1. _k_ を _k_ + 1 にする。
        1. もし _space_ が Object なら
          1. もし _space_ が [[NumberData]] 内部スロットを持つなら
            1. _space_ を ? ToNumber(_space_) とする。
          1. それ以外で _space_ が [[StringData]] 内部スロットを持つなら
            1. _space_ を ? ToString(_space_) とする。
        1. もし _space_ が Number なら
          1. _spaceMV_ を ! ToIntegerOrInfinity(_space_) とする。
          1. _spaceMV_ を min(10, _spaceMV_) に設定する。
          1. もし _spaceMV_ &lt; 1 なら _gap_ を空文字列、それ以外はコード単位 0x0020 (SPACE) の _spaceMV_ 回繰り返しからなる文字列値とする。
        1. それ以外で _space_ が String なら
          1. もし _space_ の長さ ≤ 10 なら _gap_ を _space_ とし、そうでなければ _space_ の 0 から 10 までの部分文字列とする。
        1. それ以外
          1. _gap_ を空文字列とする。
        1. _wrapper_ を OrdinaryObjectCreate(%Object.prototype%) とする。
        1. ! CreateDataPropertyOrThrow(_wrapper_, 空文字列, _value_) を実行する。
        1. _state_ を JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ } とする。
        1. ? SerializeJSONProperty(_state_, 空文字列, _wrapper_) を返す。
      </emu-alg>
      <p>この関数の *"length"* プロパティは *3*<sub>𝔽</sub> である。</p>
      <emu-note>
        <p>JSON 構造は任意の深さにネスト可能であるが非循環でなければならない。_value_ が循環構造であるか含む場合、この関数は *TypeError* 例外を投げねばならない。以下は文字列化できない値の例:</p>
        <pre><code class="javascript">
          a = [];
          a[0] = a;
          my_text = JSON.stringify(a); // これは TypeError を投げなければならない。
        </code></pre>
      </emu-note>
      <emu-note>
        <p>シンボリックなプリミティブ値は以下のようにレンダリングされる:</p>
        <ul>
          <li>
            *null* 値は JSON テキストでは文字列値 *"null"* として表現される。
          </li>
          <li>
            *undefined* 値はレンダリングされない。
          </li>
          <li>
            *true* 値は JSON テキストでは文字列値 *"true"* として表現される。
          </li>
          <li>
            *false* 値は JSON テキストでは文字列値 *"false"* として表現される。
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>文字列値は QUOTATION MARK (`"`) コード単位で囲まれる。コード単位 `"` と `\\` は `\\` 接頭辞でエスケープされる。制御文字コード単位は `\\u`HHHH のエスケープシーケンス、または短い形式 `\\b` (BACKSPACE), `\\f` (FORM FEED), `\\n` (LINE FEED), `\\r` (CARRIAGE RETURN), `\\t` (CHARACTER TABULATION) に置換される。</p>
      </emu-note>
      <emu-note>
        <p>有限の数値は ToString(_number_) 呼び出しと同様に文字列化される。*NaN* と符号に関わらず *Infinity* は文字列値 *"null"* として表現される。</p>
      </emu-note>
      <emu-note>
        <p>JSON 表現を持たない値（*undefined* や関数など）は文字列を生成しない。代わりに *undefined* を生成する。配列ではこれらの値は文字列値 *"null"* として表現され、オブジェクトでは表現不能な値はそのプロパティが文字列化から除外される。</p>
      </emu-note>
      <emu-note>
        <p>オブジェクトは U+007B (LEFT CURLY BRACKET) で開始し、0 個以上のプロパティを U+002C (COMMA) で区切り、U+007D (RIGHT CURLY BRACKET) で閉じる。プロパティはプロパティ名を表す引用符付き String、U+003A (COLON)、およびその文字列化された値で構成される。配列は U+005B (LEFT SQUARE BRACKET) で開始し、0 個以上の値を U+002C (COMMA) で区切り、U+005D (RIGHT SQUARE BRACKET) で閉じる。</p>
      </emu-note>

      <emu-clause id="sec-json-serialization-record">
        <h1>JSON Serialization Record</h1>
        <p><dfn variants="JSON Serialization Records">JSON Serialization Record</dfn> は JSON 形式へのシリアライズを可能にするために用いられる Record 値である。</p>
        <p>JSON Serialization Record は <emu-xref href="#table-json-serialization-record"></emu-xref> に挙げるフィールドを持つ。</p>
        <emu-table id="table-json-serialization-record" caption="JSON Serialization Record のフィールド">
          <table>
            <thead>
              <tr>
                <th>フィールド名</th>
                <th>値</th>
                <th>意味</th>
              </tr>
            </thead>
            <tr>
              <td>[[ReplacerFunction]]</td>
              <td>関数オブジェクトまたは *undefined*</td>
              <td>オブジェクトプロパティに代替値を提供できる関数（JSON.stringify の _replacer_ パラメータ）。</td>
            </tr>
            <tr>
              <td>[[PropertyList]]</td>
              <td>String の List または *undefined*</td>
              <td>非配列オブジェクトをシリアライズする際に含めるプロパティ名（JSON.stringify の _replacer_ パラメータ）。</td>
            </tr>
            <tr>
              <td>[[Gap]]</td>
              <td>String</td>
              <td>インデント単位（JSON.stringify の _space_ パラメータ）。</td>
            </tr>
            <tr>
              <td>[[Stack]]</td>
              <td>Object の List</td>
              <td>シリアライズ処理中の入れ子オブジェクト集合。循環構造検出に使用。</td>
            </tr>
            <tr>
              <td>[[Indent]]</td>
              <td>String</td>
              <td>現在のインデント。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-serializejsonproperty" type="abstract operation">
        <h1>
          SerializeJSONProperty (
            _state_: a JSON Serialization Record,
            _key_: a String,
            _holder_: an Object,
          ): 正常完了で String または *undefined* を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _value_ を ? Get(_holder_, _key_) とする。
          1. もし _value_ が Object かまたは _value_ が BigInt なら
            1. _toJSON_ を ? GetV(_value_, *"toJSON"*) とする。
            1. もし IsCallable(_toJSON_) が *true* なら
              1. _value_ を ? Call(_toJSON_, _value_, « _key_ ») とする。
          1. もし _state_.[[ReplacerFunction]] が *undefined* でなければ
            1. _value_ を ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ ») とする。
          1. もし _value_ が Object なら
            1. もし _value_ が [[NumberData]] 内部スロットを持つなら
              1. _value_ を ? ToNumber(_value_) とする。
            1. それ以外で [[StringData]] 内部スロットを持つなら
              1. _value_ を ? ToString(_value_) とする。
            1. それ以外で [[BooleanData]] 内部スロットを持つなら
              1. _value_ を _value_.[[BooleanData]] とする。
            1. それ以外で [[BigIntData]] 内部スロットを持つなら
              1. _value_ を _value_.[[BigIntData]] とする。
          1. もし _value_ が *null* なら *"null"* を返す。
          1. もし _value_ が *true* なら *"true"* を返す。
          1. もし _value_ が *false* なら *"false"* を返す。
          1. もし _value_ が String なら QuoteJSONString(_value_) を返す。
          1. もし _value_ が Number なら
            1. もし _value_ が有限なら ! ToString(_value_) を返す。
            1. *"null"* を返す。
          1. もし _value_ が BigInt なら *TypeError* 例外を投げる。
          1. もし _value_ が Object かつ IsCallable(_value_) が *false* なら
            1. _isArray_ を ? IsArray(_value_) とする。
            1. もし _isArray_ が *true* なら ? SerializeJSONArray(_state_, _value_) を返す。
            1. ? SerializeJSONObject(_state_, _value_) を返す。
          1. *undefined* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-quotejsonstring" type="abstract operation">
        <h1>
          QuoteJSONString (
            _value_: a String,
          ): String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_value_ を 0x0022 (QUOTATION MARK) コード単位で囲み、その内部の特定コード単位をエスケープする。この操作は <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> に記述される通り UTF-16 エンコードされたコードポイント列として _value_ を解釈する。</dd>
        </dl>
        <emu-alg>
          1. _product_ をコード単位 0x0022 (QUOTATION MARK) だけからなる文字列値とする。
          1. StringToCodePoints(_value_) の各コードポイント _C_ について
            1. もし _C_ が <emu-xref href="#table-json-single-character-escapes"></emu-xref> の “Code Point” 列に記載されているなら
              1. _product_ を _product_ と対応行の “Escape Sequence” 列のエスケープシーケンスの文字列連結とする。
            1. それ以外で _C_ の数値が 0x0020 (SPACE) 未満か、_C_ が前方サロゲートまたは後方サロゲートと同じ数値なら
              1. _unit_ を _C_ の数値と同じ数値を持つコード単位とする。
              1. _product_ を _product_ と UnicodeEscape(_unit_) の文字列連結とする。
            1. それ以外
              1. _product_ を _product_ と UTF16EncodeCodePoint(_C_) の文字列連結とする。
          1. _product_ を _product_ とコード単位 0x0022 (QUOTATION MARK) の文字列連結とする。
          1. _product_ を返す。
        </emu-alg>
        <emu-table id="table-json-single-character-escapes" caption="JSON 単一文字エスケープシーケンス">
          <table>
            <thead>
              <tr>
                <th>
                  Code Point
                </th>
                <th>
                  Unicode Character Name
                </th>
                <th>
                  Escape Sequence
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                U+0008
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                `\\b`
              </td>
            </tr>
            <tr>
              <td>
                U+0009
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                `\\t`
              </td>
            </tr>
            <tr>
              <td>
                U+000A
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                `\\n`
              </td>
            </tr>
            <tr>
              <td>
                U+000C
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                `\\f`
              </td>
            </tr>
            <tr>
              <td>
                U+000D
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                `\\r`
              </td>
            </tr>
            <tr>
              <td>
                U+0022
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `\\"`
              </td>
            </tr>
            <tr>
              <td>
                U+005C
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\\\`
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-unicodeescape" type="abstract operation">
        <h1>
          UnicodeEscape (
            _C_: a code unit,
          ): String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_C_ を Unicode エスケープシーケンスとして表現する。</dd>
        </dl>
        <emu-alg>
          1. _n_ を _C_ の数値とする。
          1. 事前条件: _n_ ≤ 0xFFFF.
          1. _hex_ を _n_ の小文字 16 進数形式の文字列表現とする。
          1. コード単位 0x005C (REVERSE SOLIDUS), *"u"*, および StringPad(_hex_, 4, *"0"*, ~start~) の文字列連結を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonobject" type="abstract operation">
        <h1>
          SerializeJSONObject (
            _state_: a JSON Serialization Record,
            _value_: an Object,
          ): 正常完了で String を含むか、または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>オブジェクトをシリアライズする。</dd>
        </dl>
        <emu-alg>
          1. もし _state_.[[Stack]] が _value_ を含むなら構造が循環しているので *TypeError* 例外を投げる。
          1. _value_ を _state_.[[Stack]] に追加する。
          1. _stepBack_ を _state_.[[Indent]] とする。
          1. _state_.[[Indent]] を _state_.[[Indent]] と _state_.[[Gap]] の文字列連結とする。
          1. もし _state_.[[PropertyList]] が *undefined* でなければ
            1. _K_ を _state_.[[PropertyList]] とする。
          1. それ以外
            1. _K_ を ? EnumerableOwnProperties(_value_, ~key~) とする。
          1. _partial_ を新たな空 List とする。
          1. 各 _K_ の要素 _P_ について
            1. _strP_ を ? SerializeJSONProperty(_state_, _P_, _value_) とする。
            1. もし _strP_ が *undefined* でなければ
              1. _member_ を QuoteJSONString(_P_) とする。
              1. _member_ を _member_ と *":"* の文字列連結とする。
              1. もし _state_.[[Gap]] が空文字列でなければ
                1. _member_ を _member_ とコード単位 0x0020 (SPACE) の文字列連結とする。
              1. _member_ を _member_ と _strP_ の文字列連結とする。
              1. _member_ を _partial_ に追加する。
          1. もし _partial_ が空なら
            1. _final_ を *"{}"* とする。
          1. それ以外
            1. もし _state_.[[Gap]] が空文字列なら
              1. _properties_ を _partial_ の全要素文字列をコード単位 0x002C (COMMA) で区切って連結した String 値とし（先頭や末尾には挿入しない）、_final_ を *"{"*, _properties_, *"}"* の文字列連結とする。
            1. それ以外
              1. _separator_ を コード単位 0x002C (COMMA), 0x000A (LINE FEED), _state_.[[Indent]] の文字列連結とする。
              1. _properties_ を _partial_ の全要素文字列を _separator_ で区切って連結した String 値とし（先頭/末尾には挿入しない）、_final_ を *"{"*, コード単位 0x000A (LINE FEED), _state_.[[Indent]], _properties_, コード単位 0x000A (LINE FEED), _stepBack_, *"}"* の文字列連結とする。
          1. _state_.[[Stack]] の最後の要素を除去する。
          1. _state_.[[Indent]] を _stepBack_ に設定する。
          1. _final_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonarray" type="abstract operation">
        <h1>
          SerializeJSONArray (
            _state_: a JSON Serialization Record,
            _value_: an ECMAScript language value,
          ): 正常完了で String を含むか、または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>配列をシリアライズする。</dd>
        </dl>
        <emu-alg>
          1. もし _state_.[[Stack]] が _value_ を含むなら構造が循環しているので *TypeError* 例外を投げる。
          1. _value_ を _state_.[[Stack]] に追加する。
          1. _stepBack_ を _state_.[[Indent]] とする。
          1. _state_.[[Indent]] を _state_.[[Indent]] と _state_.[[Gap]] の文字列連結とする。
          1. _partial_ を新たな空 List とする。
          1. _len_ を ? LengthOfArrayLike(_value_) とする。
          1. _index_ を 0 とする。
          1. _index_ &lt; _len_ の間繰り返す:
            1. _strP_ を ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_) とする。
            1. もし _strP_ が *undefined* なら
              1. *"null"* を _partial_ に追加する。
            1. それ以外
              1. _strP_ を _partial_ に追加する。
            1. _index_ を _index_ + 1 にする。
          1. もし _partial_ が空なら
            1. _final_ を *"[]"* とする。
          1. それ以外
            1. もし _state_.[[Gap]] が空文字列なら
              1. _properties_ を _partial_ の全要素文字列をコード単位 0x002C (COMMA) で区切って連結した String 値とする。
              1. _final_ を *"["*, _properties_, *"]"* の文字列連結とする。
            1. それ以外
              1. _separator_ を コード単位 0x002C (COMMA), コード単位 0x000A (LINE FEED), _state_.[[Indent]] の文字列連結とする。
              1. _properties_ を _partial_ の全要素文字列を _separator_ で区切って連結した String 値とする。
              1. _final_ を *"["*, コード単位 0x000A (LINE FEED), _state_.[[Indent]], _properties_, コード単位 0x000A (LINE FEED), _stepBack_, *"]"* の文字列連結とする。
          1. _state_.[[Stack]] の最後の要素を除去する。
          1. _state_.[[Indent]] を _stepBack_ に設定する。
          1. _final_ を返す。
        </emu-alg>
        <emu-note>
          <p>配列の表現には *+0*<sub>𝔽</sub>（含む）から `array.length`（含まない）までの要素のみが含まれる。配列インデックスでないキーのプロパティは文字列化から除外される。配列は左角括弧、要素を COMMA で区切り、右角括弧で表現される。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-json-@@tostringtag" id="sec-json-%symbol.tostringtag%">
      <h1>JSON [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"JSON"* である。</p>
      <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>メモリの管理</h1>

  <emu-clause id="sec-weak-ref-objects">
    <h1>WeakRef オブジェクト</h1>
    <p>WeakRef は、ターゲットとなるオブジェクトまたはシンボルをガベージコレクションから保護せずに参照するためのオブジェクトである。ターゲットがまだガベージコレクションに回収されていない場合、WeakRef は逆参照してターゲット値へアクセスできる。</p>

    <emu-clause id="sec-weak-ref-constructor">
      <h1>WeakRef コンストラクタ</h1>
      <p><dfn variants="WeakRefs">WeakRef</dfn> コンストラクタは次の通り:</p>
      <ul>
        <li><dfn>%WeakRef%</dfn> である。</li>
        <li>
          グローバルオブジェクトの *"WeakRef"* プロパティの初期値である。
        </li>
        <li>
          コンストラクタとして呼び出されたとき新しい WeakRef を生成し初期化する。
        </li>
        <li>
          関数として呼び出されることを意図しておらず、そのように呼び出された場合は例外を投げる。
        </li>
        <li>
          クラス定義の `extends` 句における値として使用できる。指定された `WeakRef` の挙動を継承することを意図するサブクラスのコンストラクタは、`WeakRef.prototype` 組み込みメソッドをサポートするために必要な内部状態でサブクラスインスタンスを生成・初期化するため、`WeakRef` コンストラクタへの `super` 呼び出しを含めなければならない。
        </li>
      </ul>

      <emu-clause id="sec-weak-ref-target">
        <h1>WeakRef ( _target_ )</h1>
        <p>この関数は呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. もし NewTarget が *undefined* なら *TypeError* 例外を投げる。
          1. もし CanBeHeldWeakly(_target_) が *false* なら *TypeError* 例外を投げる。
          1. _weakRef_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakRef.prototype%"*, « [[WeakRefTarget]] ») とする。
          1. AddToKeptObjects(_target_) を実行する。
          1. _weakRef_.[[WeakRefTarget]] に _target_ を設定する。
          1. _weakRef_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-constructor">
      <h1>WeakRef コンストラクタのプロパティ</h1>
      <p>WeakRef コンストラクタは次の通り:</p>
      <ul>
        <li>
          その [[Prototype]] 内部スロットの値は %Function.prototype% である。
        </li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype">
        <h1>WeakRef.prototype</h1>
        <p>`WeakRef.prototype` の初期値は WeakRef プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-prototype-object">
      <h1>WeakRef プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>WeakRef プロトタイプオブジェクト</dfn> は次の通り:</p>
      <ul>
        <li><dfn>%WeakRef.prototype%</dfn> である。</li>
        <li>
          その [[Prototype]] 内部スロットの値は %Object.prototype% である。
        </li>
        <li>通常のオブジェクトである。</li>
        <li>[[WeakRefTarget]] 内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype.constructor" normative-optional>
        <h1>WeakRef.prototype.constructor</h1>

        <p>`WeakRef.prototype.constructor` の初期値は %WeakRef% である。</p>
      </emu-clause>

      <emu-clause id="sec-weak-ref.prototype.deref">
        <h1>WeakRef.prototype.deref ( )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _weakRef_ を *this* 値とする。
          1. ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]) を実行する。
          1. WeakRefDeref(_weakRef_) を返す。
        </emu-alg>

        <emu-note>
          <p>WeakRef が *undefined* でない _target_ 値を返す場合、その _target_ 値は現在の ECMAScript コードの実行が完了するまでガベージコレクションされないべきである。AddToKeptObjects 操作は読み取りの一貫性が維持されることを保証する。</p>

          <pre><code class="javascript">
            let target = { foo() {} };
            let weakRef = new WeakRef(target);

            // ... あとで ...

            if (weakRef.deref()) {
              weakRef.deref().foo();
            }
          </code></pre>

          <p>上の例では、最初の deref が *undefined* で評価されないなら、2 回目の deref も *undefined* にはなり得ない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-weak-ref.prototype-@@tostringtag" id="sec-weak-ref.prototype-%symbol.tostringtag%">
        <h1>WeakRef.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"WeakRef"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-weakref-abstract-operations">
      <h1>WeakRef 抽象操作</h1>

      <emu-clause id="sec-weakrefderef" type="abstract operation">
        <h1>
          WeakRefDeref (
            _weakRef_: a WeakRef,
          ): ECMAScript 言語値
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _target_ を _weakRef_.[[WeakRefTarget]] とする。
          1. もし _target_ が ~empty~ でないなら
            1. AddToKeptObjects(_target_) を実行する。
            1. _target_ を返す。
          1. *undefined* を返す。
        </emu-alg>
        <emu-note>
          <p>この抽象操作は、WeakRef.prototype.deref と切り離して定義されており、ライブネスを簡潔に定義できるようにしている。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weak-ref-instances">
      <h1>WeakRef インスタンスのプロパティ</h1>
      <p>WeakRef インスタンスは WeakRef プロトタイプオブジェクトからプロパティを継承する通常のオブジェクトである。WeakRef インスタンスはさらに [[WeakRefTarget]] 内部スロットを持つ。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry オブジェクト</h1>
    <p>FinalizationRegistry は、ターゲットオブジェクトおよびシンボルがガベージコレクションされた際に実行されるクリーンアップ操作の登録および登録解除を管理するオブジェクトである。</p>

    <emu-clause id="sec-finalization-registry-constructor">
      <h1>FinalizationRegistry コンストラクタ</h1>
      <p><dfn variants="FinalizationRegistrys">FinalizationRegistry</dfn> コンストラクタは次の通り:</p>
      <ul>
        <li><dfn>%FinalizationRegistry%</dfn> である。</li>
        <li>
          グローバルオブジェクトの *"FinalizationRegistry"* プロパティの初期値である。
        </li>
        <li>
          コンストラクタとして呼び出されたとき新しい FinalizationRegistry を生成し初期化する。
        </li>
        <li>
          関数として呼び出されることを意図しておらず、そのように呼び出された場合は例外を投げる。
        </li>
        <li>
          クラス定義の `extends` 句における値として使用できる。指定された `FinalizationRegistry` の挙動を継承することを意図するサブクラスのコンストラクタは、`FinalizationRegistry.prototype` 組み込みメソッドをサポートするために必要な内部状態でサブクラスインスタンスを生成・初期化するため、`FinalizationRegistry` コンストラクタへの `super` 呼び出しを含めなければならない。
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry-cleanup-callback">
        <h1>FinalizationRegistry ( _cleanupCallback_ )</h1>
        <p>この関数は呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. もし NewTarget が *undefined* なら *TypeError* 例外を投げる。
          1. もし IsCallable(_cleanupCallback_) が *false* なら *TypeError* 例外を投げる。
          1. _finalizationRegistry_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%FinalizationRegistry.prototype%"*, « [[Realm]], [[CleanupCallback]], [[Cells]] ») とする。
          1. _fn_ をアクティブな関数オブジェクトとする。
          1. _finalizationRegistry_.[[Realm]] に _fn_.[[Realm]] を設定する。
          1. _finalizationRegistry_.[[CleanupCallback]] に HostMakeJobCallback(_cleanupCallback_) を設定する。
          1. _finalizationRegistry_.[[Cells]] に新しい空の List を設定する。
          1. _finalizationRegistry_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-constructor">
      <h1>FinalizationRegistry コンストラクタのプロパティ</h1>
      <p>FinalizationRegistry コンストラクタは次の通り:</p>
      <ul>
        <li>
          その [[Prototype]] 内部スロットの値は %Function.prototype% である。
        </li>
        <li>以下のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype">
        <h1>FinalizationRegistry.prototype</h1>
        <p>`FinalizationRegistry.prototype` の初期値は FinalizationRegistry プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-prototype-object">
      <h1>FinalizationRegistry プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>FinalizationRegistry プロトタイプオブジェクト</dfn> は次の通り:</p>
      <ul>
        <li><dfn>%FinalizationRegistry.prototype%</dfn> である。</li>
        <li>
          その [[Prototype]] 内部スロットの値は %Object.prototype% である。
        </li>
        <li>通常のオブジェクトである。</li>
        <li>
          [[Cells]] および [[CleanupCallback]] 内部スロットを持たない。
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype.constructor">
        <h1>FinalizationRegistry.prototype.constructor</h1>
        <p>`FinalizationRegistry.prototype.constructor` の初期値は %FinalizationRegistry% である。</p>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.register">
        <h1>FinalizationRegistry.prototype.register ( _target_, _heldValue_ [ , _unregisterToken_ ] )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _finalizationRegistry_ を *this* 値とする。
          1. ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]) を実行する。
          1. もし CanBeHeldWeakly(_target_) が *false* なら *TypeError* 例外を投げる。
          1. もし SameValue(_target_, _heldValue_) が *true* なら *TypeError* 例外を投げる。
          1. もし CanBeHeldWeakly(_unregisterToken_) が *false* なら
            1. もし _unregisterToken_ が *undefined* でないなら *TypeError* 例外を投げる。
            1. _unregisterToken_ を ~empty~ に設定する。
          1. _cell_ を Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ } とする。
          1. _cell_ を _finalizationRegistry_.[[Cells]] に追加する。
          1. *undefined* を返す。
        </emu-alg>

        <emu-note>
          <p>本仕様のアルゴリズムと定義に基づくと、_finalizationRegistry_.[[Cells]] が _cell_ を含む間、_cell_.[[HeldValue]] はライブである。しかしこれは必ずしも _cell_.[[UnregisterToken]] や _cell_.[[Target]] がライブであることを意味しない。例えば、あるオブジェクトをその自身を unregister token として登録しても、そのオブジェクトを永遠に生存させるわけではない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.unregister">
        <h1>FinalizationRegistry.prototype.unregister ( _unregisterToken_ )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _finalizationRegistry_ を *this* 値とする。
          1. ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]) を実行する。
          1. もし CanBeHeldWeakly(_unregisterToken_) が *false* なら *TypeError* 例外を投げる。
          1. _removed_ を *false* とする。
          1. _finalizationRegistry_.[[Cells]] の各 Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } である _cell_ について
            1. もし _cell_.[[UnregisterToken]] が ~empty~ でなく、かつ SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) が *true* なら
              1. _cell_ を _finalizationRegistry_.[[Cells]] から除去する。
              1. _removed_ を *true* に設定する。
          1. _removed_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-finalization-registry.prototype-@@tostringtag" id="sec-finalization-registry.prototype-%symbol.tostringtag%">
        <h1>FinalizationRegistry.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"FinalizationRegistry"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-finalization-registry-instances">
      <h1>FinalizationRegistry インスタンスのプロパティ</h1>
      <p>FinalizationRegistry インスタンスは FinalizationRegistry プロトタイプオブジェクトからプロパティを継承する通常のオブジェクトである。FinalizationRegistry インスタンスはさらに [[Cells]] および [[CleanupCallback]] 内部スロットを持つ。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>制御抽象オブジェクト (Control Abstraction Objects)</h1>

  <emu-clause id="sec-iteration">
    <h1>反復 (Iteration)</h1>

    <emu-clause id="sec-common-iteration-interfaces">
      <h1>共通の反復インタフェース (Common Iteration Interfaces)</h1>
      <p>インタフェースとは、対応する値が特定の仕様に適合するプロパティキーの集合である。インタフェースの仕様で記述されたすべてのプロパティを提供する任意のオブジェクトは、そのインタフェースに<em>適合</em>する。インタフェースは別個のオブジェクトとして表現されない。そのインタフェースに適合する、個別に実装された多数のオブジェクトが存在し得る。個々のオブジェクトは複数のインタフェースに適合し得る。</p>

      <emu-clause id="sec-iterable-interface">
        <h1>Iterable インタフェース (The Iterable Interface)</h1>
        <p><dfn variants="iterable,iterables,iterable object,iterable objects">iterable インタフェース</dfn> は <emu-xref href="#table-iterable-interface-required-properties"></emu-xref> に記述されるプロパティを含む:</p>
        <emu-table id="table-iterable-interface-required-properties" caption="Iterable インタフェース 必須プロパティ (Iterable Interface Required Properties)" oldids="table-52">
          <table>
            <thead>
              <tr>
                <th>
                  プロパティ (Property)
                </th>
                <th>
                  値 (Value)
                </th>
                <th>
                  要件 (Requirements)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `%Symbol.iterator%`
              </td>
              <td>
                イテレータオブジェクトを返す関数 (a function that returns an iterator object)
              </td>
              <td>
                返されるオブジェクトは iterator インタフェースに適合しなければならない (The returned object must conform to the iterator interface).
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-iterator-interface">
        <h1>Iterator インタフェース (The Iterator Interface)</h1>
        <p><dfn variants="iterator object,iterator objects,iterator,iterators">iterator インタフェース</dfn> を実装するオブジェクトは <emu-xref href="#table-iterator-interface-required-properties"></emu-xref> のプロパティを含まなければならない。そのようなオブジェクトは <emu-xref href="#table-iterator-interface-optional-properties"></emu-xref> のプロパティを実装してもよい。</p>
        <emu-table id="table-iterator-interface-required-properties" caption="Iterator インタフェース 必須プロパティ (Iterator Interface Required Properties)" oldids="table-53">
          <table>
            <thead>
              <tr>
                <th>
                  プロパティ (Property)
                </th>
                <th>
                  値 (Value)
                </th>
                <th>
                  要件 (Requirements)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"next"*
              </td>
              <td>
                IteratorResult オブジェクトを返す関数 (a function that returns an IteratorResult object)
              </td>
              <td>
                返されるオブジェクトは IteratorResult インタフェースに適合しなければならない。あるイテレータの `next` メソッドへの以前の呼び出しが *"done"* プロパティが *true* の IteratorResult オブジェクトを返した場合、そのオブジェクトへの以後のすべての `next` 呼び出しも *"done"* プロパティが *true* の IteratorResult オブジェクトを返すべきである。ただしこの要件は強制されない。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>`next` 関数に引数を渡すことができるが、その解釈と妥当性は対象イテレータに依存する。for-of 文および他の一般的なイテレータ利用者は引数を渡さないため、そのように利用されることを想定するイテレータオブジェクトは引数なしで呼ばれる状況に対処できなければならない。</p>
        </emu-note>
        <emu-table id="table-iterator-interface-optional-properties" caption="Iterator インタフェース 任意プロパティ (Iterator Interface Optional Properties)" oldids="table-54">
          <table>
            <thead>
              <tr>
                <th>
                  プロパティ (Property)
                </th>
                <th>
                  値 (Value)
                </th>
                <th>
                  要件 (Requirements)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"return"*
              </td>
              <td>
                IteratorResult オブジェクトを返す関数 (a function that returns an IteratorResult object)
              </td>
              <td>
                返されるオブジェクトは IteratorResult インタフェースに適合しなければならない。このメソッドの呼び出しは、呼び出し側がこれ以上そのイテレータの `next` メソッドを呼び出す意図がないことをイテレータオブジェクトへ通知する。返される IteratorResult オブジェクトは典型的に *"done"* プロパティが *true* の値を持ち、`return` メソッドの引数として渡された値を持つ *"value"* プロパティを持つ。しかしこの要件は強制されない。
              </td>
            </tr>
            <tr>
              <td>
                *"throw"*
              </td>
              <td>
                IteratorResult オブジェクトを返す関数 (a function that returns an IteratorResult object)
              </td>
              <td>
                返されるオブジェクトは IteratorResult インタフェースに適合しなければならない。このメソッドの呼び出しは、呼び出し側がエラー状態を検出したことをイテレータオブジェクトに通知する。引数はエラー状態を識別するために用いることができ、典型的には例外オブジェクトである。典型的な応答はその引数値を `throw` することである。メソッドが `throw` しない場合、返される IteratorResult オブジェクトは通常 *"done"* プロパティが *true* の値を持つ。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>通常これらのメソッドの呼び出し側は、呼び出す前に存在確認を行うべきである。`for`-`of`、`yield*`、配列の分割代入などの特定の ECMAScript 言語機能は存在確認後にこれらを呼び出す。引数として iterable オブジェクトを受け取る多くの ECMAScript ライブラリ関数も条件付きでそれらを呼び出す。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-asynciterable-interface">
        <h1>Async Iterable インタフェース (The Async Iterable Interface)</h1>
        <p><dfn variants="async iterable,async iterables,async iterable object,async iterable objects">async iterable インタフェース</dfn> は <emu-xref href="#table-async-iterable"></emu-xref> に記述されるプロパティを含む:</p>
        <emu-table id="table-async-iterable" caption="Async Iterable インタフェース 必須プロパティ (Async Iterable Interface Required Properties)">
          <table>
            <thead>
              <tr>
                <th>プロパティ (Property)</th>
                <th>値 (Value)</th>
                <th>要件 (Requirements)</th>
              </tr>
            </thead>
            <tr>
              <td>`%Symbol.asyncIterator%`</td>
              <td>非同期イテレータオブジェクトを返す関数 (a function that returns an async iterator object)</td>
              <td>返されるオブジェクトは async iterator インタフェースに適合しなければならない (The returned object must conform to the async iterator interface).</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asynciterator-interface">
        <h1>Async Iterator インタフェース (The Async Iterator Interface)</h1>
        <p><dfn variants="async iterator object,async iterator objects,async iterator,async iterators">async iterator インタフェース</dfn> を実装するオブジェクトは <emu-xref href="#table-async-iterator-required"></emu-xref> のプロパティを含まなければならない。そのようなオブジェクトは <emu-xref href="#table-async-iterator-optional"></emu-xref> のプロパティを実装してもよい。</p>
        <emu-table id="table-async-iterator-required" caption="Async Iterator インタフェース 必須プロパティ (Async Iterator Interface Required Properties)">
          <table>
            <thead>
              <tr>
                <th>プロパティ (Property)</th>
                <th>値 (Value)</th>
                <th>要件 (Requirements)</th>
              </tr>
            </thead>
            <tr>
              <td>*"next"*</td>
              <td>IteratorResult オブジェクトの promise を返す関数 (a function that returns a promise for an IteratorResult object)</td>
              <td>
                <p>返される promise は、履行時に IteratorResult インタフェースに適合するオブジェクトで履行されなければならない。ある async イテレータの `next` メソッドへの以前の呼び出しが *"done"* プロパティが *true* の IteratorResult オブジェクトの promise を返した場合、そのオブジェクトへの以後のすべての `next` 呼び出しも *"done"* プロパティが *true* の IteratorResult オブジェクトの promise を返すべきである。ただしこの要件は強制されない。</p>

                <p>さらに、履行値となる IteratorResult オブジェクトの *"value"* プロパティの値は promise（または「thenable」）でないべきである。これも強制されない。</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>`next` 関数には引数を渡せるが、その解釈と妥当性は対象となる async イテレータに依存する。`for`-`await`-`of` 文および他の一般的な async イテレータ利用者は引数を渡さないため、そのような利用を想定する async イテレータオブジェクトは引数なし呼び出しに備える必要がある。</p>
        </emu-note>
        <emu-table id="table-async-iterator-optional" caption="Async Iterator インタフェース 任意プロパティ (Async Iterator Interface Optional Properties)">
          <table>
            <thead>
              <tr>
                <th>プロパティ (Property)</th>
                <th>値 (Value)</th>
                <th>要件 (Requirements)</th>
              </tr>
            </thead>
            <tr>
              <td>*"return"*</td>
              <td>IteratorResult オブジェクトの promise を返す関数 (a function that returns a promise for an IteratorResult object)</td>
              <td>
                <p>返される promise は履行時に IteratorResult インタフェースに適合するオブジェクトで履行されなければならない。このメソッドの呼び出しは、呼び出し側がその async イテレータの `next` メソッドをこれ以上呼び出す意図がないことを通知する。返される promise は典型的に *"done"* プロパティが *true* の IteratorResult オブジェクトで履行され、かつ `return` メソッドに渡された引数の値を持つ *"value"* プロパティを持つ。ただしこの要件は強制されない。</p>

                <p>さらに、履行値となる IteratorResult オブジェクトの *"value"* プロパティの値は promise（または「thenable」）でないべきである。引数値が典型的な方法で使用される場合、もしそれが拒否された promise なら同じ理由で拒否された promise を返すべきであり、履行された promise ならその履行値を返される promise の IteratorResult オブジェクトの *"value"* プロパティとして使用すべきである。ただしこれらの要件も強制されない。</p>
              </td>
            </tr>
            <tr>
              <td>*"throw"*</td>
              <td>IteratorResult オブジェクトの promise を返す関数 (a function that returns a promise for an IteratorResult object)</td>
              <td>
                <p>返される promise は履行時に IteratorResult インタフェースに適合するオブジェクトで履行されなければならない。このメソッド呼び出しは、呼び出し側がエラー状態を検出したことを async イテレータオブジェクトに通知する。引数はエラー状態を識別するために使用でき、典型的には例外オブジェクトである。典型的な応答は、その引数値で拒否される promise を返すことである。</p>

                <p>返される promise が履行された場合、履行値である IteratorResult オブジェクトは通常 *"done"* プロパティが *true* の値を持つ。さらに、その *"value"* プロパティの値は promise（または「thenable」）でないべきだが、この要件は強制されない。</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>通常これらのメソッドの呼び出し側は存在確認を行ってから呼び出すべきである。`for`-`await`-`of` や `yield*` を含む特定の ECMAScript 言語機能は存在確認後にこれらを呼び出す。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iteratorresult-interface">
        <h1>IteratorResult インタフェース (The IteratorResult Interface)</h1>
        <p><dfn variants="IteratorResult object,IteratorResult objects">IteratorResult インタフェース</dfn> は <emu-xref href="#table-iteratorresult-interface-properties"></emu-xref> に列挙されるプロパティを含む:</p>
        <emu-table id="table-iteratorresult-interface-properties" caption="IteratorResult インタフェース プロパティ (IteratorResult Interface Properties)" oldids="table-55">
          <table>
            <thead>
              <tr>
                <th>
                  プロパティ (Property)
                </th>
                <th>
                  値 (Value)
                </th>
                <th>
                  要件 (Requirements)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"done"*
              </td>
              <td>
                真偽値 (a Boolean)
              </td>
              <td>
                これはイテレータの `next` メソッド呼び出しの結果状態である。イテレータの終端に到達した場合 *"done"* は *true*。終端でない場合 *"done"* は *false* で値が利用可能。*"done"* プロパティ（自身または継承）が存在しない場合、その値は *false* と見なされる。
              </td>
            </tr>
            <tr>
              <td>
                *"value"*
              </td>
              <td>
                ECMAScript 言語値 (an ECMAScript language value)
              </td>
              <td>
                done が *false* の場合、これは現在の反復要素の値。done が *true* の場合、（提供されたなら）イテレータの戻り値。イテレータに戻り値がない場合 *"value"* は *undefined*。その場合、明示的な *"value"* プロパティを継承していなければ、適合オブジェクトから *"value"* プロパティを省いてもよい。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-helper-objects">
      <h1>イテレータヘルパーオブジェクト (Iterator Helper Objects)</h1>
      <p><dfn variants="Iterator Helper objects">Iterator Helper オブジェクト</dfn> は、特定のソースイテレータオブジェクトの遅延変換を表す通常のオブジェクトである。Iterator Helper オブジェクト用の名前付きコンストラクタはない。代わりに、Iterator Helper オブジェクトは Iterator インスタンスオブジェクトの特定メソッド呼び出しによって生成される。</p>

      <emu-clause id="sec-%iteratorhelperprototype%-object">
        <h1>%IteratorHelperPrototype% オブジェクト (The %IteratorHelperPrototype% Object)</h1>
        <p><dfn>%IteratorHelperPrototype%</dfn> オブジェクト:</p>
        <ul>
          <li>すべての Iterator Helper オブジェクトに継承されるプロパティを持つ。</li>
          <li>通常のオブジェクトである。</li>
          <li>[[Prototype]] 内部スロットの値は %Iterator.prototype% である。</li>
          <li>次のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-%iteratorhelperprototype%.next">
          <h1>%IteratorHelperPrototype%.next ( )</h1>
          <emu-alg>
            1. ? GeneratorResume(*this* value, *undefined*, *"Iterator Helper"*) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%.return">
          <h1>%IteratorHelperPrototype%.return ( )</h1>
          <emu-alg>
            1. _O_ を *this* 値とする。
            1. ? RequireInternalSlot(_O_, [[UnderlyingIterator]]) を実行する。
            1. 事前条件: _O_ は [[GeneratorState]] 内部スロットを持つ。
            1. もし _O_.[[GeneratorState]] が ~suspended-start~ なら
              1. _O_.[[GeneratorState]] を ~completed~ に設定する。
              1. 注: 一度 generator が completed 状態になると離脱せず、その関連実行コンテキストは再開されない。_O_ に関連する任意の実行状態はここで破棄できる。
              1. ? IteratorClose(_O_.[[UnderlyingIterator]], NormalCompletion(~unused~)) を実行する。
              1. CreateIteratorResultObject(*undefined*, *true*) を返す。
            1. _C_ を ReturnCompletion(*undefined*) とする。
            1. ? GeneratorResumeAbrupt(_O_, _C_, *"Iterator Helper"*) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%-%symbol.tostringtag%">
          <h1>%IteratorHelperPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"Iterator Helper"* である。</p>
          <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-objects">
      <h1>イテレータオブジェクト (Iterator Objects)</h1>

      <emu-clause id="sec-iterator-constructor">
        <h1>Iterator コンストラクタ (The Iterator Constructor)</h1>
        <p><dfn>Iterator</dfn> コンストラクタ:</p>
        <ul>
          <li><dfn>%Iterator%</dfn> である。</li>
          <li>グローバルオブジェクトの *"Iterator"* プロパティの初期値である。</li>
          <li>サブクラス化可能として設計されている。クラス定義の *extends* 句の値として使用できる。</li>
        </ul>

        <emu-clause id="sec-iterator">
          <h1>Iterator ( )</h1>
          <p>この関数は呼び出されると次を実行する:</p>
          <emu-alg>
            1. もし NewTarget が *undefined* またはアクティブな関数オブジェクトのいずれかなら *TypeError* 例外を投げる。
            1. ? OrdinaryCreateFromConstructor(NewTarget, *"%Iterator.prototype%"*) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-iterator-constructor">
        <h1>Iterator コンストラクタのプロパティ (Properties of the Iterator Constructor)</h1>
        <p>Iterator コンストラクタ:</p>
        <ul>
          <li>[[Prototype]] 内部スロットの値は %Function.prototype% である。</li>
          <li>次のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-iterator.from">
          <h1>Iterator.from ( _O_ )</h1>
          <emu-alg>
            1. _iteratorRecord_ を ? GetIteratorFlattenable(_O_, ~iterate-string-primitives~) とする。
            1. _hasInstance_ を ? OrdinaryHasInstance(%Iterator%, _iteratorRecord_.[[Iterator]]) とする。
            1. もし _hasInstance_ が *true* なら
              1. _iteratorRecord_.[[Iterator]] を返す。
            1. _wrapper_ を OrdinaryObjectCreate(%WrapForValidIteratorPrototype%, « [[Iterated]] ») とする。
            1. _wrapper_.[[Iterated]] に _iteratorRecord_ を設定する。
            1. _wrapper_ を返す。
          </emu-alg>

          <emu-clause id="sec-%wrapforvaliditeratorprototype%-object">
            <h1>%WrapForValidIteratorPrototype% オブジェクト (The %WrapForValidIteratorPrototype% Object)</h1>
            <p><dfn>%WrapForValidIteratorPrototype%</dfn> オブジェクト:</p>
            <ul>
              <li>通常のオブジェクトである。</li>
              <li>[[Prototype]] 内部スロットの値は %Iterator.prototype% である。</li>
            </ul>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.next">
              <h1>%WrapForValidIteratorPrototype%.next ( )</h1>
              <emu-alg>
                1. _O_ を *this* 値とする。
                1. ? RequireInternalSlot(_O_, [[Iterated]]) を実行する。
                1. _iteratorRecord_ を _O_.[[Iterated]] とする。
                1. ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]) を返す。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.return">
              <h1>%WrapForValidIteratorPrototype%.return ( )</h1>
              <emu-alg>
                1. _O_ を *this* 値とする。
                1. ? RequireInternalSlot(_O_, [[Iterated]]) を実行する。
                1. _iterator_ を _O_.[[Iterated]].[[Iterator]] とする。
                1. 事前条件: _iterator_ は Object。
                1. _returnMethod_ を ? GetMethod(_iterator_, *"return"*) とする。
                1. もし _returnMethod_ が *undefined* なら
                  1. CreateIteratorResultObject(*undefined*, *true*) を返す。
                1. ? Call(_returnMethod_, _iterator_) を返す。
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype">
          <h1>Iterator.prototype</h1>
          <p>Iterator.prototype の初期値は Iterator プロトタイプオブジェクトである。</p>
          <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-%iteratorprototype%-object" id="sec-%iterator.prototype%-object">
      <h1>Iterator プロトタイプオブジェクトのプロパティ (Properties of the Iterator Prototype Object)</h1>
      <p><dfn>Iterator プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%Iterator.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
      </ul>
      <emu-note>
        <p>この仕様で iterator インタフェースを実装するすべてのオブジェクトは %Iterator.prototype% を継承する。ECMAScript コードは %Iterator.prototype% を継承するオブジェクトを定義することもできる。%Iterator.prototype% はすべてのイテレータオブジェクトに適用可能な追加メソッドを追加できる場所を提供する。</p>
        <p>次の式は ECMAScript コードが %Iterator.prototype% オブジェクトにアクセスする一つの方法である:</p>
        <pre><code class="javascript">Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))</code></pre>
      </emu-note>

      <emu-clause id="sec-iterator.prototype.constructor">
        <h1>Iterator.prototype.constructor</h1>
        <p>`Iterator.prototype.constructor` は属性 { [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つアクセスプロパティである。[[Get]] および [[Set]] 属性は次のように定義される:</p>

        <emu-clause id="sec-get-iterator.prototype.constructor">
          <h1>get Iterator.prototype.constructor</h1>
          <p>[[Get]] 属性の値は引数を必要としない組み込み関数であり、呼び出されると次を実行する:</p>
          <emu-alg>
            1. %Iterator% を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype.constructor">
          <h1>set Iterator.prototype.constructor</h1>
          <p>[[Set]] 属性の値は引数 _v_ を取る組み込み関数であり、呼び出されると次を実行する:</p>
          <emu-alg>
            1. ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, *"constructor"*, _v_) を実行する。
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>ほとんどの組み込みプロトタイプ上の *"constructor"* プロパティと異なり、Web 互換性の理由からこのプロパティはアクセサでなければならない。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.drop">
        <h1>Iterator.prototype.drop ( _limit_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. _numLimit_ を Completion(ToNumber(_limit_)) とする。
          1. IfAbruptCloseIterator(_numLimit_, _iterated_)。
          1. もし _numLimit_ が *NaN* なら
            1. _error_ を ThrowCompletion(新しく生成された *RangeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _integerLimit_ を ! ToIntegerOrInfinity(_numLimit_) とする。
          1. もし _integerLimit_ &lt; 0 なら
            1. _error_ を ThrowCompletion(新しく生成された *RangeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _closure_ を、引数なしで _iterated_ と _integerLimit_ を捕捉し、呼び出されると次を実行する新たな Abstract Closure とする:
            1. _remaining_ を _integerLimit_ とする。
            1. _remaining_ > 0 の間繰り返す,
              1. もし _remaining_ ≠ +∞ なら
                1. _remaining_ を _remaining_ - 1 にする。
              1. _next_ を ? IteratorStep(_iterated_) とする。
              1. もし _next_ が ~done~ なら ReturnCompletion(*undefined*) を返す。
            1. 繰り返す,
              1. _value_ を ? IteratorStepValue(_iterated_) とする。
              1. もし _value_ が ~done~ なら ReturnCompletion(*undefined*) を返す。
              1. _completion_ を Completion(Yield(_value_)) とする。
              1. IfAbruptCloseIterator(_completion_, _iterated_)。
          1. _result_ を CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] ») とする。
          1. _result_.[[UnderlyingIterator]] に _iterated_ を設定する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.every">
        <h1>Iterator.prototype.every ( _predicate_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_predicate_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _counter_ を 0 とする。
          1. 繰り返す,
            1. _value_ を ? IteratorStepValue(_iterated_) とする。
            1. もし _value_ が ~done~ なら *true* を返す。
            1. _result_ を Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)) とする。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. もし ToBoolean(_result_) が *false* なら ? IteratorClose(_iterated_, NormalCompletion(*false*)) を返す。
            1. _counter_ を _counter_ + 1 にする。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.filter">
        <h1>Iterator.prototype.filter ( _predicate_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_predicate_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _closure_ を、引数なしで _iterated_ と _predicate_ を捕捉し呼び出されると次を実行する新たな Abstract Closure とする:
            1. _counter_ を 0 とする。
            1. 繰り返す,
              1. _value_ を ? IteratorStepValue(_iterated_) とする。
              1. もし _value_ が ~done~ なら ReturnCompletion(*undefined*) を返す。
              1. _selected_ を Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)) とする。
              1. IfAbruptCloseIterator(_selected_, _iterated_)。
              1. もし ToBoolean(_selected_) が *true* なら
                1. _completion_ を Completion(Yield(_value_)) とする。
                1. IfAbruptCloseIterator(_completion_, _iterated_)。
              1. _counter_ を _counter_ + 1 にする。
          1. _result_ を CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] ») とする。
          1. _result_.[[UnderlyingIterator]] に _iterated_ を設定する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.find">
        <h1>Iterator.prototype.find ( _predicate_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_predicate_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _counter_ を 0 とする。
          1. 繰り返す,
            1. _value_ を ? IteratorStepValue(_iterated_) とする。
            1. もし _value_ が ~done~ なら *undefined* を返す。
            1. _result_ を Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)) とする。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. もし ToBoolean(_result_) が *true* なら ? IteratorClose(_iterated_, NormalCompletion(_value_)) を返す。
            1. _counter_ を _counter_ + 1 にする。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.flatmap">
        <h1>Iterator.prototype.flatMap ( _mapper_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_mapper_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _closure_ を、引数なしで _iterated_ と _mapper_ を捕捉し呼び出されると次を実行する新たな Abstract Closure とする:
            1. _counter_ を 0 とする。
            1. 繰り返す,
              1. _value_ を ? IteratorStepValue(_iterated_) とする。
              1. もし _value_ が ~done~ なら ReturnCompletion(*undefined*) を返す。
              1. _mapped_ を Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »)) とする。
              1. IfAbruptCloseIterator(_mapped_, _iterated_)。
              1. _innerIterator_ を Completion(GetIteratorFlattenable(_mapped_, ~reject-primitives~)) とする。
              1. IfAbruptCloseIterator(_innerIterator_, _iterated_)。
              1. _innerAlive_ を *true* とする。
              1. _innerAlive_ が *true* の間繰り返す,
                1. _innerValue_ を Completion(IteratorStepValue(_innerIterator_)) とする。
                1. IfAbruptCloseIterator(_innerValue_, _iterated_)。
                1. もし _innerValue_ が ~done~ なら
                  1. _innerAlive_ を *false* に設定する。
                1. それ以外
                  1. _completion_ を Completion(Yield(_innerValue_)) とする。
                  1. もし _completion_ が abrupt completion なら
                    1. _backupCompletion_ を Completion(IteratorClose(_innerIterator_, _completion_)) とする。
                    1. IfAbruptCloseIterator(_backupCompletion_, _iterated_)。
                    1. ? IteratorClose(_iterated_, _completion_) を返す。
              1. _counter_ を _counter_ + 1 にする。
          1. _result_ を CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] ») とする。
          1. _result_.[[UnderlyingIterator]] に _iterated_ を設定する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.foreach">
        <h1>Iterator.prototype.forEach ( _procedure_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_procedure_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _counter_ を 0 とする。
          1. 繰り返す,
            1. _value_ を ? IteratorStepValue(_iterated_) とする。
            1. もし _value_ が ~done~ なら *undefined* を返す。
            1. _result_ を Completion(Call(_procedure_, *undefined*, « _value_, 𝔽(_counter_) »)) とする。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. _counter_ を _counter_ + 1 にする。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.map">
        <h1>Iterator.prototype.map ( _mapper_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_mapper_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _closure_ を、引数なしで _iterated_ と _mapper_ を捕捉し呼び出されると次を実行する新たな Abstract Closure とする:
            1. _counter_ を 0 とする。
            1. 繰り返す,
              1. _value_ を ? IteratorStepValue(_iterated_) とする。
              1. もし _value_ が ~done~ なら ReturnCompletion(*undefined*) を返す。
              1. _mapped_ を Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »)) とする。
              1. IfAbruptCloseIterator(_mapped_, _iterated_)。
              1. _completion_ を Completion(Yield(_mapped_)) とする。
              1. IfAbruptCloseIterator(_completion_, _iterated_)。
              1. _counter_ を _counter_ + 1 にする。
          1. _result_ を CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] ») とする。
          1. _result_.[[UnderlyingIterator]] に _iterated_ を設定する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.reduce">
        <h1>Iterator.prototype.reduce ( _reducer_ [ , _initialValue_ ] )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_reducer_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. もし _initialValue_ が存在しなければ
            1. _accumulator_ を ? IteratorStepValue(_iterated_) とする。
            1. もし _accumulator_ が ~done~ なら *TypeError* 例外を投げる。
            1. _counter_ を 1 とする。
          1. それ以外
            1. _accumulator_ を _initialValue_ とする。
            1. _counter_ を 0 とする。
          1. 繰り返す,
            1. _value_ を ? IteratorStepValue(_iterated_) とする。
            1. もし _value_ が ~done~ なら _accumulator_ を返す。
            1. _result_ を Completion(Call(_reducer_, *undefined*, « _accumulator_, _value_, 𝔽(_counter_) »)) とする。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. _accumulator_ を _result_ に設定する。
            1. _counter_ を _counter_ + 1 にする。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.some">
        <h1>Iterator.prototype.some ( _predicate_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. もし IsCallable(_predicate_) が *false* なら
            1. _error_ を ThrowCompletion(新しく生成された *TypeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _counter_ を 0 とする。
          1. 繰り返す,
            1. _value_ を ? IteratorStepValue(_iterated_) とする。
            1. もし _value_ が ~done~ なら *false* を返す。
            1. _result_ を Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)) とする。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. もし ToBoolean(_result_) が *true* なら ? IteratorClose(_iterated_, NormalCompletion(*true*)) を返す。
            1. _counter_ を _counter_ + 1 にする。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.take">
        <h1>Iterator.prototype.take ( _limit_ )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } とする。
          1. _numLimit_ を Completion(ToNumber(_limit_)) とする。
          1. IfAbruptCloseIterator(_numLimit_, _iterated_)。
          1. もし _numLimit_ が *NaN* なら
            1. _error_ を ThrowCompletion(新しく生成された *RangeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _integerLimit_ を ! ToIntegerOrInfinity(_numLimit_) とする。
          1. もし _integerLimit_ &lt; 0 なら
            1. _error_ を ThrowCompletion(新しく生成された *RangeError* オブジェクト) とする。
            1. ? IteratorClose(_iterated_, _error_) を返す。
          1. _iterated_ を ? GetIteratorDirect(_O_) に設定する。
          1. _closure_ を、引数なしで _iterated_ と _integerLimit_ を捕捉し呼び出されると次を実行する新たな Abstract Closure とする:
            1. _remaining_ を _integerLimit_ とする。
            1. 繰り返す,
              1. もし _remaining_ = 0 なら
                1. ? IteratorClose(_iterated_, ReturnCompletion(*undefined*)) を返す。
              1. もし _remaining_ ≠ +∞ なら
                1. _remaining_ を _remaining_ - 1 にする。
              1. _value_ を ? IteratorStepValue(_iterated_) とする。
              1. もし _value_ が ~done~ なら ReturnCompletion(*undefined*) を返す。
              1. _completion_ を Completion(Yield(_value_)) とする。
              1. IfAbruptCloseIterator(_completion_, _iterated_)。
          1. _result_ を CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] ») とする。
          1. _result_.[[UnderlyingIterator]] に _iterated_ を設定する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.toarray">
        <h1>Iterator.prototype.toArray ( )</h1>
        <p>このメソッドは呼び出されると次を実行する:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. もし _O_ が Object でなければ *TypeError* 例外を投げる。
          1. _iterated_ を ? GetIteratorDirect(_O_) とする。
          1. _items_ を新しい空の List とする。
          1. 繰り返す,
            1. _value_ を ? IteratorStepValue(_iterated_) とする。
            1. もし _value_ が ~done~ なら CreateArrayFromList(_items_) を返す。
            1. _value_ を _items_ に追加する。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%iteratorprototype%-@@iterator,sec-%iteratorprototype%-%symbol.iterator%" id="sec-iterator.prototype-%symbol.iterator%">
        <h1>Iterator.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>この関数は呼び出されると次を実行する:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティの値は *"[Symbol.iterator]"* である。</p>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype-%symbol.tostringtag%">
        <h1>Iterator.prototype [ %Symbol.toStringTag% ]</h1>
        <p>`Iterator.prototype[%Symbol.toStringTag%]` は属性 { [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つアクセスプロパティである。[[Get]] および [[Set]] 属性は次のように定義される:</p>

        <emu-clause id="sec-get-iterator.prototype-%symbol.tostringtag%">
          <h1>get Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>[[Get]] 属性の値は引数を必要としない組み込み関数であり、呼び出されると次を実行する:</p>
          <emu-alg>
            1. *"Iterator"* を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype-%symbol.tostringtag%">
          <h1>set Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>[[Set]] 属性の値は引数 _v_ を取る組み込み関数であり、呼び出されると次を実行する:</p>
          <emu-alg>
            1. ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, %Symbol.toStringTag%, _v_) を実行する。
            1. *undefined* を返す。
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>ほとんどの組み込みプロトタイプ上の %Symbol.toStringTag% プロパティと異なり、Web 互換性の理由からこのプロパティはアクセサでなければならない。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciteratorprototype">
      <h1>%AsyncIteratorPrototype% オブジェクト (The %AsyncIteratorPrototype% Object)</h1>
      <p><dfn>%AsyncIteratorPrototype%</dfn> オブジェクト:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
      </ul>
      <emu-note>
        <p>この仕様で async iterator インタフェースを実装するすべてのオブジェクトは %AsyncIteratorPrototype% を継承する。ECMAScript コードは %AsyncIteratorPrototype% を継承するオブジェクトを定義することもできる。%AsyncIteratorPrototype% オブジェクトはすべての async イテレータオブジェクトに適用可能な追加メソッドを追加できる場所を提供する。</p>
      </emu-note>

      <emu-clause oldids="sec-asynciteratorprototype-asynciterator" id="sec-%asynciteratorprototype%-%symbol.asynciterator%">
        <h1>%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )</h1>
        <p>この関数は呼び出されると次を実行する:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティの値は *"[Symbol.asyncIterator]"* である。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-from-sync-iterator-objects">
      <h1>同期イテレータからの非同期イテレータオブジェクト (Async-from-Sync Iterator Objects)</h1>
      <p><dfn variants="Async-from-Sync Iterator objects">Async-from-Sync Iterator オブジェクト</dfn> は特定の同期イテレータを適応させる async イテレータである。Async-from-Sync Iterator オブジェクトは ECMAScript コードから直接アクセスされることはない。名前付きコンストラクタは存在せず、必要に応じて抽象操作 CreateAsyncFromSyncIterator によって生成される。</p>

      <emu-clause id="sec-createasyncfromsynciterator" type="abstract operation">
        <h1>
          CreateAsyncFromSyncIterator (
            _syncIteratorRecord_: an Iterator Record,
          ): Iterator Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>同期の Iterator Record から async の Iterator Record を生成するために使用される。</dd>
        </dl>
        <emu-alg>
          1. _asyncIterator_ を OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] ») とする。
          1. _asyncIterator_.[[SyncIteratorRecord]] に _syncIteratorRecord_ を設定する。
          1. _nextMethod_ を ! Get(_asyncIterator_, *"next"*) とする。
          1. _iteratorRecord_ を Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* } とする。
          1. _iteratorRecord_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%asyncfromsynciteratorprototype%-object">
        <h1>%AsyncFromSyncIteratorPrototype% オブジェクト (The %AsyncFromSyncIteratorPrototype% Object)</h1>
        <p><dfn>%AsyncFromSyncIteratorPrototype%</dfn> オブジェクト:</p>
        <ul>
          <li>すべての Async-from-Sync Iterator オブジェクトに継承されるプロパティを持つ。</li>
          <li>通常のオブジェクトである。</li>
          <li>[[Prototype]] 内部スロットの値は %AsyncIteratorPrototype% である。</li>
          <li>ECMAScript コードから直接アクセスされない。</li>
          <li>次のプロパティを持つ:</li>
        </ul>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.next">
          <h1>%AsyncFromSyncIteratorPrototype%.next ( [ _value_ ] )</h1>
          <emu-alg>
            1. _O_ を *this* 値とする。
            1. 事前条件: _O_ は [[SyncIteratorRecord]] 内部スロットを持つ Object。
            1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
            1. _syncIteratorRecord_ を _O_.[[SyncIteratorRecord]] とする。
            1. もし _value_ が存在すれば
              1. _result_ を Completion(IteratorNext(_syncIteratorRecord_, _value_)) とする。
            1. それ以外
              1. _result_ を Completion(IteratorNext(_syncIteratorRecord_)) とする。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
            1. AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.return">
          <h1>%AsyncFromSyncIteratorPrototype%.return ( [ _value_ ] )</h1>

          <emu-alg>
            1. _O_ を *this* 値とする。
            1. 事前条件: _O_ は [[SyncIteratorRecord]] 内部スロットを持つ Object。
            1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
            1. _syncIteratorRecord_ を _O_.[[SyncIteratorRecord]] とする。
            1. _syncIterator_ を _syncIteratorRecord_.[[Iterator]] とする。
            1. _return_ を Completion(GetMethod(_syncIterator_, *"return"*)) とする。
            1. IfAbruptRejectPromise(_return_, _promiseCapability_)。
            1. もし _return_ が *undefined* なら
              1. _iteratorResult_ を CreateIteratorResultObject(_value_, *true*) とする。
              1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ ») を実行する。
              1. _promiseCapability_.[[Promise]] を返す。
            1. もし _value_ が存在すれば
              1. _result_ を Completion(Call(_return_, _syncIterator_, « _value_ »)) とする。
            1. それ以外
              1. _result_ を Completion(Call(_return_, _syncIterator_)) とする。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
            1. もし _result_ が Object でなければ
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新しく生成された *TypeError* オブジェクト ») を実行する。
              1. _promiseCapability_.[[Promise]] を返す。
            1. AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *false*) を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.throw">
          <h1>%AsyncFromSyncIteratorPrototype%.throw ( [ _value_ ] )</h1>
          <emu-note>本仕様では _value_ は常に提供されるが、<emu-xref title href="#sec-%asyncfromsynciteratorprototype%.return"></emu-xref> との一貫性のため任意としている。</emu-note>

          <emu-alg>
            1. _O_ を *this* 値とする。
            1. 事前条件: _O_ は [[SyncIteratorRecord]] 内部スロットを持つ Object。
            1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
            1. _syncIteratorRecord_ を _O_.[[SyncIteratorRecord]] とする。
            1. _syncIterator_ を _syncIteratorRecord_.[[Iterator]] とする。
            1. _throw_ を Completion(GetMethod(_syncIterator_, *"throw"*)) とする。
            1. IfAbruptRejectPromise(_throw_, _promiseCapability_)。
            1. もし _throw_ が *undefined* なら
              1. 注: _syncIterator_ に `throw` メソッドがない場合、capability を拒否する前にクリーンアップの機会を与えるため閉じる。
              1. _closeCompletion_ を NormalCompletion(~empty~) とする。
              1. _result_ を Completion(IteratorClose(_syncIteratorRecord_, _closeCompletion_)) とする。
              1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
              1. 注: 次のステップはプロトコル違反（_syncIterator_ に `throw` メソッドがない）を示す *TypeError* を投げる。
              1. 注: _syncIterator_ の close が例外を投げない場合、その結果は無視される（拒否された promise を生成しても）。
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新しく生成された *TypeError* オブジェクト ») を実行する。
              1. _promiseCapability_.[[Promise]] を返す。
            1. もし _value_ が存在すれば
              1. _result_ を Completion(Call(_throw_, _syncIterator_, « _value_ »)) とする。
            1. それ以外
              1. _result_ を Completion(Call(_throw_, _syncIterator_)) とする。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
            1. もし _result_ が Object でなければ
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新しく生成された *TypeError* オブジェクト ») を実行する。
              1. _promiseCapability_.[[Promise]] を返す。
            1. AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*) を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-async-from-sync-iterator-instances">
        <h1>Async-from-Sync Iterator インスタンスのプロパティ (Properties of Async-from-Sync Iterator Instances)</h1>
        <p>Async-from-Sync Iterator インスタンスは %AsyncFromSyncIteratorPrototype% 組込みオブジェクトからプロパティを継承する通常のオブジェクトである。これらインスタンスは <emu-xref href="#table-async-from-sync-iterator-internal-slots"></emu-xref> に列挙される内部スロットを持って初期化される。</p>
        <emu-table id="table-async-from-sync-iterator-internal-slots" caption="Async-from-Sync Iterator インスタンスの内部スロット (Internal Slots of Async-from-Sync Iterator Instances)">
          <table>
            <thead>
              <tr>
                <th>
                  内部スロット (Internal Slot)
                </th>
                <th>
                  型 (Type)
                </th>
                <th>
                  説明 (Description)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[SyncIteratorRecord]]
              </td>
              <td>
                Iterator Record
              </td>
              <td>
                適応対象となる元の同期イテレータを表す (Represents the original synchronous iterator which is being adapted).
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncfromsynciteratorcontinuation" type="abstract operation" oldids="sec-async-from-sync-iterator-value-unwrap-functions">
        <h1>
          AsyncFromSyncIteratorContinuation (
            _result_: an Object,
            _promiseCapability_: a PromiseCapability Record for an intrinsic %Promise%,
            _syncIteratorRecord_: an Iterator Record,
            _closeOnRejection_: a Boolean,
          ): Promise
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 注: _promiseCapability_ は組込み %Promise% から派生するので、以下の IfAbruptRejectPromise 使用に伴う _promiseCapability_.[[Reject]] への呼び出しは throw しないことが保証される。
          1. _done_ を Completion(IteratorComplete(_result_)) とする。
          1. IfAbruptRejectPromise(_done_, _promiseCapability_)。
          1. _value_ を Completion(IteratorValue(_result_)) とする。
          1. IfAbruptRejectPromise(_value_, _promiseCapability_)。
          1. _valueWrapper_ を Completion(PromiseResolve(%Promise%, _value_)) とする。
          1. もし _valueWrapper_ が abrupt completion で、_done_ が *false*, かつ _closeOnRejection_ が *true* なら
            1. _valueWrapper_ を Completion(IteratorClose(_syncIteratorRecord_, _valueWrapper_)) とする。
          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_)。
          1. _unwrap_ をパラメータ (_v_) を持ち _done_ を捕捉し呼び出されると次を実行する新たな Abstract Closure とし、CreateIteratorResultObject(_v_, _done_) を返す。
          1. _onFulfilled_ を CreateBuiltinFunction(_unwrap_, 1, *""*, « ») とする。
          1. 注: _onFulfilled_ は IteratorResult オブジェクトの *"value"* プロパティを処理する際、その値が promise であれば待機し、新たな「unwrapped」 IteratorResult オブジェクトとして再パッケージするために使用される。
          1. もし _done_ が *true* または _closeOnRejection_ が *false* なら
            1. _onRejected_ を *undefined* とする。
          1. それ以外
            1. _closeIterator_ をパラメータ (_error_) を持ち _syncIteratorRecord_ を捕捉し呼び出されると ? IteratorClose(_syncIteratorRecord_, ThrowCompletion(_error_)) を返す新たな Abstract Closure とする。
            1. _onRejected_ を CreateBuiltinFunction(_closeIterator_, 1, *""*, « ») とする。
            1. 注: _onRejected_ は IteratorResult オブジェクトが返す *"value"* プロパティが拒否された promise である場合に Iterator を close するために使用される。
          1. PerformPromiseThen(_valueWrapper_, _onFulfilled_, _onRejected_, _promiseCapability_) を実行する。
          1. _promiseCapability_.[[Promise]] を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-promise-objects">
    <h1>Promise オブジェクト</h1>
    <p>Promise は、延期された（かつ非同期である可能性のある）計算の最終的な結果に対するプレースホルダーとして使われるオブジェクトである。</p>
    <p>任意の Promise は互いに排他的な 3 つの状態のいずれかにある: <em>fulfilled</em>（履行済）、<em>rejected</em>（拒否済）、<em>pending</em>（保留）:</p>
    <ul>
      <li>
        Promise `p` が fulfilled であるとは、`p.then(f, r)` が直ちに関数 `f` を呼び出す Job をキューに入れる場合をいう。
      </li>
      <li>
        Promise `p` が rejected であるとは、`p.then(f, r)` が直ちに関数 `r` を呼び出す Job をキューに入れる場合をいう。
      </li>
      <li>
        Promise が pending であるとは、それが fulfilled でも rejected でもない場合をいう。
      </li>
    </ul>
    <p>Promise が <em>settled</em>（確定）であるとは、それが pending でない（すなわち fulfilled か rejected である）ことをいう。</p>
    <p>Promise が <em>resolved</em> であるとは、それが settled であるか、他の Promise の状態に一致するよう「ロックイン」された場合をいう。resolved な Promise をさらに resolve あるいは reject しようとしても効果はない。Promise が resolved でない場合、それは <em>unresolved</em> である。unresolved な Promise は常に pending 状態である。resolved な Promise は pending / fulfilled / rejected のいずれにもなり得る。</p>

    <emu-clause id="sec-promise-abstract-operations">
      <h1>Promise の抽象操作</h1>

      <emu-clause id="sec-promisecapability-records">
        <h1>PromiseCapability レコード</h1>
        <p><dfn variants="PromiseCapability Records">PromiseCapability Record</dfn> は、ある Promise（または Promise 風オブジェクト）と、それを解決または拒否できる関数をカプセル化するために用いられる Record 値である。PromiseCapability Record は抽象操作 NewPromiseCapability によって生成される。</p>
        <p>PromiseCapability Record は <emu-xref href="#table-promisecapability-record-fields"></emu-xref> に列挙するフィールドを持つ。</p>
        <emu-table id="table-promisecapability-record-fields" caption="PromiseCapability Record フィールド" oldids="table-57">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Promise]]
              </td>
              <td>
                Object
              </td>
              <td>
                Promise として使用可能なオブジェクト。
              </td>
            </tr>
            <tr>
              <td>
                [[Resolve]]
              </td>
              <td>
                関数オブジェクト
              </td>
              <td>
                対象の Promise を解決するために使われる関数。
              </td>
            </tr>
            <tr>
              <td>
                [[Reject]]
              </td>
              <td>
                関数オブジェクト
              </td>
              <td>
                対象の Promise を拒否するために使われる関数。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ifabruptrejectpromise" aoid="IfAbruptRejectPromise">
          <h1>IfAbruptRejectPromise ( _value_, _capability_ )</h1>
          <p>IfAbruptRejectPromise は PromiseCapability Record を用いるアルゴリズム手順列の短縮記法である。次の形式のアルゴリズム手順:</p>
          <emu-alg>
            1. IfAbruptRejectPromise(_value_, _capability_).
          </emu-alg>
          <p>は次と同じ意味である:</p>
          <emu-alg>
            1. 事前条件: _value_ は Completion Record である。
            1. もし _value_ が abrupt completion なら
              1. ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] ») を実行する。
              1. _capability_.[[Promise]] を返す。
            1. それ以外
              1. _value_ を ! _value_ に設定する。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promisereaction-records">
        <h1>PromiseReaction レコード</h1>
        <p><dfn variants="PromiseReaction Records">PromiseReaction Record</dfn> は、ある Promise が特定の値で解決または拒否されたときにどのように反応すべきかを格納するための Record 値である。PromiseReaction Record は抽象操作 PerformPromiseThen によって生成され、NewPromiseReactionJob が返す Abstract Closure によって使用される。</p>
        <p>PromiseReaction Record は <emu-xref href="#table-promisereaction-record-fields"></emu-xref> に列挙するフィールドを持つ。</p>
        <emu-table id="table-promisereaction-record-fields" caption="PromiseReaction Record フィールド" oldids="table-58">
          <table>
            <thead>
              <tr>
                <th>
                  フィールド名
                </th>
                <th>
                  値
                </th>
                <th>
                  意味
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Capability]]
              </td>
              <td>
                PromiseCapability Record または *undefined*
              </td>
              <td>
                このレコードがリアクションハンドラを提供する Promise のケイパビリティ。
              </td>
            </tr>
            <tr>
              <td>
                [[Type]]
              </td>
              <td>
                ~fulfill~ または ~reject~
              </td>
              <td>
                [[Handler]] が ~empty~ のときに、確定種別固有の挙動を可能にするために使用される。
              </td>
            </tr>
            <tr>
              <td>
                [[Handler]]
              </td>
              <td>
                JobCallback Record または ~empty~
              </td>
              <td>
                入力値に適用され、その戻り値が派生 Promise の挙動を決定する関数。[[Handler]] が ~empty~ の場合、[[Type]] の値に依存した関数が代わりに使用される。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-createresolvingfunctions" type="abstract operation">
        <h1>
          CreateResolvingFunctions (
            _promise_: a Promise,
          ): [[Resolve]] (関数オブジェクト) および [[Reject]] (関数オブジェクト) フィールドを持つ Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _alreadyResolved_ を Record { [[Value]]: *false* } とする。
          1. _stepsResolve_ を <emu-xref href="#sec-promise-resolve-functions" title></emu-xref> で定義されるアルゴリズム手順とする。
          1. _lengthResolve_ を <emu-xref href="#sec-promise-resolve-functions" title></emu-xref> にある関数定義の省略不可パラメータ数とする。
          1. _resolve_ を CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *""*, « [[Promise]], [[AlreadyResolved]] ») とする。
          1. _resolve_.[[Promise]] に _promise_ を設定する。
          1. _resolve_.[[AlreadyResolved]] に _alreadyResolved_ を設定する。
          1. _stepsReject_ を <emu-xref href="#sec-promise-reject-functions" title></emu-xref> で定義されるアルゴリズム手順とする。
          1. _lengthReject_ を <emu-xref href="#sec-promise-reject-functions" title></emu-xref> にある関数定義の省略不可パラメータ数とする。
          1. _reject_ を CreateBuiltinFunction(_stepsReject_, _lengthReject_, *""*, « [[Promise]], [[AlreadyResolved]] ») とする。
          1. _reject_.[[Promise]] に _promise_ を設定する。
          1. _reject_.[[AlreadyResolved]] に _alreadyResolved_ を設定する。
          1. Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ } を返す。
        </emu-alg>

        <emu-clause id="sec-promise-reject-functions">
          <h1>Promise Reject 関数</h1>
          <p>Promise reject 関数は [[Promise]] と [[AlreadyResolved]] 内部スロットを持つ匿名組み込み関数である。</p>
          <p>Promise reject 関数が引数 _reason_ で呼ばれたとき、次を行う:</p>
          <emu-alg>
            1. _F_ をアクティブな関数オブジェクトとする。
            1. 事前条件: _F_ は値が Object である [[Promise]] 内部スロットを持つ。
            1. _promise_ を _F_.[[Promise]] とする。
            1. _alreadyResolved_ を _F_.[[AlreadyResolved]] とする。
            1. もし _alreadyResolved_.[[Value]] が *true* なら *undefined* を返す。
            1. _alreadyResolved_.[[Value]] を *true* に設定する。
            1. RejectPromise(_promise_, _reason_) を実行する。
            1. *undefined* を返す。
          </emu-alg>
          <p>Promise reject 関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
        </emu-clause>

        <emu-clause id="sec-promise-resolve-functions">
          <h1>Promise Resolve 関数</h1>
          <p>Promise resolve 関数は [[Promise]] と [[AlreadyResolved]] 内部スロットを持つ匿名組み込み関数である。</p>
          <p>Promise resolve 関数が引数 _resolution_ で呼ばれたとき、次を行う:</p>
          <emu-alg>
            1. _F_ をアクティブな関数オブジェクトとする。
            1. 事前条件: _F_ は値が Object である [[Promise]] 内部スロットを持つ。
            1. _promise_ を _F_.[[Promise]] とする。
            1. _alreadyResolved_ を _F_.[[AlreadyResolved]] とする。
            1. もし _alreadyResolved_.[[Value]] が *true* なら *undefined* を返す。
            1. _alreadyResolved_.[[Value]] を *true* に設定する。
            1. もし SameValue(_resolution_, _promise_) が *true* なら
              1. _selfResolutionError_ を新たに生成された *TypeError* オブジェクトとする。
              1. RejectPromise(_promise_, _selfResolutionError_) を実行する。
              1. *undefined* を返す。
            1. もし _resolution_ が Object でなければ
              1. FulfillPromise(_promise_, _resolution_) を実行する。
              1. *undefined* を返す。
            1. _then_ を Completion(Get(_resolution_, *"then"*)) とする。
            1. もし _then_ が abrupt completion なら
              1. RejectPromise(_promise_, _then_.[[Value]]) を実行する。
              1. *undefined* を返す。
            1. _thenAction_ を _then_.[[Value]] とする。
            1. もし IsCallable(_thenAction_) が *false* なら
              1. FulfillPromise(_promise_, _resolution_) を実行する。
              1. *undefined* を返す。
            1. _thenJobCallback_ を HostMakeJobCallback(_thenAction_) とする。
            1. _job_ を NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_) とする。
            1. HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]) を実行する。
            1. *undefined* を返す。
          </emu-alg>
          <p>Promise resolve 関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-fulfillpromise" type="abstract operation">
        <h1>
          FulfillPromise (
            _promise_: a Promise,
            _value_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _promise_.[[PromiseState]] は ~pending~ である。
          1. _reactions_ を _promise_.[[PromiseFulfillReactions]] とする。
          1. _promise_.[[PromiseResult]] を _value_ に設定する。
          1. _promise_.[[PromiseFulfillReactions]] を *undefined* に設定する。
          1. _promise_.[[PromiseRejectReactions]] を *undefined* に設定する。
          1. _promise_.[[PromiseState]] を ~fulfilled~ に設定する。
          1. TriggerPromiseReactions(_reactions_, _value_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromisecapability" type="abstract operation" oldids="sec-getcapabilitiesexecutor-functions">
        <h1>
          NewPromiseCapability (
            _C_: an ECMAScript language value,
          ): 正常完了で PromiseCapability Record を含むか、または throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>これは _C_ を組み込み Promise コンストラクタと同様の方法でコンストラクタとして用いて Promise を生成し、その `resolve` / `reject` 関数を取得しようとする。得られた Promise と `resolve` / `reject` 関数によって新しい PromiseCapability Record を初期化する。</dd>
        </dl>
        <emu-alg>
          1. もし IsConstructor(_C_) が *false* なら *TypeError* 例外を投げる。
          1. 注: _C_ は Promise コンストラクタのパラメータ規約（<emu-xref href="#sec-promise-executor"></emu-xref> 参照）をサポートするコンストラクタ関数であると仮定される。
          1. _resolvingFunctions_ を Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* } とする。
          1. _executorClosure_ をパラメータ (_resolve_, _reject_) を持ち _resolvingFunctions_ を捕捉し、呼び出されると次を行う新たな Abstract Closure とする:
            1. もし _resolvingFunctions_.[[Resolve]] が *undefined* でなければ *TypeError* 例外を投げる。
            1. もし _resolvingFunctions_.[[Reject]] が *undefined* でなければ *TypeError* 例外を投げる。
            1. _resolvingFunctions_.[[Resolve]] を _resolve_ に設定する。
            1. _resolvingFunctions_.[[Reject]] を _reject_ に設定する。
            1. NormalCompletion(*undefined*) を返す。
          1. _executor_ を CreateBuiltinFunction(_executorClosure_, 2, *""*, « ») とする。
          1. _promise_ を ? Construct(_C_, « _executor_ ») とする。
          1. もし IsCallable(_resolvingFunctions_.[[Resolve]]) が *false* なら *TypeError* 例外を投げる。
          1. もし IsCallable(_resolvingFunctions_.[[Reject]]) が *false* なら *TypeError* 例外を投げる。
          1. PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] } を返す。
        </emu-alg>
        <emu-note>
          <p>この抽象操作は、渡された executor 関数引数を Promise コンストラクタと同様に呼び出す任意のコンストラクタに対して総称的であるため、Promise のサブクラス化をサポートする。これは Promise コンストラクタの静的メソッドを任意のサブクラスへ一般化するために使用される。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-ispromise" type="abstract operation">
        <h1>
          IsPromise (
            _x_: an ECMAScript language value,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>オブジェクト上の promise ブランドを確認する。</dd>
        </dl>
        <emu-alg>
          1. もし _x_ が Object でなければ *false* を返す。
          1. もし _x_ が [[PromiseState]] 内部スロットを持たなければ *false* を返す。
          1. *true* を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rejectpromise" type="abstract operation">
        <h1>
          RejectPromise (
            _promise_: a Promise,
            _reason_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _promise_.[[PromiseState]] は ~pending~ である。
          1. _reactions_ を _promise_.[[PromiseRejectReactions]] とする。
          1. _promise_.[[PromiseResult]] を _reason_ に設定する。
          1. _promise_.[[PromiseFulfillReactions]] を *undefined* に設定する。
          1. _promise_.[[PromiseRejectReactions]] を *undefined* に設定する。
          1. _promise_.[[PromiseState]] を ~rejected~ に設定する。
          1. もし _promise_.[[PromiseIsHandled]] が *false* なら HostPromiseRejectionTracker(_promise_, *"reject"*) を実行する。
          1. TriggerPromiseReactions(_reactions_, _reason_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-triggerpromisereactions" type="abstract operation">
        <h1>
          TriggerPromiseReactions (
            _reactions_: a List of PromiseReaction Records,
            _argument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_reactions_ の各レコードに対して新たな Job をキューに入れる。各 Job は PromiseReaction Record の [[Type]] と [[Handler]] を処理し、[[Handler]] が ~empty~ でなければ与えられた引数を渡して呼び出す。[[Handler]] が ~empty~ の場合、挙動は [[Type]] によって決定される。</dd>
        </dl>
        <emu-alg>
          1. _reactions_ の各要素 _reaction_ について
            1. _job_ を NewPromiseReactionJob(_reaction_, _argument_) とする。
            1. HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-host-promise-rejection-tracker" type="host-defined abstract operation">
        <h1>
          HostPromiseRejectionTracker (
            _promise_: a Promise,
            _operation_: *"reject"* or *"handle"*,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ホスト環境が Promise の拒否を追跡できるようにする。</dd>
        </dl>
        <p>HostPromiseRejectionTracker のデフォルト実装は ~unused~ を返すことである。</p>

        <emu-note>
          <p>HostPromiseRejectionTracker は次の 2 つの状況で呼ばれる:</p>

          <ul>
            <li>Promise がハンドラなしで拒否されたとき、_operation_ 引数に *"reject"* を指定して呼ばれる。</li>
            <li>拒否済みの Promise に初めてハンドラが追加されたとき、_operation_ 引数に *"handle"* を指定して呼ばれる。</li>
          </ul>

          <p>典型的な実装は、未処理拒否を開発者に通知しようと試みる一方で、後からハンドラが追加されて以前の通知が無効化される場合にも注意深く通知する。</p>
        </emu-note>

        <emu-note>
          <p>_operation_ が *"handle"* の場合、実装はガベージコレクションを妨げる形で _promise_ への参照を保持すべきではない。_operation_ が *"reject"* の場合には、拒否は稀でホットパスではないと期待されるため、実装は _promise_ への参照を保持してもよい。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-jobs">
      <h1>Promise の Job (Promise Jobs)</h1>

      <emu-clause id="sec-newpromisereactionjob" type="abstract operation" oldids="sec-promisereactionjob">
        <h1>
          NewPromiseReactionJob (
            _reaction_: a PromiseReaction Record,
            _argument_: an ECMAScript language value,
          ): フィールド [[Job]] (Job Abstract Closure) および [[Realm]] (Realm Record または *null*) を持つ Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>受け取った値に適切なハンドラを適用し、その戻り値を用いてそのハンドラに関連付けられた派生 Promise を解決または拒否する新しい Job Abstract Closure を返す。</dd>
        </dl>
        <emu-alg>
          1. _job_ を、引数なしで _reaction_ と _argument_ を捕捉し、呼び出されると次を実行する新たな Job Abstract Closure とする:
            1. _promiseCapability_ を _reaction_.[[Capability]] とする。
            1. _type_ を _reaction_.[[Type]] とする。
            1. _handler_ を _reaction_.[[Handler]] とする。
            1. もし _handler_ が ~empty~ なら
              1. もし _type_ が ~fulfill~ なら
                1. _handlerResult_ を NormalCompletion(_argument_) とする。
              1. それ以外
                1. 事前条件: _type_ は ~reject~ である。
                1. _handlerResult_ を ThrowCompletion(_argument_) とする。
            1. それ以外
              1. _handlerResult_ を Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)) とする。
            1. もし _promiseCapability_ が *undefined* なら
              1. 事前条件: _handlerResult_ は abrupt completion ではない。
              1. ~empty~ を返す。
            1. 事前条件: _promiseCapability_ は PromiseCapability Record である。
            1. もし _handlerResult_ が abrupt completion なら
              1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] ») を返す。
            1. それ以外
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] ») を返す。
          1. _handlerRealm_ を *null* とする。
          1. もし _reaction_.[[Handler]] が ~empty~ でないなら
            1. _getHandlerRealmResult_ を Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])) とする。
            1. もし _getHandlerRealmResult_ が normal completion なら _handlerRealm_ を _getHandlerRealmResult_.[[Value]] に設定する。
            1. それ以外なら _handlerRealm_ を現在の Realm Record に設定する。
            1. 注: _handlerRealm_ が *null* になるのはハンドラが *undefined* の場合に限られる。ハンドラが取り消された Proxy で ECMAScript コードが実行されない場合、_handlerRealm_ はエラーオブジェクト生成に用いられる。
          1. Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ } を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromiseresolvethenablejob" type="abstract operation" oldids="sec-promiseresolvethenablejob">
        <h1>
          NewPromiseResolveThenableJob (
            _promiseToResolve_: a Promise,
            _thenable_: an Object,
            _then_: a JobCallback Record,
          ): フィールド [[Job]] (Job Abstract Closure) および [[Realm]] (Realm Record) を持つ Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _job_ を、引数なしで _promiseToResolve_, _thenable_, _then_ を捕捉し、呼び出されると次を実行する新たな Job Abstract Closure とする:
            1. _resolvingFunctions_ を CreateResolvingFunctions(_promiseToResolve_) とする。
            1. _thenCallResult_ を Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)) とする。
            1. もし _thenCallResult_ が abrupt completion なら
              1. ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] ») を返す。
            1. ! _thenCallResult_ を返す。
          1. _getThenRealmResult_ を Completion(GetFunctionRealm(_then_.[[Callback]])) とする。
          1. もし _getThenRealmResult_ が normal completion なら _thenRealm_ を _getThenRealmResult_.[[Value]] とする。
          1. それ以外なら _thenRealm_ を現在の Realm Record とする。
          1. 注: _thenRealm_ が *null* になることはない。_then_.[[Callback]] が取り消された Proxy でコードが実行されない場合、_thenRealm_ はエラーオブジェクト生成に用いられる。
          1. Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ } を返す。
        </emu-alg>
        <emu-note>
          <p>この Job は与えられた thenable とその `then` メソッドを利用して指定された Promise を解決する。この過程は、`then` メソッドの評価が周囲コードの評価完了後に行われることを保証するため、Job として実行されなければならない。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-constructor">
      <h1>Promise コンストラクタ (The Promise Constructor)</h1>
      <p>Promise コンストラクタ:</p>
      <ul>
        <li><dfn>%Promise%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Promise"* プロパティの初期値である。</li>
        <li>コンストラクタとして呼び出されたとき新しい Promise を生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、そのように呼び出された場合は例外を投げる。</li>
        <li>クラス定義の `extends` 句における値として使用できる。指定された Promise の挙動を継承することを意図するサブクラスのコンストラクタは、`Promise` および `Promise.prototype` の組み込みメソッドをサポートするために必要な内部状態でサブクラスインスタンスを生成・初期化するため、Promise コンストラクタへの `super` 呼び出しを含めなければならない。</li>
      </ul>

      <emu-clause id="sec-promise-executor">
        <h1>Promise ( _executor_ )</h1>
        <p>この関数は呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. もし NewTarget が *undefined* なら *TypeError* 例外を投げる。
          1. もし IsCallable(_executor_) が *false* なら *TypeError* 例外を投げる。
          1. _promise_ を ? OrdinaryCreateFromConstructor(NewTarget, *"%Promise.prototype%"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] ») とする。
          1. _promise_.[[PromiseState]] を ~pending~ に設定する。
          1. _promise_.[[PromiseResult]] を ~empty~ に設定する。
          1. _promise_.[[PromiseFulfillReactions]] を新しい空 List に設定する。
          1. _promise_.[[PromiseRejectReactions]] を新しい空 List に設定する。
          1. _promise_.[[PromiseIsHandled]] を *false* に設定する。
          1. _resolvingFunctions_ を CreateResolvingFunctions(_promise_) とする。
          1. _completion_ を Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)) とする。
          1. もし _completion_ が abrupt completion なら
            1. ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] ») を実行する。
          1. _promise_ を返す。
        </emu-alg>
        <emu-note>
          <p>_executor_ 引数は関数オブジェクトでなければならない。これはこの Promise が表す、遅延される可能性のある処理の開始と完了報告のために呼び出される。executor は 2 つの引数 _resolve_ と _reject_ で呼び出される。これらは遅延計算の最終的な完了または失敗を報告するために _executor_ が使用できる関数である。executor から復帰することは遅延処理が完了したことを意味せず、遅延処理を最終的に実行する要求が受理されたことのみを意味する。</p>
          <p>_executor_ に渡される _resolve_ 関数は 1 つの引数を受け取る。_executor_ コードは最終的に _resolve_ を呼び、関連する Promise を解決したい意図を示すことができる。_resolve_ に渡される引数は遅延処理の最終的な値を表し、実際の履行値か、履行された場合にその値を与える別の Promise のいずれかである。</p>
          <p>_executor_ に渡される _reject_ 関数は 1 つの引数を受け取る。_executor_ コードは最終的に _reject_ を呼び、関連する Promise が拒否され決して履行されないことを示すことができる。_reject_ に渡される引数は Promise の拒否理由として用いられ、典型的には Error オブジェクトである。</p>
          <p>Promise コンストラクタが _executor_ に渡す resolve / reject 関数には、関連する Promise を実際に解決/拒否する能力がある。サブクラスは異なるコンストラクタ挙動を持ち、resolve と reject にカスタマイズされた値を渡す場合がある。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-constructor">
      <h1>Promise コンストラクタのプロパティ (Properties of the Promise Constructor)</h1>
      <p>Promise コンストラクタ:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値は %Function.prototype% である。</li>
        <li>次のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-promise.all">
        <h1>Promise.all ( _iterable_ )</h1>
        <p>この関数は、渡された Promise 群について、その履行値の配列で履行される新しい Promise を返す。あるいは最初に拒否された Promise の理由で拒否される。実行中、渡された iterable の各要素を Promise に解決する。</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
          1. _promiseResolve_ を Completion(GetPromiseResolve(_C_)) とする。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. _iteratorRecord_ を Completion(GetIterator(_iterable_, ~sync~)) とする。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. _result_ を Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) とする。
          1. もし _result_ が abrupt completion なら
            1. もし _iteratorRecord_.[[Done]] が *false* なら _result_ を Completion(IteratorClose(_iteratorRecord_, _result_)) に設定する。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. ! _result_ を返す。
        </emu-alg>
        <emu-note>
          <p>この関数は *this* 値が Promise コンストラクタのパラメータ規約をサポートするコンストラクタ関数であることを要する。</p>
        </emu-note>

        <emu-clause id="sec-getpromiseresolve" type="abstract operation">
          <h1>
            GetPromiseResolve (
              _promiseConstructor_: a constructor,
            ): 正常完了で関数オブジェクトを含むか、または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _promiseResolve_ を ? Get(_promiseConstructor_, *"resolve"*) とする。
            1. もし IsCallable(_promiseResolve_) が *false* なら *TypeError* 例外を投げる。
            1. _promiseResolve_ を返す。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-performpromiseall" type="abstract operation">
          <h1>
            PerformPromiseAll (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): 正常完了で ECMAScript 言語値を含むか、または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _values_ を新しい空 List とする。
            1. _remainingElementsCount_ を Record { [[Value]]: 1 } とする。
            1. _index_ を 0 とする。
            1. 繰り返す,
              1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
              1. もし _next_ が ~done~ なら
                1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] - 1 に設定する。
                1. もし _remainingElementsCount_.[[Value]] = 0 なら
                  1. _valuesArray_ を CreateArrayFromList(_values_) とする。
                  1. ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») を実行する。
                1. _resultCapability_.[[Promise]] を返す。
              1. *undefined* を _values_ に追加する。
              1. _nextPromise_ を ? Call(_promiseResolve_, _constructor_, « _next_ ») とする。
              1. _steps_ を <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref> で定義されるアルゴリズム手順とする。
              1. _length_ を <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref> にある関数定義の省略不可パラメータ数とする。
              1. _onFulfilled_ を CreateBuiltinFunction(_steps_, _length_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] ») とする。
              1. _onFulfilled_.[[AlreadyCalled]] を *false* に設定する。
              1. _onFulfilled_.[[Index]] を _index_ に設定する。
              1. _onFulfilled_.[[Values]] を _values_ に設定する。
              1. _onFulfilled_.[[Capability]] を _resultCapability_ に設定する。
              1. _onFulfilled_.[[RemainingElements]] を _remainingElementsCount_ に設定する。
              1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] + 1 に設定する。
              1. ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _resultCapability_.[[Reject]] ») を実行する。
              1. _index_ を _index_ + 1 に設定する。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.all-resolve-element-functions">
          <h1>`Promise.all` Resolve 要素関数 (`Promise.all` Resolve Element Functions)</h1>
          <p>`Promise.all` Resolve 要素関数は特定の `Promise.all` の要素を解決するために使われる匿名組み込み関数である。各 `Promise.all` Resolve 要素関数は [[Index]], [[Values]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 内部スロットを持つ。</p>
          <p>`Promise.all` Resolve 要素関数が引数 _x_ で呼ばれたとき、次を行う:</p>
          <emu-alg>
            1. _F_ をアクティブな関数オブジェクトとする。
            1. もし _F_.[[AlreadyCalled]] が *true* なら *undefined* を返す。
            1. _F_.[[AlreadyCalled]] を *true* に設定する。
            1. _index_ を _F_.[[Index]] とする。
            1. _values_ を _F_.[[Values]] とする。
            1. _promiseCapability_ を _F_.[[Capability]] とする。
            1. _remainingElementsCount_ を _F_.[[RemainingElements]] とする。
            1. _values_[_index_] を _x_ に設定する。
            1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] - 1 に設定する。
            1. もし _remainingElementsCount_.[[Value]] = 0 なら
              1. _valuesArray_ を CreateArrayFromList(_values_) とする。
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») を返す。
            1. *undefined* を返す。
          </emu-alg>
          <p>`Promise.all` Resolve 要素関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.allsettled">
        <h1>Promise.allSettled ( _iterable_ )</h1>
        <p>この関数は、元のすべての Promise が確定（fulfilled か rejected）した後に、Promise 状態スナップショットの配列で履行される Promise を返す。実行中、渡された iterable の各要素を Promise に解決する。</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
          1. _promiseResolve_ を Completion(GetPromiseResolve(_C_)) とする。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. _iteratorRecord_ を Completion(GetIterator(_iterable_, ~sync~)) とする。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. _result_ を Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) とする。
          1. もし _result_ が abrupt completion なら
            1. もし _iteratorRecord_.[[Done]] が *false* なら _result_ を Completion(IteratorClose(_iteratorRecord_, _result_)) に設定する。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. ! _result_ を返す。
        </emu-alg>
        <emu-note>
          <p>この関数は *this* 値が Promise コンストラクタのパラメータ規約をサポートするコンストラクタ関数であることを要する。</p>
        </emu-note>

        <emu-clause id="sec-performpromiseallsettled" type="abstract operation">
          <h1>
            PerformPromiseAllSettled (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): 正常完了で ECMAScript 言語値を含むか、または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _values_ を新しい空 List とする。
            1. _remainingElementsCount_ を Record { [[Value]]: 1 } とする。
            1. _index_ を 0 とする。
            1. 繰り返す,
              1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
              1. もし _next_ が ~done~ なら
                1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] - 1 に設定する。
                1. もし _remainingElementsCount_.[[Value]] = 0 なら
                  1. _valuesArray_ を CreateArrayFromList(_values_) とする。
                  1. ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») を実行する。
                1. _resultCapability_.[[Promise]] を返す。
              1. *undefined* を _values_ に追加する。
              1. _nextPromise_ を ? Call(_promiseResolve_, _constructor_, « _next_ ») とする。
              1. _stepsFulfilled_ を <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref> で定義されるアルゴリズム手順とする。
              1. _lengthFulfilled_ を <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref> にある関数定義の省略不可パラメータ数とする。
              1. _onFulfilled_ を CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] ») とする。
              1. _alreadyCalled_ を Record { [[Value]]: *false* } とする。
              1. _onFulfilled_.[[AlreadyCalled]] を _alreadyCalled_ に設定する。
              1. _onFulfilled_.[[Index]] を _index_ に設定する。
              1. _onFulfilled_.[[Values]] を _values_ に設定する。
              1. _onFulfilled_.[[Capability]] を _resultCapability_ に設定する。
              1. _onFulfilled_.[[RemainingElements]] を _remainingElementsCount_ に設定する。
              1. _stepsRejected_ を <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref> で定義されるアルゴリズム手順とする。
              1. _lengthRejected_ を <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref> にある関数定義の省略不可パラメータ数とする。
              1. _onRejected_ を CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] ») とする。
              1. _onRejected_.[[AlreadyCalled]] を _alreadyCalled_ に設定する。
              1. _onRejected_.[[Index]] を _index_ に設定する。
              1. _onRejected_.[[Values]] を _values_ に設定する。
              1. _onRejected_.[[Capability]] を _resultCapability_ に設定する。
              1. _onRejected_.[[RemainingElements]] を _remainingElementsCount_ に設定する。
              1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] + 1 に設定する。
              1. ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _onRejected_ ») を実行する。
              1. _index_ を _index_ + 1 に設定する。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-resolve-element-functions">
          <h1>`Promise.allSettled` Resolve 要素関数 (`Promise.allSettled` Resolve Element Functions)</h1>
          <p>`Promise.allSettled` Resolve 要素関数は特定の `Promise.allSettled` の要素を解決するために使われる匿名組み込み関数である。各 `Promise.allSettled` Resolve 要素関数は [[Index]], [[Values]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 内部スロットを持つ。</p>
          <p>`Promise.allSettled` Resolve 要素関数が引数 _x_ で呼ばれたとき、次を行う:</p>
          <emu-alg>
            1. _F_ をアクティブな関数オブジェクトとする。
            1. _alreadyCalled_ を _F_.[[AlreadyCalled]] とする。
            1. もし _alreadyCalled_.[[Value]] が *true* なら *undefined* を返す。
            1. _alreadyCalled_.[[Value]] を *true* に設定する。
            1. _index_ を _F_.[[Index]] とする。
            1. _values_ を _F_.[[Values]] とする。
            1. _promiseCapability_ を _F_.[[Capability]] とする。
            1. _remainingElementsCount_ を _F_.[[RemainingElements]] とする。
            1. _obj_ を OrdinaryObjectCreate(%Object.prototype%) とする。
            1. ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"fulfilled"*) を実行する。
            1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _x_) を実行する。
            1. _values_[_index_] を _obj_ に設定する。
            1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] - 1 に設定する。
            1. もし _remainingElementsCount_.[[Value]] = 0 なら
              1. _valuesArray_ を CreateArrayFromList(_values_) とする。
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») を返す。
            1. *undefined* を返す。
          </emu-alg>
          <p>`Promise.allSettled` Resolve 要素関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-reject-element-functions">
          <h1>`Promise.allSettled` Reject 要素関数 (`Promise.allSettled` Reject Element Functions)</h1>
          <p>`Promise.allSettled` Reject 要素関数は特定の `Promise.allSettled` の要素を拒否させるために使われる匿名組み込み関数である。各 `Promise.allSettled` Reject 要素関数は [[Index]], [[Values]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 内部スロットを持つ。</p>
          <p>`Promise.allSettled` Reject 要素関数が引数 _x_ で呼ばれたとき、次を行う:</p>
          <emu-alg>
            1. _F_ をアクティブな関数オブジェクトとする。
            1. _alreadyCalled_ を _F_.[[AlreadyCalled]] とする。
            1. もし _alreadyCalled_.[[Value]] が *true* なら *undefined* を返す。
            1. _alreadyCalled_.[[Value]] を *true* に設定する。
            1. _index_ を _F_.[[Index]] とする。
            1. _values_ を _F_.[[Values]] とする。
            1. _promiseCapability_ を _F_.[[Capability]] とする。
            1. _remainingElementsCount_ を _F_.[[RemainingElements]] とする。
            1. _obj_ を OrdinaryObjectCreate(%Object.prototype%) とする。
            1. ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"rejected"*) を実行する。
            1. ! CreateDataPropertyOrThrow(_obj_, *"reason"*, _x_) を実行する。
            1. _values_[_index_] を _obj_ に設定する。
            1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] - 1 に設定する。
            1. もし _remainingElementsCount_.[[Value]] = 0 なら
              1. _valuesArray_ を CreateArrayFromList(_values_) とする。
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») を返す。
            1. *undefined* を返す。
          </emu-alg>
          <p>`Promise.allSettled` Reject 要素関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.any">
        <h1>Promise.any ( _iterable_ )</h1>
        <p>この関数は、最初に fulfilled になった渡された Promise の値で履行されるか、すべてが拒否された場合には拒否理由を保持する `AggregateError` で拒否される Promise を返す。実行中、渡された iterable の各要素を Promise に解決する。</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
          1. _promiseResolve_ を Completion(GetPromiseResolve(_C_)) とする。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. _iteratorRecord_ を Completion(GetIterator(_iterable_, ~sync~)) とする。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. _result_ を Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) とする。
          1. もし _result_ が abrupt completion なら
            1. もし _iteratorRecord_.[[Done]] が *false* なら _result_ を Completion(IteratorClose(_iteratorRecord_, _result_)) に設定する。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. ! _result_ を返す。
        </emu-alg>
        <emu-note>
          <p>この関数は *this* 値が `Promise` コンストラクタのパラメータ規約をサポートするコンストラクタ関数であることを要する。</p>
        </emu-note>

        <emu-clause id="sec-performpromiseany" type="abstract operation">
          <h1>
            PerformPromiseAny (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): 正常完了で ECMAScript 言語値を含むか、または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _errors_ を新しい空 List とする。
            1. _remainingElementsCount_ を Record { [[Value]]: 1 } とする。
            1. _index_ を 0 とする。
            1. 繰り返す,
              1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
              1. もし _next_ が ~done~ なら
                1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] - 1 に設定する。
                1. もし _remainingElementsCount_.[[Value]] = 0 なら
                  1. _error_ を新しく生成された *AggregateError* オブジェクトとする。
                  1. ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }) を実行する。
                  1. Return ThrowCompletion(_error_)。
                1. _resultCapability_.[[Promise]] を返す。
              1. *undefined* を _errors_ に追加する。
              1. _nextPromise_ を ? Call(_promiseResolve_, _constructor_, « _next_ ») とする。
              1. _stepsRejected_ を <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref> で定義されるアルゴリズム手順とする。
              1. _lengthRejected_ を <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref> にある関数定義の省略不可パラメータ数とする。
              1. _onRejected_ を CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] ») とする。
              1. _onRejected_.[[AlreadyCalled]] を *false* に設定する。
              1. _onRejected_.[[Index]] を _index_ に設定する。
              1. _onRejected_.[[Errors]] を _errors_ に設定する。
              1. _onRejected_.[[Capability]] を _resultCapability_ に設定する。
              1. _onRejected_.[[RemainingElements]] を _remainingElementsCount_ に設定する。
              1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] + 1 に設定する。
              1. ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _onRejected_ ») を実行する。
              1. _index_ を _index_ + 1 に設定する。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.any-reject-element-functions">
          <h1>`Promise.any` Reject 要素関数 (`Promise.any` Reject Element Functions)</h1>
          <p>`Promise.any` Reject 要素関数は特定の `Promise.any` 要素を拒否するために使われる匿名組み込み関数である。各 `Promise.any` Reject 要素関数は [[Index]], [[Errors]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 内部スロットを持つ。</p>
          <p>`Promise.any` Reject 要素関数が引数 _x_ で呼ばれたとき、次を行う:</p>
          <emu-alg>
            1. _F_ をアクティブな関数オブジェクトとする。
            1. もし _F_.[[AlreadyCalled]] が *true* なら *undefined* を返す。
            1. _F_.[[AlreadyCalled]] を *true* に設定する。
            1. _index_ を _F_.[[Index]] とする。
            1. _errors_ を _F_.[[Errors]] とする。
            1. _promiseCapability_ を _F_.[[Capability]] とする。
            1. _remainingElementsCount_ を _F_.[[RemainingElements]] とする。
            1. _errors_[_index_] を _x_ に設定する。
            1. _remainingElementsCount_.[[Value]] を _remainingElementsCount_.[[Value]] - 1 に設定する。
            1. もし _remainingElementsCount_.[[Value]] = 0 なら
              1. _error_ を新しく生成された *AggregateError* オブジェクトとする。
              1. ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }) を実行する。
              1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ ») を返す。
            1. *undefined* を返す。
          </emu-alg>
          <p>`Promise.any` Reject 要素関数の *"length"* プロパティは *1*<sub>𝔽</sub> である。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype">
        <h1>Promise.prototype</h1>
        <p>`Promise.prototype` の初期値は Promise プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-promise.race">
        <h1>Promise.race ( _iterable_ )</h1>
        <p>この関数は、渡された Promise 群のうち最初に確定したものと同じ方法で確定する新しい Promise を返す。実行中、渡された _iterable_ の各要素を Promise に解決する。</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
          1. _promiseResolve_ を Completion(GetPromiseResolve(_C_)) とする。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. _iteratorRecord_ を Completion(GetIterator(_iterable_, ~sync~)) とする。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. _result_ を Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) とする。
          1. もし _result_ が abrupt completion なら
            1. もし _iteratorRecord_.[[Done]] が *false* なら _result_ を Completion(IteratorClose(_iteratorRecord_, _result_)) に設定する。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. ! _result_ を返す。
        </emu-alg>
        <emu-note>
          <p>_iterable_ 引数が値を一切生成しないか、生成された Promise がいずれも確定しない場合、このメソッドが返す pending 状態の Promise は確定しないままである。</p>
        </emu-note>
        <emu-note>
          <p>この関数は *this* 値が Promise コンストラクタのパラメータ規約をサポートするコンストラクタ関数であり、かつ *this* 値が `resolve` メソッドを提供することを期待する。</p>
        </emu-note>

        <emu-clause id="sec-performpromiserace" type="abstract operation">
          <h1>
            PerformPromiseRace (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): 正常完了で ECMAScript 言語値を含むか、または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 繰り返す,
              1. _next_ を ? IteratorStepValue(_iteratorRecord_) とする。
              1. もし _next_ が ~done~ なら
                1. _resultCapability_.[[Promise]] を返す。
              1. _nextPromise_ を ? Call(_promiseResolve_, _constructor_, « _next_ ») とする。
              1. ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] ») を実行する。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.reject">
        <h1>Promise.reject ( _r_ )</h1>
        <p>この関数は渡された引数で拒否された新しい Promise を返す。</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
          1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ ») を実行する。
          1. _promiseCapability_.[[Promise]] を返す。
        </emu-alg>
        <emu-note>
          <p>この関数は *this* 値が Promise コンストラクタのパラメータ規約をサポートするコンストラクタ関数であることを期待する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.resolve">
        <h1>Promise.resolve ( _x_ )</h1>
        <p>この関数は、引数がこのコンストラクタによって生成された Promise であればその引数自体を、そうでなければ引数で解決された新しい Promise を返す。</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. もし _C_ が Object でなければ *TypeError* 例外を投げる。
          1. ? PromiseResolve(_C_, _x_) を返す。
        </emu-alg>
        <emu-note>
          <p>この関数は *this* 値が Promise コンストラクタのパラメータ規約をサポートするコンストラクタ関数であることを期待する。</p>
        </emu-note>

        <emu-clause id="sec-promise-resolve" type="abstract operation">
          <h1>
            PromiseResolve (
              _C_: an Object,
              _x_: an ECMAScript language value,
            ): 正常完了で ECMAScript 言語値を含むか、または throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_ で解決された新しい Promise を返す。</dd>
          </dl>
          <emu-alg>
            1. もし IsPromise(_x_) が *true* なら
              1. _xConstructor_ を ? Get(_x_, *"constructor"*) とする。
              1. もし SameValue(_xConstructor_, _C_) が *true* なら _x_ を返す。
            1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
            1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ ») を実行する。
            1. _promiseCapability_.[[Promise]] を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.try">
        <h1>Promise.try ( _callback_, ..._args_ )</h1>
        <p>この関数は呼び出されたとき次の手順を実行する:</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. もし _C_ が Object でなければ *TypeError* 例外を投げる。
          1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
          1. _status_ を Completion(Call(_callback_, *undefined*, _args_)) とする。
          1. もし _status_ が abrupt completion なら
            1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _status_.[[Value]] ») を実行する。
          1. それ以外
            1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _status_.[[Value]] ») を実行する。
          1. _promiseCapability_.[[Promise]] を返す。
        </emu-alg>
        <emu-note>
          <p>この関数は *this* 値が Promise コンストラクタのパラメータ規約をサポートするコンストラクタ関数であることを期待する。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.withResolvers">
        <h1>Promise.withResolvers ( )</h1>
        <p>この関数は 3 つのプロパティ（新しい Promise とそれに結び付けられた `resolve` / `reject` 関数）を持つオブジェクトを返す。</p>
        <emu-alg>
          1. _C_ を *this* 値とする。
          1. _promiseCapability_ を ? NewPromiseCapability(_C_) とする。
          1. _obj_ を OrdinaryObjectCreate(%Object.prototype%) とする。
          1. ! CreateDataPropertyOrThrow(_obj_, *"promise"*, _promiseCapability_.[[Promise]]) を実行する。
          1. ! CreateDataPropertyOrThrow(_obj_, *"resolve"*, _promiseCapability_.[[Resolve]]) を実行する。
          1. ! CreateDataPropertyOrThrow(_obj_, *"reject"*, _promiseCapability_.[[Reject]]) を実行する。
          1. _obj_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-get-promise-@@species" id="sec-get-promise-%symbol.species%">
        <h1>get Promise [ %Symbol.species% ]</h1>
        <p>`Promise[%Symbol.species%]` は set アクセサ関数が *undefined* であるアクセサプロパティであり、get アクセサ関数は呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. *this* 値を返す。
        </emu-alg>
        <p>この関数の *"name"* プロパティの値は *"get [Symbol.species]"* である。</p>
        <emu-note>
          <p>Promise プロトタイプメソッドは通常、派生オブジェクト生成に *this* 値のコンストラクタを使用する。しかしサブクラスコンストラクタはその %Symbol.species% プロパティを再定義することで既定の挙動を上書きできる。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-prototype-object">
      <h1>Promise プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>Promise プロトタイプオブジェクト</dfn> は次の通り:</p>
      <ul>
        <li><dfn>%Promise.prototype%</dfn> である。</li>
        <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
        <li>通常のオブジェクトである。</li>
        <li>[[PromiseState]] 内部スロットや Promise インスタンスの他の内部スロットを持たない。</li>
      </ul>

      <emu-clause id="sec-promise.prototype.catch">
        <h1>Promise.prototype.catch ( _onRejected_ )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _promise_ を *this* 値とする。
          1. Return ? Invoke(_promise_, *"then"*, « *undefined*, _onRejected_ »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.constructor">
        <h1>Promise.prototype.constructor</h1>
        <p>`Promise.prototype.constructor` の初期値は %Promise% である。</p>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.finally" oldids="sec-thenfinallyfunctions,sec-catchfinallyfunctions">
        <h1>Promise.prototype.finally ( _onFinally_ )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _promise_ を *this* 値とする。
          1. もし _promise_ が Object でなければ *TypeError* 例外を投げる。
          1. _C_ を ? SpeciesConstructor(_promise_, %Promise%) とする。
          1. 事前条件: IsConstructor(_C_) は *true* である。
          1. もし IsCallable(_onFinally_) が *false* なら
            1. _thenFinally_ を _onFinally_ とする。
            1. _catchFinally_ を _onFinally_ とする。
          1. それ以外
            1. _thenFinallyClosure_ をパラメータ (_value_) を取り _onFinally_ と _C_ を捕捉し呼び出されると次を行う新たな Abstract Closure とする:
              1. _result_ を ? Call(_onFinally_, *undefined*) とする。
              1. _p_ を ? PromiseResolve(_C_, _result_) とする。
              1. _returnValue_ を引数なしで _value_ を捕捉し呼び出されると次を行う新たな Abstract Closure とし、NormalCompletion(_value_) を返す。
              1. _valueThunk_ を CreateBuiltinFunction(_returnValue_, 0, *""*, « ») とする。
              1. Return ? Invoke(_p_, *"then"*, « _valueThunk_ »).
            1. _thenFinally_ を CreateBuiltinFunction(_thenFinallyClosure_, 1, *""*, « ») とする。
            1. _catchFinallyClosure_ をパラメータ (_reason_) を取り _onFinally_ と _C_ を捕捉し呼び出されると次を行う新たな Abstract Closure とする:
              1. _result_ を ? Call(_onFinally_, *undefined*) とする。
              1. _p_ を ? PromiseResolve(_C_, _result_) とする。
              1. _throwReason_ を引数なしで _reason_ を捕捉し呼び出されると次を行う新たな Abstract Closure とし、Return ThrowCompletion(_reason_)。
              1. _thrower_ を CreateBuiltinFunction(_throwReason_, 0, *""*, « ») とする。
              1. Return ? Invoke(_p_, *"then"*, « _thrower_ »).
            1. _catchFinally_ を CreateBuiltinFunction(_catchFinallyClosure_, 1, *""*, « ») とする。
          1. Return ? Invoke(_promise_, *"then"*, « _thenFinally_, _catchFinally_ »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.then">
        <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _promise_ を *this* 値とする。
          1. もし IsPromise(_promise_) が *false* なら *TypeError* 例外を投げる。
          1. _C_ を ? SpeciesConstructor(_promise_, %Promise%) とする。
          1. _resultCapability_ を ? NewPromiseCapability(_C_) とする。
          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_)。
        </emu-alg>

        <emu-clause id="sec-performpromisethen" type="abstract operation">
          <h1>
            PerformPromiseThen (
              _promise_: a Promise,
              _onFulfilled_: an ECMAScript language value,
              _onRejected_: an ECMAScript language value,
              optional _resultCapability_: a PromiseCapability Record,
            ): an ECMAScript language value
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_promise_ に対し _onFulfilled_ と _onRejected_ を確定時アクションとして “then” 操作を行う。_resultCapability_ が渡された場合、その Promise を更新して結果を格納する。渡されない場合、結果を不要とする仕様内部操作による呼び出しである。</dd>
          </dl>
          <emu-alg>
            1. 事前条件: IsPromise(_promise_) は *true* である。
            1. もし _resultCapability_ が存在しなければ
              1. _resultCapability_ を *undefined* に設定する。
            1. もし IsCallable(_onFulfilled_) が *false* なら
              1. _onFulfilledJobCallback_ を ~empty~ とする。
            1. それ以外
              1. _onFulfilledJobCallback_ を HostMakeJobCallback(_onFulfilled_) とする。
            1. もし IsCallable(_onRejected_) が *false* なら
              1. _onRejectedJobCallback_ を ~empty~ とする。
            1. それ以外
              1. _onRejectedJobCallback_ を HostMakeJobCallback(_onRejected_) とする。
            1. _fulfillReaction_ を PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ } とする。
            1. _rejectReaction_ を PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ } とする。
            1. もし _promise_.[[PromiseState]] が ~pending~ なら
              1. _fulfillReaction_ を _promise_.[[PromiseFulfillReactions]] に追加する。
              1. _rejectReaction_ を _promise_.[[PromiseRejectReactions]] に追加する。
            1. それ以外で _promise_.[[PromiseState]] が ~fulfilled~ なら
              1. _value_ を _promise_.[[PromiseResult]] とする。
              1. _fulfillJob_ を NewPromiseReactionJob(_fulfillReaction_, _value_) とする。
              1. HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]) を実行する。
            1. それ以外
              1. 事前条件: _promise_.[[PromiseState]] は ~rejected~ である。
              1. _reason_ を _promise_.[[PromiseResult]] とする。
              1. もし _promise_.[[PromiseIsHandled]] が *false* なら HostPromiseRejectionTracker(_promise_, *"handle"*) を実行する。
              1. _rejectJob_ を NewPromiseReactionJob(_rejectReaction_, _reason_) とする。
              1. HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]) を実行する。
            1. _promise_.[[PromiseIsHandled]] を *true* に設定する。
            1. もし _resultCapability_ が *undefined* なら
              1. *undefined* を返す。
            1. それ以外
              1. _resultCapability_.[[Promise]] を返す。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-promise.prototype-@@tostringtag" id="sec-promise.prototype-%symbol.tostringtag%">
        <h1>Promise.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"Promise"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-promise-instances">
      <h1>Promise インスタンスのプロパティ</h1>
      <p>Promise インスタンスは（組み込み %Promise.prototype% である）Promise プロトタイプオブジェクトからプロパティを継承する通常のオブジェクトである。Promise インスタンスは <emu-xref href="#table-internal-slots-of-promise-instances"></emu-xref> に記述される内部スロットを持って初期化される。</p>
      <emu-table id="table-internal-slots-of-promise-instances" caption="Promise インスタンスの内部スロット" oldids="table-59">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[PromiseState]]
            </td>
            <td>
              ~pending~, ~fulfilled~, or ~rejected~
            </td>
            <td>
              その `then` メソッドへの呼び出しに対し Promise がどのように反応するかを制御する。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseResult]]
            </td>
            <td>
              ECMAScript 言語値または ~empty~
            </td>
            <td>
              Promise が履行または拒否された値（存在する場合）。~empty~ は [[PromiseState]] が ~pending~ の場合に限り設定される。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseFulfillReactions]]
            </td>
            <td>
              PromiseReaction Record の List
            </td>
            <td>
              ~pending~ から ~fulfilled~ への遷移時（または遷移した場合）に処理されるレコード。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseRejectReactions]]
            </td>
            <td>
              PromiseReaction Record の List
            </td>
            <td>
              ~pending~ から ~rejected~ への遷移時（または遷移した場合）に処理されるレコード。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseIsHandled]]
            </td>
            <td>
              Boolean
            </td>
            <td>
              一度でも履行または拒否ハンドラを持ったことがあるかを示す；未処理拒否の追跡に使用される。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generatorfunction-objects">
    <h1>GeneratorFunction オブジェクト</h1>
    <p>GeneratorFunction は、通常 |GeneratorDeclaration|、|GeneratorExpression|、|GeneratorMethod| を評価することで生成される関数である。また %GeneratorFunction% 組込みを呼び出すことでも生成され得る。</p>
    <emu-figure id="figure-2" caption="Generator オブジェクトの関係" informative>
      <img alt="無数のボックスと矢印。" height="700" src="https://tc39.es/ecma262/img/figure-2.svg" width="900">
    </emu-figure>

    <emu-clause id="sec-generatorfunction-constructor">
      <h1>GeneratorFunction コンストラクタ</h1>
      <p>GeneratorFunction コンストラクタ:</p>
      <ul>
        <li><dfn>%GeneratorFunction%</dfn> である。</li>
        <li>`Function` のサブクラスである。</li>
        <li>コンストラクタとしてではなく関数として呼び出されたとき、新しい GeneratorFunction を生成し初期化する。したがって関数呼び出し `GeneratorFunction (…)` は同じ引数でのオブジェクト生成式 `new GeneratorFunction (…)` と同等である。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された GeneratorFunction の挙動を継承することを意図するサブクラスのコンストラクタは、組込み GeneratorFunction の挙動に必要な内部スロットを持つサブクラスインスタンスを生成・初期化するため、GeneratorFunction コンストラクタへの `super` 呼び出しを含めなければならない。ジェネレータ関数オブジェクトを定義する全ての ECMAScript 構文形式は GeneratorFunction の直接インスタンスを生成する。GeneratorFunction のサブクラスインスタンスを構文的に生成する手段は存在しない。</li>
      </ul>

      <emu-clause id="sec-generatorfunction">
        <h1>GeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最後の引数（もしあれば）がジェネレータ関数の本体（実行コード）を指定し、それ以前の引数が仮引数を指定する。</p>
        <p>この関数は呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _C_ をアクティブな関数オブジェクトとする。
          1. もし _bodyArg_ が存在しなければ _bodyArg_ を空文字列に設定する。
          1. ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_) を返す。
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> の注を参照。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-constructor">
      <h1>GeneratorFunction コンストラクタのプロパティ</h1>
      <p>GeneratorFunction コンストラクタ:</p>
      <ul>
        <li>Function コンストラクタを継承する標準組込み関数オブジェクトである。</li>
        <li>[[Prototype]] 内部スロットの値は %Function% である。</li>
        <li oldids="sec-generatorfunction.length">*"length"* プロパティを持ち、その値は *1*<sub>𝔽</sub> である。</li>
        <li>*"name"* プロパティを持ち、その値は *"GeneratorFunction"* である。</li>
        <li>次のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype">
        <h1>GeneratorFunction.prototype</h1>
        <p>`GeneratorFunction.prototype` の初期値は GeneratorFunction プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-prototype-object">
      <h1>GeneratorFunction プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>GeneratorFunction プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%GeneratorFunction.prototype%</dfn> である (<emu-xref href="#figure-2"></emu-xref> を参照)。</li>
        <li>通常のオブジェクトである。</li>
        <li>関数オブジェクトではなく、<emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> または <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref> に列挙される [[ECMAScriptCode]] 内部スロットやその他の内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロットの値は %Function.prototype% である。</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype.constructor">
        <h1>GeneratorFunction.prototype.constructor</h1>
        <p>`GeneratorFunction.prototype.constructor` の初期値は %GeneratorFunction% である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype.prototype">
        <h1>GeneratorFunction.prototype.prototype</h1>
        <p>`GeneratorFunction.prototype.prototype` の初期値は %GeneratorPrototype% である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-generatorfunction.prototype-@@tostringtag" id="sec-generatorfunction.prototype-%symbol.tostringtag%">
        <h1>GeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"GeneratorFunction"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-generatorfunction-instances">
      <h1>GeneratorFunction インスタンス</h1>
      <p>すべての GeneratorFunction インスタンスは ECMAScript 関数オブジェクトであり、<emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> に列挙される内部スロットを持つ。そのすべてのインスタンスにおける [[IsClassConstructor]] 内部スロットの値は *false* である。</p>
      <p>各 GeneratorFunction インスタンスは次の独自プロパティを持つ:</p>

      <emu-clause id="sec-generatorfunction-instances-length">
        <h1>length</h1>
        <p><emu-xref href="#sec-function-instances-length"></emu-xref> で与えられる Function インスタンスの *"length"* プロパティの仕様は GeneratorFunction インスタンスにも適用される。</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> で与えられる Function インスタンスの *"name"* プロパティの仕様は GeneratorFunction インスタンスにも適用される。</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-prototype">
        <h1>prototype</h1>
        <p>GeneratorFunction インスタンスが生成されるたびに別の通常オブジェクトも生成され、そのジェネレータ関数の *"prototype"* プロパティの初期値となる。prototype プロパティの値は、そのジェネレータ関数オブジェクトが [[Call]] を用いて呼び出されたとき、新たに生成される Generator の [[Prototype]] 内部スロットを初期化するために用いられる。</p>
        <p>このプロパティは属性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
        <emu-note>
          <p>Function インスタンスと異なり、GeneratorFunction の *"prototype"* プロパティの値であるオブジェクトは、その値がその GeneratorFunction インスタンスである *"constructor"* プロパティを持たない。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgeneratorfunction-objects">
    <h1>AsyncGeneratorFunction オブジェクト</h1>
    <p>AsyncGeneratorFunction は、通常 |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |AsyncGeneratorMethod| の構文生成物を評価することで生成される関数である。また %AsyncGeneratorFunction% 組込みを呼び出すことでも生成され得る。</p>

    <emu-clause id="sec-asyncgeneratorfunction-constructor">
      <h1>AsyncGeneratorFunction コンストラクタ</h1>
      <p>AsyncGeneratorFunction コンストラクタ:</p>
      <ul>
        <li><dfn>%AsyncGeneratorFunction%</dfn> である。</li>
        <li>`Function` のサブクラスである。</li>
        <li>コンストラクタとしてではなく関数として呼び出されたとき、新しい AsyncGeneratorFunction を生成し初期化する。したがって関数呼び出し `AsyncGeneratorFunction (...)` は同じ引数でのオブジェクト生成式 `new AsyncGeneratorFunction (...)` と同等である。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された AsyncGeneratorFunction の挙動を継承することを意図するサブクラスのコンストラクタは、組込み AsyncGeneratorFunction の挙動に必要な内部スロットを持つサブクラスインスタンスを生成・初期化するため、AsyncGeneratorFunction コンストラクタへの `super` 呼び出しを含めなければならない。非同期ジェネレータ関数オブジェクトを定義する全ての ECMAScript 構文形式は AsyncGeneratorFunction の直接インスタンスを生成する。AsyncGeneratorFunction サブクラスのインスタンスを構文的に生成する手段は存在しない。</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction">
        <h1>AsyncGeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最後の引数（もしあれば）が非同期ジェネレータ関数の本体（実行コード）を指定し、それ以前の引数が仮引数を指定する。</p>
        <p>この関数は呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _C_ をアクティブな関数オブジェクトとする。
          1. もし _bodyArg_ が存在しなければ _bodyArg_ を空文字列に設定する。
          1. ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_) を返す。
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> の注を参照。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction">
      <h1>AsyncGeneratorFunction コンストラクタのプロパティ</h1>
      <p>AsyncGeneratorFunction コンストラクタ:</p>
      <ul>
        <li>Function コンストラクタを継承する標準組込み関数オブジェクトである。</li>
        <li>[[Prototype]] 内部スロットの値は %Function% である。</li>
        <li oldids="sec-asyncgeneratorfunction-length">*"length"* プロパティを持ち、その値は *1*<sub>𝔽</sub> である。</li>
        <li>*"name"* プロパティを持ち、その値は *"AsyncGeneratorFunction"* である。</li>
        <li>次のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype">
        <h1>AsyncGeneratorFunction.prototype</h1>
        <p>`AsyncGeneratorFunction.prototype` の初期値は AsyncGeneratorFunction プロトタイプオブジェクトである。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction-prototype">
      <h1>AsyncGeneratorFunction プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>AsyncGeneratorFunction プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%AsyncGeneratorFunction.prototype%</dfn> である。</li>
        <li>通常のオブジェクトである。</li>
        <li>関数オブジェクトではなく、<emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> または <emu-xref href="#table-internal-slots-of-asyncgenerator-instances"></emu-xref> に列挙される [[ECMAScriptCode]] 内部スロットやその他の内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロットの値は %Function.prototype% である。</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-constructor">
        <h1>AsyncGeneratorFunction.prototype.constructor</h1>
        <p>`AsyncGeneratorFunction.prototype.constructor` の初期値は %AsyncGeneratorFunction% である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-prototype">
        <h1>AsyncGeneratorFunction.prototype.prototype</h1>
        <p>`AsyncGeneratorFunction.prototype.prototype` の初期値は %AsyncGeneratorPrototype% である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-asyncgeneratorfunction-prototype-tostringtag" id="sec-asyncgeneratorfunction-prototype-%symbol.tostringtag%">
        <h1>AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"AsyncGeneratorFunction"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncgeneratorfunction-instances">
      <h1>AsyncGeneratorFunction インスタンス</h1>
      <p>すべての AsyncGeneratorFunction インスタンスは ECMAScript 関数オブジェクトであり、<emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> に列挙される内部スロットを持つ。そのすべてのインスタンスにおける [[IsClassConstructor]] 内部スロットの値は *false* である。</p>
      <p>各 AsyncGeneratorFunction インスタンスは次の独自プロパティを持つ:</p>

      <emu-clause id="sec-asyncgeneratorfunction-instance-length">
        <h1>length</h1>
        <p>*"length"* プロパティの値は、その AsyncGeneratorFunction が典型的に期待する引数の数を示す整数 Number である。ただし言語仕様上、他の数の引数で呼び出すことも許される。*"length"* プロパティで指定された数以外の引数個数で呼び出された際の動作はその関数に依存する。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> で与えられる Function インスタンスの *"name"* プロパティの仕様は AsyncGeneratorFunction インスタンスにも適用される。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-prototype">
        <h1>prototype</h1>
        <p>AsyncGeneratorFunction インスタンスが生成されるたびに別の通常オブジェクトも生成され、その非同期ジェネレータ関数の *"prototype"* プロパティの初期値となる。prototype プロパティの値は、そのジェネレータ関数オブジェクトが [[Call]] を用いて呼び出されたとき、新たに生成される AsyncGenerator の [[Prototype]] 内部スロットを初期化するために用いられる。</p>
        <p>このプロパティは属性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
        <emu-note>
          <p>関数インスタンスと異なり、AsyncGeneratorFunction の *"prototype"* プロパティの値であるオブジェクトは、その値がその AsyncGeneratorFunction インスタンスである *"constructor"* プロパティを持たない。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-objects">
    <h1>Generator オブジェクト</h1>
    <p>Generator はジェネレータ関数を呼び出すことで生成され、イテレータインタフェースおよび iterable インタフェースの双方に適合する。</p>
    <p>Generator インスタンスは、それを生成したジェネレータ関数の *"prototype"* プロパティ初期値から直接プロパティを継承する。Generator インスタンスは間接的に %GeneratorPrototype% からプロパティを継承する。</p>

    <emu-clause id="sec-properties-of-generator-prototype">
      <h1>%GeneratorPrototype% オブジェクト</h1>
      <p><dfn>%GeneratorPrototype%</dfn> オブジェクト:</p>
      <ul>
        <li><dfn>%GeneratorFunction.prototype.prototype%</dfn> である。</li>
        <li>通常のオブジェクトである。</li>
        <li>Generator インスタンスではなく、[[GeneratorState]] 内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロットの値は %Iterator.prototype% である。</li>
        <li>すべての Generator インスタンスが間接的に継承するプロパティを持つ。</li>
      </ul>

      <emu-clause id="sec-generator.prototype.constructor">
        <h1>%GeneratorPrototype%.constructor</h1>
        <p>%GeneratorPrototype%`.constructor` の初期値は %GeneratorFunction.prototype% である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.next">
        <h1>%GeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. ? GeneratorResume(*this* value, _value_, ~empty~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.return">
        <h1>%GeneratorPrototype%.return ( _value_ )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _g_ を *this* 値とする。
          1. _C_ を ReturnCompletion(_value_) とする。
          1. ? GeneratorResumeAbrupt(_g_, _C_, ~empty~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.throw">
        <h1>%GeneratorPrototype%.throw ( _exception_ )</h1>
        <p>このメソッドは呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _g_ を *this* 値とする。
          1. _C_ を ThrowCompletion(_exception_) とする。
          1. ? GeneratorResumeAbrupt(_g_, _C_, ~empty~) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-generator.prototype-@@tostringtag" id="sec-generator.prototype-%symbol.tostringtag%">
        <h1>%GeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"Generator"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Generator インスタンスのプロパティ</h1>
      <p>Generator インスタンスは <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref> に記述される内部スロットを持って初期化される。</p>
      <emu-table id="table-internal-slots-of-generator-instances" caption="Generator インスタンスの内部スロット" oldids="table-56">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              ~suspended-start~, ~suspended-yield~, ~executing~, or ~completed~
            </td>
            <td>
              ジェネレータの現在の実行状態。
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              実行コンテキスト
            </td>
            <td>
              このジェネレータのコードを実行する際に使用される実行コンテキスト。
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorBrand]]
            </td>
            <td>
              文字列または ~empty~
            </td>
            <td>
              異なる種類のジェネレータを区別するために使用されるブランド。ECMAScript ソーステキストで宣言されたジェネレータの [[GeneratorBrand]] は常に ~empty~ である。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator 抽象操作</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: a Generator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _generator_.[[GeneratorState]] は ~suspended-start~ である。
          1. _genContext_ を実行中の実行コンテキストとする。
          1. _genContext_ の Generator コンポーネントを _generator_ に設定する。
          1. _closure_ を、引数なしで _generatorBody_ を捕捉し、呼び出されると次を行う新たな Abstract Closure とする:
            1. _acGenContext_ を実行中の実行コンテキストとする。
            1. _acGenerator_ を _acGenContext_ の Generator コンポーネントとする。
            1. もし _generatorBody_ が Parse Node なら
              1. _result_ を Completion(Evaluation of _generatorBody_) とする。
            1. それ以外
              1. 事前条件: _generatorBody_ は引数なしの Abstract Closure である。
              1. _result_ を Completion(_generatorBody_()) とする。
            1. 事前条件: ここに戻ってきたとき、ジェネレータは例外を投げたか、暗黙または明示の return を実行している。
            1. _acGenContext_ を実行コンテキストスタックから除去し、スタックトップの実行コンテキストを実行中の実行コンテキストとして復元する。
            1. _acGenerator_.[[GeneratorState]] を ~completed~ に設定する。
            1. 注: ジェネレータが ~completed~ 状態に入ると二度と離れず、その関連実行コンテキストが再開されることはない。_acGenerator_ に関連する任意の実行状態はこの時点で破棄可能。
            1. もし _result_ が normal completion なら
              1. _resultValue_ を *undefined* とする。
            1. それ以外で _result_ が return completion なら
              1. _resultValue_ を _result_.[[Value]] とする。
            1. それ以外
              1. 事前条件: _result_ は throw completion である。
              1. ? _result_ を返す。
            1. NormalCompletion(CreateIteratorResultObject(_resultValue_, *true*)) を返す。
          1. _genContext_ のコード評価状態を、評価が再開されたとき引数なしで _closure_ が呼び出されるように設定する。
          1. _generator_.[[GeneratorContext]] を _genContext_ に設定する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" type="abstract operation">
        <h1>
          GeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): 正常完了で ~suspended-start~, ~suspended-yield~, ~completed~ のいずれかを含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_generator_, [[GeneratorState]]) を実行する。
          1. ? RequireInternalSlot(_generator_, [[GeneratorBrand]]) を実行する。
          1. もし _generator_.[[GeneratorBrand]] が _generatorBrand_ でなければ *TypeError* 例外を投げる。
          1. 事前条件: _generator_ は [[GeneratorContext]] 内部スロットも持つ。
          1. _state_ を _generator_.[[GeneratorState]] とする。
          1. もし _state_ が ~executing~ なら *TypeError* 例外を投げる。
          1. _state_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" type="abstract operation">
        <h1>
          GeneratorResume (
            _generator_: an ECMAScript language value,
            _value_: an ECMAScript language value or ~empty~,
            _generatorBrand_: a String or ~empty~,
          ): 正常完了で ECMAScript 言語値を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _state_ を ? GeneratorValidate(_generator_, _generatorBrand_) とする。
          1. もし _state_ が ~completed~ なら CreateIteratorResultObject(*undefined*, *true*) を返す。
          1. 事前条件: _state_ は ~suspended-start~ または ~suspended-yield~ のいずれか。
          1. _genContext_ を _generator_.[[GeneratorContext]] とする。
          1. _methodContext_ を実行中の実行コンテキストとする。
          1. _methodContext_ をサスペンドする。
          1. _generator_.[[GeneratorState]] を ~executing~ に設定する。
          1. _genContext_ を実行コンテキストスタックにプッシュし、_genContext_ を実行中の実行コンテキストとする。
          1. <emu-meta effects="user-code">_genContext_ のサスペンドされた評価を再開</emu-meta>し、サスペンドを発生させた操作の結果として NormalCompletion(_value_) を用いる。_result_ を再開された計算により返された値とする。
          1. 事前条件: ここに戻るとき、_genContext_ はすでに実行コンテキストスタックから除去され、_methodContext_ が現在の実行中の実行コンテキストである。
          1. ? _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" type="abstract operation">
        <h1>
          GeneratorResumeAbrupt (
            _generator_: an ECMAScript language value,
            _abruptCompletion_: a return completion or a throw completion,
            _generatorBrand_: a String or ~empty~,
          ): 正常完了で ECMAScript 言語値を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _state_ を ? GeneratorValidate(_generator_, _generatorBrand_) とする。
          1. もし _state_ が ~suspended-start~ なら
            1. _generator_.[[GeneratorState]] を ~completed~ に設定する。
            1. 注: ジェネレータが ~completed~ 状態に入ると二度と離れず、その関連実行コンテキストが再開されることはない。_generator_ に関連する任意の実行状態はこの時点で破棄可能。
            1. _state_ を ~completed~ に設定する。
          1. もし _state_ が ~completed~ なら
            1. もし _abruptCompletion_ が return completion なら
              1. CreateIteratorResultObject(_abruptCompletion_.[[Value]], *true*) を返す。
            1. ? _abruptCompletion_ を返す。
          1. 事前条件: _state_ は ~suspended-yield~ である。
          1. _genContext_ を _generator_.[[GeneratorContext]] とする。
          1. _methodContext_ を実行中の実行コンテキストとする。
          1. _methodContext_ をサスペンドする。
          1. _generator_.[[GeneratorState]] を ~executing~ に設定する。
          1. _genContext_ を実行コンテキストスタックにプッシュし、_genContext_ を実行中の実行コンテキストとする。
          1. <emu-meta effects="user-code">_genContext_ のサスペンドされた評価を再開</emu-meta>し、サスペンドを発生させた操作の結果として _abruptCompletion_ を用いる。_result_ を再開された計算により返された Completion Record とする。
          1. 事前条件: ここに戻るとき、_genContext_ はすでに実行コンテキストスタックから除去され、_methodContext_ が現在の実行中の実行コンテキストである。
          1. ? _result_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getgeneratorkind" type="abstract operation">
        <h1>GetGeneratorKind ( ): ~non-generator~, ~sync~, or ~async~</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _genContext_ を実行中の実行コンテキストとする。
          1. もし _genContext_ が Generator コンポーネントを持たなければ ~non-generator~ を返す。
          1. _generator_ を _genContext_ の Generator コンポーネントとする。
          1. もし _generator_ が [[AsyncGeneratorState]] 内部スロットを持てば ~async~ を返す。
          1. それ以外は ~sync~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatoryield" type="abstract operation">
        <h1>
          GeneratorYield (
            _iteratorResult_: an Object that conforms to the IteratorResult interface,
          ): 正常完了で ECMAScript 言語値を含むか、または abrupt completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. _genContext_ を実行中の実行コンテキストとする。
          1. 事前条件: _genContext_ はジェネレータの実行コンテキストである。
          1. _generator_ を _genContext_ の Generator コンポーネントの値とする。
          1. 事前条件: GetGeneratorKind() は ~sync~ である。
          1. _generator_.[[GeneratorState]] を ~suspended-yield~ に設定する。
          1. _genContext_ を実行コンテキストスタックから除去し、スタックトップの実行コンテキストを実行中の実行コンテキストとして復元する。
          1. _callerContext_ を実行中の実行コンテキストとする。
          1. _callerContext_ を再開し NormalCompletion(_iteratorResult_) を渡す。もし _genContext_ が再度再開されるなら、_resumptionValue_ をそれで再開された Completion Record とする。
          1. 事前条件: ここに制御が到達したとき、_genContext_ が再び実行中の実行コンテキストである。
          1. _resumptionValue_ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yield" type="abstract operation">
        <h1>
          Yield (
            _value_: an ECMAScript language value,
          ): 正常完了で ECMAScript 言語値を含むか、または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _generatorKind_ を GetGeneratorKind() とする。
          1. もし _generatorKind_ が ~async~ なら ? AsyncGeneratorYield(? Await(_value_)) を返す。
          1. それ以外は ? GeneratorYield(CreateIteratorResultObject(_value_, *false*)) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createiteratorfromclosure" type="abstract operation">
        <h1>
          CreateIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
            optional _extraSlots_: a List of names of internal slots,
          ): a Generator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 注: _closure_ は IteratorResult オブジェクトを yield するために Yield 操作を使用することができる。
          1. もし _extraSlots_ が存在しなければ _extraSlots_ を新しい空 List に設定する。
          1. _internalSlotsList_ を _extraSlots_ と « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] » のリスト結合とする。
          1. _generator_ を OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_) とする。
          1. _generator_.[[GeneratorBrand]] を _generatorBrand_ に設定する。
          1. _generator_.[[GeneratorState]] を ~suspended-start~ に設定する。
          1. _callerContext_ を実行中の実行コンテキストとする。
          1. _calleeContext_ を新しい実行コンテキストとする。
          1. _calleeContext_ の Function を *null* に設定する。
          1. _calleeContext_ の Realm を現在の Realm Record に設定する。
          1. _calleeContext_ の ScriptOrModule を _callerContext_ の ScriptOrModule に設定する。
          1. もし _callerContext_ がまだサスペンドされていなければ _callerContext_ をサスペンドする。
          1. _calleeContext_ を実行コンテキストスタックにプッシュし、_calleeContext_ を実行中の実行コンテキストとする。
          1. GeneratorStart(_generator_, _closure_) を実行する。
          1. _calleeContext_ を実行コンテキストスタックから除去し、_callerContext_ を実行中の実行コンテキストとして復元する。
          1. _generator_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator オブジェクト</h1>
    <p>AsyncGenerator は非同期ジェネレータ関数を呼び出すことで生成され、非同期イテレータインタフェースおよび非同期 iterable インタフェースの双方に適合する。</p>

    <p>AsyncGenerator インスタンスは、それを生成した非同期ジェネレータ関数の *"prototype"* プロパティ初期値から直接プロパティを継承し、間接的に %AsyncGeneratorPrototype% からプロパティを継承する。</p>

    <emu-clause id="sec-properties-of-asyncgenerator-prototype">
      <h1>%AsyncGeneratorPrototype% オブジェクト</h1>
      <p><dfn>%AsyncGeneratorPrototype%</dfn> オブジェクト:</p>
      <ul>
        <li><dfn>%AsyncGeneratorFunction.prototype.prototype%</dfn> である。</li>
        <li>通常のオブジェクトである。</li>
        <li>AsyncGenerator インスタンスではなく、[[AsyncGeneratorState]] 内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロットの値は %AsyncIteratorPrototype% である。</li>
        <li>すべての AsyncGenerator インスタンスが間接的に継承するプロパティを持つ。</li>
      </ul>

      <emu-clause id="sec-asyncgenerator-prototype-constructor">
        <h1>%AsyncGeneratorPrototype%.constructor</h1>
        <p>%AsyncGeneratorPrototype%`.constructor` の初期値は %AsyncGeneratorFunction.prototype% である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-next">
        <h1>%AsyncGeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. _generator_ を *this* 値とする。
          1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
          1. _result_ を Completion(AsyncGeneratorValidate(_generator_, ~empty~)) とする。
          1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. _state_ を _generator_.[[AsyncGeneratorState]] とする。
          1. もし _state_ が ~completed~ なら
            1. _iteratorResult_ を CreateIteratorResultObject(*undefined*, *true*) とする。
            1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ ») を実行する。
            1. _promiseCapability_.[[Promise]] を返す。
          1. _completion_ を NormalCompletion(_value_) とする。
          1. AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_) を実行する。
          1. もし _state_ が ~suspended-start~ または ~suspended-yield~ のいずれかなら
            1. AsyncGeneratorResume(_generator_, _completion_) を実行する。
          1. それ以外
            1. 事前条件: _state_ は ~executing~ または ~draining-queue~ のいずれか。
          1. _promiseCapability_.[[Promise]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-return">
        <h1>%AsyncGeneratorPrototype%.return ( _value_ )</h1>
        <emu-alg>
          1. _generator_ を *this* 値とする。
          1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
          1. _result_ を Completion(AsyncGeneratorValidate(_generator_, ~empty~)) とする。
          1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. _completion_ を ReturnCompletion(_value_) とする。
          1. AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_) を実行する。
          1. _state_ を _generator_.[[AsyncGeneratorState]] とする。
          1. もし _state_ が ~suspended-start~ あるいは ~completed~ のいずれかなら
            1. _generator_.[[AsyncGeneratorState]] を ~draining-queue~ に設定する。
            1. AsyncGeneratorAwaitReturn(_generator_) を実行する。
          1. それ以外で _state_ が ~suspended-yield~ なら
            1. AsyncGeneratorResume(_generator_, _completion_) を実行する。
          1. それ以外
            1. 事前条件: _state_ は ~executing~ または ~draining-queue~ のいずれか。
          1. _promiseCapability_.[[Promise]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-throw">
        <h1>%AsyncGeneratorPrototype%.throw ( _exception_ )</h1>
        <emu-alg>
          1. _generator_ を *this* 値とする。
          1. _promiseCapability_ を ! NewPromiseCapability(%Promise%) とする。
          1. _result_ を Completion(AsyncGeneratorValidate(_generator_, ~empty~)) とする。
          1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. _state_ を _generator_.[[AsyncGeneratorState]] とする。
          1. もし _state_ が ~suspended-start~ なら
            1. _generator_.[[AsyncGeneratorState]] を ~completed~ に設定する。
            1. _state_ を ~completed~ に設定する。
          1. もし _state_ が ~completed~ なら
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ ») を実行する。
            1. _promiseCapability_.[[Promise]] を返す。
          1. _completion_ を ThrowCompletion(_exception_) とする。
          1. AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_) を実行する。
          1. もし _state_ が ~suspended-yield~ なら
            1. AsyncGeneratorResume(_generator_, _completion_) を実行する。
          1. それ以外
            1. 事前条件: _state_ は ~executing~ または ~draining-queue~ のいずれか。
          1. _promiseCapability_.[[Promise]] を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-asyncgenerator-prototype-tostringtag" id="sec-asyncgenerator-prototype-%symbol.tostringtag%">
        <h1>%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"AsyncGenerator"* である。</p>
        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>AsyncGenerator インスタンスのプロパティ</h1>
      <p>AsyncGenerator インスタンスは初期化時に以下の内部スロットを持つ:</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="AsyncGenerator インスタンスの内部スロット">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>~suspended-start~, ~suspended-yield~, ~executing~, ~draining-queue~, or ~completed~</td>
            <td>非同期ジェネレータの現在の実行状態。</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>an execution context</td>
            <td>この非同期ジェネレータのコードを実行する際に用いる実行コンテキスト。</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>a List of AsyncGeneratorRequest Records</td>
            <td>非同期ジェネレータ再開要求を表すレコード。状態遷移中を除き、[[AsyncGeneratorState]] が ~executing~ または ~draining-queue~ の場合に限り非空。</td>
          </tr>
          <tr>
            <td>[[GeneratorBrand]]</td>
            <td>a String or ~empty~</td>
            <td>異なる種類の非同期ジェネレータを識別するブランド。ECMAScript ソースで宣言されたものの [[GeneratorBrand]] は常に ~empty~。</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator 抽象操作</h1>

      <emu-clause id="sec-asyncgeneratorrequest-records">
        <h1>AsyncGeneratorRequest レコード</h1>
        <p><dfn variants="AsyncGeneratorRequests">AsyncGeneratorRequest</dfn> は、非同期ジェネレータをどのように再開すべきかの情報を保持し、対応する promise を履行または拒否するためのケイパビリティを含む Record 値である。</p>
        <p>以下のフィールドを持つ:</p>
        <emu-table caption="AsyncGeneratorRequest Record フィールド">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Completion]]</td>
              <td>a Completion Record</td>
              <td>非同期ジェネレータを再開する際に使用すべき Completion Record。</td>
            </tr>
            <tr>
              <td>[[Capability]]</td>
              <td>a PromiseCapability Record</td>
              <td>この要求に関連付けられた promise ケイパビリティ。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _generator_.[[AsyncGeneratorState]] は ~suspended-start~。
          1. _genContext_ を実行中の実行コンテキストとする。
          1. _genContext_ の Generator コンポーネントを _generator_ に設定する。
          1. _closure_ を、引数なしで _generatorBody_ を捕捉し、呼び出されると次を行う新たな Abstract Closure とする:
            1. _acGenContext_ を実行中の実行コンテキストとする。
            1. _acGenerator_ を _acGenContext_ の Generator コンポーネントとする。
            1. もし _generatorBody_ が Parse Node なら
              1. _result_ を Completion(Evaluation of _generatorBody_) とする。
            1. それ以外
              1. 事前条件: _generatorBody_ は引数なしの Abstract Closure。
              1. _result_ を Completion(_generatorBody_()) とする。
            1. 事前条件: ここに戻るとき、非同期ジェネレータは例外送出または暗黙/明示の return を行っている。
            1. _acGenContext_ を実行コンテキストスタックから除去し、スタック頂上の実行コンテキストを実行中として復元する。
            1. _acGenerator_.[[AsyncGeneratorState]] を ~draining-queue~ に設定する。
            1. もし _result_ が normal completion なら _result_ を NormalCompletion(*undefined*) に設定する。
            1. もし _result_ が return completion なら _result_ を NormalCompletion(_result_.[[Value]]) に設定する。
            1. AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*) を実行する。
            1. AsyncGeneratorDrainQueue(_acGenerator_) を実行する。
            1. NormalCompletion(*undefined*) を返す。
          1. _genContext_ のコード評価状態を、再開時に引数なしで _closure_ が呼ばれるよう設定する。
          1. _generator_.[[AsyncGeneratorContext]] を _genContext_ に設定する。
          1. _generator_.[[AsyncGeneratorQueue]] を新しい空の List に設定する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorvalidate" type="abstract operation">
        <h1>
          AsyncGeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): 正常完了で ~unused~ を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]) を実行。
          1. ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]) を実行。
          1. ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]) を実行。
          1. もし _generator_.[[GeneratorBrand]] が _generatorBrand_ でなければ *TypeError* 例外を投げる。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorenqueue" type="abstract operation">
        <h1>
          AsyncGeneratorEnqueue (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _promiseCapability_: a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _request_ を AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ } とする。
          1. _request_ を _generator_.[[AsyncGeneratorQueue]] に追加する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorcompletestep" type="abstract operation">
        <h1>
          AsyncGeneratorCompleteStep (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _done_: a Boolean,
            optional _realm_: a Realm Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _generator_.[[AsyncGeneratorQueue]] は空でない。
          1. _next_ を _generator_.[[AsyncGeneratorQueue]] の先頭要素とする。
          1. 先頭要素を _generator_.[[AsyncGeneratorQueue]] から除去する。
          1. _promiseCapability_ を _next_.[[Capability]] とする。
          1. _value_ を _completion_.[[Value]] とする。
          1. もし _completion_ が throw completion なら
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ ») を実行する。
          1. それ以外
            1. 事前条件: _completion_ は normal completion。
            1. もし _realm_ が存在すれば
              1. _oldRealm_ を実行中の実行コンテキストの Realm とする。
              1. 実行中の実行コンテキストの Realm を _realm_ に設定する。
              1. _iteratorResult_ を CreateIteratorResultObject(_value_, _done_) とする。
              1. 実行中の実行コンテキストの Realm を _oldRealm_ に戻す。
            1. それ以外
              1. _iteratorResult_ を CreateIteratorResultObject(_value_, _done_) とする。
            1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ ») を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresume" type="abstract operation">
        <h1>
          AsyncGeneratorResume (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _generator_.[[AsyncGeneratorState]] は ~suspended-start~ か ~suspended-yield~ のいずれか。
          1. _genContext_ を _generator_.[[AsyncGeneratorContext]] とする。
          1. _callerContext_ を実行中の実行コンテキストとする。
          1. _callerContext_ をサスペンドする。
          1. _generator_.[[AsyncGeneratorState]] を ~executing~ に設定する。
          1. _genContext_ を実行コンテキストスタックにプッシュし、実行中の実行コンテキストとする。
          1. <emu-meta effects="user-code">_genContext_ のサスペンドされた評価を再開</emu-meta>し、サスペンドを引き起こした操作の結果として _completion_ を用いる。_result_ を再開計算が返す Completion Record とする。
          1. 事前条件: _result_ は abrupt completion にはならない。
          1. 事前条件: ここに戻るとき _genContext_ はスタックから除去され、_callerContext_ が実行中。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorunwrapyieldresumption" type="abstract operation">
        <h1>
          AsyncGeneratorUnwrapYieldResumption (
            _resumptionValue_: a Completion Record,
          ): 正常完了で ECMAScript 言語値を含むか、または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. もし _resumptionValue_ が return completion でなければ ? _resumptionValue_ を返す。
          1. _awaited_ を Completion(Await(_resumptionValue_.[[Value]])) とする。
          1. もし _awaited_ が throw completion なら ? _awaited_ を返す。
          1. 事前条件: _awaited_ は normal completion。
          1. Return ReturnCompletion(_awaited_.[[Value]])。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratoryield" type="abstract operation">
        <h1>
          AsyncGeneratorYield (
            _value_: an ECMAScript language value,
          ): 正常完了で ECMAScript 言語値を含むか、または abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _genContext_ を実行中の実行コンテキストとする。
          1. 事前条件: _genContext_ はジェネレータの実行コンテキスト。
          1. _generator_ を _genContext_ の Generator コンポーネントの値とする。
          1. 事前条件: GetGeneratorKind() は ~async~。
          1. _completion_ を NormalCompletion(_value_) とする。
          1. 事前条件: 実行コンテキストスタックは少なくとも 2 要素を持つ。
          1. _previousContext_ をスタック二番目の要素とする。
          1. _previousRealm_ を _previousContext_ の Realm とする。
          1. AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_) を実行する。
          1. _queue_ を _generator_.[[AsyncGeneratorQueue]] とする。
          1. もし _queue_ が空でないなら
            1. 注: ジェネレータをサスペンドせず実行継続。
            1. _toYield_ を _queue_ の先頭要素とする。
            1. _resumptionValue_ を Completion(_toYield_.[[Completion]]) とする。
            1. ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_) を返す。
          1. それ以外
            1. _generator_.[[AsyncGeneratorState]] を ~suspended-yield~ に設定する。
            1. _genContext_ を実行コンテキストスタックから除去し、頂上の実行コンテキストを実行中として復元する。
            1. _callerContext_ を実行中の実行コンテキストとする。
            1. _callerContext_ を *undefined* を渡して再開する。もし _genContext_ が再度再開されるなら _resumptionValue_ をその Completion Record とする。
            1. 事前条件: ここに到達したとき _genContext_ が再び実行中。
            1. ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_) を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorawaitreturn" type="abstract operation">
        <h1>
          AsyncGeneratorAwaitReturn (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 事前条件: _generator_.[[AsyncGeneratorState]] は ~draining-queue~。
          1. _queue_ を _generator_.[[AsyncGeneratorQueue]] とする。
          1. 事前条件: _queue_ は空でない。
          1. _next_ を _queue_ の先頭要素とする。
          1. _completion_ を Completion(_next_.[[Completion]]) とする。
          1. 事前条件: _completion_ は return completion。
          1. _promiseCompletion_ を Completion(PromiseResolve(%Promise%, _completion_.[[Value]])) とする。
          1. もし _promiseCompletion_ が abrupt completion なら
            1. AsyncGeneratorCompleteStep(_generator_, _promiseCompletion_, *true*) を実行。
            1. AsyncGeneratorDrainQueue(_generator_) を実行。
            1. ~unused~ を返す。
          1. 事前条件: _promiseCompletion_ は normal completion。
          1. _promise_ を _promiseCompletion_.[[Value]] とする。
          1. _fulfilledClosure_ をパラメータ (_value_) を取り _generator_ を捕捉し呼び出されると次を行う新たな Abstract Closure とする:
            1. 事前条件: _generator_.[[AsyncGeneratorState]] は ~draining-queue~。
            1. _result_ を NormalCompletion(_value_) とする。
            1. AsyncGeneratorCompleteStep(_generator_, _result_, *true*) を実行。
            1. AsyncGeneratorDrainQueue(_generator_) を実行。
            1. NormalCompletion(*undefined*) を返す。
          1. _onFulfilled_ を CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « ») とする。
          1. _rejectedClosure_ をパラメータ (_reason_) を取り _generator_ を捕捉し呼び出されると次を行う新たな Abstract Closure とする:
            1. 事前条件: _generator_.[[AsyncGeneratorState]] は ~draining-queue~。
            1. _result_ を ThrowCompletion(_reason_) とする。
            1. AsyncGeneratorCompleteStep(_generator_, _result_, *true*) を実行。
            1. AsyncGeneratorDrainQueue(_generator_) を実行。
            1. NormalCompletion(*undefined*) を返す。
          1. _onRejected_ を CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « ») とする。
          1. PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratordrainqueue" type="abstract operation">
        <h1>
          AsyncGeneratorDrainQueue (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>AsyncGeneratorQueue を、return completion を保持する AsyncGeneratorRequest に遭遇するまで処理する。</dd>
        </dl>
        <emu-alg>
          1. 事前条件: _generator_.[[AsyncGeneratorState]] は ~draining-queue~。
          1. _queue_ を _generator_.[[AsyncGeneratorQueue]] とする。
          1. _queue_ が空でない間繰り返す,
            1. _next_ を _queue_ の先頭要素とする。
            1. _completion_ を Completion(_next_.[[Completion]]) とする。
            1. もし _completion_ が return completion なら
              1. AsyncGeneratorAwaitReturn(_generator_) を実行。
              1. ~unused~ を返す。
            1. それ以外
              1. もし _completion_ が normal completion なら
                1. _completion_ を NormalCompletion(*undefined*) に設定。
              1. AsyncGeneratorCompleteStep(_generator_, _completion_, *true*) を実行。
          1. _generator_.[[AsyncGeneratorState]] を ~completed~ に設定。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createasynciteratorfromclosure" type="abstract operation">
        <h1>
          CreateAsyncIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): an AsyncGenerator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 注: _closure_ は Await 操作および IteratorResult オブジェクトを yield するための Yield 操作を含み得る。
          1. _internalSlotsList_ を « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] » とする。
          1. _generator_ を OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_) とする。
          1. _generator_.[[GeneratorBrand]] を _generatorBrand_ に設定する。
          1. _generator_.[[AsyncGeneratorState]] を ~suspended-start~ に設定する。
          1. _callerContext_ を実行中の実行コンテキストとする。
          1. _calleeContext_ を新しい実行コンテキストとする。
          1. _calleeContext_ の Function を *null* に設定する。
          1. _calleeContext_ の Realm を現在の Realm Record に設定する。
          1. _calleeContext_ の ScriptOrModule を _callerContext_ の ScriptOrModule に設定する。
          1. もし _callerContext_ がまだサスペンドされていなければ _callerContext_ をサスペンドする。
          1. _calleeContext_ を実行コンテキストスタックにプッシュし、実行中の実行コンテキストとする。
          1. AsyncGeneratorStart(_generator_, _closure_) を実行する。
          1. _calleeContext_ を実行コンテキストスタックから除去し、_callerContext_ を実行中として復元する。
          1. _generator_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-objects">
    <h1>AsyncFunction オブジェクト</h1>
    <p>AsyncFunction は通常 |AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncMethod|、|AsyncArrowFunction| を評価することで生成される。%AsyncFunction% 組込みを呼び出すことでも生成され得る。</p>

    <emu-clause id="sec-async-function-constructor">
      <h1>AsyncFunction コンストラクタ</h1>

      <p>AsyncFunction コンストラクタ:</p>
      <ul>
        <li><dfn>%AsyncFunction%</dfn> である。</li>
        <li>`Function` のサブクラスである。</li>
        <li>コンストラクタではなく関数として呼び出されたとき新しい AsyncFunction を生成し初期化する。したがって関数呼び出し `AsyncFunction(…)` は同じ引数での `new AsyncFunction(…)` と同等。</li>
        <li>クラス定義の `extends` 句の値として使用できる。指定された AsyncFunction の挙動を継承するサブクラスコンストラクタは、組込み非同期関数挙動に必要な内部スロットを備えたサブクラスインスタンスを生成・初期化するため AsyncFunction コンストラクタへの `super` 呼び出しを含めなければならない。非同期関数オブジェクトを定義する全ての構文形式は AsyncFunction の直接インスタンスを生成する。AsyncFunction サブクラスインスタンスを構文的に生成する手段はない。</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-arguments">
        <h1>AsyncFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最後の引数（存在する場合）が非同期関数の本体（実行コード）を指定し、それ以前の引数が仮引数を指定する。</p>
        <p>この関数は呼び出されると次を実行する:</p>

        <emu-alg>
          1. _C_ をアクティブな関数オブジェクトとする。
          1. もし _bodyArg_ が存在しなければ _bodyArg_ を空文字列に設定する。
          1. ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_) を返す。
        </emu-alg>

        <emu-note><emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> の注参照。</emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-constructor-properties">
      <h1>AsyncFunction コンストラクタのプロパティ</h1>

      <p>AsyncFunction コンストラクタ:</p>
      <ul>
        <li>Function コンストラクタを継承する標準組込み関数オブジェクトである。</li>
        <li>[[Prototype]] 内部スロットの値は %Function% である。</li>
        <li oldids="sec-async-function-constructor-length">*"length"* プロパティを持ち、その値は *1*<sub>𝔽</sub> である。</li>
        <li>*"name"* プロパティを持ち、その値は *"AsyncFunction"* である。</li>
        <li>次のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-prototype">
        <h1>AsyncFunction.prototype</h1>
        <p>`AsyncFunction.prototype` の初期値は AsyncFunction プロトタイプオブジェクトである。</p>

        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-prototype-properties">
      <h1>AsyncFunction プロトタイプオブジェクトのプロパティ</h1>
      <p><dfn>AsyncFunction プロトタイプオブジェクト</dfn>:</p>
      <ul>
        <li><dfn>%AsyncFunction.prototype%</dfn> である。</li>
        <li>通常のオブジェクトである。</li>
        <li>関数オブジェクトではなく、<emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> に列挙される [[ECMAScriptCode]] 内部スロットや他の内部スロットを持たない。</li>
        <li>[[Prototype]] 内部スロットの値は %Function.prototype% である。</li>
      </ul>

      <emu-clause id="sec-async-function-prototype-properties-constructor">
        <h1>AsyncFunction.prototype.constructor</h1>

        <p>`AsyncFunction.prototype.constructor` の初期値は %AsyncFunction% である。</p>

        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>

      <emu-clause oldids="sec-async-function-prototype-properties-toStringTag" id="sec-async-function-prototype-%symbol.tostringtag%">
        <h1>AsyncFunction.prototype [ %Symbol.toStringTag% ]</h1>

        <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"AsyncFunction"* である。</p>

        <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-instances">
      <h1>AsyncFunction インスタンス</h1>

      <p>すべての AsyncFunction インスタンスは ECMAScript 関数オブジェクトであり、<emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> に列挙される内部スロットを持つ。これらのインスタンスの [[IsClassConstructor]] 内部スロット値は *false*。AsyncFunction インスタンスはコンストラクタではなく [[Construct]] 内部メソッドを持たない。また構築不可能であるため prototype プロパティを持たない。</p>
      <p>各 AsyncFunction インスタンスは次の独自プロパティを持つ:</p>

      <emu-clause id="sec-async-function-instances-length">
        <h1>length</h1>
        <p><emu-xref href="#sec-function-instances-length"></emu-xref> で与えられる Function インスタンスの *"length"* プロパティ仕様は AsyncFunction インスタンスにも適用される。</p>
      </emu-clause>

      <emu-clause id="sec-async-function-instances-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> で与えられる Function インスタンスの *"name"* プロパティ仕様は AsyncFunction インスタンスにも適用される。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-functions-abstract-operations">
      <h1>Async Function 抽象操作</h1>

      <emu-clause id="sec-async-functions-abstract-operations-async-function-start" type="abstract operation">
        <h1>
          AsyncFunctionStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncFunctionBody_: a |FunctionBody| Parse Node, an |ExpressionBody| Parse Node, or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _runningContext_ を実行中の実行コンテキストとする。
          1. _asyncContext_ を _runningContext_ のコピーとする。
          1. 注: 現在実行中のコンテキストを再開することは未定義であるため、AsyncBlockStart が再開できるよう実行状態のコピーが必要。
          1. AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_) を実行する。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncblockstart" type="abstract operation">
        <h1>
          AsyncBlockStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncBody_: a Parse Node or an Abstract Closure with no parameters,
            _asyncContext_: an execution context,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _runningContext_ を実行中の実行コンテキストとする。
          1. _closure_ を、引数なしで _promiseCapability_ と _asyncBody_ を捕捉し呼び出されると次を行う新たな Abstract Closure とする:
            1. _acAsyncContext_ を実行中の実行コンテキストとする。
            1. もし _asyncBody_ が Parse Node なら
              1. _result_ を Completion(Evaluation of _asyncBody_) とする。
            1. それ以外
              1. 事前条件: _asyncBody_ は引数なしの Abstract Closure。
              1. _result_ を Completion(_asyncBody_()) とする。
            1. 事前条件: ここに戻るとき非同期関数は例外送出か暗黙/明示の return を行っており、全ての await は完了。
            1. _acAsyncContext_ を実行コンテキストスタックから除去し、頂上の実行コンテキストを実行中として復元。
            1. もし _result_ が normal completion なら
              1. ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* ») を実行。
            1. それ以外で _result_ が return completion なら
              1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] ») を実行。
            1. それ以外
              1. 事前条件: _result_ は throw completion。
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] ») を実行。
            1. [id="step-asyncblockstart-return-undefined"] NormalCompletion(~unused~) を返す。
          1. _asyncContext_ のコード評価状態を、再開時に引数なしで _closure_ が呼ばれるよう設定。
          1. _asyncContext_ を実行コンテキストスタックにプッシュし実行中とする。
          1. <emu-meta effects="user-code">_asyncContext_ のサスペンドされた評価を再開</emu-meta>。_result_ を再開計算が返した値とする。
          1. 事前条件: ここに戻るとき _asyncContext_ はスタックから除去され _runningContext_ が実行中。
          1. 事前条件: _result_ は値 ~unused~ を持つ normal completion。値の起源は Await か（await が無い場合）上記 <emu-xref href="#step-asyncblockstart-return-undefined"></emu-xref>。
          1. ~unused~ を返す。
        </emu-alg>
      </emu-clause>

      <emu-clause id="await" oldids="await-fulfilled,await-rejected" type="abstract operation">
        <h1>
          Await (
            _value_: an ECMAScript language value,
          ): 正常完了で ECMAScript 言語値または ~empty~ を含むか、または throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _asyncContext_ を実行中の実行コンテキストとする。
          1. _promise_ を ? PromiseResolve(%Promise%, _value_) とする。
          1. _fulfilledClosure_ をパラメータ (_v_) を取り _asyncContext_ を捕捉し呼び出されると次を行う新たな Abstract Closure とする:
            1. _prevContext_ を実行中の実行コンテキストとする。
            1. _prevContext_ をサスペンドする。
            1. _asyncContext_ を実行コンテキストスタックにプッシュし実行中とする。
            1. <emu-meta effects="user-code">_asyncContext_ のサスペンドされた評価を再開</emu-meta>し、サスペンドを発生させた操作の結果として NormalCompletion(_v_) を用いる。
            1. 事前条件: この段階で _asyncContext_ はスタックから除去され _prevContext_ が実行中。
            1. NormalCompletion(*undefined*) を返す。
          1. _onFulfilled_ を CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « ») とする。
          1. _rejectedClosure_ をパラメータ (_reason_) を取り _asyncContext_ を捕捉し呼び出されると次を行う新たな Abstract Closure とする:
            1. _prevContext_ を実行中の実行コンテキストとする。
            1. _prevContext_ をサスペンドする。
            1. _asyncContext_ を実行コンテキストスタックにプッシュし実行中とする。
            1. <emu-meta effects="user-code">_asyncContext_ のサスペンドされた評価を再開</emu-meta>し、サスペンドを発生させた操作の結果として ThrowCompletion(_reason_) を用いる。
            1. 事前条件: この段階で _asyncContext_ はスタックから除去され _prevContext_ が実行中。
            1. NormalCompletion(*undefined*) を返す。
          1. _onRejected_ を CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « ») とする。
          1. PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_) を実行する。
          1. _asyncContext_ を実行コンテキストスタックから除去し、頂上の実行コンテキストを実行中として復元する。
          1. _callerContext_ を実行中の実行コンテキストとする。
          1. _callerContext_ を ~empty~ を渡して再開する。もし _asyncContext_ が再度再開されるなら _completion_ をその Completion Record とする。
          1. 事前条件: ここに到達したとき _asyncContext_ が再び実行中。
          1. _completion_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection">
  <h1>リフレクション (Reflection)</h1>

  <emu-clause id="sec-reflect-object">
    <h1>Reflect オブジェクト (The Reflect Object)</h1>
    <p>Reflect オブジェクト:</p>
    <ul>
      <li><dfn>%Reflect%</dfn> である。</li>
      <li>グローバルオブジェクトの *"Reflect"* プロパティの初期値である。</li>
      <li>通常のオブジェクトである。</li>
      <li>[[Prototype]] 内部スロットの値は %Object.prototype% である。</li>
      <li>関数オブジェクトではない。</li>
      <li>[[Construct]] 内部メソッドを持たない；`new` 演算子でコンストラクタとして使用できない。</li>
      <li>[[Call]] 内部メソッドを持たない；関数として呼び出すことはできない。</li>
    </ul>

    <emu-clause id="sec-reflect.apply">
      <h1>Reflect.apply ( _target_, _thisArgument_, _argumentsList_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし IsCallable(_target_) が *false* なら *TypeError* 例外を投げる。
        1. _args_ を ? CreateListFromArrayLike(_argumentsList_) とする。
        1. PrepareForTailCall() を実行する。
        1. ? Call(_target_, _thisArgument_, _args_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.construct">
      <h1>Reflect.construct ( _target_, _argumentsList_ [ , _newTarget_ ] )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし IsConstructor(_target_) が *false* なら *TypeError* 例外を投げる。
        1. もし _newTarget_ が存在しなければ _newTarget_ を _target_ に設定する。
        1. それ以外で IsConstructor(_newTarget_) が *false* なら *TypeError* 例外を投げる。
        1. _args_ を ? CreateListFromArrayLike(_argumentsList_) とする。
        1. ? Construct(_target_, _args_, _newTarget_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.defineproperty">
      <h1>Reflect.defineProperty ( _target_, _propertyKey_, _attributes_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. _key_ を ? ToPropertyKey(_propertyKey_) とする。
        1. _desc_ を ? ToPropertyDescriptor(_attributes_) とする。
        1. ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_key_, _desc_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.deleteproperty">
      <h1>Reflect.deleteProperty ( _target_, _propertyKey_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. _key_ を ? ToPropertyKey(_propertyKey_) とする。
        1. ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_key_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.get">
      <h1>Reflect.get ( _target_, _propertyKey_ [ , _receiver_ ] )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. _key_ を ? ToPropertyKey(_propertyKey_) とする。
        1. もし _receiver_ が存在しなければ
          1. _receiver_ を _target_ に設定する。
        1. ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_key_, _receiver_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getownpropertydescriptor">
      <h1>Reflect.getOwnPropertyDescriptor ( _target_, _propertyKey_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. _key_ を ? ToPropertyKey(_propertyKey_) とする。
        1. _desc_ を ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_) とする。
        1. FromPropertyDescriptor(_desc_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getprototypeof">
      <h1>Reflect.getPrototypeOf ( _target_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]()</emu-meta> を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.has">
      <h1>Reflect.has ( _target_, _propertyKey_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. _key_ を ? ToPropertyKey(_propertyKey_) とする。
        1. ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_key_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.isextensible">
      <h1>Reflect.isExtensible ( _target_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. ? <emu-meta effects="user-code">_target_.[[IsExtensible]]()</emu-meta> を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.ownkeys">
      <h1>Reflect.ownKeys ( _target_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. _keys_ を ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> とする。
        1. CreateArrayFromList(_keys_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.preventextensions">
      <h1>Reflect.preventExtensions ( _target_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta> を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.set">
      <h1>Reflect.set ( _target_, _propertyKey_, _V_ [ , _receiver_ ] )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. _key_ を ? ToPropertyKey(_propertyKey_) とする。
        1. もし _receiver_ が存在しなければ
          1. _receiver_ を _target_ に設定する。
        1. ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_key_, _V_, _receiver_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.setprototypeof">
      <h1>Reflect.setPrototypeOf ( _target_, _proto_ )</h1>
      <p>この関数は呼び出されると次の手順を実行する:</p>
      <emu-alg>
        1. もし _target_ が Object でなければ *TypeError* 例外を投げる。
        1. もし _proto_ が Object でなく かつ _proto_ が *null* でなければ *TypeError* 例外を投げる。
        1. ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_proto_) を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-reflect-@@tostringtag" id="sec-reflect-%symbol.tostringtag%">
      <h1>Reflect [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"Reflect"* である。</p>
      <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } を持つ。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-objects">
    <h1>Proxy オブジェクト (Proxy Objects)</h1>

    <emu-clause id="sec-proxy-constructor">
      <h1>Proxy コンストラクタ (The Proxy Constructor)</h1>
      <p>Proxy コンストラクタ:</p>
      <ul>
        <li><dfn>%Proxy%</dfn> である。</li>
        <li>グローバルオブジェクトの *"Proxy"* プロパティの初期値である。</li>
        <li>コンストラクタとして呼び出されたとき新しい Proxy オブジェクトを生成し初期化する。</li>
        <li>関数として呼び出すことは意図されておらず、そのように呼び出されると例外を投げる。</li>
      </ul>

      <emu-clause id="sec-proxy-target-handler">
        <h1>Proxy ( _target_, _handler_ )</h1>
        <p>この関数は呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. もし NewTarget が *undefined* なら *TypeError* 例外を投げる。
          1. ? ProxyCreate(_target_, _handler_) を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-proxy-constructor">
      <h1>Proxy コンストラクタのプロパティ (Properties of the Proxy Constructor)</h1>
      <p>Proxy コンストラクタ:</p>
      <ul>
        <li>[[Prototype]] 内部スロットの値は %Function.prototype% である。</li>
        <li>Proxy オブジェクトは初期化を要する [[Prototype]] 内部スロットを持たないため *"prototype"* プロパティを持たない。</li>
        <li>次のプロパティを持つ:</li>
      </ul>

      <emu-clause id="sec-proxy.revocable" oldids="sec-proxy-revocation-functions">
        <h1>Proxy.revocable ( _target_, _handler_ )</h1>
        <p>この関数は取り消し可能な Proxy オブジェクトを生成する。</p>
        <p>呼び出されると次の手順を実行する:</p>
        <emu-alg>
          1. _proxy_ を ? ProxyCreate(_target_, _handler_) とする。
          1. _revokerClosure_ を、引数無しで何も捕捉せず呼び出されると次を行う新たな Abstract Closure とする:
            1. _F_ をアクティブな関数オブジェクトとする。
            1. _p_ を _F_.[[RevocableProxy]] とする。
            1. もし _p_ が *null* なら NormalCompletion(*undefined*) を返す。
            1. _F_.[[RevocableProxy]] を *null* に設定する。
            1. 事前条件: _p_ は Proxy エキゾチックオブジェクトである。
            1. _p_.[[ProxyTarget]] を *null* に設定する。
            1. _p_.[[ProxyHandler]] を *null* に設定する。
            1. NormalCompletion(*undefined*) を返す。
          1. _revoker_ を CreateBuiltinFunction(_revokerClosure_, 0, *""*, « [[RevocableProxy]] ») とする。
          1. _revoker_.[[RevocableProxy]] を _proxy_ に設定する。
          1. _result_ を OrdinaryObjectCreate(%Object.prototype%) とする。
          1. ! CreateDataPropertyOrThrow(_result_, *"proxy"*, _proxy_) を実行する。
          1. ! CreateDataPropertyOrThrow(_result_, *"revoke"*, _revoker_) を実行する。
          1. _result_ を返す。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-module-namespace-objects">
    <h1>モジュール名前空間オブジェクト (Module Namespace Objects)</h1>
    <p>モジュール名前空間オブジェクトはモジュールのエクスポート束縛へ実行時のプロパティベースアクセスを提供する module namespace エキゾチックオブジェクトである。Module Namespace Objects 用のコンストラクタ関数は存在しない。代わりに、このようなオブジェクトは |NameSpaceImport| を含む |ImportDeclaration| によりインポートされた各モジュールごとに生成される。</p>
    <p><emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> で規定されるプロパティに加えて、各 Module Namespace Object は次の自前プロパティを持つ:</p>

    <emu-clause oldids="sec-@@tostringtag" id="sec-%symbol.tostringtag%">
      <h1>%Symbol.toStringTag%</h1>
      <p>%Symbol.toStringTag% プロパティの初期値は文字列値 *"Module"* である。</p>
      <p>このプロパティは属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } を持つ。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-memory-model">
  <h1>メモリーモデル (Memory Model)</h1>
  <p>メモリ一貫性モデル、すなわち <dfn>memory model</dfn> は、SharedArrayBuffer に裏付けられた TypedArray インスタンスへのアクセスおよび Atomics オブジェクト上のメソッドにより生じる Shared Data Block イベントの起こり得る順序を規定する。プログラムに（後述の定義による）データ競合がない場合、イベント順序は逐次的一貫性 (sequentially consistent) として現れ、すなわち各エージェントのアクションのインターリーブとして現れる。プログラムにデータ競合がある場合、共有メモリアクセスは逐次的一貫性を欠いて見える可能性がある。例えばプログラムは因果律に反する振る舞いやその他の驚きを示し得る。これらの驚きはコンパイラ変換および CPU 設計（例: 命令のアウトオブオーダ実行や投機）に由来する。メモリーモデルはプログラムが逐次的一貫性を示す正確な条件と、データ競合から読み得る値の可能性を定義する。言い換えると、undefined behaviour は存在しない。</p>
  <p>メモリーモデルは SharedArrayBuffer 上の抽象操作または Atomics オブジェクト上のメソッドによって評価中に導入されるイベントに対する関係制約として定義される。</p>
  <emu-note>
    <p>この節は SharedArrayBuffer 上の抽象操作によって導入されるイベントに関する公理的モデルを提供する。モデルは仕様の他の部分と異なりアルゴリズム的に表現できないことを強調する。抽象操作によるイベントの非決定的導入は ECMAScript 評価の操作的意味論とメモリーモデルの公理的意味論とのインタフェースである。これらイベントの意味は評価内の全イベントのグラフを考慮して定義される。これらは静的意味論でも実行時意味論でもない。既知のアルゴリズム実装は示されておらず、代わりに特定のイベントグラフが許容されるか否かを決定する制約集合がある。</p>
  </emu-note>

  <emu-clause id="sec-memory-model-fundamentals">
    <h1>メモリーモデルの基本 (Memory Model Fundamentals)</h1>
    <p>共有メモリアクセス（読み書き）は後述の定義に従い atomic アクセスと data アクセスの 2 群に分けられる。Atomic アクセスは逐次的一貫性を持つ、すなわちエージェントクラスタ内の全エージェントが合意する厳密な全順序が存在する。非 atomic アクセスは全エージェントが合意する厳密な全順序を持たず、すなわち unordered である。</p>
    <emu-note>
      <p>逐次的一貫性より弱く、unordered より強い順序（例: release-acquire）はサポートされない。</p>
    </emu-note>
    <p><dfn variants="Shared Data Block events">Shared Data Block event</dfn> は <dfn>ReadSharedMemory</dfn>、<dfn>WriteSharedMemory</dfn>、または <dfn>ReadModifyWriteSharedMemory</dfn> Record のいずれかである。</p>

    <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory イベントフィールド (ReadSharedMemory Event Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~ または ~unordered~</td>
          <td>このイベントに対してメモリーモデルが保証する最弱の順序。</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>Boolean</td>
          <td>このイベントが同一範囲を持つ複数の書き込みイベントから読み取ることを許されるかどうか。</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>Shared Data Block</td>
          <td>イベントが作用するブロック。</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>非負整数</td>
          <td>[[Block]] 内での読み取りのバイト位置。</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>非負整数</td>
          <td>読み取りサイズ。</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory イベントフィールド (WriteSharedMemory Event Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~, ~unordered~, または ~init~</td>
          <td>このイベントに対してメモリーモデルが保証する最弱の順序。</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>Boolean</td>
          <td>このイベントが同一範囲を持つ複数の読み取りイベントから読み取られることを許されるかどうか。</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>Shared Data Block</td>
          <td>イベントが作用するブロック。</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>非負整数</td>
          <td>[[Block]] 内での書き込みのバイト位置。</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>非負整数</td>
          <td>書き込みサイズ。</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>バイト値の List</td>
          <td>他のイベントによって読み取られるバイト値の List。</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory イベントフィールド (ReadModifyWriteSharedMemory Event Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~</td>
          <td>Read-modify-write イベントは常に逐次的一貫性。</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>*true*</td>
          <td>Read-modify-write イベントは tear しない。</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>Shared Data Block</td>
          <td>イベントが作用するブロック。</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>非負整数</td>
          <td>[[Block]] 内での read-modify-write のバイト位置。</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>非負整数</td>
          <td>read-modify-write のサイズ。</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>バイト値の List</td>
          <td>[[ModifyOp]] に渡されるバイト値の List。</td>
        </tr>
        <tr>
          <td>[[ModifyOp]]</td>
          <td>read-modify-write 変更関数</td>
          <td>読み取ったバイト値の List と [[Payload]] から変更後のバイト値の List を返す抽象クロージャ。</td>
        </tr>
      </table>
    </emu-table>

    <p>これらのイベントは抽象操作または Atomics オブジェクト上のメソッドによって導入される。</p>
    <p>一部操作は <dfn>Synchronize</dfn> イベントも導入し得る。<dfn variants="Synchronize events">Synchronize event</dfn> はフィールドを持たず、他イベントの許容順序を直接制約するためだけに存在する。</p>
    <p>Shared Data Block イベントと Synchronize イベントに加えて、ホスト固有イベントが存在する。</p>
    <p>ReadSharedMemory / WriteSharedMemory / ReadModifyWriteSharedMemory イベントの範囲はその [[ByteIndex]] から [[ByteIndex]] + [[ElementSize]] - 1 までの連続整数集合とする。2 つのイベントの範囲が同じ [[Block]] を持ち要素毎に等しいとき、それらの範囲は等しい。2 つのイベントの範囲が同じ [[Block]] を持ち、範囲が等しくなく かつ 交差が空でないとき、範囲は重複 (overlapping) する。2 つのイベントの範囲が同じ [[Block]] を持たないか、範囲が等しくも重複もしていないとき、範囲は素 (disjoint) である。</p>
    <emu-note>
      <p>考慮すべきホスト固有同期イベント例：SharedArrayBuffer を一方のエージェントから他方へ送る（ブラウザでの `postMessage` など）、エージェントの開始と停止、共有メモリ以外のチャネルによるエージェントクラスタ内通信。特定の実行 _execution_ において、それらイベントは host-synchronizes-with 厳密半順序を通じてホストにより提供される。さらにホストは is-agent-order-before 関係に参加するため _execution_.[[EventList]] にホスト固有同期イベントを追加できる。</p>
    </emu-note>
    <p>イベントは以下で定義する関係によって候補実行内で順序付けられる。</p>
  </emu-clause>

  <emu-clause id="sec-agent-event-records">
    <h1>Agent Events レコード (Agent Events Records)</h1>
    <p><dfn variants="Agent Events Records">Agent Events Record</dfn> は次のフィールドを持つ Record である。</p>
    <emu-table id="table-agent-events-records" caption="Agent Events Record フィールド (Agent Events Record Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[AgentSignifier]]</td>
          <td>エージェント識別子</td>
          <td>この順序付けに結果した評価を行ったエージェント。</td>
        </tr>
        <tr>
          <td>[[EventList]]</td>
          <td>イベントの List</td>
          <td>評価中にイベントがリストへ追加される。</td>
        </tr>
        <tr>
          <td>[[AgentSynchronizesWith]]</td>
          <td>Synchronize イベントのペアの List</td>
          <td>操作的意味論によって導入された Synchronize 関係。</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-chosen-value-records">
    <h1>Chosen Value レコード (Chosen Value Records)</h1>
    <p><dfn variants="Chosen Value Records">Chosen Value Record</dfn> は次のフィールドを持つ Record である。</p>
    <emu-table id="table-chosen-value-records" caption="Chosen Value Record フィールド (Chosen Value Record Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Event]]</td>
          <td>Shared Data Block event</td>
          <td>この選択値のために導入された ReadSharedMemory または ReadModifyWriteSharedMemory イベント。</td>
        </tr>
        <tr>
          <td>[[ChosenValue]]</td>
          <td>バイト値の List</td>
          <td>評価中に非決定的に選択されたバイト。</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-candidate-executions">
    <h1>候補実行 (Candidate Executions)</h1>
    <p><dfn variants="candidate executions">candidate execution</dfn> とは次のフィールドを持つエージェントクラスタ評価の Record である。</p>
    <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record フィールド (Candidate Execution Record Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[EventsRecords]]</td>
          <td>Agent Events Records の List</td>
          <td>エージェントを評価中に追加されたイベントの List に対応付ける。</td>
        </tr>
        <tr>
          <td>[[ChosenValues]]</td>
          <td>Chosen Value Records の List</td>
          <td>ReadSharedMemory または ReadModifyWriteSharedMemory イベントを評価中に選択されたバイト値の List に対応付ける。</td>
        </tr>
      </table>
    </emu-table>

    <p><dfn variants="empty candidate executions">empty candidate execution</dfn> はフィールドが空 List である candidate execution Record である。</p>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-the-memory-model" oldids="sec-synchronizeeventset">
    <h1>メモリーモデル用抽象操作 (Abstract Operations for the Memory Model)</h1>

    <emu-clause id="sec-event-set" type="abstract operation">
      <h1>
        EventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _events_ を空集合とする。
        1. _execution_.[[EventsRecords]] の各 Agent Events Record _aer_ について
          1. _aer_.[[EventList]] の各イベント _E_ について
            1. _E_ を _events_ に追加する。
        1. _events_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedatablockeventset" type="abstract operation">
      <h1>
        SharedDataBlockEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _events_ を空集合とする。
        1. EventSet(_execution_) の各イベント _E_ について
          1. もし _E_ が ReadSharedMemory / WriteSharedMemory / ReadModifyWriteSharedMemory イベントなら _E_ を _events_ に追加する。
        1. _events_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hosteventset" type="abstract operation">
      <h1>
        HostEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _events_ を空集合とする。
        1. EventSet(_execution_) の各イベント _E_ について
          1. もし _E_ が SharedDataBlockEventSet(_execution_) に含まれないなら _E_ を _events_ に追加する。
        1. _events_ を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-composewriteeventbytes" type="abstract operation">
      <h1>
        ComposeWriteEventBytes (
          _execution_: a candidate execution,
          _byteIndex_: a non-negative integer,
          _Ws_: a List of either WriteSharedMemory or ReadModifyWriteSharedMemory events,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _byteLocation_ を _byteIndex_ とする。
        1. _bytesRead_ を新しい空の List とする。
        1. _Ws_ の各要素 _W_ について
          1. 事前条件: _W_ はその範囲に _byteLocation_ を含む。
          1. _payloadIndex_ を _byteLocation_ - _W_.[[ByteIndex]] とする。
          1. もし _W_ が WriteSharedMemory イベントなら
            1. _byte_ を _W_.[[Payload]][_payloadIndex_] とする。
          1. それ以外
            1. 事前条件: _W_ は ReadModifyWriteSharedMemory イベントである。
            1. _bytes_ を ValueOfReadEvent(_execution_, _W_) とする。
            1. _bytesModified_ を _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]) とする。
            1. _byte_ を _bytesModified_[_payloadIndex_] とする。
          1. _byte_ を _bytesRead_ に追加する。
          1. _byteLocation_ を _byteLocation_ + 1 に設定する。
        1. _bytesRead_ を返す。
      </emu-alg>
      <emu-note>
        <p>read-modify-write 変更 [[ModifyOp]] は ReadModifyWriteSharedMemory イベントを導入する Atomics オブジェクト上の関数プロパティによって与えられる。</p>
      </emu-note>
      <emu-note>
        <p>この抽象操作は書き込みイベントの List をバイト値の List に合成する。ReadSharedMemory および ReadModifyWriteSharedMemory イベントのイベント意味論で使用される。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valueofreadevent" type="abstract operation">
      <h1>
        ValueOfReadEvent (
          _execution_: a candidate execution,
          _R_: a ReadSharedMemory or ReadModifyWriteSharedMemory event,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _Ws_ を _execution_ における reads-bytes-from(_R_) とする。
        1. 事前条件: _Ws_ は _R_.[[ElementSize]] と同じ長さの WriteSharedMemory または ReadModifyWriteSharedMemory イベントの List。
        1. ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_) を返す。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relations-of-candidate-executions">
    <h1>候補実行における関係 (Relations of Candidate Executions)</h1>

    <p>以下の関係と数学的関数は特定の候補実行をパラメータに取り、そのイベントを順序付ける。</p>

    <emu-clause id="sec-agent-order">
      <h1>is-agent-order-before</h1>
      <p>候補実行 _execution_ における <dfn>is-agent-order-before</dfn> 関係は次を満たす最小のイベント上の関係である。</p>
      <ul>
        <li>イベント _E_ と _D_ について、_execution_.[[EventsRecords]] 内のある Agent Events Record _aer_ が存在し _aer_.[[EventList]] に _E_ と _D_ が含まれ かつ _E_ が List 順序で _D_ より前にあるなら、_E_ is-agent-order-before _D_ in _execution_。</li>
      </ul>

      <emu-note>
        <p>各エージェントは評価中にエージェント毎の厳密な全順序でイベントを導入する。これはそれら厳密全順序の合併である。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-reads-bytes-from" aoid="reads-bytes-from">
      <h1>reads-bytes-from</h1>
      <p>候補実行 _execution_ における <em>reads-bytes-from</em> 関数は SharedDataBlockEventSet(_execution_) 内のイベントを同集合内のイベントの List に写像し次の条件を満たす数学的関数である。</p>
      <ul>
        <li>
          <p>SharedDataBlockEventSet(_execution_) 内の各 ReadSharedMemory または ReadModifyWriteSharedMemory イベント _R_ について、reads-bytes-from(_R_) in _execution_ は長さ _R_.[[ElementSize]] の List であり、その要素は WriteSharedMemory または ReadModifyWriteSharedMemory イベント _Ws_ で次を満たす。</p>
          <ul>
            <li>_Ws_ 内インデックス _i_ を持つ各イベント _W_ は _R_.[[ByteIndex]] + _i_ をその範囲に含む。</li>
            <li>_R_ は _Ws_ 内に存在しない。</li>
          </ul>
        </li>
      </ul>
      <p>候補実行は常に reads-bytes-from 関数を許容する。</p>
    </emu-clause>

    <emu-clause id="sec-reads-from">
      <h1>reads-from</h1>
      <p>候補実行 _execution_ における <dfn>reads-from</dfn> 関係は次を満たす最小のイベント上の関係である。</p>
      <ul>
        <li>イベント _R_ と _W_ について、SharedDataBlockEventSet(_execution_) が両方を含み、かつ reads-bytes-from(_R_) in _execution_ が _W_ を含むなら _R_ reads-from _W_ in _execution_。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-host-synchronizes-with">
      <h1>host-synchronizes-with</h1>
      <p>候補実行 _execution_ における <dfn>host-synchronizes-with</dfn> 関係はホスト提供のホスト固有イベント上の厳密半順序で少なくとも次を満たす。</p>
      <ul>
        <li>もし _E_ host-synchronizes-with _D_ in _execution_ なら HostEventSet(_execution_) は _E_ と _D_ を含む。</li>
        <li>host-synchronizes-with と is-agent-order-before の合併にサイクルが存在しない。</li>
      </ul>

      <emu-note>
        <p>候補実行 _execution_ 内のホスト固有イベント _E_ と _D_ について、_E_ host-synchronizes-with _D_ in _execution_ は _E_ happens-before _D_ in _execution_ を意味する。</p>
      </emu-note>
      <emu-note>
        <p>この関係はホストに追加の同期機構（HTML ワーカー間の `postMessage` など）を提供させる。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-synchronizes-with">
      <h1>synchronizes-with</h1>
      <p>候補実行 _execution_ における <dfn>synchronizes-with</dfn> 関係は次を満たす最小のイベント上の関係である。</p>
      <ul>
        <li>
          イベント _R_ と _W_ について、_R_ reads-from _W_ in _execution_, _R_.[[Order]] が ~seq-cst~, _W_.[[Order]] が ~seq-cst~, かつ _R_ と _W_ が等しい範囲なら _W_ synchronizes-with _R_ in _execution_。
        </li>
        <li>
          _execution_.[[EventsRecords]] の各要素 _eventsRecord_ について次が成り立つ。
          <ul>
            <li>イベント _S_ と _Sw_ について、_eventsRecord_.[[AgentSynchronizesWith]] が (_S_, _Sw_) を含むなら _S_ synchronizes-with _Sw_ in _execution_。</li>
          </ul>
        </li>
        <li>イベント _E_ と _D_ について、_execution_.[[HostSynchronizesWith]] が (_E_, _D_) を含むなら _E_ synchronizes-with _D_ in _execution_。</li>
      </ul>

      <emu-note>
        <p>メモリーモデル文献の慣例により、候補実行 _execution_ では書き込みイベントが読み取りイベントを synchronizes-with する。</p>
      </emu-note>

      <emu-note>
        <p>候補実行 _execution_ では ~init~ イベントはこの関係に参加せず、代わりに happens-before により直接制約される。</p>
      </emu-note>

      <emu-note>
        <p>候補実行 _execution_ において reads-from で関連する全 ~seq-cst~ イベントが synchronizes-with で関連するとは限らない。等しい範囲を持つイベントのみが synchronizes-with で関連する。</p>
      </emu-note>

      <emu-note>
        <p>候補実行 _execution_ の Shared Data Block イベント _R_ と _W_ で _W_ synchronizes-with _R_ の場合、_R_ は _W_ 以外の書き込みからも reads-from し得る。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-happens-before">
      <h1>happens-before</h1>
      <p>候補実行 _execution_ における <dfn>happens-before</dfn> 関係は次を満たす最小のイベント上の関係である。</p>

      <ul>
        <li>
          <p>イベント _E_ と _D_ について、次のいずれかが真なら _E_ happens-before _D_ in _execution_。</p>
          <ul>
            <li>_E_ is-agent-order-before _D_ in _execution_。</li>
            <li>_E_ synchronizes-with _D_ in _execution_。</li>
            <li>SharedDataBlockEventSet(_execution_) が _E_ と _D_ を含み、_E_.[[Order]] が ~init~ で、_E_ と _D_ が重複する範囲を持つ。</li>
            <li>イベント _F_ が存在し _E_ happens-before _F_ かつ _F_ happens-before _D_ in _execution_。</li>
          </ul>
        </li>
      </ul>

      <emu-note>
        <p>happens-before は agent-order の上位集合であるため、候補実行は ECMAScript の単一スレッド評価意味論と整合する。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-valid-executions">
    <h1>有効な実行の性質 (Properties of Valid Executions)</h1>

    <emu-clause id="sec-valid-chosen-reads">
      <h1>Valid Chosen Reads</h1>
      <p>候補実行 _execution_ が valid chosen reads を持つとは次のアルゴリズムが *true* を返す場合である。</p>
      <emu-alg>
        1. SharedDataBlockEventSet(_execution_) の各 ReadSharedMemory または ReadModifyWriteSharedMemory イベント _R_ について
          1. _chosenValueRecord_ を _execution_.[[ChosenValues]] のうち [[Event]] フィールドが _R_ である要素とする。
          1. _chosenValue_ を _chosenValueRecord_.[[ChosenValue]] とする。
          1. _readValue_ を ValueOfReadEvent(_execution_, _R_) とする。
          1. _chosenLen_ を _chosenValue_ の要素数とする。
          1. _readLen_ を _readValue_ の要素数とする。
          1. もし _chosenLen_ ≠ _readLen_ なら
            1. *false* を返す。
          1. もし 区間 [0, _chosenLen_) のある整数 _i_ について _chosenValue_[_i_] ≠ _readValue_[_i_] なら
            1. *false* を返す。
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-coherent-reads">
      <h1>Coherent Reads</h1>
      <p>候補実行 _execution_ が coherent reads を持つとは次のアルゴリズムが *true* を返す場合である。</p>
      <emu-alg>
        1. SharedDataBlockEventSet(_execution_) の各 ReadSharedMemory または ReadModifyWriteSharedMemory イベント _R_ について
          1. _Ws_ を reads-bytes-from(_R_) in _execution_ とする。
          1. _byteLocation_ を _R_.[[ByteIndex]] とする。
          1. _Ws_ の各要素 _W_ について
            1. もし _R_ happens-before _W_ in _execution_ なら
              1. *false* を返す。
            1. もし _byteLocation_ をその範囲に含む WriteSharedMemory または ReadModifyWriteSharedMemory イベント _V_ が存在し、_W_ happens-before _V_ かつ _V_ happens-before _R_ in _execution_ なら
              1. *false* を返す。
            1. _byteLocation_ を _byteLocation_ + 1 に設定する。
        1. *true* を返す。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tear-free-aligned-reads">
      <h1>Tear Free Reads</h1>
      <p>候補実行 _execution_ が tear free reads を持つとは次のアルゴリズムが *true* を返す場合である。</p>
      <emu-alg>
        1. SharedDataBlockEventSet(_execution_) の各 ReadSharedMemory または ReadModifyWriteSharedMemory イベント _R_ について
          1. もし _R_.[[NoTear]] が *true* なら
            1. 事前条件: _R_.[[ByteIndex]] を _R_.[[ElementSize]] で割った余りは 0。
            1. _R_ reads-from _W_ in _execution_ であり _W_.[[NoTear]] が *true* である各イベント _W_ について
              1. もし _R_ と _W_ が等しい範囲を持ち、_R_ と _W_ が同じ Shared Data Block event でなく、_R_ reads-from _V_ in _execution_ を満たす等しい範囲と [[NoTear]] が *true* のイベント _V_ が存在するなら
                1. *false* を返す。
        1. *true* を返す。
      </emu-alg>

      <emu-note>
        <p>イベントの [[NoTear]] フィールドは整数 TypedArray へのアクセスで導入されたとき *true*、浮動小数点 TypedArray または DataView で導入されたとき *false*。</p>
        <p>直感的説明: メモリ範囲が整数 TypedArray によりアラインされた形でアクセスされたとき、その範囲に対する単一の書き込みイベントが同範囲の他の書き込みイベントとのデータ競合で「勝つ」必要がある。より厳密には、アラインされた読み取りイベントが、同一範囲を持つ複数の異なる書き込みイベントのバイトを混合した値を読んではならない。なお、アラインされた読み取りイベントが重複範囲を持つ複数の書き込みイベントから読む可能性は残る。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-memory-order">
      <h1>Sequentially Consistent Atomics</h1>
      <p>候補実行 _execution_ において、<dfn>is-memory-order-before</dfn> は EventSet(_execution_) 内の全イベント上の厳密全順序で次を満たす。</p>
      <ul>
        <li>イベント _E_ と _D_ について、_E_ happens-before _D_ in _execution_ なら _E_ is-memory-order-before _D_ in _execution_。</li>
        <li>
          <p>_R_ reads-from _W_ in _execution_ であるイベント _R_ と _W_ について、SharedDataBlockEventSet(_execution_) 内に WriteSharedMemory または ReadModifyWriteSharedMemory イベント _V_ が存在し、_V_.[[Order]] が ~seq-cst~, _W_ is-memory-order-before _V_, _V_ is-memory-order-before _R_ であり、かつ以下のいずれかが真である状況は存在しない。</p>
          <ul>
            <li>_W_ synchronizes-with _R_ in _execution_ かつ _V_ と _R_ が等しい範囲。</li>
            <li>_W_ happens-before _R_ かつ _V_ happens-before _R_ in _execution_, _W_.[[Order]] が ~seq-cst~, かつ _W_ と _V_ が等しい範囲。</li>
            <li>_W_ happens-before _R_ かつ _W_ happens-before _V_ in _execution_, _R_.[[Order]] が ~seq-cst~, かつ _V_ と _R_ が等しい範囲。</li>
          </ul>
          <emu-note>
            <p>この節は等しい範囲における ~seq-cst~ イベントを追加制約する。</p>
          </emu-note>
        </li>
        <li>
          <p>SharedDataBlockEventSet(_execution_) 内の各 WriteSharedMemory または ReadModifyWriteSharedMemory イベント _W_ について、_W_.[[Order]] が ~seq-cst~ なら、_W_ より memory-order 前に等しい範囲で無限個の ReadSharedMemory または ReadModifyWriteSharedMemory イベントが存在することはない。</p>
          <emu-note>
            <p>この節とエージェントの前進性保証により、~seq-cst~ 書き込みが有限時間で等しい範囲の ~seq-cst~ 読み取りに可視化されるという活性 (liveness) 条件を確保する。</p>
          </emu-note>
        </li>
      </ul>
      <p>候補実行は is-memory-order-before 関係を許容するなら sequentially consistent atomics を持つ。</p>

      <emu-note>
        <p>is-memory-order-before は EventSet(_execution_) の全イベントを含むが、_execution_ 内で happens-before または synchronizes-with によって制約されないものは順序中の任意位置に現れてよい。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valid-executions">
      <h1>Valid Executions</h1>
      <p>候補実行 _execution_ が有効実行 (execution) であるとは、以下すべてが真であること。</p>
      <ul>
        <li>ホストが _execution_ に対する host-synchronizes-with 関係を提供する。</li>
        <li>_execution_ が厳密半順序である happens-before 関係を許容する。</li>
        <li>_execution_ が valid chosen reads を持つ。</li>
        <li>_execution_ が coherent reads を持つ。</li>
        <li>_execution_ が tear free reads を持つ。</li>
        <li>_execution_ が sequentially consistent atomics を持つ。</li>
      </ul>
      <p>全てのプログラムは少なくとも 1 つの有効実行を持つ。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-races">
    <h1>競合 (Races)</h1>
    <p>実行 _execution_ と SharedDataBlockEventSet(_execution_) に含まれるイベント _E_ と _D_ について、次のアルゴリズムが *true* を返すとき _E_ と _D_ は <em>race</em> にある。</p>
    <emu-alg>
      1. もし _E_ と _D_ が同一の Shared Data Block event でないなら
        1. もし _E_ happens-before _D_ in _execution_ かつ _D_ happens-before _E_ in _execution_ の双方が成り立たないなら
          1. もし _E_ と _D_ が共に WriteSharedMemory または ReadModifyWriteSharedMemory イベントで かつ _E_ と _D_ の範囲が素でないなら
            1. *true* を返す。
          1. もし _E_ reads-from _D_ in _execution_ または _D_ reads-from _E_ in _execution_ なら
            1. *true* を返す。
      1. *false* を返す。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-races">
    <h1>データ競合 (Data Races)</h1>
    <p>実行 _execution_ と SharedDataBlockEventSet(_execution_) に含まれるイベント _E_ と _D_ について、次のアルゴリズムが *true* を返すとき _E_ と _D_ は <dfn>data race</dfn> にある。</p>
    <emu-alg>
      1. もし _E_ と _D_ が <emu-xref href="#sec-races">race</emu-xref> in _execution_ にあるなら
        1. もし _E_.[[Order]] が ~seq-cst~ ではない または _D_.[[Order]] が ~seq-cst~ ではないなら
          1. *true* を返す。
        1. もし _E_ と _D_ が重複する範囲を持つなら
          1. *true* を返す。
      1. *false* を返す。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-race-freedom">
    <h1>データ競合の不存在 (Data Race Freedom)</h1>
    <p>実行 _execution_ が <dfn>data race free</dfn> とは SharedDataBlockEventSet(_execution_) 内に data race にある 2 つのイベントが存在しないこと。</p>
    <p>プログラムが data race free とはそのすべての実行が data race free であること。</p>
    <p>メモリーモデルは data race free プログラムの全イベントについて逐次的一貫性を保証する。</p>
  </emu-clause>

  <emu-clause id="sec-shared-memory-guidelines">
    <h1>共有メモリ利用指針 (Shared Memory Guidelines)</h1>
    <emu-note>
      <p>以下は共有メモリを扱う ECMAScript プログラマ向けガイドラインである。</p>
      <p>プログラムを data race free に保つ（すなわち同一メモリ位置に対する並行する非 atomic 操作が不可能であるようにする）ことを推奨する。Data race free プログラムは各エージェントの評価意味論ステップが互いにインターリーブされる意味論（インターリービング意味論）を持つ。Data race free プログラムではメモリーモデルの詳細を理解する必要はない。詳細は ECMAScript をより良く書くための直観をほぼ与えない。</p>
      <p>より一般には、プログラムが data race free でなくとも、atomic 操作がどのデータ競合にも巻き込まれず、競合する操作がすべて同じアクセスサイズであれば予測可能な振る舞いを持ち得る。Atomic 操作を競合に巻き込まない最も簡単な方法は、atomic と非 atomic の操作が異なるメモリセルを使用し、異なるサイズの atomic アクセスを同じセルに同時利用しないようにすることである。実質的にプログラムは共有メモリを可能な限り強い型付けがあるものとして扱うべきである。依然として競合する非 atomic アクセスの順序やタイミングに依存することはできないが、メモリを強く型付けとして扱えば競合するアクセスは「tear」（値のビット断片の混在）しない。</p>
    </emu-note>

    <emu-note>
      <p>以下は共有メモリを使用するプログラムにコンパイラ変換を適用する ECMAScript 実装者向けガイドラインである。</p>
      <p>単一エージェント環境で有効なほとんどのプログラム変換をマルチエージェント環境でも許容することが望ましい。これによりマルチエージェントプログラムにおける各エージェントの性能が単一エージェント環境と同様に良好となる。しばしばこれら変換は判断が難しい。以下にメモリーモデルによって含意される（またはそれより強い）規範的意図を持つが網羅的ではない規則を示す。これらは is-agent-order-before 関係を構成するイベントが導入される以前のプログラム変換に適用されることを意図する。</p>
      <p><dfn variants="agent-order slices">agent-order slice</dfn> を単一エージェントに関わる is-agent-order-before 関係の部分集合とする。</p>
      <p>読み取りイベントの <dfn>possible read values</dfn> を、そのイベントに対する全有効実行における ValueOfReadEvent の値集合とする。</p>
      <p>共有メモリが存在しない場合に有効なエージェント順スライスの任意の変換は、以下の例外を除き共有メモリ存在下でも有効である。</p>
      <ul>
        <li>
          <p><em>Atomic は石版に刻まれている</em>: プログラム変換はエージェント順スライス内の ~seq-cst~ イベントを ~unordered~ 操作と再順序付けしてはならず、~seq-cst~ 操作同士を再順序付けしてもならず、~seq-cst~ 操作を is-agent-order-before 関係から除去してもならない。</p>
          <p>(実際には並べ替え禁止はコンパイラに全 ~seq-cst~ 操作が同期であり最終的な is-memory-order-before 関係に含まれると仮定させる。これは相互エージェント解析不在で通常仮定せざるを得ない。さらに呼び出し先の memory-order への影響が未知な呼び出しは ~seq-cst~ 操作を含み得ると仮定させる。)</p>
        </li>
        <li>
          <p><em>読み取りは安定</em>: 任意の共有メモリ読み取りは 1 回の実行で単一の値のみ観測しなければならない。</p>
          <p>(例: プログラム上意味的に 1 回の読みを複数回実行した場合、後続で観測される値はそのうち 1 つのみ許される。Rematerialization として知られる変換はこの規則に違反し得る。)</p>
        </li>
        <li>
          <p><em>書き込みは安定</em>: 共有メモリへの全ての観測可能な書き込みは実行中のプログラム意味論から導かれていなければならない。</p>
          <p>(例: より大きな場所での read-modify-write を用いて小さなデータを書いたり、プログラムが書き得ない値の書き込み、他エージェントにより上書きされ得る位置に直前に読み取った値をそのまま書き戻したりしてはならない。)</p>
        </li>
        <li>
          <p><em>Possible read values は空であってはならない</em>: プログラム変換は共有メモリ読み取りの possible read values を空集合にしてはならない。</p>
          <p>(直観に反して、この規則は実際には書き込み上の変換を制約する。書き込みは読み取りイベントにより読まれることでメモリーモデル上の効力を持つため。例えば書き込みは ~seq-cst~ 操作 2 つの間で移動・合併・時に再順序付けできるが、ある位置を更新する全ての書き込みを除去することはできない；何らかの書き込みは残さねばならない。)</p>
        </li>
      </ul>
      <p>依然として有効な変換例: 同一位置への複数の非 atomic 読み取りのマージ、非 atomic 読み取りの再順序付け、投機的非 atomic 読み取りの導入、同一位置への複数非 atomic 書き込みのマージ、異なる位置への非 atomic 書き込みの再順序付け、非 atomic 読み取りのループ外へのホイスト（終了性に影響があっても）。一般にエイリアスされた TypedArray は位置が異なることの証明を難しくする。</p>
    </emu-note>

    <emu-note>
      <p>以下は共有メモリアクセスに対して機械語生成を行う ECMAScript 実装者向けガイドラインである。</p>
      <p>ARM や Power より弱くないメモリーモデルを持つアーキテクチャでは、非 atomic store / load は素の store / load 命令にコンパイルできる。Atomic store / load は逐次的一貫性を保証する命令にコンパイルできる。そうした命令が無い場合、フェンス（両側への配置など）を利用する。Read-modify-write 操作は対象アーキテクチャの read-modify-write 命令列（x86 の <code>LOCK</code> 接頭辞、ARM の load-exclusive/store-exclusive、Power の load-link/store-conditional 等）にコンパイルできる。</p>
      <p>具体的に、メモリーモデルは以下のコード生成を許容する意図である。</p>
      <ul>
        <li>プログラム中の全 atomic 操作は必要であると仮定する。</li>
        <li>Atomic 操作は互い、または非 atomic 操作と再順序付けされない。</li>
        <li>関数呼び出しは常に atomic 操作を行うと仮定する。</li>
        <li>Atomic 操作はより大きなデータ上の read-modify-write を用いて実装されず、適切なサイズの atomic 操作がプラットフォームにない場合は non-lock-free atomics として実装される。（全ての興味あるサイズの通常メモリアクセス命令は存在すると仮定。）</li>
      </ul>
      <p>素朴なコード生成パターン:</p>
      <ul>
        <li>通常の load/store は単一の load/store 命令。</li>
        <li>ロックフリー atomic load/store は完全フェンス、通常 load/store、完全フェンス。</li>
        <li>ロックフリー atomic read-modify-write は完全フェンス、atomic read-modify-write 命令列、完全フェンス。</li>
        <li>非ロックフリー atomic はスピンロック獲得、完全フェンス、非 atomic load/store 列、完全フェンス、スピンロック解放。</li>
      </ul>
      <p>この写像は、アドレス範囲上の atomic 操作が非 atomic 書き込みまたは異なるサイズの atomic 操作と競合しない限り正しい。それで十分である：メモリーモデルは競合に関与する atomic 操作を非 atomic とみなす。一方素朴な写像は強い：メモリーモデルが実際には保証しない逐次的一貫フェンスとして atomic 操作を使用できる。</p>
      <p>これら基本パターンへの局所的改善も、メモリーモデル制約に従う限り許容される。例:</p>
      <ul>
        <li>冗長フェンスの除去（x86 では load/store 周りのフェンス省略など、LOCK 接頭辞命令使用により read-modify-write でフェンス不要）や、弱いフェンスの使用。</li>
        <li>多くのプラットフォームは必要な全サイズのロックフリー atomic をサポート。非ロックフリーが必要なら atomic 操作本体を囲むフェンスはロック獲得/解放に折り込める。最も簡単なのは SharedArrayBuffer 毎に単一のロック語を持つこと。</li>
        <li>2 つの連続フェンスは単一フェンスと同等な場合が多く、連続する 2 つの atomic 操作生成時は間に 1 つで良い。x86 では atomic store 連続間のフェンスを省略可能など。</li>
      </ul>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-grammar-summary">
  <h1>文法サマリー</h1>

  <emu-annex id="sec-lexical-grammar">
    <h1>字句文法 (Lexical Grammar)</h1>
    <emu-prodref name="SourceCharacter"></emu-prodref>
    <emu-prodref name="InputElementDiv"></emu-prodref>
    <emu-prodref name="InputElementRegExp"></emu-prodref>
    <emu-prodref name="InputElementRegExpOrTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementHashbangOrRegExp"></emu-prodref>
    <emu-prodref name="WhiteSpace"></emu-prodref>
    <emu-prodref name="LineTerminator"></emu-prodref>
    <emu-prodref name="LineTerminatorSequence"></emu-prodref>
    <emu-prodref name="Comment"></emu-prodref>
    <emu-prodref name="MultiLineComment"></emu-prodref>
    <emu-prodref name="MultiLineCommentChars"></emu-prodref>
    <emu-prodref name="PostAsteriskCommentChars"></emu-prodref>
    <emu-prodref name="MultiLineNotAsteriskChar"></emu-prodref>
    <emu-prodref name="MultiLineNotForwardSlashOrAsteriskChar"></emu-prodref>
    <emu-prodref name="SingleLineComment"></emu-prodref>
    <emu-prodref name="SingleLineCommentChars"></emu-prodref>
    <emu-prodref name="SingleLineCommentChar"></emu-prodref>
    <emu-prodref name="HashbangComment"></emu-prodref>
    <emu-prodref name="CommonToken"></emu-prodref>
    <emu-prodref name="PrivateIdentifier"></emu-prodref>
    <emu-prodref name="IdentifierName"></emu-prodref>
    <emu-prodref name="IdentifierStart"></emu-prodref>
    <emu-prodref name="IdentifierPart"></emu-prodref>
    <emu-prodref name="IdentifierStartChar"></emu-prodref>
    <emu-prodref name="IdentifierPartChar"></emu-prodref>
    <emu-prodref name="AsciiLetter"></emu-prodref>
    <emu-prodref name="UnicodeIDStart"></emu-prodref>
    <emu-prodref name="UnicodeIDContinue"></emu-prodref>
    <emu-prodref name="ReservedWord"></emu-prodref>
    <emu-prodref name="Punctuator"></emu-prodref>
    <emu-prodref name="OptionalChainingPunctuator"></emu-prodref>
    <emu-prodref name="OtherPunctuator"></emu-prodref>
    <emu-prodref name="DivPunctuator"></emu-prodref>
    <emu-prodref name="RightBracePunctuator"></emu-prodref>
    <emu-prodref name="NullLiteral"></emu-prodref>
    <emu-prodref name="BooleanLiteral"></emu-prodref>
    <emu-prodref name="NumericLiteralSeparator"></emu-prodref>
    <emu-prodref name="NumericLiteral"></emu-prodref>
    <emu-prodref name="DecimalBigIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="BigIntLiteralSuffix"></emu-prodref>
    <emu-prodref name="DecimalLiteral"></emu-prodref>
    <emu-prodref name="DecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="DecimalDigits"></emu-prodref>
    <emu-prodref name="DecimalDigit"></emu-prodref>
    <emu-prodref name="NonZeroDigit"></emu-prodref>
    <emu-prodref name="ExponentPart"></emu-prodref>
    <emu-prodref name="ExponentIndicator"></emu-prodref>
    <emu-prodref name="SignedInteger"></emu-prodref>
    <emu-prodref name="BinaryIntegerLiteral"></emu-prodref>
    <emu-prodref name="BinaryDigits"></emu-prodref>
    <emu-prodref name="BinaryDigit"></emu-prodref>
    <emu-prodref name="OctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigits"></emu-prodref>
    <emu-prodref name="LegacyOctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonOctalDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="LegacyOctalLikeDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigit"></emu-prodref>
    <emu-prodref name="NonOctalDigit"></emu-prodref>
    <emu-prodref name="HexIntegerLiteral"></emu-prodref>
    <emu-prodref name="HexDigits"></emu-prodref>
    <emu-prodref name="HexDigit"></emu-prodref>
    <emu-prodref name="StringLiteral"></emu-prodref>
    <emu-prodref name="DoubleStringCharacters"></emu-prodref>
    <emu-prodref name="SingleStringCharacters"></emu-prodref>
    <emu-prodref name="DoubleStringCharacter"></emu-prodref>
    <emu-prodref name="SingleStringCharacter"></emu-prodref>
    <emu-prodref name="LineContinuation"></emu-prodref>
    <emu-prodref name="EscapeSequence"></emu-prodref>
    <emu-prodref name="CharacterEscapeSequence"></emu-prodref>
    <emu-prodref name="SingleEscapeCharacter"></emu-prodref>
    <emu-prodref name="NonEscapeCharacter"></emu-prodref>
    <emu-prodref name="EscapeCharacter"></emu-prodref>
    <emu-prodref name="LegacyOctalEscapeSequence"></emu-prodref>
    <emu-prodref name="NonZeroOctalDigit"></emu-prodref>
    <emu-prodref name="ZeroToThree"></emu-prodref>
    <emu-prodref name="FourToSeven"></emu-prodref>
    <emu-prodref name="NonOctalDecimalEscapeSequence"></emu-prodref>
    <emu-prodref name="HexEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="Hex4Digits"></emu-prodref>
    <emu-prodref name="RegularExpressionLiteral"></emu-prodref>
    <emu-prodref name="RegularExpressionBody"></emu-prodref>
    <emu-prodref name="RegularExpressionChars"></emu-prodref>
    <emu-prodref name="RegularExpressionFirstChar"></emu-prodref>
    <emu-prodref name="RegularExpressionChar"></emu-prodref>
    <emu-prodref name="RegularExpressionBackslashSequence"></emu-prodref>
    <emu-prodref name="RegularExpressionNonTerminator"></emu-prodref>
    <emu-prodref name="RegularExpressionClass"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChars"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChar"></emu-prodref>
    <emu-prodref name="RegularExpressionFlags"></emu-prodref>
    <emu-prodref name="Template"></emu-prodref>
    <emu-prodref name="NoSubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateHead"></emu-prodref>
    <emu-prodref name="TemplateSubstitutionTail"></emu-prodref>
    <emu-prodref name="TemplateMiddle"></emu-prodref>
    <emu-prodref name="TemplateTail"></emu-prodref>
    <emu-prodref name="TemplateCharacters"></emu-prodref>
    <emu-prodref name="TemplateCharacter"></emu-prodref>
    <emu-prodref name="TemplateEscapeSequence"></emu-prodref>
    <emu-prodref name="NotEscapeSequence"></emu-prodref>
    <emu-prodref name="NotCodePoint"></emu-prodref>
    <emu-prodref name="CodePoint"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-expressions">
    <h1>式 (Expressions)</h1>
    <emu-prodref name="IdentifierReference"></emu-prodref>
    <emu-prodref name="BindingIdentifier"></emu-prodref>
    <emu-prodref name="LabelIdentifier"></emu-prodref>
    <emu-prodref name="Identifier"></emu-prodref>
    <emu-prodref name="PrimaryExpression"></emu-prodref>
    <emu-prodref name="CoverParenthesizedExpressionAndArrowParameterList"></emu-prodref>
    <p>
      次の生成規則のインスタンスを処理する際<br>
      <emu-prodref name="PrimaryExpression" a="parencover"></emu-prodref><br>
      |CoverParenthesizedExpressionAndArrowParameterList| の解釈は以下の文法で精密化される:
    </p>
    <emu-prodref name="ParenthesizedExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Literal"></emu-prodref>
    <emu-prodref name="ArrayLiteral"></emu-prodref>
    <emu-prodref name="ElementList"></emu-prodref>
    <emu-prodref name="Elision"></emu-prodref>
    <emu-prodref name="SpreadElement"></emu-prodref>
    <emu-prodref name="ObjectLiteral"></emu-prodref>
    <emu-prodref name="PropertyDefinitionList"></emu-prodref>
    <emu-prodref name="PropertyDefinition"></emu-prodref>
    <emu-prodref name="PropertyName"></emu-prodref>
    <emu-prodref name="LiteralPropertyName"></emu-prodref>
    <emu-prodref name="ComputedPropertyName"></emu-prodref>
    <emu-prodref name="CoverInitializedName"></emu-prodref>
    <emu-prodref name="Initializer"></emu-prodref>
    <emu-prodref name="TemplateLiteral"></emu-prodref>
    <emu-prodref name="SubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateSpans"></emu-prodref>
    <emu-prodref name="TemplateMiddleList"></emu-prodref>
    <emu-prodref name="MemberExpression"></emu-prodref>
    <emu-prodref name="SuperProperty"></emu-prodref>
    <emu-prodref name="MetaProperty"></emu-prodref>
    <emu-prodref name="NewTarget"></emu-prodref>
    <emu-prodref name="ImportMeta"></emu-prodref>
    <emu-prodref name="NewExpression"></emu-prodref>
    <emu-prodref name="CallExpression"></emu-prodref>
    <p>
      次の生成規則のインスタンスを処理する際<br>
      <emu-prodref name="CallExpression" a="callcover"></emu-prodref><br>
      |CoverCallExpressionAndAsyncArrowHead| の解釈は以下の文法で精密化される:
    </p>
    <emu-prodref name="CallMemberExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="SuperCall"></emu-prodref>
    <emu-prodref name="ImportCall"></emu-prodref>
    <emu-prodref name="Arguments"></emu-prodref>
    <emu-prodref name="ArgumentList"></emu-prodref>
    <emu-prodref name="OptionalExpression"></emu-prodref>
    <emu-prodref name="OptionalChain"></emu-prodref>
    <emu-prodref name="LeftHandSideExpression"></emu-prodref>
    <emu-prodref name="UpdateExpression"></emu-prodref>
    <emu-prodref name="UnaryExpression"></emu-prodref>
    <emu-prodref name="ExponentiationExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeOperator"></emu-prodref>
    <emu-prodref name="AdditiveExpression"></emu-prodref>
    <emu-prodref name="ShiftExpression"></emu-prodref>
    <emu-prodref name="RelationalExpression"></emu-prodref>
    <emu-prodref name="EqualityExpression"></emu-prodref>
    <emu-prodref name="BitwiseANDExpression"></emu-prodref>
    <emu-prodref name="BitwiseXORExpression"></emu-prodref>
    <emu-prodref name="BitwiseORExpression"></emu-prodref>
    <emu-prodref name="LogicalANDExpression"></emu-prodref>
    <emu-prodref name="LogicalORExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpressionHead"></emu-prodref>
    <emu-prodref name="ShortCircuitExpression"></emu-prodref>
    <emu-prodref name="ConditionalExpression"></emu-prodref>
    <emu-prodref name="AssignmentExpression"></emu-prodref>
    <emu-prodref name="AssignmentOperator"></emu-prodref>
    <p>
      次の生成規則のインスタンスを処理する特定の状況で<br>
      <emu-prodref name="AssignmentExpression" a="assignment"></emu-prodref><br>
      |LeftHandSideExpression| の解釈は以下の文法で精密化される:
    </p>
    <emu-prodref name="AssignmentPattern"></emu-prodref>
    <emu-prodref name="ObjectAssignmentPattern"></emu-prodref>
    <emu-prodref name="ArrayAssignmentPattern"></emu-prodref>
    <emu-prodref name="AssignmentRestProperty"></emu-prodref>
    <emu-prodref name="AssignmentPropertyList"></emu-prodref>
    <emu-prodref name="AssignmentElementList"></emu-prodref>
    <emu-prodref name="AssignmentElisionElement"></emu-prodref>
    <emu-prodref name="AssignmentProperty"></emu-prodref>
    <emu-prodref name="AssignmentElement"></emu-prodref>
    <emu-prodref name="AssignmentRestElement"></emu-prodref>
    <emu-prodref name="DestructuringAssignmentTarget"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Expression"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-statements">
    <h1>文 (Statements)</h1>
    <emu-prodref name="Statement"></emu-prodref>
    <emu-prodref name="Declaration"></emu-prodref>
    <emu-prodref name="HoistableDeclaration"></emu-prodref>
    <emu-prodref name="BreakableStatement"></emu-prodref>
    <emu-prodref name="BlockStatement"></emu-prodref>
    <emu-prodref name="Block"></emu-prodref>
    <emu-prodref name="StatementList"></emu-prodref>
    <emu-prodref name="StatementListItem"></emu-prodref>
    <emu-prodref name="LexicalDeclaration"></emu-prodref>
    <emu-prodref name="LetOrConst"></emu-prodref>
    <emu-prodref name="BindingList"></emu-prodref>
    <emu-prodref name="LexicalBinding"></emu-prodref>
    <emu-prodref name="VariableStatement"></emu-prodref>
    <emu-prodref name="VariableDeclarationList"></emu-prodref>
    <emu-prodref name="VariableDeclaration"></emu-prodref>
    <emu-prodref name="BindingPattern"></emu-prodref>
    <emu-prodref name="ObjectBindingPattern"></emu-prodref>
    <emu-prodref name="ArrayBindingPattern"></emu-prodref>
    <emu-prodref name="BindingRestProperty"></emu-prodref>
    <emu-prodref name="BindingPropertyList"></emu-prodref>
    <emu-prodref name="BindingElementList"></emu-prodref>
    <emu-prodref name="BindingElisionElement"></emu-prodref>
    <emu-prodref name="BindingProperty"></emu-prodref>
    <emu-prodref name="BindingElement"></emu-prodref>
    <emu-prodref name="SingleNameBinding"></emu-prodref>
    <emu-prodref name="BindingRestElement"></emu-prodref>
    <emu-prodref name="EmptyStatement"></emu-prodref>
    <emu-prodref name="ExpressionStatement"></emu-prodref>
    <emu-prodref name="IfStatement"></emu-prodref>
    <emu-prodref name="IterationStatement"></emu-prodref>
    <emu-prodref name="DoWhileStatement"></emu-prodref>
    <emu-prodref name="WhileStatement"></emu-prodref>
    <emu-prodref name="ForStatement"></emu-prodref>
    <emu-prodref name="ForInOfStatement"></emu-prodref>
    <emu-prodref name="ForDeclaration"></emu-prodref>
    <emu-prodref name="ForBinding"></emu-prodref>
    <emu-prodref name="ContinueStatement"></emu-prodref>
    <emu-prodref name="BreakStatement"></emu-prodref>
    <emu-prodref name="ReturnStatement"></emu-prodref>
    <emu-prodref name="WithStatement"></emu-prodref>
    <emu-prodref name="SwitchStatement"></emu-prodref>
    <emu-prodref name="CaseBlock"></emu-prodref>
    <emu-prodref name="CaseClauses"></emu-prodref>
    <emu-prodref name="CaseClause"></emu-prodref>
    <emu-prodref name="DefaultClause"></emu-prodref>
    <emu-prodref name="LabelledStatement"></emu-prodref>
    <emu-prodref name="LabelledItem"></emu-prodref>
    <emu-prodref name="ThrowStatement"></emu-prodref>
    <emu-prodref name="TryStatement"></emu-prodref>
    <emu-prodref name="Catch"></emu-prodref>
    <emu-prodref name="Finally"></emu-prodref>
    <emu-prodref name="CatchParameter"></emu-prodref>
    <emu-prodref name="DebuggerStatement"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-functions-and-classes">
    <h1>関数とクラス (Functions and Classes)</h1>
    <emu-prodref name="UniqueFormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameterList"></emu-prodref>
    <emu-prodref name="FunctionRestParameter"></emu-prodref>
    <emu-prodref name="FormalParameter"></emu-prodref>
    <emu-prodref name="FunctionDeclaration"></emu-prodref>
    <emu-prodref name="FunctionExpression"></emu-prodref>
    <emu-prodref name="FunctionBody"></emu-prodref>
    <emu-prodref name="FunctionStatementList"></emu-prodref>
    <emu-prodref name="ArrowFunction"></emu-prodref>
    <emu-prodref name="ArrowParameters"></emu-prodref>
    <emu-prodref name="ConciseBody"></emu-prodref>
    <emu-prodref name="ExpressionBody"></emu-prodref>
    <p>
      次の生成規則のインスタンスを処理する際<br>
      <emu-prodref name="ArrowParameters" a="parencover"></emu-prodref><br>
      |CoverParenthesizedExpressionAndArrowParameterList| の解釈は以下の文法で精密化される:
    </p>
    <emu-prodref name="ArrowFormalParameters"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="AsyncArrowFunction"></emu-prodref>
    <emu-prodref name="AsyncConciseBody"></emu-prodref>
    <emu-prodref name="AsyncArrowBindingIdentifier"></emu-prodref>
    <emu-prodref name="CoverCallExpressionAndAsyncArrowHead"></emu-prodref>
    <p>
      次の生成規則のインスタンスを処理する際<br>
      <emu-prodref name="AsyncArrowFunction" a="callcover"></emu-prodref><br>
      |CoverCallExpressionAndAsyncArrowHead| の解釈は以下の文法で精密化される:
    </p>
    <emu-prodref name="AsyncArrowHead"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="MethodDefinition"></emu-prodref>
    <emu-prodref name="PropertySetParameterList"></emu-prodref>
    <emu-prodref name="GeneratorDeclaration"></emu-prodref>
    <emu-prodref name="GeneratorExpression"></emu-prodref>
    <emu-prodref name="GeneratorMethod"></emu-prodref>
    <emu-prodref name="GeneratorBody"></emu-prodref>
    <emu-prodref name="YieldExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorDeclaration"></emu-prodref>
    <emu-prodref name="AsyncGeneratorExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorMethod"></emu-prodref>
    <emu-prodref name="AsyncGeneratorBody"></emu-prodref>
    <emu-prodref name="AsyncFunctionDeclaration"></emu-prodref>
    <emu-prodref name="AsyncFunctionExpression"></emu-prodref>
    <emu-prodref name="AsyncMethod"></emu-prodref>
    <emu-prodref name="AsyncFunctionBody"></emu-prodref>
    <emu-prodref name="AwaitExpression"></emu-prodref>
    <emu-prodref name="ClassDeclaration"></emu-prodref>
    <emu-prodref name="ClassExpression"></emu-prodref>
    <emu-prodref name="ClassTail"></emu-prodref>
    <emu-prodref name="ClassHeritage"></emu-prodref>
    <emu-prodref name="ClassBody"></emu-prodref>
    <emu-prodref name="ClassElementList"></emu-prodref>
    <emu-prodref name="ClassElement"></emu-prodref>
    <emu-prodref name="FieldDefinition"></emu-prodref>
    <emu-prodref name="ClassElementName"></emu-prodref>
    <emu-prodref name="ClassStaticBlock"></emu-prodref>
    <emu-prodref name="ClassStaticBlockBody"></emu-prodref>
    <emu-prodref name="ClassStaticBlockStatementList"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-scripts-and-modules">
    <h1>スクリプトとモジュール (Scripts and Modules)</h1>
    <emu-prodref name="Script"></emu-prodref>
    <emu-prodref name="ScriptBody"></emu-prodref>
    <emu-prodref name="Module"></emu-prodref>
    <emu-prodref name="ModuleBody"></emu-prodref>
    <emu-prodref name="ModuleItemList"></emu-prodref>
    <emu-prodref name="ModuleItem"></emu-prodref>
    <emu-prodref name="ModuleExportName"></emu-prodref>
    <emu-prodref name="ImportDeclaration"></emu-prodref>
    <emu-prodref name="ImportClause"></emu-prodref>
    <emu-prodref name="ImportedDefaultBinding"></emu-prodref>
    <emu-prodref name="NameSpaceImport"></emu-prodref>
    <emu-prodref name="NamedImports"></emu-prodref>
    <emu-prodref name="FromClause"></emu-prodref>
    <emu-prodref name="ImportsList"></emu-prodref>
    <emu-prodref name="ImportSpecifier"></emu-prodref>
    <emu-prodref name="ModuleSpecifier"></emu-prodref>
    <emu-prodref name="ImportedBinding"></emu-prodref>
    <emu-prodref name="WithClause"></emu-prodref>
    <emu-prodref name="WithEntries"></emu-prodref>
    <emu-prodref name="AttributeKey"></emu-prodref>
    <emu-prodref name="ExportDeclaration"></emu-prodref>
    <emu-prodref name="ExportFromClause"></emu-prodref>
    <emu-prodref name="NamedExports"></emu-prodref>
    <emu-prodref name="ExportsList"></emu-prodref>
    <emu-prodref name="ExportSpecifier"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-number-conversions">
    <h1>数値変換 (Number Conversions)</h1>
    <emu-prodref name="StringNumericLiteral"></emu-prodref>
    <emu-prodref name="StrWhiteSpace"></emu-prodref>
    <emu-prodref name="StrWhiteSpaceChar"></emu-prodref>
    <emu-prodref name="StrNumericLiteral"></emu-prodref>
    <emu-prodref name="StrDecimalLiteral"></emu-prodref>
    <emu-prodref name="StrUnsignedDecimalLiteral"></emu-prodref>
    <p>|StringNumericLiteral| 文法で明示的に定義されていない文法記号は <emu-xref href="#sec-literals-numeric-literals">数値リテラルの字句文法</emu-xref> で用いられる定義を使用する。</p>
    <emu-prodref name="StringIntegerLiteral"></emu-prodref>
    <emu-prodref name="StrIntegerLiteral"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-time-zone-offset-string-format">
    <h1>タイムゾーンオフセット文字列形式 (Time Zone Offset String Format)</h1>
    <emu-prodref name="UTCOffset"></emu-prodref>
    <emu-prodref name="ASCIISign"></emu-prodref>
    <emu-prodref name="Hour"></emu-prodref>
    <emu-prodref name="HourSubcomponents"></emu-prodref>
    <emu-prodref name="TimeSeparator"></emu-prodref>
    <emu-prodref name="MinuteSecond"></emu-prodref>
    <emu-prodref name="TemporalDecimalFraction"></emu-prodref>
    <emu-prodref name="TemporalDecimalSeparator"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-regular-expressions">
    <h1>正規表現 (Regular Expressions)</h1>
    <emu-prodref name="Pattern"></emu-prodref>
    <emu-prodref name="Disjunction"></emu-prodref>
    <emu-prodref name="Alternative"></emu-prodref>
    <emu-prodref name="Term"></emu-prodref>
    <emu-prodref name="Assertion"></emu-prodref>
    <emu-prodref name="Quantifier"></emu-prodref>
    <emu-prodref name="QuantifierPrefix"></emu-prodref>
    <emu-prodref name="Atom"></emu-prodref>
    <emu-prodref name="RegularExpressionModifiers"></emu-prodref>
    <emu-prodref name="RegularExpressionModifier"></emu-prodref>
    <emu-prodref name="SyntaxCharacter"></emu-prodref>
    <emu-prodref name="PatternCharacter"></emu-prodref>
    <emu-prodref name="AtomEscape"></emu-prodref>
    <emu-prodref name="CharacterEscape"></emu-prodref>
    <emu-prodref name="ControlEscape"></emu-prodref>
    <emu-prodref name="GroupSpecifier"></emu-prodref>
    <emu-prodref name="GroupName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierStart"></emu-prodref>
    <emu-prodref name="RegExpIdentifierPart"></emu-prodref>
    <emu-prodref name="RegExpUnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeLeadSurrogate"></emu-prodref>
    <emu-prodref name="UnicodeTrailSurrogate"></emu-prodref>
    <p>選択される関連 `u` |HexLeadSurrogate| が曖昧な各 `\\u` |HexTrailSurrogate| は、他に対応する `\\u` |HexTrailSurrogate| を持たない最も近い `u` |HexLeadSurrogate| に関連付けられなければならない。</p>
    <p>&nbsp;</p>
    <emu-prodref name="HexLeadSurrogate"></emu-prodref>
    <emu-prodref name="HexTrailSurrogate"></emu-prodref>
    <emu-prodref name="HexNonSurrogate"></emu-prodref>
    <emu-prodref name="IdentityEscape"></emu-prodref>
    <emu-prodref name="DecimalEscape"></emu-prodref>
    <emu-prodref name="CharacterClassEscape"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueExpression"></emu-prodref>
    <emu-prodref name="UnicodePropertyName"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValue"></emu-prodref>
    <emu-prodref name="LoneUnicodePropertyNameOrValue"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacter"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacter"></emu-prodref>
    <emu-prodref name="CharacterClass"></emu-prodref>
    <emu-prodref name="ClassContents"></emu-prodref>
    <emu-prodref name="NonemptyClassRanges"></emu-prodref>
    <emu-prodref name="NonemptyClassRangesNoDash"></emu-prodref>
    <emu-prodref name="ClassAtom"></emu-prodref>
    <emu-prodref name="ClassAtomNoDash"></emu-prodref>
    <emu-prodref name="ClassEscape"></emu-prodref>
    <emu-prodref name="ClassSetExpression"></emu-prodref>
    <emu-prodref name="ClassUnion"></emu-prodref>
    <emu-prodref name="ClassIntersection"></emu-prodref>
    <emu-prodref name="ClassSubtraction"></emu-prodref>
    <emu-prodref name="ClassSetRange"></emu-prodref>
    <emu-prodref name="ClassSetOperand"></emu-prodref>
    <emu-prodref name="NestedClass"></emu-prodref>
    <emu-prodref name="ClassStringDisjunction"></emu-prodref>
    <emu-prodref name="ClassStringDisjunctionContents"></emu-prodref>
    <emu-prodref name="ClassString"></emu-prodref>
    <emu-prodref name="NonEmptyClassString"></emu-prodref>
    <emu-prodref name="ClassSetCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedDoublePunctuator"></emu-prodref>
    <emu-prodref name="ClassSetSyntaxCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedPunctuator"></emu-prodref>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace="annexB" normative>
  <h1>Web ブラウザ向け追加 ECMAScript 機能</h1>
  <p>本附属書で定義される ECMAScript 言語の構文および意味論は、ECMAScript ホストが Web ブラウザである場合には必須である。ホストが Web ブラウザでない場合、この附属書の内容は規範的だが任意である。</p>
  <p>本附属書で定義される一部の機能は本附属書内に記述され、他の一部は本文（メイン仕様）内に記述される。</p>
  <p>ある機能が本文で規定されている場合、その機能が文書に影響する各箇所は彩色されたボックス内の "Normative Optional" という語で示される。さらに、アルゴリズムや早期エラー規則中で特定の文言がその機能に依存する場合、それは「その関連機能を <dfn variants="otherwise supports">the host supports</dfn>（ホストがサポートする）」という条件でガードされる。Web ブラウザはそのような機能をすべてサポートすることが要求される。</p>
  <emu-note>
    <p>この附属書は各種レガシー機能および Web ブラウザ ECMAScript ホストの特性を記述する。本附属書に規定される言語機能と挙動は一つ以上の望ましくない特性を持ち、レガシー利用が存在しなければ仕様から削除されるものである。しかし多数の既存 Web ページがこれら機能を利用しているため、Web ブラウザは継続的なサポートが必要である。本附属書の規定はこれらレガシー機能の相互運用可能な実装要件を定義する。</p>
    <p>これら機能は ECMAScript 言語のコアには含まれないと見なされる。新しい ECMAScript コードを書く際、開発者はこれらの機能や振る舞いの存在を使用・前提とすべきではない。Web ブラウザの一部であるか、Web ブラウザが遭遇する同じレガシー ECMAScript コードを実行する必要がある場合を除き、実装はこれら機能の実装を推奨されない。</p>
  </emu-note>

  <emu-annex id="sec-additional-syntax">
    <h1>追加構文</h1>

    <emu-annex id="sec-html-like-comments">
      <h1>HTML 風コメント</h1>
      <p><emu-xref href="#sec-comments"></emu-xref> の構文と意味論は、ゴール記号 |Module| を用いたソーステキスト解析ではこの拡張が許可されないことを除き、以下のように拡張される。</p>
      <h2>構文</h2>
      <emu-grammar type="definition">
        InputElementHashbangOrRegExp ::
          WhiteSpace
          LineTerminator
          Comment
          CommonToken
          HashbangComment
          RegularExpressionLiteral
          HTMLCloseComment

        Comment ::
          MultiLineComment
          SingleLineComment
          SingleLineHTMLOpenComment
          SingleLineHTMLCloseComment
          SingleLineDelimitedComment

        MultiLineComment ::
          `/*` FirstCommentLine? LineTerminator MultiLineCommentChars? `*/` HTMLCloseComment?

        FirstCommentLine ::
          SingleLineDelimitedCommentChars

        SingleLineHTMLOpenComment ::
          `&lt;!--` SingleLineCommentChars?

        SingleLineHTMLCloseComment ::
          LineTerminatorSequence HTMLCloseComment

        SingleLineDelimitedComment ::
          `/*` SingleLineDelimitedCommentChars? `*/`

        HTMLCloseComment ::
          WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `--&gt;` SingleLineCommentChars?

        SingleLineDelimitedCommentChars ::
          SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotAsteriskChar ::
          SourceCharacter but not one of `*` or LineTerminator

        SingleLinePostAsteriskCommentChars ::
          SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotForwardSlashOrAsteriskChar ::
          SourceCharacter but not one of `/` or `*` or LineTerminator

        WhiteSpaceSequence ::
          WhiteSpace WhiteSpaceSequence?

        SingleLineDelimitedCommentSequence ::
          SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?
      </emu-grammar>
      <p>|LineTerminator| のコードポイントを含む |MultiLineComment| と同様に、|SingleLineHTMLCloseComment| は構文文法による構文解析上 |LineTerminator| と見なされる。</p>
    </emu-annex>

    <emu-annex id="sec-regular-expressions-patterns">
      <h1>正規表現パターン</h1>
      <p><emu-xref href="#sec-patterns"></emu-xref> の構文は以下のように修正・拡張される。これらの変更は文法生成規則の順序および文脈情報で解消される曖昧性を導入する。以下の文法で構文解析する際、各選択肢はそれ以前の生成規則選択肢がマッチしない場合のみ検討される。</p>
      <p>この代替パターン文法と意味論は BMP パターンの構文と意味論のみを変更する。以下の文法拡張には [UnicodeMode] パラメータ付き生成規則が含まれる。しかし、これら拡張はゴール記号に [UnicodeMode] パラメータが存在する場合に認識される Unicode パターンの構文を変更しない。</p>
      <h2>構文</h2>
      <emu-grammar type="definition">
        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [+UnicodeMode] Assertion[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] Assertion[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups]

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          [+UnicodeMode] `(?=` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [+UnicodeMode] `(?!` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups]
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        QuantifiableAssertion[NamedCaptureGroups] ::
          `(?=` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`

        ExtendedAtom[NamedCaptureGroups] ::
          `.`
          `\` AtomEscape[~UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]
          CharacterClass[~UnicodeMode, ~UnicodeSetsMode]
          `(` GroupSpecifier[~UnicodeMode]? Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          InvalidBracedQuantifier
          ExtendedPatternCharacter

        InvalidBracedQuantifier ::
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        ExtendedPatternCharacter ::
          SourceCharacter but not one of `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `|`

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] DecimalEscape
          [~UnicodeMode] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is &le; CountLeftCapturingParensWithin(the |Pattern| containing |DecimalEscape|)]
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode, NamedCaptureGroups] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          [~UnicodeMode] LegacyOctalEscapeSequence
          IdentityEscape[?UnicodeMode, ?NamedCaptureGroups]

        IdentityEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacterIdentityEscape[?NamedCaptureGroups]

        SourceCharacterIdentityEscape[NamedCaptureGroups] ::
          [~NamedCaptureGroups] SourceCharacter but not `c`
          [+NamedCaptureGroups] SourceCharacter but not one of `c` or `k`

        ClassAtomNoDash[UnicodeMode, NamedCaptureGroups] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]

        ClassEscape[UnicodeMode, NamedCaptureGroups] ::
          `b`
          [+UnicodeMode] `-`
          [~UnicodeMode] `c` ClassControlLetter
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]

        ClassControlLetter ::
          DecimalDigit
          `_`
      </emu-grammar>
      <emu-note>
        <p>同一の左辺が [+UnicodeMode] と [~UnicodeMode] の両方で現れるのは曖昧性解消の優先度を制御するためである。</p>
      </emu-note>

      <emu-annex id="sec-patterns-static-semantics-early-errors-annexb">
        <h1>静的意味論: 早期エラー</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-early-errors"></emu-xref> の意味論は次のように拡張される:</p>
        <emu-grammar>ExtendedAtom :: InvalidBracedQuantifier</emu-grammar>
        <ul>
          <li>
            この生成規則にマッチするソーステキストが存在する場合は Syntax Error である。
          </li>
        </ul>
        <p>さらに、以下の生成規則に対する規則は <ins>強調された</ins> 追加文言を含むよう修正される:</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            最初の |ClassAtom| の IsCharacterClass が *true* または 2 番目の |ClassAtom| の IsCharacterClass が *true* <ins>かつ本生成規則が <sub>[UnicodeMode]</sub> パラメータを持つ</ins> 場合は Syntax Error。
          </li>
          <li>
            最初の |ClassAtom| の IsCharacterClass が *false*、2 番目の |ClassAtom| の IsCharacterClass が *false* で、最初の |ClassAtom| の CharacterValue が 2 番目より厳密に大きい場合は Syntax Error。
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            |ClassAtomNoDash| の IsCharacterClass が *true* または |ClassAtom| の IsCharacterClass が *true* <ins>かつ本生成規則が <sub>[UnicodeMode]</sub> パラメータを持つ</ins> 場合は Syntax Error。
          </li>
          <li>
            |ClassAtomNoDash| の IsCharacterClass が *false*、|ClassAtom| の IsCharacterClass が *false* で、|ClassAtomNoDash| の CharacterValue が |ClassAtom| の CharacterValue より厳密に大きい場合は Syntax Error。
          </li>
        </ul>
      </emu-annex>

      <emu-annex id="sec-countleftcapturingparens-annexb">
        <h1>静的意味論: CountLeftCapturingParensWithin / CountLeftCapturingParensBefore</h1>
        <p>CountLeftCapturingParensWithin および CountLeftCapturingParensBefore の定義において “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>” という参照は “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>” または “<emu-grammar>ExtendedAtom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>” を意味するものとして解釈する。</p>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-is-character-class-annexb">
        <h1>静的意味論: IsCharacterClass</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-is-character-class"></emu-xref> の意味論は以下のように拡張される:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. *false* を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-character-value-annexb">
        <h1>静的意味論: CharacterValue</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-character-value"></emu-xref> の意味論は以下のように拡張される:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. U+005C (REVERSE SOLIDUS) の数値値を返す。
        </emu-alg>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. _ch_ を |ClassControlLetter| にマッチしたコードポイントとする。
          1. _i_ を _ch_ の数値値とする。
          1. _i_ を 32 で割った余りを返す。
        </emu-alg>
        <emu-grammar>CharacterEscape :: LegacyOctalEscapeSequence</emu-grammar>
        <emu-alg>
          1. |LegacyOctalEscapeSequence| の MV を返す (<emu-xref href="#sec-string-literals-static-semantics-mv"></emu-xref> を参照)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compilesubpattern-annexb" oldids="sec-regular-expression-patterns-semantics">
        <h1>実行時意味論: CompileSubpattern</h1>
        <p>CompileSubpattern の意味論は以下のように拡張される:</p>

        <p><emu-grammar>Term :: QuantifiableAssertion Quantifier</emu-grammar> の規則は <emu-grammar>Term :: Atom Quantifier</emu-grammar> の規則と同一だが |Atom| を |QuantifiableAssertion| に置き換える。</p>
        <p><emu-grammar>Term :: ExtendedAtom Quantifier</emu-grammar> の規則は <emu-grammar>Term :: Atom Quantifier</emu-grammar> の規則と同一だが |Atom| を |ExtendedAtom| に置き換える。</p>
        <p><emu-grammar>Term :: ExtendedAtom</emu-grammar> の規則は <emu-grammar>Term :: Atom</emu-grammar> の規則と同一だが |Atom| を |ExtendedAtom| に置き換える。</p>
      </emu-annex>

      <emu-annex id="sec-compileassertion-annexb">
        <h1>実行時意味論: CompileAssertion</h1>
        <p><emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar> および <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar> の CompileAssertion 規則は |QuantifiableAssertion| 生成規則にも用いられるが、|Assertion| を |QuantifiableAssertion| に置き換える。</p>
      </emu-annex>

      <emu-annex id="sec-compileatom-annexb">
        <h1>実行時意味論: CompileAtom</h1>
        <p>|Atom| 生成規則（<emu-grammar>Atom :: PatternCharacter</emu-grammar> を除く）に対する CompileAtom 規則は |ExtendedAtom| 生成規則にも用いられ、|Atom| を |ExtendedAtom| に置き換える。さらに parameter _direction_ を伴う以下の規則が追加される:</p>
        <emu-grammar>ExtendedAtom :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. _A_ を単一文字 `\\` U+005C (REVERSE SOLIDUS) を含む CharSet とする。
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) を返す。
        </emu-alg>
        <emu-grammar>ExtendedAtom :: ExtendedPatternCharacter</emu-grammar>
        <emu-alg>
          1. _ch_ を |ExtendedPatternCharacter| により表される文字とする。
          1. _A_ を文字 _ch_ を 1 要素として含む CharSet とする。
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compiletocharset-annexb">
        <h1>実行時意味論: CompileToCharSet</h1>
        <p><emu-xref href="#sec-compiletocharset"></emu-xref> の意味論は以下のように拡張される:</p>

        <p>次の 2 つの規則は CompileToCharSet の対応する規則を置き換える。</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ を第 1 の |ClassAtom| に対し引数 _rer_ で CompileToCharSet を適用した結果とする。
          1. _B_ を第 2 の |ClassAtom| に対し引数 _rer_ で CompileToCharSet を適用した結果とする。
          1. _C_ を |ClassContents| に対し引数 _rer_ で CompileToCharSet を適用した結果とする。
          1. _D_ を CharacterRangeOrUnion(_rer_, _A_, _B_) とする。
          1. _D_ と _C_ の和集合を返す。
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ を |ClassAtomNoDash| に対し引数 _rer_ で CompileToCharSet を適用した結果とする。
          1. _B_ を |ClassAtom| に対し引数 _rer_ で CompileToCharSet を適用した結果とする。
          1. _C_ を |ClassContents| に対し引数 _rer_ で CompileToCharSet を適用した結果とする。
          1. _D_ を CharacterRangeOrUnion(_rer_, _A_, _B_) とする。
          1. _D_ と _C_ の和集合を返す。
        </emu-alg>

        <p>加えて、以下の規則が CompileToCharSet に追加される。</p>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. _cv_ をこの |ClassEscape| の CharacterValue とする。
          1. _c_ を文字値が _cv_ の文字とする。
          1. 文字 _c_ を単一要素として含む CharSet を返す。
        </emu-alg>
        <emu-grammar>ClassAtomNoDash :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. 単一文字 `\\` U+005C (REVERSE SOLIDUS) を含む CharSet を返す。
        </emu-alg>

        <emu-note>この生成規則は、受容可能な制御文字が続かない文字クラス内部のシーケンス `\c` からのみ到達し得る。</emu-note>

        <emu-annex id="sec-runtime-semantics-characterrangeorunion-abstract-operation" type="abstract operation">
          <h1>
            CharacterRangeOrUnion (
              _rer_: a RegExp Record,
              _A_: a CharSet,
              _B_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. HasEitherUnicodeFlag(_rer_) が *false* なら
              1. もし _A_ がちょうど 1 文字を含むわけではない、または _B_ がちょうど 1 文字を含むわけではないなら
                1. _C_ を単一文字 `-` U+002D (HYPHEN-MINUS) を含む CharSet とする。
                1. CharSet _A_, _B_, _C_ の和集合を返す。
            1. CharacterRange(_A_, _B_) を返す。
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-parsepattern-annexb">
        <h1>静的意味論: ParsePattern ( _patternText_, _u_, _v_ )</h1>
        <p><emu-xref href="#sec-parsepattern"></emu-xref> の意味論は以下のように拡張される:</p>
        <p>抽象操作 ParsePattern は引数 _patternText_（Unicode コードポイント列）、_u_（Boolean）、_v_（Boolean）を取り、呼び出し時に次を行う:</p>
        <emu-alg>
          1. もし _v_ が *true* かつ _u_ が *true* なら
            1. _parseResult_ を 1 個以上の *SyntaxError* オブジェクトを含む List とする。
          1. それ以外で _v_ が *true* なら
            1. _parseResult_ を ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|) とする。
          1. それ以外で _u_ が *true* なら
            1. _parseResult_ を ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|) とする。
          1. それ以外
            1. _parseResult_ を ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, ~NamedCaptureGroups]|) とする。
            1. もし _parseResult_ が Parse Node でかつ |GroupName| を含むなら
              1. _parseResult_ を ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|) に設定する。
          1. _parseResult_ を返す。
        </emu-alg>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-additional-built-in-properties">
    <h1>追加の組込みプロパティ</h1>
    <p>ECMAScript ホストが Web ブラウザである場合、標準組込みオブジェクトに以下の追加プロパティが定義される。</p>

    <emu-annex id="sec-additional-properties-of-the-global-object">
      <h1>グローバルオブジェクトの追加プロパティ</h1>
      <p><emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref> の項目が <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref> に追加される。</p>
      <emu-table id="table-additional-well-known-intrinsic-objects" caption="Additional Well-known Intrinsic Objects" oldids="table-60">
        <table>
          <thead>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              %escape%
            </td>
            <td>
              `escape`
            </td>
            <td>
              `escape` 関数 (<emu-xref href="#sec-escape-string"></emu-xref>)
            </td>
          </tr>
          <tr>
            <td>
              %unescape%
            </td>
            <td>
              `unescape`
            </td>
            <td>
              `unescape` 関数 (<emu-xref href="#sec-unescape-string"></emu-xref>)
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-annex id="sec-escape-string">
        <h1>escape ( _string_ )</h1>
        <p>この関数はグローバルオブジェクトのプロパティである。特定のコードユニットを 16 進エスケープシーケンスに置換した新しい String 値を生成する。</p>
        <p>数値値が 0x00FF 以下のコードユニットを置換する際は <code>%<var>xx</var></code> 形式の 2 桁エスケープシーケンスを用いる。数値値が 0x00FF を超えるコードユニットを置換する際は <code>%u<var>xxxx</var></code> 形式の 4 桁エスケープシーケンスを用いる。</p>
        <p>これは <dfn>%escape%</dfn> イントリンシックオブジェクトである。</p>
        <p>呼び出し時、次の手順を実行する:</p>
        <emu-alg>
          1. _string_ を ? ToString(_string_) に設定する。
          1. _len_ を _string_ の長さとする。
          1. _R_ を空文字列とする。
          1. _unescapedSet_ を ASCII の単語構成文字と *"@\*+-./"* の文字列連結とする。
          1. _k_ を 0 とする。
          1. 繰り返し (_k_ &lt; _len_ の間):
            1. _C_ を _string_ 内インデックス _k_ のコードユニットとする。
            1. もし _unescapedSet_ が _C_ を含むなら
              1. _S_ を _C_ とする。
            1. それ以外
              1. _n_ を _C_ の数値値とする。
              1. もし _n_ &lt; 256 なら
                1. _hex_ を _n_ の大文字 16 進表現とする。
                1. _S_ を *"%"* と StringPad(_hex_, 2, *"0"*, ~start~) の連結とする。
              1. それ以外
                1. _hex_ を _n_ の大文字 16 進表現とする。
                1. _S_ を *"%u"* と StringPad(_hex_, 4, *"0"*, ~start~) の連結とする。
            1. _R_ を _R_ と _S_ の連結に設定する。
            1. _k_ を _k_ + 1 に設定する。
          1. _R_ を返す。
        </emu-alg>
        <emu-note>
          <p>このエンコーディングは部分的に RFC 1738 に記述されたエンコーディングに基づくが、本標準で規定されるエンコーディング全体は RFC 1738 の内容を参照せず上記で完結している。このエンコーディングは RFC 3986 による RFC 1738 への変更を反映しない。</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-unescape-string">
        <h1>unescape ( _string_ )</h1>
        <p>この関数はグローバルオブジェクトのプロパティである。`escape` 関数によって導入され得る種類の各エスケープシーケンスを、その表すコードユニットへ置換した新しい String 値を生成する。</p>
        <p>これは <dfn>%unescape%</dfn> イントリンシックオブジェクトである。</p>
        <p>呼び出し時、次の手順を実行する:</p>
        <emu-alg>
          1. _string_ を ? ToString(_string_) に設定する。
          1. _len_ を _string_ の長さとする。
          1. _R_ を空文字列とする。
          1. _k_ を 0 とする。
          1. 繰り返し (_k_ &lt; _len_ の間):
            1. _C_ を _string_ 内インデックス _k_ のコードユニットとする。
            1. もし _C_ がコードユニット 0x0025 (PERCENT SIGN) なら
              1. _hexDigits_ を空文字列とする。
              1. _optionalAdvance_ を 0 とする。
              1. もし _k_ + 5 &lt; _len_ かつ _string_ のインデックス _k_ + 1 のコードユニットが 0x0075 (LATIN SMALL LETTER U) なら
                1. _hexDigits_ を _string_ の _k_ + 2 から _k_ + 6 までの部分文字列とする。
                1. _optionalAdvance_ を 5 に設定する。
              1. それ以外で _k_ + 3 ≤ _len_ なら
                1. _hexDigits_ を _string_ の _k_ + 1 から _k_ + 3 までの部分文字列とする。
                1. _optionalAdvance_ を 2 に設定する。
              1. _parseResult_ を ParseText(_hexDigits_, |HexDigits[~Sep]|) とする。
              1. もし _parseResult_ が Parse Node なら
                1. _n_ を _parseResult_ の MV とする。
                1. _C_ を数値値 _n_ のコードユニットとする。
                1. _k_ を _k_ + _optionalAdvance_ に設定する。
            1. _R_ を _R_ と _C_ の連結に設定する。
            1. _k_ を _k_ + 1 に設定する。
          1. _R_ を返す。
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-string.prototype-object">
      <h1>String.prototype オブジェクトの追加プロパティ</h1>

      <emu-annex id="sec-string.prototype.substr">
        <h1>String.prototype.substr ( _start_, _length_ )</h1>
        <p>このメソッドは *this* 値を String に変換した結果の <emu-not-ref>substring</emu-not-ref> を返す。開始インデックス _start_ から _length_ 個のコードユニット（_length_ が *undefined* の場合末尾まで）を含む。_start_ が負なら _sourceLength_ を文字列長として <emu-eqn>_sourceLength_ + _start_</emu-eqn> として扱う。結果は String 値であり String オブジェクトではない。</p>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. ? RequireObjectCoercible(_O_) を実行する。
          1. _S_ を ? ToString(_O_) とする。
          1. _size_ を _S_ の長さとする。
          1. _intStart_ を ? ToIntegerOrInfinity(_start_) とする。
          1. もし _intStart_ = -∞ なら _intStart_ を 0 に設定する。
          1. それ以外で _intStart_ &lt; 0 なら _intStart_ を max(_size_ + _intStart_, 0) に設定する。
          1. それ以外は _intStart_ を min(_intStart_, _size_) に設定する。
          1. もし _length_ が *undefined* なら _intLength_ を _size_ とする；そうでなければ _intLength_ を ? ToIntegerOrInfinity(_length_) とする。
          1. _intLength_ を 0 と _size_ の間にクランプした結果に設定する。
          1. _intEnd_ を min(_intStart_ + _intLength_, _size_) とする。
          1. _S_ の _intStart_ から _intEnd_ までの substring を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは意図的にジェネリックであり、*this* 値が String オブジェクトであることを要求しない。他オブジェクトへメソッドとして移して使用できる。</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-string.prototype.anchor">
        <h1>String.prototype.anchor ( _name_ )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"a"*, *"name"*, _name_) を返す。
        </emu-alg>

        <emu-annex id="sec-createhtml" type="abstract operation">
          <h1>
            CreateHTML (
              _string_: an ECMAScript language value,
              _tag_: a String,
              _attribute_: a String,
              _value_: an ECMAScript language value,
            ): 正常完了で String を含むか、または throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ? RequireObjectCoercible(_string_) を実行する。
            1. _S_ を ? ToString(_string_) とする。
            1. _p1_ を *"&lt;"* と _tag_ の連結とする。
            1. もし _attribute_ が空文字列でなければ
              1. _V_ を ? ToString(_value_) とする。
              1. _escapedV_ を _V_ 内の各 0x0022 (QUOTATION MARK) を 6 コードユニット列 *"&amp;quot;"* に置換した文字列値とする。
              1. _p1_ を以下の連結とする:
                * _p1_
                * 0x0020 (SPACE)
                * _attribute_
                * 0x003D (EQUALS SIGN)
                * 0x0022 (QUOTATION MARK)
                * _escapedV_
                * 0x0022 (QUOTATION MARK)
            1. _p2_ を _p1_ と *">"* の連結とする。
            1. _p3_ を _p2_ と _S_ の連結とする。
            1. _p4_ を _p3_, *"&lt;/"*, _tag_, *">"* の連結とする。
            1. _p4_ を返す。
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-string.prototype.big">
        <h1>String.prototype.big ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"big"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.blink">
        <h1>String.prototype.blink ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"blink"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.bold">
        <h1>String.prototype.bold ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"b"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fixed">
        <h1>String.prototype.fixed ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"tt"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontcolor">
        <h1>String.prototype.fontcolor ( _colour_ )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"font"*, *"color"*, _colour_) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontsize">
        <h1>String.prototype.fontsize ( _size_ )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"font"*, *"size"*, _size_) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.italics">
        <h1>String.prototype.italics ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"i"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.link">
        <h1>String.prototype.link ( _url_ )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"a"*, *"href"*, _url_) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.small">
        <h1>String.prototype.small ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"small"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.strike">
        <h1>String.prototype.strike ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"strike"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sub">
        <h1>String.prototype.sub ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"sub"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sup">
        <h1>String.prototype.sup ( )</h1>
        <p>呼び出し時、次を行う:</p>
        <emu-alg>
          1. _S_ を *this* 値とする。
          1. ? CreateHTML(_S_, *"sup"*, *""*, *""*) を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="String.prototype.trimleft">
        <h1>String.prototype.trimLeft ( )</h1>
        <emu-note>
          <p>*"trimStart"* プロパティが推奨される。*"trimLeft"* は主として古いコードとの互換性のために提供される。新しい ECMAScript コードでは *"trimStart"* の使用が推奨される。</p>
        </emu-note>
        <p>*"trimLeft"* プロパティの初期値は <emu-xref href="#sec-string.prototype.trimstart"></emu-xref> で定義される %String.prototype.trimStart% である。</p>
      </emu-annex>

      <emu-annex id="String.prototype.trimright">
        <h1>String.prototype.trimRight ( )</h1>
        <emu-note>
          <p>*"trimEnd"* プロパティが推奨される。*"trimRight"* は主として古いコードとの互換性のために提供される。新しい ECMAScript コードでは *"trimEnd"* の使用が推奨される。</p>
        </emu-note>
        <p>*"trimRight"* プロパティの初期値は <emu-xref href="#sec-string.prototype.trimend"></emu-xref> で定義される %String.prototype.trimEnd% である。</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-date.prototype-object">
      <h1>Date.prototype オブジェクトの追加プロパティ</h1>

      <emu-annex id="sec-date.prototype.getyear">
        <h1>Date.prototype.getYear ( )</h1>
        <emu-note>
          <p>“2000 年問題” を回避できるため、ほぼ全ての目的で `getFullYear` メソッドが推奨される。</p>
        </emu-note>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _dateObject_ を *this* 値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. もし _t_ が *NaN* なら *NaN* を返す。
          1. YearFromTime(LocalTime(_t_)) - *1900*<sub>𝔽</sub> を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.setyear">
        <h1>Date.prototype.setYear ( _year_ )</h1>
        <emu-note>
          <p>“2000 年問題” を回避できるため、ほぼ全ての目的で `setFullYear` メソッドが推奨される。</p>
        </emu-note>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _dateObject_ を *this* 値とする。
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) を実行する。
          1. _t_ を _dateObject_.[[DateValue]] とする。
          1. _y_ を ? ToNumber(_year_) とする。
          1. もし _t_ が *NaN* なら _t_ を *+0*<sub>𝔽</sub> に、そうでなければ _t_ を LocalTime(_t_) に設定する。
          1. _yyyy_ を MakeFullYear(_y_) とする。
          1. _d_ を MakeDay(_yyyy_, MonthFromTime(_t_), DateFromTime(_t_)) とする。
          1. _date_ を MakeDate(_d_, TimeWithinDay(_t_)) とする。
          1. _u_ を TimeClip(UTC(_date_)) とする。
          1. _dateObject_.[[DateValue]] を _u_ に設定する。
          1. _u_ を返す。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.togmtstring">
        <h1>Date.prototype.toGMTString ( )</h1>
        <emu-note>
          <p>`toUTCString` メソッドが推奨される。このメソッドは主として古いコードとの互換性のために提供される。</p>
        </emu-note>
        <p>*"toGMTString"* プロパティの初期値は <emu-xref href="#sec-date.prototype.toutcstring"></emu-xref> で定義される %Date.prototype.toUTCString% である。</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-regexp.prototype-object">
      <h1>RegExp.prototype オブジェクトの追加プロパティ</h1>

      <emu-annex id="sec-regexp.prototype.compile">
        <h1>RegExp.prototype.compile ( _pattern_, _flags_ )</h1>
        <p>このメソッドは呼び出し時に次を行う:</p>
        <emu-alg>
          1. _O_ を *this* 値とする。
          1. ? RequireInternalSlot(_O_, [[RegExpMatcher]]) を実行する。
          1. もし _pattern_ が Object で [[RegExpMatcher]] 内部スロットを持つなら
            1. もし _flags_ が *undefined* でなければ *TypeError* 例外を投げる。
            1. _P_ を _pattern_.[[OriginalSource]] とする。
            1. _F_ を _pattern_.[[OriginalFlags]] とする。
          1. それ以外
            1. _P_ を _pattern_ とする。
            1. _F_ を _flags_ とする。
          1. ? RegExpInitialize(_O_, _P_, _F_) を返す。
        </emu-alg>
        <emu-note>
          <p>このメソッドは *this* の RegExp を新しいパターンとフラグで完全に再初期化する。実装はこのメソッドの使用を、結果の RegExp オブジェクトが複数回使用され最適化候補であるという表明として解釈し得る。</p>
        </emu-note>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-other-additional-features">
    <h1>その他の追加機能</h1>

    <emu-annex id="sec-labelled-function-declarations">
      <h1>ラベル付き Function 宣言</h1>
      <p>ECMAScript 2015 以前、|LabelledStatement| の仕様は |FunctionDeclaration| にステートメントラベルを関連付けることを許可していなかった。しかし非 strict コード向けの拡張として許容され、多くのブラウザホスト実装はそれをサポートしていた。ECMAScript 2015 以降、|LabelledStatement| の文法生成規則は |FunctionDeclaration| を |LabelledItem| として許容するが、<emu-xref href="#sec-labelled-statements-static-semantics-early-errors"></emu-xref> の早期エラー規則がそれを Syntax Error とする。その規則はホストがこの機能をサポートする場合、非 strict コードで Syntax Error を抑制するよう修正される。</p>
      <emu-note>
        <p>|WithStatement|, |IfStatement|, |IterationStatement| の早期エラー規則は非 strict コード内でこれらのステートメントがラベル付き |FunctionDeclaration| を含むことを防ぐ。</p>
      </emu-note>
    </emu-annex>

    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>ブロックレベル Function 宣言 (Web レガシー互換意味論)</h1>
      <p>ECMAScript 2015 以前、|Block| ステートメントの |StatementList| 要素として |FunctionDeclaration| が出現することは ECMAScript 仕様で定義されていなかった。しかしその形式は拡張として許容され、多くのブラウザ実装で許可されていた。不幸にも実装間で意味論が異なる。これらの差異のため、|Block| レベルの function 宣言を用いる既存 Web ソースは、全ブラウザ実装の意味論的交差に依存する場合のみ移植性がある。以下はその交差意味論に属するユースケースである:</p>
      <ol>
        <li>
          <p>関数が宣言され単一のブロック内でのみ参照される。</p>
          <ul>
            <li>
              識別子 _f_ を |BindingIdentifier| とする 1 つ以上の |FunctionDeclaration| が外側関数 _g_ の関数コード内の |Block| にネストして現れる。
            </li>
            <li>
              _g_ の関数コード内に `var` 以外の _f_ の他の宣言が存在しない。
            </li>
            <li>
              _f_ の |IdentifierReference| としての出現は、_f_ の宣言を含む |Block| の |StatementList| 内にある。
            </li>
          </ul>
        </li>
        <li>
          <p>関数が 1 つの |Block| 内で宣言され（必要なら使用される）さらに同一 |Block| 外の内側関数定義から参照される。</p>
          <ul>
            <li>
              識別子 _f_ を |BindingIdentifier| とする 1 つ以上の |FunctionDeclaration| が外側関数 _g_ の関数コード内の |Block| にネストして現れる。
            </li>
            <li>
              _g_ の関数コード内に `var` 以外の _f_ の他の宣言が存在しない。
            </li>
            <li>
              _f_ の |IdentifierReference| 出現が宣言を含む |Block| の |StatementList| 内に存在してもよい。
            </li>
            <li>
              _g_ 内にネストした別の関数 _h_ 内に _f_ の |IdentifierReference| 出現が少なくとも 1 つ存在し、_h_ 内からの参照を隠す _f_ の他の宣言がない。
            </li>
            <li>
              _h_ の呼び出しは _f_ の宣言が評価された後にのみ起こる。
            </li>
          </ul>
        </li>
        <li>
          <p>関数が 1 つのブロック内で宣言され（必要なら使用され）さらに後続のブロック内で参照される。</p>
          <ul>
            <li>
              識別子 _f_ を |BindingIdentifier| とする 1 つ以上の |FunctionDeclaration| が外側関数 _g_ の関数コード内の |Block| にネストして現れる。
            </li>
            <li>
              _g_ の関数コード内に `var` 以外の _f_ の他の宣言が存在しない。
            </li>
            <li>
              _f_ の |IdentifierReference| 出現が宣言を含む |Block| の |StatementList| 内に存在してもよい。
            </li>
            <li>
              _g_ の関数コード内で、その |Block| の後に字句的に続く位置に _f_ の |IdentifierReference| 出現が少なくとも 1 つ存在する。
            </li>
          </ul>
        </li>
      </ol>
      <p>最初のユースケースは ECMAScript 2015 が提供する |Block| レベル function 宣言の意味論と相互運用可能である。このユースケースを用いる既存のソースは <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>、<emu-xref href="#sec-ecmascript-language-statements-and-declarations"></emu-xref>、<emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref> で定義される意味論を用いて動作する。</p>
      <p>2 番目と 3 番目のユースケースの ECMAScript 2015 相互運用性には、<emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>、<emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref>、<emu-xref href="#sec-eval-x"></emu-xref>、<emu-xref href="#sec-globaldeclarationinstantiation"></emu-xref> 節の意味論への以下の拡張が必要である。</p>
      <p>実装が診断警告メッセージを報告する仕組みを持つ場合、この互換意味論が適用され非互換意味論との差異が観測可能となる |FunctionDeclaration| を含むコードに対して警告を出すべきである。例えば var バインディングの導入が早期エラーを生むために導入されない場合は警告を出すべきでない。</p>
      <p>この機能は次の箇所で特別な意味論を伴う:</p>
      <ul>
        <li><emu-xref href="#sec-block-static-semantics-early-errors"></emu-xref> における <emu-grammar>Block : `{` StatementList `}`</emu-grammar> の早期エラー規則の一つ</li>
        <li><emu-xref href="#sec-switch-statement-static-semantics-early-errors"></emu-xref> における <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar> の早期エラー規則の一つ</li>
        <li>FunctionDeclarationInstantiation の <emu-xref href="#step-functiondeclarationinstantiation-web-compat-insertion-point"></emu-xref> ステップ</li>
        <li>BlockDeclarationInstantiation の <emu-xref href="#step-blockdeclarationinstantiation-createmutablebinding"></emu-xref> ステップ</li>
        <li>BlockDeclarationInstantiation の <emu-xref href="#step-blockdeclarationinstantiation-initializebinding"></emu-xref> ステップ</li>
        <li>GlobalDeclarationInstantiation の <emu-xref href="#step-globaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> ステップ</li>
        <li>EvalDeclarationInstantiation の <emu-xref href="#step-evaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> ステップ</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-functiondeclarations-in-ifstatement-statement-clauses">
      <h1>IfStatement の節内 FunctionDeclarations</h1>
      <p>以下は <emu-xref href="#sec-if-statement"></emu-xref> の |IfStatement| 生成規則を拡張する:</p>
      <emu-grammar type="definition">
        IfStatement[Yield, Await, Return] :
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` Statement[?Yield, ?Await, ?Return]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] [lookahead != `else`]
      </emu-grammar>
      <p>この生成規則は非 strict コードを解析する場合にのみ適用される。この生成規則にマッチするソーステキストは、各 |FunctionDeclaration[?Yield, ?Await, ~Default]| の一致がその位置に 1 つの |BlockStatement| の唯一の |StatementListItem| として存在するかのように処理される。その合成 |BlockStatement| の意味論は <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref> で指定される Web レガシー互換意味論を含む。</p>
    </emu-annex>

    <emu-annex id="sec-variablestatements-in-catch-blocks">
      <h1>Catch ブロック内の VariableStatements</h1>
      <p>この機能では、|Catch| 節の |Block| が |CatchParameter| によってもバインドされる名前を `var` 宣言でバインドできる。これは <emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref> 内 <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar> の早期エラー規則を修正することで達成する。</p>
      <emu-note>
        <p>実行時にはそのようなバインディングは VariableDeclarationEnvironment にインスタンス化される。同名の |CatchParameter| によって導入されたバインディングをシャドウせず、そのような `var` 宣言の |Initializer| は catch パラメータに代入する。</p>
      </emu-note>
      <p>この変更は |Catch| 節の |Block| 内に含まれる direct eval 呼び出しによって導入される `var` および `function` 宣言にも適用される。この変更は EvalDeclarationInstantiation の <emu-xref href="#step-evaldeclarationinstantiation-throw-duplicate-binding"></emu-xref> および <emu-xref href="#step-evaldeclarationinstantiation-web-compat-bindingexists"></emu-xref> ステップを修正することで行う。</p>
    </emu-annex>

    <emu-annex id="sec-initializers-in-forin-statement-heads">
      <h1>ForIn 文ヘッドの Initializer</h1>
      <p>以下は <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref> における |ForInOfStatement| 生成規則を拡張する:</p>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` `var` BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>
      <p>この生成規則は非 strict コードを解析する場合にのみ適用される。</p>
      <p><emu-xref href="#sec-static-semantics-containsduplicatelabels"></emu-xref> の ContainsDuplicateLabels の静的意味論は以下で拡張される:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsDuplicateLabels を引数 _labelSet_ で返す。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-containsundefinedbreaktarget"></emu-xref> の ContainsUndefinedBreakTarget の静的意味論は以下で拡張される:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedBreakTarget を引数 _labelSet_ で返す。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-containsundefinedcontinuetarget"></emu-xref> の ContainsUndefinedContinueTarget の静的意味論は以下で拡張される:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| の ContainsUndefinedContinueTarget を引数 _iterationSet_ と « » で返す。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-isdestructuring"></emu-xref> の IsDestructuring の静的意味論は以下で拡張される:</p>
      <emu-grammar>
        BindingIdentifier :
          Identifier
          `yield`
          `await`
      </emu-grammar>
      <emu-alg>
        1. *false* を返す。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-vardeclarednames"></emu-xref> の VarDeclaredNames の静的意味論は以下で拡張される:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _names1_ を |BindingIdentifier| の BoundNames とする。
        1. _names2_ を |Statement| の VarDeclaredNames とする。
        1. _names1_ と _names2_ のリスト結合を返す。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-varscopeddeclarations"></emu-xref> の VarScopedDeclarations の静的意味論は以下で拡張される:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_ を « |BindingIdentifier| » とする。
        1. _declarations2_ を |Statement| の VarScopedDeclarations とする。
        1. _declarations1_ と _declarations2_ のリスト結合を返す。
      </emu-alg>
      <p><emu-xref href="#sec-runtime-semantics-forinofloopevaluation"></emu-xref> の ForInOfLoopEvaluation の実行時意味論は以下で拡張される:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _bindingId_ を |BindingIdentifier| の StringValue とする。
        1. _lhs_ を ? ResolveBinding(_bindingId_) とする。
        1. もし IsAnonymousFunctionDefinition(|Initializer|) が *true* なら
          1. _value_ を ? NamedEvaluation(|Initializer|, 引数 _bindingId_) とする。
        1. それ以外
          1. _rhs_ を ? Evaluation(|Initializer|) とする。
          1. _value_ を ? GetValue(_rhs_) とする。
        1. ? PutValue(_lhs_, _value_) を実行する。
        1. _keyResult_ を ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~) とする。
        1. ? ForIn/OfBodyEvaluation(|BindingIdentifier|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_) を返す。
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-IsHTMLDDA-internal-slot">
      <h1>[[IsHTMLDDA]] 内部スロット</h1>
      <p>ホスト定義オブジェクトに <dfn>[[IsHTMLDDA]] internal slot</dfn> が存在する場合がある。この内部スロットを持つオブジェクトは <emu-xref href="#sec-toboolean">ToBoolean</emu-xref> 抽象操作および IsLooselyEqual 抽象操作、ならびに <emu-xref href="#sec-typeof-operator">`typeof` 演算子</emu-xref> の被演算子として使用されると *undefined* のように振る舞う。</p>
      <emu-note>
        <p>[[IsHTMLDDA]] 内部スロットを持つオブジェクトは本仕様によって生成されない。ただし Web 互換性のために存在するブラウザの <a href="https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all"><code>document.all</code> オブジェクト</a> はこのスロットを持つホスト定義エキゾチックオブジェクトである。この種の他の例は知られておらず、実装は `document.all` を例外として新たに作成すべきでない。</p>
      </emu-note>
      <p>この機能は次の箇所で特別な意味論を伴う:</p>
      <ul>
        <li>ToBoolean の <emu-xref href="#step-to-boolean-web-compat-insertion-point"></emu-xref> ステップ</li>
        <li>IsLooselyEqual の <emu-xref href="#step-abstract-equality-comparison-web-compat-insertion-point"></emu-xref> ステップ</li>
        <li>`typeof` の評価意味論における <emu-xref href="#step-typeof-web-compat-insertion-point"></emu-xref> ステップ</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-make-job-callback">
      <h1>HostMakeJobCallback における非デフォルト挙動</h1>
      <p>HostMakeJobCallback 抽象操作は Web ブラウザであるホストが非デフォルト挙動を指定することを許可する。</p>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-ensure-can-add-private-field">
      <h1>HostEnsureCanAddPrivateElement における非デフォルト挙動</h1>
      <p>HostEnsureCanAddPrivateElement 抽象操作は Web ブラウザであるホストが非デフォルト挙動を指定することを許可する。</p>
    </emu-annex>

    <emu-annex id="sec-runtime-errors-for-function-call-assignment-targets">
      <h1>関数呼び出し代入ターゲットの実行時エラー</h1>
      <p>非 strict コードで関数呼び出し (<emu-xref href="#sec-function-calls"></emu-xref>) が代入ターゲットとして用いられる場合、早期エラーを生成する代わりに、代入の評価中に *ReferenceError* がスローされる。</p>
      <emu-note>
        <p>代入ターゲットが |AssignmentExpression| の |LeftHandSideExpression| である場合、代入演算子は `=` か |AssignmentOperator| でなければならず、論理代入演算子 (`??=`, `&&=`, `||=`) には適用されない。</p>
      </emu-note>
      <p><emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> および <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar> に関する AssignmentTargetType の <emu-xref href="#step-assignmenttargettype-web-compat"></emu-xref> ステップを参照。</p>
    </emu-annex>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-strict-mode-of-ecmascript">
  <h1>ECMAScript の Strict Mode</h1>
  <p><b>Strict mode の制約と例外</b></p>
  <ul>
    <li>
      `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, および `yield` は strict mode コード内では予約語である (<emu-xref href="#sec-keywords-and-reserved-words"></emu-xref>)。
    </li>
    <li>
      適合実装は strict mode コードを処理する際、生成規則 <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar> および <emu-grammar>DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral</emu-grammar> のインスタンスを禁止しなければならない。
    </li>
    <li>
      適合実装は strict mode コードを処理する際、生成規則 <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> および <emu-grammar>EscapeSequence :: NonOctalDecimalEscapeSequence</emu-grammar> のインスタンスを禁止しなければならない。
    </li>
    <li>
      宣言されていない識別子または解決不能な参照への代入はグローバルオブジェクトにプロパティを作成しない。Strict mode コード内で単純代入が行われる場合、その |LeftHandSideExpression| は解決不能 Reference に評価されてはならない。そうなった場合 *ReferenceError* 例外が投げられる (<emu-xref href="#sec-putvalue"></emu-xref>)。|LeftHandSideExpression| はまた { [[Writable]]: *false* } の属性値を持つデータプロパティ、{ [[Set]]: *undefined* } の属性値を持つアクセサプロパティ、あるいは [[Extensible]] 内部スロットが *false* のオブジェクトに存在しないプロパティを参照してはならない。これらの場合 `TypeError` 例外が投げられる (<emu-xref href="#sec-assignment-operators"></emu-xref>)。
    </li>
    <li>
      StringValue が *"eval"* または *"arguments"* の |IdentifierReference| は代入演算子 (<emu-xref href="#sec-assignment-operators"></emu-xref>) の |LeftHandSideExpression|、|UpdateExpression| (<emu-xref href="#sec-update-expressions"></emu-xref>)、あるいは Prefix Increment (<emu-xref href="#sec-prefix-increment-operator"></emu-xref>) / Prefix Decrement (<emu-xref href="#sec-prefix-decrement-operator"></emu-xref>) 演算子により操作される |UnaryExpression| として現れてはならない。
    </li>
    <li>
      Strict 関数の arguments オブジェクトはアクセス時に *TypeError* 例外を投げる設定不可能なアクセサプロパティ *"callee"* を定義する (<emu-xref href="#sec-createunmappedargumentsobject"></emu-xref>)。
    </li>
    <li>
      Strict 関数の arguments オブジェクトは対応する仮引数バインディングと <emu-xref href="#array-index">配列インデックス</emu-xref> プロパティ値を動的に共有しない (<emu-xref href="#sec-arguments-exotic-objects"></emu-xref>)。
    </li>
    <li>
      Strict 関数で arguments オブジェクトが生成された場合、ローカル識別子 `arguments` のそのオブジェクトへのバインディングは不変であり、代入式のターゲットになり得ない (<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>)。
    </li>
    <li>
      Strict mode コード内で |BindingIdentifier| の StringValue が *"eval"* または *"arguments"* であると *SyntaxError* である (<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>)。
    </li>
    <li>
      Strict mode の eval コードは呼び出し元の variable environment 内に変数や関数をインスタンス化できない。代わりに新しい variable environment が作成され、その環境が eval コードの宣言バインディング初期化に使われる (<emu-xref href="#sec-eval-x"></emu-xref>)。
    </li>
    <li>
      Strict mode コードで *this* が評価される場合、その *this* 値はオブジェクトへ強制変換されない。*undefined* または *null* の *this* 値はグローバルオブジェクトへ変換されず、プリミティブ値はラッパオブジェクトへ変換されない。関数呼び出し（`Function.prototype.apply` や `Function.prototype.call` を含む）で渡される *this* 値は強制変換されない (<emu-xref href="#sec-ordinarycallbindthis"></emu-xref>, <emu-xref href="#sec-function.prototype.apply"></emu-xref>, <emu-xref href="#sec-function.prototype.call"></emu-xref>)。
    </li>
    <li>
      Strict mode コード内で `delete` 演算子が現れ、その |UnaryExpression| が変数・関数引数・関数名への直接参照である場合 *SyntaxError* が投げられる (<emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>)。
    </li>
    <li>
      Strict mode コード内で `delete` 演算子が現れ、削除対象プロパティが属性 { [[Configurable]]: *false* } を持つか削除不可能である場合 *TypeError* が投げられる (<emu-xref href="#sec-delete-operator-runtime-semantics-evaluation"></emu-xref>)。
    </li>
    <li>
      Strict mode コードは |WithStatement| を含めてはならない。そのような文脈での |WithStatement| 出現は *SyntaxError* である (<emu-xref href="#sec-with-statement-static-semantics-early-errors"></emu-xref>)。
    </li>
    <li>
      Strict mode コード内で |CatchParameter| が現れ、その BoundNames が `eval` か `arguments` を含むと *SyntaxError* である (<emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>)。
    </li>
    <li>
      Strict 関数の |FormalParameters| に同一 |BindingIdentifier| が複数回現れると *SyntaxError* である。Function / Generator / AsyncFunction コンストラクタでそのような関数を作成しようとすると *SyntaxError* となる (<emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-createdynamicfunction"></emu-xref>)。
    </li>
    <li>
      実装は本仕様で定義された範囲を超えて、strict 関数内での関数インスタンスの *"caller"* または *"arguments"* という名前のプロパティの意味を拡張してはならない。
    </li>
  </ul>
</emu-annex>

<emu-annex id="sec-host-layering-points">
  <h1>ホストのレイヤリングポイント</h1>
  <p>ホストの定義については <emu-xref href="#sec-hosts-and-implementations"></emu-xref> を参照。</p>

  <emu-annex id="sec-host-hooks-summary">
    <h1>ホストフック</h1>
    <p><b>HostCallJobCallback(...)</b></p>
    <p><b>HostEnqueueFinalizationRegistryCleanupJob(...)</b></p>
    <p><b>HostEnqueueGenericJob(...)</b></p>
    <p><b>HostEnqueuePromiseJob(...)</b></p>
    <p><b>HostEnqueueTimeoutJob(...)</b></p>
    <p><b>HostEnsureCanCompileStrings(...)</b></p>
    <p><b>HostFinalizeImportMeta(...)</b></p>
    <p><b>HostGetImportMetaProperties(...)</b></p>
    <p><b>HostGrowSharedArrayBuffer(...)</b></p>
    <p><b>HostHasSourceTextAvailable(...)</b></p>
    <p><b>HostLoadImportedModule(...)</b></p>
    <p><b>HostGetSupportedImportAttributes(...)</b></p>
    <p><b>HostMakeJobCallback(...)</b></p>
    <p><b>HostPromiseRejectionTracker(...)</b></p>
    <p><b>HostResizeArrayBuffer(...)</b></p>
    <p><b>InitializeHostDefinedRealm(...)</b></p>
  </emu-annex>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>ホスト定義フィールド</h1>
    <p>Realm Record の [[HostDefined]]: <emu-xref href="#table-realm-record-fields"></emu-xref> を参照。</p>
    <p>Script Record の [[HostDefined]]: <emu-xref href="#table-script-records"></emu-xref> を参照。</p>
    <p>Module Record の [[HostDefined]]: <emu-xref href="#table-module-record-fields"></emu-xref> を参照。</p>
    <p>JobCallback Record の [[HostDefined]]: <emu-xref href="#table-jobcallback-records"></emu-xref> を参照。</p>
    <p>Candidate Executions の [[HostSynchronizesWith]]: <emu-xref href="#table-candidate-execution-records"></emu-xref> を参照。</p>
    <p>[[IsHTMLDDA]]: <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref> を参照。</p>
  </emu-annex>

  <emu-annex id="sec-host-defined-objects-summary">
    <h1>ホスト定義オブジェクト</h1>
    <p>グローバルオブジェクト: <emu-xref href="#sec-global-object"></emu-xref> 節を参照。</p>
  </emu-annex>

  <emu-annex id="sec-host-running-jobs">
    <h1>ジョブの実行</h1>
    <p>Job 抽象クロージャ呼び出しの前の準備ステップおよび後のクリーンアップステップ。<emu-xref href="#sec-jobs"></emu-xref> を参照。</p>
  </emu-annex>

  <emu-annex id="sec-host-internal-methods-of-exotic-objects">
    <h1>エキゾチックオブジェクトの内部メソッド</h1>
    <p>本仕様内で明示的に規定されていないエキゾチックオブジェクトに対する <emu-xref href="#table-essential-internal-methods"></emu-xref> の必須内部メソッドのいずれか。</p>
  </emu-annex>

  <emu-annex id="sec-host-built-in-objects-and-methods">
    <h1>組込みオブジェクトとメソッド</h1>
    <p><emu-xref href="#sec-forbidden-extensions"></emu-xref> で制限される場合を除き、本仕様で定義されていない組込みオブジェクトおよびメソッド。</p>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact">
  <h1>ECMAScript 2015 における修正と明確化（互換性へ影響し得るもの）</h1>
  <p><emu-xref href="#sec-candeclareglobalvar"></emu-xref>-<emu-xref href="#sec-createglobalfunctionbinding"></emu-xref>: 第 5 / 5.1 版では新しいグローバル宣言に対応するグローバルオブジェクトプロパティが既に存在するかをプロパティ存在テストで判定していた。ECMAScript 2015 では独自 (own) プロパティ存在テストを使用する。これは多くの Web ブラウザ実装で一般的な挙動に対応する。</p>
  <p><emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>: 第 5 版は配列インデックスまたは新しい長さ値の整数変換前に現在の配列長を捕捉するよう移動した。しかし変換過程が配列長を変化させ得る副作用を持つ場合、その捕捉値は無効になり得た。ECMAScript 2015 はそのような副作用が起こり得た後で現在の配列長を捕捉しなければならないと規定する。</p>
  <p><emu-xref href="#sec-timeclip"></emu-xref>: 以前の版では TimeClip 抽象操作は 0 時刻を *+0*<sub>𝔽</sub> か *-0*<sub>𝔽</sub> いずれかで表現してよかった。ECMAScript 2015 は常に *+0*<sub>𝔽</sub> を返すと規定する。つまり Date の時刻値が観測可能に *-0*<sub>𝔽</sub> となることはなく、時刻値を返すメソッドも *-0*<sub>𝔽</sub> を返さない。</p>
  <p><emu-xref href="#sec-date-time-string-format"></emu-xref>: UTC オフセット表現が存在しない場合、ローカルタイムゾーンが使用される。第 5.1 版は誤って欠如するタイムゾーンを *"z"* と解釈すべきと述べていた。</p>
  <p><emu-xref href="#sec-date.prototype.toisostring"></emu-xref>: 年が <emu-xref href="#sec-date-time-string-format"></emu-xref> で規定される Date Time String Format で表現できない場合 RangeError 例外を投げる。以前の版はそのケースを規定していなかった。</p>
  <p><emu-xref href="#sec-date.prototype.tostring"></emu-xref>: 以前の版は time value が *NaN* のとき `Date.prototype.toString` が返す値を規定していなかった。ECMAScript 2015 は結果を文字列 *"Invalid Date"* と規定する。</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>, <emu-xref href="#sec-escaperegexppattern"></emu-xref>: RegExp インスタンスの *"source"* プロパティ値内の LineTerminator コードポイントはエスケープシーケンスで表現されなければならない。第 5.1 版は `/` のエスケープのみ要求していた。</p>
  <p><emu-xref href="#sec-regexp.prototype-%symbol.match%"></emu-xref>, <emu-xref href="#sec-regexp.prototype-%symbol.replace%"></emu-xref>: 以前の版で `String.prototype.match` と `String.prototype.replace` の仕様は `global` フラグを持つ RegExp 値をパターン引数にした場合の挙動が不正確であった。以前の仕様は各マッチ試行で `lastIndex` が変化しなければ 1 増やすべきと述べたが、正しい挙動は空文字列にマッチした場合のみ 1 増やすことである。</p>
  <p><emu-xref href="#sec-array.prototype.sort"></emu-xref>: 以前の版は `_comparator_` が *NaN* を返した場合の `Array.prototype.sort` の解釈を規定していなかった。ECMAScript 2015 はその値を *+0*<sub>𝔽</sub> が返されたかのように扱うと規定する。また 2015 版は `_comparator_` の結果に ToNumber を適用する。以前は Number でない結果の効果は実装依存であり、実際には実装は ToNumber を呼び出していた。</p>
</emu-annex>

<emu-annex id="sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions">
  <h1>従来版との非互換を導入する追加および変更</h1>
  <p><emu-xref href="#sec-reference-record-specification-type"></emu-xref>: ECMAScript 2015 では関数呼び出しは Reference Record を返すことができない。</p>
  <p><emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>: ECMAScript 2015 では String 値への ToNumber が |BinaryIntegerLiteral| と |OctalIntegerLiteral| の数値文字列を認識して変換する。以前はそれらは *NaN* へ変換されていた。</p>
  <p><emu-xref href="#sec-code-realms"></emu-xref>: ECMAScript 2018 ではテンプレートオブジェクトは以前のように Realm 内の全出現横断ではなく Parse Node（ソース位置）に基づき正規化される。</p>
  <p><emu-xref href="#sec-white-space"></emu-xref>: ECMAScript 2016 では Unicode 8.0.0 以上が必須になり、2015 版の Unicode 5.1 必須から変更された。特に U+180E MONGOLIAN VOWEL SEPARATOR は `Space_Separator` (`Zs`) から `Format` (`Cf`) へ移動（Unicode 6.3.0）し、空白としての扱いが変化した。これは空白に敏感なメソッドの挙動差異を生む。例えば以前は `"\u180E".trim().length` は `0` だが 2016 以降は `1`。さらに ECMAScript 2017 は常に Unicode 最新版を使用することを義務付けた。</p>
  <p><emu-xref href="#sec-names-and-keywords"></emu-xref>: ECMAScript 2015 では |IdentifierName| の有効コードポイントを Unicode プロパティ “ID_Start” と “ID_Continue” で規定。以前は様々な Unicode カテゴリ列挙で規定されていた。</p>
  <p><emu-xref href="#sec-rules-of-automatic-semicolon-insertion"></emu-xref>: ECMAScript 2015 では do-while 文末尾のセミコロンが欠如していると自動セミコロン挿入が追加する。これは実装挙動との整合。</p>
  <p><emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref>: ECMAScript 2015 では Object Initializer で重複プロパティ名があっても早期エラーではなくなった。</p>
  <p><emu-xref href="#sec-assignment-operators-static-semantics-early-errors"></emu-xref>: ECMAScript 2015 では |FunctionExpression| の関数名のような不変バインディングへの代入を含む strict mode コードは早期エラーではなく実行時エラーを生成する。</p>
  <p><emu-xref href="#sec-block"></emu-xref>: ECMAScript 2015 ではトークン let に続いて入力要素 |LineTerminator| その後 |Identifier| で始まる |StatementList| は |LexicalDeclaration| の開始。以前は自動セミコロン挿入が常に |Identifier| 前にセミコロンを挿入した。</p>
  <p><emu-xref href="#sec-expression-statement"></emu-xref>: ECMAScript 2015 ではトークン `let` に続いてトークン `[` の並びで始まる |StatementListItem| は |LexicalDeclaration| の開始。以前は |ExpressionStatement| の開始だった。</p>
  <p><emu-xref href="#sec-if-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015 では |IfStatement| の通常結果が ~empty~ になることはない。|Statement| 部分が評価されないか ~empty~ を含む通常完了なら結果は *undefined*。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015 では for 文の `(` の直後が `let [` トークン列なら `let` は |LexicalDeclaration| の開始。以前は |Expression| の開始だった。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015 では for-in 文の ( の直後が `let [` なら `let` は |ForDeclaration| の開始。以前は |LeftHandSideExpression| の開始だった。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015 以前、初期化式は `in` の前の |VariableDeclaration| の一部として現れ得た。2015 では同位置の |ForBinding| はそのような初期化子を許さない。2017 では非 strict コードでのみ許容。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015 では |IterationStatement| の評価結果が [[Value]] ~empty~ の通常完了になることはない。|Statement| 部分が評価されないか最終評価が ~empty~ の場合結果は *undefined*。</p>
  <p><emu-xref href="#sec-with-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015 では |WithStatement| の評価結果が ~empty~ の通常完了にならない。|Statement| 部分が ~empty~ の通常完了なら結果は *undefined*。</p>
  <p><emu-xref href="#sec-switch-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015 では |SwitchStatement| の評価結果が ~empty~ の通常完了にならない。|CaseBlock| 部分が ~empty~ の通常完了なら結果は *undefined*。</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>: ECMAScript 2015 では |Catch| 節がパラメータと同じ |Identifier| の `var` 宣言を含むと早期エラー。以前はその変数宣言は囲む variable environment にインスタンス化され初期化子値が |Catch| パラメータへ代入された。</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>, <emu-xref href="#sec-evaldeclarationinstantiation"></emu-xref>: ECMAScript 2015 では |Catch| 節が非 strict の直接 `eval` を評価し、その eval コードが |Catch| パラメータと同じ |Identifier| をバインドする `var` / `FunctionDeclaration` を含むと実行時 *SyntaxError* を投げる。</p>
  <p><emu-xref href="#sec-try-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015 では |TryStatement| の結果が ~empty~ 値になることはない。|Block| 部分が ~empty~ を含む通常完了なら結果は *undefined*。|Block| が throw 完了で |Catch| が ~empty~ の通常完了を返し、|Finally| が無いか ~empty~ の通常完了なら結果は *undefined*。</p>
  <p><emu-xref href="#sec-runtime-semantics-methoddefinitionevaluation"></emu-xref>: ECMAScript 2015 では |ObjectLiteral| のアクセサプロパティ [[Get]] / [[Set]] 属性値として作成される関数オブジェクトはコンストラクタではなく *"prototype"* 自身プロパティを持たない。以前はコンストラクタで *"prototype"* を持っていた。</p>
  <p><emu-xref href="#sec-object.freeze"></emu-xref>: ECMAScript 2015 では `Object.freeze` 引数がオブジェクトでない場合、独自プロパティを持たない非拡張の通常オブジェクトとして扱う。以前は常に *TypeError*。</p>
  <p><emu-xref href="#sec-object.getownpropertydescriptor"></emu-xref>: ECMAScript 2015 では引数がオブジェクトでない場合 ToObject 変換を試み、成功すればその結果を使用。以前は常に *TypeError*。</p>
  <p><emu-xref href="#sec-object.getownpropertynames"></emu-xref>: 同上の挙動。</p>
  <p><emu-xref href="#sec-object.getprototypeof"></emu-xref>: 同上の挙動。</p>
  <p><emu-xref href="#sec-object.isextensible"></emu-xref>: 引数がオブジェクトでない場合、非拡張の空オブジェクトとして扱う。以前は *TypeError*。</p>
  <p><emu-xref href="#sec-object.isfrozen"></emu-xref>: 同様。</p>
  <p><emu-xref href="#sec-object.issealed"></emu-xref>: 同様。</p>
  <p><emu-xref href="#sec-object.keys"></emu-xref>: 引数がオブジェクトでない場合 ToObject を試み、成功時その結果を使用。以前は *TypeError*。</p>
  <p><emu-xref href="#sec-object.preventextensions"></emu-xref>: 引数が非オブジェクトなら非拡張の空オブジェクト扱い。以前は *TypeError*。</p>
  <p><emu-xref href="#sec-object.seal"></emu-xref>: 同様。</p>
  <p><emu-xref href="#sec-function.prototype.bind"></emu-xref>: ECMAScript 2015 ではバインド関数の [[Prototype]] はターゲット関数の [[GetPrototypeOf]] の値。以前は常に %Function.prototype%。</p>
  <p><emu-xref href="#sec-function-instances-length"></emu-xref>: ECMAScript 2015 では関数インスタンスの *"length"* プロパティは設定可能。以前は不可。</p>
  <p><emu-xref href="#sec-properties-of-the-nativeerror-constructors"></emu-xref>: ECMAScript 2015 では _NativeError_ コンストラクタの [[Prototype]] 内部スロットは Error コンストラクタ。以前は Function prototype オブジェクト。</p>
  <p><emu-xref href="#sec-properties-of-the-date-prototype-object"></emu-xref> ECMAScript 2015 では Date prototype オブジェクトは Date インスタンスではない。以前は TimeValue が *NaN* の Date インスタンス。</p>
  <p><emu-xref href="#sec-string.prototype.localecompare"></emu-xref> ECMAScript 2015 では `String.prototype.localeCompare` は Unicode 標準で正規等価な文字列を同一として扱う。以前は正規等価性を無視しビット単位比較も可能だった。</p>
  <p><emu-xref href="#sec-string.prototype.tolowercase"></emu-xref> および <emu-xref href="#sec-string.prototype.touppercase"></emu-xref> ECMAScript 2015 では大小変換処理はコードポイント単位。以前はコードユニット個別。影響を受けるのは Deseret ブロック。</p>
  <p><emu-xref href="#sec-string.prototype.trim"></emu-xref> ECMAScript 2015 では `String.prototype.trim` は BMP 外に存在し得る空白コードポイントを認識するよう定義（Unicode 7 時点で該当なし）。以前は認識しなかった。</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref> ECMAScript 2015 では _pattern_ 引数が RegExp インスタンスで _flags_ が *undefined* でなければ、新しい RegExp を作成し既存フラグを置換。以前は *TypeError*。</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> ECMAScript 2015 では RegExp prototype オブジェクトは RegExp インスタンスではない。以前は空文字パターンのインスタンス。</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> ECMAScript 2015 では *"source"*, *"global"*, *"ignoreCase"*, *"multiline"* は RegExp prototype 上のアクセサプロパティ。以前はインスタンス上のデータプロパティ。</p>
  <p><emu-xref href="#sec-atomics.notify"></emu-xref>: ECMAScript 2019 で `Atomics.wake` は `Atomics.notify` に改名され `Atomics.wait` との混同を防ぐ。</p>
  <p><emu-xref href="#sec-asyncfromsynciteratorcontinuation"></emu-xref>, <emu-xref href="#sec-asyncgeneratorresume"></emu-xref>: ECMAScript 2019 で `await` によりエンキューされる Job 数が減り、`then()` 呼び出しと `await` 式間の解決順序に観測可能な差異を生む可能性がある。</p>
</emu-annex>

<emu-annex id="sec-bibliography" back-matter>
  <h1>参考文献</h1>
  <ol>
    <li>
      <dfn>IEEE 754-2019</dfn>: <i>IEEE Standard for Floating-Point Arithmetic</i>. Institute of Electrical and Electronic Engineers, New York (2019)
      <emu-note>
        <p>IEEE 754-2008 と IEEE 754-2019 の間で ECMA-262 仕様に影響する規範的変更はない。</p>
      </emu-note>
    </li>
    <li>
      <i>The Unicode Standard</i>, &lt;<a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>>
    </li>
    <li>
      <i>Unicode Technical Note #5: Canonical Equivalence in Applications</i>, &lt;<a href="https://unicode.org/notes/tn5/">https://unicode.org/notes/tn5/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #10: Unicode Collation Algorithm</i>, &lt;<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #15, Unicode Normalization Forms</i>, &lt;<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #18: Unicode Regular Expressions</i>, &lt;<a href="https://unicode.org/reports/tr18/">https://unicode.org/reports/tr18/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #24: Unicode `Script` Property</i>, &lt;<a href="https://unicode.org/reports/tr24/">https://unicode.org/reports/tr24/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax</i>, &lt;<a href="https://unicode.org/reports/tr31/">https://unicode.org/reports/tr31/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #44: Unicode Character Database</i>, &lt;<a href="https://unicode.org/reports/tr44/">https://unicode.org/reports/tr44/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #51: Unicode Emoji</i>, &lt;<a href="https://unicode.org/reports/tr51/">https://unicode.org/reports/tr51/</a>>
    </li>
    <li>
      <i>IANA Time Zone Database</i>, &lt;<a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>>
    </li>
    <li>
      ISO 8601:2004(E) <i>Data elements and interchange formats — Information interchange — Representation of dates and times</i>
    </li>
    <li>
      <i>RFC 1738 “Uniform Resource Locators (URL)”</i>, &lt;<a href="https://tools.ietf.org/html/rfc1738">https://tools.ietf.org/html/rfc1738</a>>
    </li>
    <li>
      <i>RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”</i>, &lt;<a href="https://tools.ietf.org/html/rfc2396">https://tools.ietf.org/html/rfc2396</a>>
    </li>
    <li>
      <i>RFC 3629 “UTF-8, a transformation format of ISO 10646”</i>, &lt;<a href="https://tools.ietf.org/html/rfc3629">https://tools.ietf.org/html/rfc3629</a>>
    </li>
    <li>
      <i>RFC 7231 “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”</i>, &lt;<a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>>
    </li>
  </ol>
</emu-annex>

<emu-annex id="sec-colophon" back-matter>
  <h1>奥付</h1>
  <p>この仕様は <a href="https://github.com/tc39/ecma262">GitHub</a> 上で <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a> と呼ばれるプレーンテキストソース形式で作成される。Ecmarkup はこの文書の編集上の慣習に従う完全な HTML レンダリングへ仕様を処理するためのフレームワークおよびツールセットを提供する HTML と Markdown の方言である。Ecmarkup は構文定義に <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a>、アルゴリズム手順記述に <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a> など複数のフォーマットおよび技術を統合している。この仕様の PDF レンダリングは CSS Paged Media 仕様を利用する印刷スタイルシートを用いて生成され <a href="https://www.princexml.com/">PrinceXML</a> で変換される。</p>
  <p>以前の版は Word を用いて作成されており、本版の基盤となった Ecmarkup ソーステキストは ECMAScript 2015 の Word ドキュメントを自動変換ツールで Ecmarkup へ変換して得られた。</p>
</emu-annex>

